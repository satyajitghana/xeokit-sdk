/** @private */
var Map = function Map(items, baseId) {
    this.items = items || [];
    this._lastUniqueId = (baseId || 0) + 1;
};

/**
 * Usage:
 *
 * id = myMap.addItem("foo") // ID internally generated
 * id = myMap.addItem("foo", "bar") // ID is "foo"
 */
Map.prototype.addItem = function addItem () {
    var item;
    if (arguments.length === 2) {
        var id = arguments[0];
        item = arguments[1];
        if (this.items[id]) { // Won't happen if given ID is string
            throw "ID clash: '" + id + "'";
        }
        this.items[id] = item;
        return id;

    } else {
        item = arguments[0] || {};
        while (true) {
            var findId = this._lastUniqueId++;
            if (!this.items[findId]) {
                this.items[findId] = item;
                return findId;
            }
        }
    }
};

Map.prototype.removeItem = function removeItem (id) {
    var item = this.items[id];
    delete this.items[id];
    return item;
};

var idMap$1 = new Map();

/**
 * Internal data class that represents the state of a menu or a submenu.
 * @private
 */
var Menu = function Menu(id) {
    this.id = id;
    this.parentItem = null; // Set to an Item when this Menu is a submenu
    this.groups = [];
    this.menuElement = null;
    this.shown = false;
    this.mouseOver = 0;
};

/**
 * Internal data class that represents a group of Items in a Menu.
 * @private
 */
var Group = function Group() {
    this.items = [];
};

/**
 * Internal data class that represents the state of a menu item.
 * @private
 */
var Item = function Item(id, getTitle, doAction, getEnabled) {
    this.id = id;
    this.getTitle = getTitle;
    this.doAction = doAction;
    this.getEnabled = getEnabled;
    this.itemElement = null;
    this.subMenu = null;
    this.enabled = true;
};

/**
 * @desc A customizable HTML context menu.
 *
 * [<img src="http://xeokit.io/img/docs/ContextMenu/ContextMenu.gif">](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ## Overview
 *
 * * A pure JavaScript, lightweight context menu
 * * Dynamically configure menu items
 * * Dynamically enable or disable items
 * * Supports cascading sub-menus
 * * Configure custom style with custom CSS (see examples above)
 *
 * ## Usage
 *
 * In the example below we'll create a ````ContextMenu```` that pops up whenever we right-click on an {@link Entity} within
 * our {@link Scene}.
 *
 * First, we'll create the ````ContextMenu````, configuring it with a list of menu items.
 *
 * Each item has:
 *
 * * a ````title```` for the item,
 * * a ````doAction()```` callback to fire when the item's title is clicked, and
 * * an optional ````getEnabled()```` callback that indicates if the item should enabled in the menu or not.
 *
 * <br>
 *
 * The ````getEnabled()```` callbacks are invoked whenever the menu is shown. When an item's ````getEnabled()```` callback
 * returns ````true````, then the item is enabled and clickable. When it returns ````false````, then the item is disabled
 * and cannot be clicked. An item without a ````getEnabled()```` callback is always enabled and clickable.
 *
 * Note how the ````doAction()```` and ````getEnabled()```` callbacks accept a ````context````
 * object. That must be set on the ````ContextMenu```` before we're able to we show it. The context object can be anything. In this example,
 * we'll use the context object to provide the callbacks with the Entity that we right-clicked.
 *
 * We'll also initially enable the ````ContextMenu````.
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_Custom)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *
 *    enabled: true,
 *
 *    items: [
 *       [
 *          {
 *             title: "Hide Object",
 *             getEnabled: (context) => {
 *                 return context.entity.visible; // Can't hide entity if already hidden
 *             },
 *             doAction: function (context) {
 *                 context.entity.visible = false;
 *             }
 *          }
 *       ],
 *       [
 *          {
 *             title: "Select Object",
 *             getEnabled: (context) => {
 *                 return (!context.entity.selected); // Can't select an entity that's already selected
 *             },
 *             doAction: function (context) {
 *                 context.entity.selected = true;
 *             }
 *          }
 *       ],
 *       [
 *          {
 *             title: "X-Ray Object",
 *             getEnabled: (context) => {
 *                 return (!context.entity.xrayed); // Can't X-ray an entity that's already X-rayed
 *             },
 *             doAction: (context) => {
 *                 context.entity.xrayed = true;
 *             }
 *          }
 *       ]
 *    ]
 * });
 * ````
 *
 * Next, we'll make the ````ContextMenu```` appear whenever we right-click on an Entity. Whenever we right-click
 * on the canvas, we'll attempt to pick the Entity at those mouse coordinates. If we succeed, we'll feed the
 * Entity into ````ContextMenu```` via the context object, then show the ````ContextMenu````.
 *
 * From there, each ````ContextMenu```` item's ````getEnabled()```` callback will be invoked (if provided), to determine if the item should
 * be enabled. If we click an item, its ````doAction()```` callback will be invoked with our context object.
 *
 * Remember that we must set the context on our ````ContextMenu```` before we show it, otherwise it will log an error to the console,
 * and ignore our attempt to show it.
 *
 * ````javascript*
 * viewer.scene.canvas.canvas.oncontextmenu = (e) => { // Right-clicked on the canvas
 *
 *     if (!objectContextMenu.enabled) {
 *         return;
 *     }
 *
 *     var hit = viewer.scene.pick({ // Try to pick an Entity at the coordinates
 *         canvasPos: [e.pageX, e.pageY]
 *     });
 *
 *     if (hit) { // Picked an Entity
 *
 *         objectContextMenu.context = { // Feed entity to ContextMenu
 *             entity: hit.entity
 *         };
 *
 *         objectContextMenu.show(e.pageX, e.pageY); // Show the ContextMenu
 *     }
 *
 *     e.preventDefault();
 * });
 * ````
 *
 * Note how we only show the ````ContextMenu```` if it's enabled. We can use that mechanism to switch between multiple
 * ````ContextMenu```` instances depending on what we clicked.
 *
 * ## Dynamic Item Titles
 *
 * To make an item dynamically regenerate its title text whenever we show the ````ContextMenu````, provide its title with a
 * ````getTitle()```` callback. The callback will fire each time you show ````ContextMenu````, which will dynamically
 * set the item title text.
 *
 * In the example below, we'll create a simple ````ContextMenu```` that allows us to toggle the selection of an object
 * via its first item, which changes text depending on whether we are selecting or deselecting the object.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_dynamicItemTitles)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *
 *    enabled: true,
 *
 *    items: [
 *       [
 *          {
 *              getTitle: (context) => {
 *                  return (!context.entity.selected) ? "Select" : "Undo Select";
 *              },
 *              doAction: function (context) {
 *                  context.entity.selected = !context.entity.selected;
 *              }
 *          },
 *          {
 *              title: "Clear Selection",
 *              getEnabled: function (context) {
 *                  return (context.viewer.scene.numSelectedObjects > 0);
 *              },
 *              doAction: function (context) {
 *                  context.viewer.scene.setObjectsSelected(context.viewer.scene.selectedObjectIds, false);
 *              }
 *          }
 *       ]
 *    ]
 * });
 * ````
 *
 * ## Sub-menus
 *
 * Each menu item can optionally have a sub-menu, which will appear when we hover over the item.
 *
 * In the example below, we'll create a much simpler ````ContextMenu```` that has only one item, called "Effects", which
 * will open a cascading sub-menu whenever we hover over that item.
 *
 * Note that our "Effects" item has no ````doAction```` callback, because an item with a sub-menu performs no
 * action of its own.
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_subMenus)]
 *
 * ````javascript
 * const canvasContextMenu = new ContextMenu({
 *     items: [ // Top level items
 *         [
 *             {
 *                 getTitle: (context) => {
 *                     return "Effects";
 *                 },
 *
 *                 items: [ // Sub-menu
 *                     [
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.visible) ? "Show" : "Hide";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.visible = !context.entity.visible;
 *                             }
 *                         },
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.selected) ? "Select" : "Undo Select";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.selected = !context.entity.selected;
 *                             }
 *                         },
 *                         {
 *                             getTitle: (context) => {
 *                                 return (!context.entity.highlighted) ? "Highlight" : "Undo Highlight";
 *                             },
 *                             doAction: function (context) {
 *                                 context.entity.highlighted = !context.entity.highlighted;
 *                             }
 *                         }
 *                     ]
 *                 ]
 *             }
 *          ]
 *      ]
 * });
 * ````
 */
var ContextMenu = function ContextMenu(cfg) {
    var this$1 = this;
    if ( cfg === void 0 ) cfg = {};


    this._id = idMap$1.addItem();
    this._context = null;
    this._enabled = false;  // True when the ContextMenu is enabled
    this._itemsCfg = [];// Items as given as configs
    this._rootMenu = null;  // The root Menu in the tree
    this._menuList = [];// List of Menus
    this._menuMap = {}; // Menus mapped to their IDs
    this._itemList = [];// List of Items
    this._itemMap = {}; // Items mapped to their IDs
    this._shown = false;// True when the ContextMenu is visible
    this._nextId = 0;

    /**
     * Subscriptions to events fired at this ContextMenu.
     * @private
     */
    this._eventSubs = {};

    if (cfg.hideOnMouseDown !== false) {
        document.addEventListener("mousedown", function (event) {
            if (!event.target.classList.contains("xeokit-context-menu-item")) {
                this$1.hide();
            }
        });
        document.addEventListener("touchstart", this._canvasTouchStartHandler = function (event) {
            if (!event.target.classList.contains("xeokit-context-menu-item")) {
                this$1.hide();
            }
        });
    }

    if (cfg.items) {
        this.items = cfg.items;
    }

    this.context = cfg.context;
    this.enabled = cfg.enabled !== false;
    this.hide();
};

var prototypeAccessors$e = { items: { configurable: true },enabled: { configurable: true },context: { configurable: true },shown: { configurable: true } };


/**
 Subscribes to an event fired at this ````ContextMenu````.

 @param {String} event The event
 @param {Function} callback Callback fired on the event
 */
ContextMenu.prototype.on = function on (event, callback) {
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = [];
        this._eventSubs[event] = subs;
    }
    subs.push(callback);
};

/**
 Fires an event at this ````ContextMenu````.

 @param {String} event The event type name
 @param {Object} value The event parameters
 */
ContextMenu.prototype.fire = function fire (event, value) {
    var subs = this._eventSubs[event];
    if (subs) {
        for (var i = 0, len = subs.length; i < len; i++) {
            subs[i](value);
        }
    }
};

/**
 * Sets the ````ContextMenu```` items.
 *
 * These can be updated dynamically at any time.
 *
 * See class documentation for an example.
 *
 * @type {Object[]}
 */
prototypeAccessors$e.items.set = function (itemsCfg) {
    this._clear();
    this._itemsCfg = itemsCfg || [];
    this._parseItems(itemsCfg);
    this._createUI();
};

/**
 * Gets the ````ContextMenu```` items.
 *
 * @type {Object[]}
 */
prototypeAccessors$e.items.get = function () {
    return this._itemsCfg;
};

/**
 * Sets whether this ````ContextMenu```` is enabled.
 *
 * Hides the menu when disabling.
 *
 * @type {Boolean}
 */
prototypeAccessors$e.enabled.set = function (enabled) {
    enabled = (!!enabled);
    if (enabled === this._enabled) {
        return;
    }
    this._enabled = enabled;
    if (!this._enabled) {
        this.hide();
    }
};

/**
 * Gets whether this ````ContextMenu```` is enabled.
 *
 * {@link ContextMenu#show} does nothing while this is ````false````.
 *
 * @type {Boolean}
 */
prototypeAccessors$e.enabled.get = function () {
    return this._enabled;
};

/**
 * Sets the ````ContextMenu```` context.
 *
 * The context can be any object that you need to be provides to the callbacks configured on {@link ContextMenu#items}.
 *
 * This must be set before calling {@link ContextMenu#show}.
 *
 * @type {Object}
 */
prototypeAccessors$e.context.set = function (context) {
    this._context = context;
};

/**
 * Gets the ````ContextMenu```` context.
 *
 * @type {Object}
 */
prototypeAccessors$e.context.get = function () {
    return this._context;
};

/**
 * Shows this ````ContextMenu```` at the given page coordinates.
 *
 * Does nothing when {@link ContextMenu#enabled} is ````false````.
 *
 * Logs error to console and does nothing if {@link ContextMenu#context} has not been set.
 *
 * Fires a "shown" event when shown.
 *
 * @param {Number} pageX Page X-coordinate.
 * @param {Number} pageY Page Y-coordinate.
 */
ContextMenu.prototype.show = function show (pageX, pageY) {
    if (!this._context) {
        console.error("ContextMenu cannot be shown without a context - set context first");
        return;
    }
    if (!this._enabled) {
        return;
    }
    if (this._shown) {
        return;
    }
    this._hideAllMenus();
    this._updateItemsTitles();
    this._updateItemsEnabledStatus();
    this._showMenu(this._rootMenu.id, pageX, pageY);
    this._shown = true;
    this.fire("shown", {});
};

/**
 * Gets whether this ````ContextMenu```` is currently shown or not.
 *
 * @returns {Boolean} Whether this ````ContextMenu```` is shown.
 */
prototypeAccessors$e.shown.get = function () {
    return this._shown;
};

/**
 * Hides this ````ContextMenu````.
 *
 * Fires a "hidden" event when hidden.
 */
ContextMenu.prototype.hide = function hide () {
    if (!this._enabled) {
        return;
    }
    if (!this._shown) {
        return;
    }
    this._hideAllMenus();
    this._shown = false;
    this.fire("hidden", {});
};

/**
 * Destroys this ````ContextMenu````.
 */
ContextMenu.prototype.destroy = function destroy () {
    this._context = null;
    this._clear();
    if (this._id !== null) {
        idMap$1.removeItem(this._id);
        this._id = null;
    }
};

ContextMenu.prototype._clear = function _clear () { // Destroys DOM elements, clears menu data
    for (var i = 0, len = this._menuList.length; i < len; i++) {
        var menu = this._menuList[i];
        var menuElement = menu.menuElement;
        menuElement.parentElement.removeChild(menuElement);
    }
    this._itemsCfg = [];
    this._rootMenu = null;
    this._menuList = [];
    this._menuMap = {};
    this._itemList = [];
    this._itemMap = {};
};

ContextMenu.prototype._parseItems = function _parseItems (itemsCfg) {
        var this$1 = this;
 // Parses "items" config into menu data

    var visitItems = function (itemsCfg) {

        var menuId = this$1._getNextId();
        var menu = new Menu(menuId);

        for (var i = 0, len = itemsCfg.length; i < len; i++) {

            var itemsGroupCfg = itemsCfg[i];

            var group = new Group();

            menu.groups.push(group);

            var loop = function ( j, lenj ) {

                var itemCfg = itemsGroupCfg[j];
                var subItemsCfg = itemCfg.items;
                var hasSubItems = (subItemsCfg && (subItemsCfg.length > 0));
                var itemId = this$1._getNextId();

                var getTitle = itemCfg.getTitle || (function () {
                    return (itemCfg.title || "");
                });

                var doAction = itemCfg.doAction || itemCfg.callback || (function () {
                });

                var getEnabled = itemCfg.getEnabled || (function () {
                    return true;
                });

                var item = new Item(itemId, getTitle, doAction, getEnabled);

                item.parentMenu = menu;

                group.items.push(item);

                if (hasSubItems) {
                    var subMenu = visitItems(subItemsCfg);
                    item.subMenu = subMenu;
                    subMenu.parentItem = item;
                }

                this$1._itemList.push(item);
                this$1._itemMap[item.id] = item;
            };

                for (var j = 0, lenj = itemsGroupCfg.length; j < lenj; j++) loop( j, lenj );
        }

        this$1._menuList.push(menu);
        this$1._menuMap[menu.id] = menu;

        return menu;
    };

    this._rootMenu = visitItems(itemsCfg);
};

ContextMenu.prototype._getNextId = function _getNextId () { // Returns a unique ID
    return "ContextMenu_" + this._id + "" + this._nextId++; // Start ID with alpha chars to make a valid DOM element selector
};

ContextMenu.prototype._createUI = function _createUI () {
        var this$1 = this;
 // Builds DOM elements for the entire menu tree

    var visitMenu = function (menu) {

        this$1._createMenuUI(menu);

        var groups = menu.groups;
        for (var i = 0, len = groups.length; i < len; i++) {
            var group = groups[i];
            var groupItems = group.items;
            for (var j = 0, lenj = groupItems.length; j < lenj; j++) {
                var item = groupItems[j];
                var subMenu = item.subMenu;
                if (subMenu) {
                    visitMenu(subMenu);
                }
            }
        }
    };

    visitMenu(this._rootMenu);
};

ContextMenu.prototype._createMenuUI = function _createMenuUI (menu) { // Builds DOM elements for a menu

    var groups = menu.groups;
    var html = [];

    html.push('<div class="xeokit-context-menu ' + menu.id + '" style="z-index:300000; position: absolute;">');

    html.push('<ul>');

    if (groups) {

        for (var i = 0, len = groups.length; i < len; i++) {

            var group = groups[i];
            var groupIdx = i;
            var groupLen = len;
            var groupItems = group.items;

            if (groupItems) {

                for (var j = 0, lenj = groupItems.length; j < lenj; j++) {

                    var item = groupItems[j];
                    var itemSubMenu = item.subMenu;
                    var actionTitle = item.title || "";

                    if (itemSubMenu) {

                        html.push(
                            '<li id="' + item.id + '" class="xeokit-context-menu-item" style="' +
                            ((groupIdx === groupLen - 1) || ((j < lenj - 1)) ? 'border-bottom: 0' : 'border-bottom: 1px solid black') +
                            '">' +
                            actionTitle +
                            ' [MORE]' +
                            '</li>');

                    } else {

                        html.push(
                            '<li id="' + item.id + '" class="xeokit-context-menu-item" style="' +
                            ((groupIdx === groupLen - 1) || ((j < lenj - 1)) ? 'border-bottom: 0' : 'border-bottom: 1px solid black') +
                            '">' +
                            actionTitle +
                            '</li>');
                    }
                }
            }
        }
    }

    html.push('</ul>');
    html.push('</div>');

    var htmlString = html.join("");

    document.body.insertAdjacentHTML('beforeend', htmlString);

    var menuElement = document.querySelector("." + menu.id);

    menu.menuElement = menuElement;

    menuElement.style["border-radius"] = 4 + "px";
    menuElement.style.display = 'none';
    menuElement.style["z-index"] = 300000;
    menuElement.style.background = "white";
    menuElement.style.border = "1px solid black";
    menuElement.style["box-shadow"] = "0 4px 5px 0 gray";
    menuElement.oncontextmenu = function (e) {
        e.preventDefault();
    };

    // Bind event handlers

    var self = this;

    var lastSubMenu = null;

    if (groups) {

        for (var i$1 = 0, len$1 = groups.length; i$1 < len$1; i$1++) {

            var group$1 = groups[i$1];
            var groupItems$1 = group$1.items;

            if (groupItems$1) {

                var loop = function ( j, lenj ) {

                    var item$1 = groupItems$1[j];
                    var itemSubMenu$1 = item$1.subMenu;

                    item$1.itemElement = document.getElementById(item$1.id);

                    if (!item$1.itemElement) {
                        console.error("ContextMenu item element not found: " + item$1.id);
                        return;
                    }

                    item$1.itemElement.addEventListener("mouseenter", function (event) {
                        event.preventDefault();
                        if (item$1.enabled === false) {
                            return;
                        }
                        var subMenu = item$1.subMenu;
                        if (!subMenu) {
                            if (lastSubMenu) {
                                self._hideMenu(lastSubMenu.id);
                                lastSubMenu = null;
                            }
                            return;
                        }
                        if (lastSubMenu && (lastSubMenu.id !== subMenu.id)) {
                            self._hideMenu(lastSubMenu.id);
                            lastSubMenu = null;
                        }

                        var itemElement = item$1.itemElement;
                        var subMenuElement = subMenu.menuElement;

                        var itemRect = itemElement.getBoundingClientRect();
                        subMenuElement.getBoundingClientRect();

                        var subMenuWidth = 200; // TODO
                        var showOnLeft = ((itemRect.right + subMenuWidth) > window.innerWidth);

                        if (showOnLeft) {
                            self._showMenu(subMenu.id, itemRect.left - subMenuWidth, itemRect.top - 1);
                        } else {
                            self._showMenu(subMenu.id, itemRect.right - 5, itemRect.top - 1);
                        }

                        lastSubMenu = subMenu;
                    });

                    if (!itemSubMenu$1) {

                        // Item without sub-menu
                        // clicking item fires the item's action callback

                        item$1.itemElement.addEventListener("click", function (event) {
                            event.preventDefault();
                            self.hide();
                            if (!self._context) {
                                return;
                            }
                            if (item$1.enabled === false) {
                                return;
                            }
                            if (item$1.doAction) {
                                item$1.doAction(self._context);
                            }
                        });


                        item$1.itemElement.addEventListener("mouseenter", function (event) {
                            event.preventDefault();
                            if (item$1.enabled === false) {
                                return;
                            }
                            if (item$1.doHover) {
                                item$1.doHover(self._context);
                            }
                        });

                    }
                };

                    for (var j$1 = 0, lenj$1 = groupItems$1.length; j$1 < lenj$1; j$1++) loop( j$1, lenj$1 );
            }
        }
    }
};

ContextMenu.prototype._updateItemsTitles = function _updateItemsTitles () { // Dynamically updates the title of each Item to the result of Item#getTitle()
    if (!this._context) {
        return;
    }
    for (var i = 0, len = this._itemList.length; i < len; i++) {
        var item = this._itemList[i];
        var itemElement = item.itemElement;
        if (!itemElement) {
            continue;
        }
        var title = item.getTitle(this._context);
        if (item.subMenu) {
            itemElement.innerText = title;
        } else {
            itemElement.innerText = title;
        }
    }
};

ContextMenu.prototype._updateItemsEnabledStatus = function _updateItemsEnabledStatus () { // Enables or disables each Item, depending on the result of Item#getEnabled()
    if (!this._context) {
        return;
    }
    for (var i = 0, len = this._itemList.length; i < len; i++) {
        var item = this._itemList[i];
        var itemElement = item.itemElement;
        if (!itemElement) {
            continue;
        }
        var getEnabled = item.getEnabled;
        if (!getEnabled) {
            continue;
        }
        var enabled = getEnabled(this._context);
        item.enabled = enabled;
        if (!enabled) {
            itemElement.classList.add("disabled");
        } else {
            itemElement.classList.remove("disabled");
        }
    }
};

ContextMenu.prototype._showMenu = function _showMenu (menuId, pageX, pageY) { // Shows the given menu, at the specified page coordinates
    var menu = this._menuMap[menuId];
    if (!menu) {
        console.error("Menu not found: " + menuId);
        return;
    }
    if (menu.shown) {
        return;
    }
    var menuElement = menu.menuElement;
    if (menuElement) {
        this._showMenuElement(menuElement, pageX, pageY);
        menu.shown = true;
    }
};

ContextMenu.prototype._hideMenu = function _hideMenu (menuId) { // Hides the given menu
    var menu = this._menuMap[menuId];
    if (!menu) {
        console.error("Menu not found: " + menuId);
        return;
    }
    if (!menu.shown) {
        return;
    }
    var menuElement = menu.menuElement;
    if (menuElement) {
        this._hideMenuElement(menuElement);
        menu.shown = false;
    }
};

ContextMenu.prototype._hideAllMenus = function _hideAllMenus () {
    for (var i = 0, len = this._menuList.length; i < len; i++) {
        var menu = this._menuList[i];
        this._hideMenu(menu.id);
    }
};

ContextMenu.prototype._showMenuElement = function _showMenuElement (menuElement, pageX, pageY) { // Shows the given menu element, at the specified page coordinates
    menuElement.style.display = 'block';
    var menuHeight = menuElement.offsetHeight;
    var menuWidth = menuElement.offsetWidth;
    if ((pageY + menuHeight) > window.innerHeight) {
        pageY = window.innerHeight - menuHeight;
    }
    if ((pageX + menuWidth) > window.innerWidth) {
        pageX = window.innerWidth - menuWidth;
    }
    menuElement.style.left = pageX + 'px';
    menuElement.style.top = pageY + 'px';
};

ContextMenu.prototype._hideMenuElement = function _hideMenuElement (menuElement) {
    menuElement.style.display = 'none';
};

Object.defineProperties( ContextMenu.prototype, prototypeAccessors$e );

/**
 @desc Base class for {@link Viewer} plugin classes.
 */
var Plugin = function Plugin(id, viewer, cfg) {

    /**
     * ID for this Plugin, unique within its {@link Viewer}.
     *
     * @type {string}
     */
    this.id = (cfg && cfg.id) ? cfg.id : id;

    /**
     * The Viewer that contains this Plugin.
     *
     * @type {Viewer}
     */
    this.viewer = viewer;

    /**
     * Subscriptions to events fired at this Plugin.
     * @private
     */
    this._eventSubs = {};

    viewer.addPlugin(this);
};

/**
 Subscribes to an event fired at this Plugin.

 @param {String} event The event
 @param {Function} callback Callback fired on the event
 */
Plugin.prototype.on = function on (event, callback) {
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = [];
        this._eventSubs[event] = subs;
    }
    subs.push(callback);
};

/**
 Fires an event at this Plugin.

 @param {String} event The event type name
 @param {Object} value The event parameters
 */
Plugin.prototype.fire = function fire (event, value) {
    var subs = this._eventSubs[event];
    if (subs) {
        for (var i = 0, len = subs.length; i < len; i++) {
            subs[i](value);
        }
    }
};

/**
 * Logs a message to the JavaScript developer console, prefixed with the ID of this Plugin.
 *
 * @param {String} msg The error message
 */
Plugin.prototype.log = function log (msg) {
    console.log(("[xeokit plugin " + (this.id) + "]: " + msg));
};

/**
 * Logs a warning message to the JavaScript developer console, prefixed with the ID of this Plugin.
 *
 * @param {String} msg The error message
 */
Plugin.prototype.warn = function warn (msg) {
    console.warn(("[xeokit plugin " + (this.id) + "]: " + msg));
};

/**
 * Logs an error message to the JavaScript developer console, prefixed with the ID of this Plugin.
 *
 * @param {String} msg The error message
 */
Plugin.prototype.error = function error (msg) {
    console.error(("[xeokit plugin " + (this.id) + "]: " + msg));
};

/**
 * Sends a message to this Plugin.
 *
 * @private
 */
Plugin.prototype.send = function send (name, value) {
    //...
};

/**
 * Destroys this Plugin and removes it from its {@link Viewer}.
 */
Plugin.prototype.destroy = function destroy () {
    this.viewer.removePlugin(this);
};

// Some temporary vars to help avoid garbage collection
var FloatArrayType = Float64Array ;

var tempMat1 = new FloatArrayType(16);
var tempMat2 = new FloatArrayType(16);
var tempVec4$6 = new FloatArrayType(4);


/**
 * @private
 */
var math = {

    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,
    MAX_DOUBLE: Number.MAX_SAFE_INTEGER,

    /**
     * The number of radiians in a degree (0.0174532925).
     * @property DEGTORAD
     * @type {Number}
     */
    DEGTORAD: 0.0174532925,

    /**
     * The number of degrees in a radian.
     * @property RADTODEG
     * @type {Number}
     */
    RADTODEG: 57.295779513,

    unglobalizeObjectId: function unglobalizeObjectId(modelId, globalId) {
        var idx = globalId.indexOf("#");
        return (idx === modelId.length && globalId.startsWith(modelId)) ? globalId.substring(idx + 1) : globalId;
    },

    globalizeObjectId: function globalizeObjectId(modelId, objectId) {
        return (modelId + "#" + objectId)
    },

    /**
     * Returns a new, uninitialized two-element vector.
     * @method vec2
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */
    vec2: function vec2(values) {
        return new FloatArrayType(values || 2);
    },

    /**
     * Returns a new, uninitialized three-element vector.
     * @method vec3
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */
    vec3: function vec3(values) {
        return new FloatArrayType(values || 3);
    },

    /**
     * Returns a new, uninitialized four-element vector.
     * @method vec4
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */
    vec4: function vec4(values) {
        return new FloatArrayType(values || 4);
    },

    /**
     * Returns a new, uninitialized 3x3 matrix.
     * @method mat3
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */
    mat3: function mat3(values) {
        return new FloatArrayType(values || 9);
    },

    /**
     * Converts a 3x3 matrix to 4x4
     * @method mat3ToMat4
     * @param mat3 3x3 matrix.
     * @param mat4 4x4 matrix
     * @static
     * @returns {Number[]}
     */
    mat3ToMat4: function mat3ToMat4(mat3, mat4) {
        if ( mat4 === void 0 ) mat4 = new FloatArrayType(16);

        mat4[0] = mat3[0];
        mat4[1] = mat3[1];
        mat4[2] = mat3[2];
        mat4[3] = 0;
        mat4[4] = mat3[3];
        mat4[5] = mat3[4];
        mat4[6] = mat3[5];
        mat4[7] = 0;
        mat4[8] = mat3[6];
        mat4[9] = mat3[7];
        mat4[10] = mat3[8];
        mat4[11] = 0;
        mat4[12] = 0;
        mat4[13] = 0;
        mat4[14] = 0;
        mat4[15] = 1;
        return mat4;
    },

    /**
     * Returns a new, uninitialized 4x4 matrix.
     * @method mat4
     * @param [values] Initial values.
     * @static
     * @returns {Number[]}
     */
    mat4: function mat4(values) {
        return new FloatArrayType(values || 16);
    },

    /**
     * Converts a 4x4 matrix to 3x3
     * @method mat4ToMat3
     * @param mat4 4x4 matrix.
     * @param mat3 3x3 matrix
     * @static
     * @returns {Number[]}
     */
    mat4ToMat3: function mat4ToMat3(mat4, mat3) { // TODO
        //return new FloatArrayType(values || 9);
    },

    /**
     * Converts a list of double-precision values to a list of high-part floats and a list of low-part floats.
     * @param doubleVals
     * @param floatValsHigh
     * @param floatValsLow
     */
    doublesToFloats: function doublesToFloats(doubleVals, floatValsHigh, floatValsLow) {
        var floatPair = new FloatArrayType(2);
        for (var i = 0, len = doubleVals.length; i < len; i++) {
            math.splitDouble(doubleVals[i], floatPair);
            floatValsHigh[i] = floatPair[0];
            floatValsLow[i] = floatPair[1];
        }
    },

    /**
     * Splits a double value into two floats.
     * @param value
     * @param floatPair
     */
    splitDouble: function splitDouble(value, floatPair) {
        var hi = FloatArrayType.from([value])[0];
        var low = value - hi;
        floatPair[0] = hi;
        floatPair[1] = low;
    },

    /**
     * Returns a new UUID.
     * @method createUUID
     * @static
     * @return string The new UUID
     */
    createUUID: ((function () {
        var lut = [];
        for (var i = 0; i < 256; i++) {
            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
        }
        return function () {
            var d0 = Math.random() * 0xffffffff | 0;
            var d1 = Math.random() * 0xffffffff | 0;
            var d2 = Math.random() * 0xffffffff | 0;
            var d3 = Math.random() * 0xffffffff | 0;
            return ((lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]) + "-" + (lut[d1 & 0xff]) + (lut[d1 >> 8 & 0xff]) + "-" + (lut[d1 >> 16 & 0x0f | 0x40]) + (lut[d1 >> 24 & 0xff]) + "-" + (lut[d2 & 0x3f | 0x80]) + (lut[d2 >> 8 & 0xff]) + "-" + (lut[d2 >> 16 & 0xff]) + (lut[d2 >> 24 & 0xff]) + (lut[d3 & 0xff]) + (lut[d3 >> 8 & 0xff]) + (lut[d3 >> 16 & 0xff]) + (lut[d3 >> 24 & 0xff]));
        };
    }))(),

    /**
     * Clamps a value to the given range.
     * @param {Number} value Value to clamp.
     * @param {Number} min Lower bound.
     * @param {Number} max Upper bound.
     * @returns {Number} Clamped result.
     */
    clamp: function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },

    /**
     * Floating-point modulus
     * @method fmod
     * @static
     * @param {Number} a
     * @param {Number} b
     * @returns {*}
     */
    fmod: function fmod(a, b) {
        if (a < b) {
            console.error("math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring");
            return a;
        }
        while (b <= a) {
            a -= b;
        }
        return a;
    },

    /**
     * Returns true if the two 3-element vectors are the same.
     * @param v1
     * @param v2
     * @returns {boolean}
     */
    compareVec3: function compareVec3(v1, v2) {
        return (v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2]);
    },

    /**
     * Negates a three-element vector.
     * @method negateVec3
     * @static
     * @param {Array(Number)} v Vector to negate
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    negateVec3: function negateVec3(v, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = -v[0];
        dest[1] = -v[1];
        dest[2] = -v[2];
        return dest;
    },

    /**
     * Negates a four-element vector.
     * @method negateVec4
     * @static
     * @param {Array(Number)} v Vector to negate
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    negateVec4: function negateVec4(v, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = -v[0];
        dest[1] = -v[1];
        dest[2] = -v[2];
        dest[3] = -v[3];
        return dest;
    },

    /**
     * Adds one four-element vector to another.
     * @method addVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    addVec4: function addVec4(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] + v[0];
        dest[1] = u[1] + v[1];
        dest[2] = u[2] + v[2];
        dest[3] = u[3] + v[3];
        return dest;
    },

    /**
     * Adds a scalar value to each element of a four-element vector.
     * @method addVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    addVec4Scalar: function addVec4Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] + s;
        dest[1] = v[1] + s;
        dest[2] = v[2] + s;
        dest[3] = v[3] + s;
        return dest;
    },

    /**
     * Adds one three-element vector to another.
     * @method addVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    addVec3: function addVec3(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] + v[0];
        dest[1] = u[1] + v[1];
        dest[2] = u[2] + v[2];
        return dest;
    },

    /**
     * Adds a scalar value to each element of a three-element vector.
     * @method addVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    addVec3Scalar: function addVec3Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] + s;
        dest[1] = v[1] + s;
        dest[2] = v[2] + s;
        return dest;
    },

    /**
     * Subtracts one four-element vector from another.
     * @method subVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    subVec4: function subVec4(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];
        dest[2] = u[2] - v[2];
        dest[3] = u[3] - v[3];
        return dest;
    },

    /**
     * Subtracts one three-element vector from another.
     * @method subVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    subVec3: function subVec3(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];
        dest[2] = u[2] - v[2];
        return dest;
    },

    /**
     * Subtracts one two-element vector from another.
     * @method subVec2
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Vector to subtract
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    subVec2: function subVec2(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];
        return dest;
    },

    /**
     * Get the geometric mean of the vectors.
     * @method geometricMeanVec2
     * @static
     * @param {...Array(Number)} vectors Vec2 to mean
     * @return {Array(Number)} The geometric mean vec2
     */
    geometricMeanVec2: function geometricMeanVec2() {
        var vectors = [], len = arguments.length;
        while ( len-- ) vectors[ len ] = arguments[ len ];

        var geometricMean = new FloatArrayType(vectors[0]);
        for (var i = 1; i < vectors.length; i++) {
            geometricMean[0] += vectors[i][0];
            geometricMean[1] += vectors[i][1];
        }
        geometricMean[0] /= vectors.length;
        geometricMean[1] /= vectors.length;
        return geometricMean;
    },

    /**
     * Subtracts a scalar value from each element of a four-element vector.
     * @method subVec4Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    subVec4Scalar: function subVec4Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] - s;
        dest[1] = v[1] - s;
        dest[2] = v[2] - s;
        dest[3] = v[3] - s;
        return dest;
    },

    /**
     * Sets each element of a 4-element vector to a scalar value minus the value of that element.
     * @method subScalarVec4
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    subScalarVec4: function subScalarVec4(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = s - v[0];
        dest[1] = s - v[1];
        dest[2] = s - v[2];
        dest[3] = s - v[3];
        return dest;
    },

    /**
     * Multiplies one three-element vector by another.
     * @method mulVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    mulVec4: function mulVec4(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] * v[0];
        dest[1] = u[1] * v[1];
        dest[2] = u[2] * v[2];
        dest[3] = u[3] * v[3];
        return dest;
    },

    /**
     * Multiplies each element of a four-element vector by a scalar.
     * @method mulVec34calar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    mulVec4Scalar: function mulVec4Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] * s;
        dest[1] = v[1] * s;
        dest[2] = v[2] * s;
        dest[3] = v[3] * s;
        return dest;
    },

    /**
     * Multiplies each element of a three-element vector by a scalar.
     * @method mulVec3Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    mulVec3Scalar: function mulVec3Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] * s;
        dest[1] = v[1] * s;
        dest[2] = v[2] * s;
        return dest;
    },

    /**
     * Multiplies each element of a two-element vector by a scalar.
     * @method mulVec2Scalar
     * @static
     * @param {Array(Number)} v The vector
     * @param {Number} s The scalar
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, v otherwise
     */
    mulVec2Scalar: function mulVec2Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] * s;
        dest[1] = v[1] * s;
        return dest;
    },

    /**
     * Divides one three-element vector by another.
     * @method divVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    divVec3: function divVec3(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] / v[0];
        dest[1] = u[1] / v[1];
        dest[2] = u[2] / v[2];
        return dest;
    },

    /**
     * Divides one four-element vector by another.
     * @method divVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @param  {Array(Number)} [dest] Destination vector
     * @return {Array(Number)} dest if specified, u otherwise
     */
    divVec4: function divVec4(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        dest[0] = u[0] / v[0];
        dest[1] = u[1] / v[1];
        dest[2] = u[2] / v[2];
        dest[3] = u[3] / v[3];
        return dest;
    },

    /**
     * Divides a scalar by a three-element vector, returning a new vector.
     * @method divScalarVec3
     * @static
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     */
    divScalarVec3: function divScalarVec3(s, v, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = s / v[0];
        dest[1] = s / v[1];
        dest[2] = s / v[2];
        return dest;
    },

    /**
     * Divides a three-element vector by a scalar.
     * @method divVec3Scalar
     * @static
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     */
    divVec3Scalar: function divVec3Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] / s;
        dest[1] = v[1] / s;
        dest[2] = v[2] / s;
        return dest;
    },

    /**
     * Divides a four-element vector by a scalar.
     * @method divVec4Scalar
     * @static
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     */
    divVec4Scalar: function divVec4Scalar(v, s, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = v[0] / s;
        dest[1] = v[1] / s;
        dest[2] = v[2] / s;
        dest[3] = v[3] / s;
        return dest;
    },


    /**
     * Divides a scalar by a four-element vector, returning a new vector.
     * @method divScalarVec4
     * @static
     * @param s scalar
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     */
    divScalarVec4: function divScalarVec4(s, v, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = s / v[0];
        dest[1] = s / v[1];
        dest[2] = s / v[2];
        dest[3] = s / v[3];
        return dest;
    },

    /**
     * Returns the dot product of two four-element vectors.
     * @method dotVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */
    dotVec4: function dotVec4(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
    },

    /**
     * Returns the cross product of two four-element vectors.
     * @method cross3Vec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The cross product
     */
    cross3Vec4: function cross3Vec4(u, v) {
        var u0 = u[0];
        var u1 = u[1];
        var u2 = u[2];
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        return [
            u1 * v2 - u2 * v1,
            u2 * v0 - u0 * v2,
            u0 * v1 - u1 * v0,
            0.0];
    },

    /**
     * Returns the cross product of two three-element vectors.
     * @method cross3Vec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The cross product
     */
    cross3Vec3: function cross3Vec3(u, v, dest) {
        if (!dest) {
            dest = u;
        }
        var x = u[0];
        var y = u[1];
        var z = u[2];
        var x2 = v[0];
        var y2 = v[1];
        var z2 = v[2];
        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    },


    sqLenVec4: function sqLenVec4(v) { // TODO
        return math.dotVec4(v, v);
    },

    /**
     * Returns the length of a four-element vector.
     * @method lenVec4
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */
    lenVec4: function lenVec4(v) {
        return Math.sqrt(math.sqLenVec4(v));
    },

    /**
     * Returns the dot product of two three-element vectors.
     * @method dotVec3
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */
    dotVec3: function dotVec3(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
    },

    /**
     * Returns the dot product of two two-element vectors.
     * @method dotVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */
    dotVec2: function dotVec2(u, v) {
        return (u[0] * v[0] + u[1] * v[1]);
    },


    sqLenVec3: function sqLenVec3(v) {
        return math.dotVec3(v, v);
    },


    sqLenVec2: function sqLenVec2(v) {
        return math.dotVec2(v, v);
    },

    /**
     * Returns the length of a three-element vector.
     * @method lenVec3
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */
    lenVec3: function lenVec3(v) {
        return Math.sqrt(math.sqLenVec3(v));
    },

    distVec3: ((function () {
        var vec = new FloatArrayType(3);
        return function (v, w) { return math.lenVec3(math.subVec3(v, w, vec)); };
    }))(),

    /**
     * Returns the length of a two-element vector.
     * @method lenVec2
     * @static
     * @param {Array(Number)} v The vector
     * @return The length
     */
    lenVec2: function lenVec2(v) {
        return Math.sqrt(math.sqLenVec2(v));
    },

    distVec2: ((function () {
        var vec = new FloatArrayType(2);
        return function (v, w) { return math.lenVec2(math.subVec2(v, w, vec)); };
    }))(),

    /**
     * @method rcpVec3
     * @static
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return [] dest if specified, v otherwise
     *
     */
    rcpVec3: function rcpVec3(v, dest) {
        return math.divScalarVec3(1.0, v, dest);
    },

    /**
     * Normalizes a four-element vector
     * @method normalizeVec4
     * @static
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return [] dest if specified, v otherwise
     *
     */
    normalizeVec4: function normalizeVec4(v, dest) {
        var f = 1.0 / math.lenVec4(v);
        return math.mulVec4Scalar(v, f, dest);
    },

    /**
     * Normalizes a three-element vector
     * @method normalizeVec4
     * @static
     */
    normalizeVec3: function normalizeVec3(v, dest) {
        var f = 1.0 / math.lenVec3(v);
        return math.mulVec3Scalar(v, f, dest);
    },

    /**
     * Normalizes a two-element vector
     * @method normalizeVec2
     * @static
     */
    normalizeVec2: function normalizeVec2(v, dest) {
        var f = 1.0 / math.lenVec2(v);
        return math.mulVec2Scalar(v, f, dest);
    },

    /**
     * Gets the angle between two vectors
     * @method angleVec3
     * @param v
     * @param w
     * @returns {number}
     */
    angleVec3: function angleVec3(v, w) {
        var theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));
        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems
        return Math.acos(theta);
    },

    /**
     * Creates a three-element vector from the rotation part of a sixteen-element matrix.
     * @param m
     * @param dest
     */
    vec3FromMat4Scale: ((function () {

        var tempVec3 = new FloatArrayType(3);

        return function (m, dest) {

            tempVec3[0] = m[0];
            tempVec3[1] = m[1];
            tempVec3[2] = m[2];

            dest[0] = math.lenVec3(tempVec3);

            tempVec3[0] = m[4];
            tempVec3[1] = m[5];
            tempVec3[2] = m[6];

            dest[1] = math.lenVec3(tempVec3);

            tempVec3[0] = m[8];
            tempVec3[1] = m[9];
            tempVec3[2] = m[10];

            dest[2] = math.lenVec3(tempVec3);

            return dest;
        };
    }))(),

    /**
     * Converts an n-element vector to a JSON-serializable
     * array with values rounded to two decimal places.
     */
    vecToArray: ((function () {
        function trunc(v) {
            return Math.round(v * 100000) / 100000
        }

        return function (v) {
            v = Array.prototype.slice.call(v);
            for (var i = 0, len = v.length; i < len; i++) {
                v[i] = trunc(v[i]);
            }
            return v;
        };
    }))(),

    /**
     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.
     * @param arr
     * @returns {{x: *, y: *, z: *}}
     */
    xyzArrayToObject: function xyzArrayToObject(arr) {
        return {"x": arr[0], "y": arr[1], "z": arr[2]};
    },

    /**
     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.
     * @param xyz
     * @param  [arry]
     * @returns {*[]}
     */
    xyzObjectToArray: function xyzObjectToArray(xyz, arry) {
        arry = arry || math.vec3();
        arry[0] = xyz.x;
        arry[1] = xyz.y;
        arry[2] = xyz.z;
        return arry;
    },

    /**
     * Duplicates a 4x4 identity matrix.
     * @method dupMat4
     * @static
     */
    dupMat4: function dupMat4(m) {
        return m.slice(0, 16);
    },

    /**
     * Extracts a 3x3 matrix from a 4x4 matrix.
     * @method mat4To3
     * @static
     */
    mat4To3: function mat4To3(m) {
        return [
            m[0], m[1], m[2],
            m[4], m[5], m[6],
            m[8], m[9], m[10]
        ];
    },

    /**
     * Returns a 4x4 matrix with each element set to the given scalar value.
     * @method m4s
     * @static
     */
    m4s: function m4s(s) {
        return [
            s, s, s, s,
            s, s, s, s,
            s, s, s, s,
            s, s, s, s
        ];
    },

    /**
     * Returns a 4x4 matrix with each element set to zero.
     * @method setMat4ToZeroes
     * @static
     */
    setMat4ToZeroes: function setMat4ToZeroes() {
        return math.m4s(0.0);
    },

    /**
     * Returns a 4x4 matrix with each element set to 1.0.
     * @method setMat4ToOnes
     * @static
     */
    setMat4ToOnes: function setMat4ToOnes() {
        return math.m4s(1.0);
    },

    /**
     * Returns a 4x4 matrix with each element set to 1.0.
     * @method setMat4ToOnes
     * @static
     */
    diagonalMat4v: function diagonalMat4v(v) {
        return new FloatArrayType([
            v[0], 0.0, 0.0, 0.0,
            0.0, v[1], 0.0, 0.0,
            0.0, 0.0, v[2], 0.0,
            0.0, 0.0, 0.0, v[3]
        ]);
    },

    /**
     * Returns a 4x4 matrix with diagonal elements set to the given vector.
     * @method diagonalMat4c
     * @static
     */
    diagonalMat4c: function diagonalMat4c(x, y, z, w) {
        return math.diagonalMat4v([x, y, z, w]);
    },

    /**
     * Returns a 4x4 matrix with diagonal elements set to the given scalar.
     * @method diagonalMat4s
     * @static
     */
    diagonalMat4s: function diagonalMat4s(s) {
        return math.diagonalMat4c(s, s, s, s);
    },

    /**
     * Returns a 4x4 identity matrix.
     * @method identityMat4
     * @static
     */
    identityMat4: function identityMat4(mat) {
        if ( mat === void 0 ) mat = new FloatArrayType(16);

        mat[0] = 1.0;
        mat[1] = 0.0;
        mat[2] = 0.0;
        mat[3] = 0.0;

        mat[4] = 0.0;
        mat[5] = 1.0;
        mat[6] = 0.0;
        mat[7] = 0.0;

        mat[8] = 0.0;
        mat[9] = 0.0;
        mat[10] = 1.0;
        mat[11] = 0.0;

        mat[12] = 0.0;
        mat[13] = 0.0;
        mat[14] = 0.0;
        mat[15] = 1.0;

        return mat;
    },

    /**
     * Returns a 3x3 identity matrix.
     * @method identityMat3
     * @static
     */
    identityMat3: function identityMat3(mat) {
        if ( mat === void 0 ) mat = new FloatArrayType(9);

        mat[0] = 1.0;
        mat[1] = 0.0;
        mat[2] = 0.0;

        mat[3] = 0.0;
        mat[4] = 1.0;
        mat[5] = 0.0;

        mat[6] = 0.0;
        mat[7] = 0.0;
        mat[8] = 1.0;

        return mat;
    },

    /**
     * Tests if the given 4x4 matrix is the identity matrix.
     * @method isIdentityMat4
     * @static
     */
    isIdentityMat4: function isIdentityMat4(m) {
        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||
            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||
            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||
            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {
            return false;
        }
        return true;
    },

    /**
     * Negates the given 4x4 matrix.
     * @method negateMat4
     * @static
     */
    negateMat4: function negateMat4(m, dest) {
        if (!dest) {
            dest = m;
        }
        dest[0] = -m[0];
        dest[1] = -m[1];
        dest[2] = -m[2];
        dest[3] = -m[3];
        dest[4] = -m[4];
        dest[5] = -m[5];
        dest[6] = -m[6];
        dest[7] = -m[7];
        dest[8] = -m[8];
        dest[9] = -m[9];
        dest[10] = -m[10];
        dest[11] = -m[11];
        dest[12] = -m[12];
        dest[13] = -m[13];
        dest[14] = -m[14];
        dest[15] = -m[15];
        return dest;
    },

    /**
     * Adds the given 4x4 matrices together.
     * @method addMat4
     * @static
     */
    addMat4: function addMat4(a, b, dest) {
        if (!dest) {
            dest = a;
        }
        dest[0] = a[0] + b[0];
        dest[1] = a[1] + b[1];
        dest[2] = a[2] + b[2];
        dest[3] = a[3] + b[3];
        dest[4] = a[4] + b[4];
        dest[5] = a[5] + b[5];
        dest[6] = a[6] + b[6];
        dest[7] = a[7] + b[7];
        dest[8] = a[8] + b[8];
        dest[9] = a[9] + b[9];
        dest[10] = a[10] + b[10];
        dest[11] = a[11] + b[11];
        dest[12] = a[12] + b[12];
        dest[13] = a[13] + b[13];
        dest[14] = a[14] + b[14];
        dest[15] = a[15] + b[15];
        return dest;
    },

    /**
     * Adds the given scalar to each element of the given 4x4 matrix.
     * @method addMat4Scalar
     * @static
     */
    addMat4Scalar: function addMat4Scalar(m, s, dest) {
        if (!dest) {
            dest = m;
        }
        dest[0] = m[0] + s;
        dest[1] = m[1] + s;
        dest[2] = m[2] + s;
        dest[3] = m[3] + s;
        dest[4] = m[4] + s;
        dest[5] = m[5] + s;
        dest[6] = m[6] + s;
        dest[7] = m[7] + s;
        dest[8] = m[8] + s;
        dest[9] = m[9] + s;
        dest[10] = m[10] + s;
        dest[11] = m[11] + s;
        dest[12] = m[12] + s;
        dest[13] = m[13] + s;
        dest[14] = m[14] + s;
        dest[15] = m[15] + s;
        return dest;
    },

    /**
     * Adds the given scalar to each element of the given 4x4 matrix.
     * @method addScalarMat4
     * @static
     */
    addScalarMat4: function addScalarMat4(s, m, dest) {
        return math.addMat4Scalar(m, s, dest);
    },

    /**
     * Subtracts the second 4x4 matrix from the first.
     * @method subMat4
     * @static
     */
    subMat4: function subMat4(a, b, dest) {
        if (!dest) {
            dest = a;
        }
        dest[0] = a[0] - b[0];
        dest[1] = a[1] - b[1];
        dest[2] = a[2] - b[2];
        dest[3] = a[3] - b[3];
        dest[4] = a[4] - b[4];
        dest[5] = a[5] - b[5];
        dest[6] = a[6] - b[6];
        dest[7] = a[7] - b[7];
        dest[8] = a[8] - b[8];
        dest[9] = a[9] - b[9];
        dest[10] = a[10] - b[10];
        dest[11] = a[11] - b[11];
        dest[12] = a[12] - b[12];
        dest[13] = a[13] - b[13];
        dest[14] = a[14] - b[14];
        dest[15] = a[15] - b[15];
        return dest;
    },

    /**
     * Subtracts the given scalar from each element of the given 4x4 matrix.
     * @method subMat4Scalar
     * @static
     */
    subMat4Scalar: function subMat4Scalar(m, s, dest) {
        if (!dest) {
            dest = m;
        }
        dest[0] = m[0] - s;
        dest[1] = m[1] - s;
        dest[2] = m[2] - s;
        dest[3] = m[3] - s;
        dest[4] = m[4] - s;
        dest[5] = m[5] - s;
        dest[6] = m[6] - s;
        dest[7] = m[7] - s;
        dest[8] = m[8] - s;
        dest[9] = m[9] - s;
        dest[10] = m[10] - s;
        dest[11] = m[11] - s;
        dest[12] = m[12] - s;
        dest[13] = m[13] - s;
        dest[14] = m[14] - s;
        dest[15] = m[15] - s;
        return dest;
    },

    /**
     * Subtracts the given scalar from each element of the given 4x4 matrix.
     * @method subScalarMat4
     * @static
     */
    subScalarMat4: function subScalarMat4(s, m, dest) {
        if (!dest) {
            dest = m;
        }
        dest[0] = s - m[0];
        dest[1] = s - m[1];
        dest[2] = s - m[2];
        dest[3] = s - m[3];
        dest[4] = s - m[4];
        dest[5] = s - m[5];
        dest[6] = s - m[6];
        dest[7] = s - m[7];
        dest[8] = s - m[8];
        dest[9] = s - m[9];
        dest[10] = s - m[10];
        dest[11] = s - m[11];
        dest[12] = s - m[12];
        dest[13] = s - m[13];
        dest[14] = s - m[14];
        dest[15] = s - m[15];
        return dest;
    },

    /**
     * Multiplies the two given 4x4 matrix by each other.
     * @method mulMat4
     * @static
     */
    mulMat4: function mulMat4(a, b, dest) {
        if (!dest) {
            dest = a;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = a[0];

        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];
        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];
        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];
        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];
        var b00 = b[0];
        var b01 = b[1];
        var b02 = b[2];
        var b03 = b[3];
        var b10 = b[4];
        var b11 = b[5];
        var b12 = b[6];
        var b13 = b[7];
        var b20 = b[8];
        var b21 = b[9];
        var b22 = b[10];
        var b23 = b[11];
        var b30 = b[12];
        var b31 = b[13];
        var b32 = b[14];
        var b33 = b[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    },

    /**
     * Multiplies the two given 3x3 matrices by each other.
     * @method mulMat4
     * @static
     */
    mulMat3: function mulMat3(a, b, dest) {
        if (!dest) {
            dest = new FloatArrayType(9);
        }

        var a11 = a[0];
        var a12 = a[3];
        var a13 = a[6];
        var a21 = a[1];
        var a22 = a[4];
        var a23 = a[7];
        var a31 = a[2];
        var a32 = a[5];
        var a33 = a[8];
        var b11 = b[0];
        var b12 = b[3];
        var b13 = b[6];
        var b21 = b[1];
        var b22 = b[4];
        var b23 = b[7];
        var b31 = b[2];
        var b32 = b[5];
        var b33 = b[8];

        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;
        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;
        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;

        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;
        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;
        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;

        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;
        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;
        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;

        return dest;
    },

    /**
     * Multiplies each element of the given 4x4 matrix by the given scalar.
     * @method mulMat4Scalar
     * @static
     */
    mulMat4Scalar: function mulMat4Scalar(m, s, dest) {
        if (!dest) {
            dest = m;
        }
        dest[0] = m[0] * s;
        dest[1] = m[1] * s;
        dest[2] = m[2] * s;
        dest[3] = m[3] * s;
        dest[4] = m[4] * s;
        dest[5] = m[5] * s;
        dest[6] = m[6] * s;
        dest[7] = m[7] * s;
        dest[8] = m[8] * s;
        dest[9] = m[9] * s;
        dest[10] = m[10] * s;
        dest[11] = m[11] * s;
        dest[12] = m[12] * s;
        dest[13] = m[13] * s;
        dest[14] = m[14] * s;
        dest[15] = m[15] * s;
        return dest;
    },

    /**
     * Multiplies the given 4x4 matrix by the given four-element vector.
     * @method mulMat4v4
     * @static
     */
    mulMat4v4: function mulMat4v4(m, v, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        var v3 = v[3];
        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
        return dest;
    },

    /**
     * Transposes the given 4x4 matrix.
     * @method transposeMat4
     * @static
     */
    transposeMat4: function transposeMat4(mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        var m4 = mat[4];

        var m14 = mat[14];
        var m8 = mat[8];
        var m13 = mat[13];
        var m12 = mat[12];
        var m9 = mat[9];
        if (!dest || mat === dest) {
            var a01 = mat[1];
            var a02 = mat[2];
            var a03 = mat[3];
            var a12 = mat[6];
            var a13 = mat[7];
            var a23 = mat[11];
            mat[1] = m4;
            mat[2] = m8;
            mat[3] = m12;
            mat[4] = a01;
            mat[6] = m9;
            mat[7] = m13;
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = m14;
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }
        dest[0] = mat[0];
        dest[1] = m4;
        dest[2] = m8;
        dest[3] = m12;
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = m9;
        dest[7] = m13;
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = m14;
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    },

    /**
     * Transposes the given 3x3 matrix.
     *
     * @method transposeMat3
     * @static
     */
    transposeMat3: function transposeMat3(mat, dest) {
        if (dest === mat) {
            var a01 = mat[1];
            var a02 = mat[2];
            var a12 = mat[5];
            dest[1] = mat[3];
            dest[2] = mat[6];
            dest[3] = a01;
            dest[5] = mat[7];
            dest[6] = a02;
            dest[7] = a12;
        } else {
            dest[0] = mat[0];
            dest[1] = mat[3];
            dest[2] = mat[6];
            dest[3] = mat[1];
            dest[4] = mat[4];
            dest[5] = mat[7];
            dest[6] = mat[2];
            dest[7] = mat[5];
            dest[8] = mat[8];
        }
        return dest;
    },

    /**
     * Returns the determinant of the given 4x4 matrix.
     * @method determinantMat4
     * @static
     */
    determinantMat4: function determinantMat4(mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0];

        var a01 = mat[1];
        var a02 = mat[2];
        var a03 = mat[3];
        var a10 = mat[4];
        var a11 = mat[5];
        var a12 = mat[6];
        var a13 = mat[7];
        var a20 = mat[8];
        var a21 = mat[9];
        var a22 = mat[10];
        var a23 = mat[11];
        var a30 = mat[12];
        var a31 = mat[13];
        var a32 = mat[14];
        var a33 = mat[15];
        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
    },

    /**
     * Returns the inverse of the given 4x4 matrix.
     * @method inverseMat4
     * @static
     */
    inverseMat4: function inverseMat4(mat, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0];

        var a01 = mat[1];
        var a02 = mat[2];
        var a03 = mat[3];
        var a10 = mat[4];
        var a11 = mat[5];
        var a12 = mat[6];
        var a13 = mat[7];
        var a20 = mat[8];
        var a21 = mat[9];
        var a22 = mat[10];
        var a23 = mat[11];
        var a30 = mat[12];
        var a31 = mat[13];
        var a32 = mat[14];
        var a33 = mat[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant (inlined to avoid double-caching)
        var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    },

    /**
     * Returns the trace of the given 4x4 matrix.
     * @method traceMat4
     * @static
     */
    traceMat4: function traceMat4(m) {
        return (m[0] + m[5] + m[10] + m[15]);
    },

    /**
     * Returns 4x4 translation matrix.
     * @method translationMat4
     * @static
     */
    translationMat4v: function translationMat4v(v, dest) {
        var m = dest || math.identityMat4();
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        return m;
    },

    /**
     * Returns 3x3 translation matrix.
     * @method translationMat3
     * @static
     */
    translationMat3v: function translationMat3v(v, dest) {
        var m = dest || math.identityMat3();
        m[6] = v[0];
        m[7] = v[1];
        return m;
    },

    /**
     * Returns 4x4 translation matrix.
     * @method translationMat4c
     * @static
     */
    translationMat4c: ((function () {
        var xyz = new FloatArrayType(3);
        return function (x, y, z, dest) {
            xyz[0] = x;
            xyz[1] = y;
            xyz[2] = z;
            return math.translationMat4v(xyz, dest);
        };
    }))(),

    /**
     * Returns 4x4 translation matrix.
     * @method translationMat4s
     * @static
     */
    translationMat4s: function translationMat4s(s, dest) {
        return math.translationMat4c(s, s, s, dest);
    },

    /**
     * Efficiently post-concatenates a translation to the given matrix.
     * @param v
     * @param m
     */
    translateMat4v: function translateMat4v(xyz, m) {
        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);
    },

    /**
     * Efficiently post-concatenates a translation to the given matrix.
     * @param x
     * @param y
     * @param z
     * @param m
     */
    OLDtranslateMat4c: function OLDtranslateMat4c(x, y, z, m) {

        var m12 = m[12];
        m[0] += m12 * x;
        m[4] += m12 * y;
        m[8] += m12 * z;

        var m13 = m[13];
        m[1] += m13 * x;
        m[5] += m13 * y;
        m[9] += m13 * z;

        var m14 = m[14];
        m[2] += m14 * x;
        m[6] += m14 * y;
        m[10] += m14 * z;

        var m15 = m[15];
        m[3] += m15 * x;
        m[7] += m15 * y;
        m[11] += m15 * z;

        return m;
    },

    translateMat4c: function translateMat4c(x, y, z, m) {

        var m3 = m[3];
        m[0] += m3 * x;
        m[1] += m3 * y;
        m[2] += m3 * z;

        var m7 = m[7];
        m[4] += m7 * x;
        m[5] += m7 * y;
        m[6] += m7 * z;

        var m11 = m[11];
        m[8] += m11 * x;
        m[9] += m11 * y;
        m[10] += m11 * z;

        var m15 = m[15];
        m[12] += m15 * x;
        m[13] += m15 * y;
        m[14] += m15 * z;

        return m;
    },

    /**
     * Creates a new matrix that replaces the translation in the rightmost column of the given
     * affine matrix with the given translation.
     * @param m
     * @param translation
     * @param dest
     * @returns {*}
     */
    setMat4Translation: function setMat4Translation(m, translation, dest) {

        dest[0] = m[0];
        dest[1] = m[1];
        dest[2] = m[2];
        dest[3] = m[3];

        dest[4] = m[4];
        dest[5] = m[5];
        dest[6] = m[6];
        dest[7] = m[7];

        dest[8] = m[8];
        dest[9] = m[9];
        dest[10] = m[10];
        dest[11] = m[11];

        dest[12] = translation[0];
        dest[13] = translation[1];
        dest[14] = translation[2];
        dest[15] = m[15];

        return dest;
    },

    /**
     * Returns 4x4 rotation matrix.
     * @method rotationMat4v
     * @static
     */
    rotationMat4v: function rotationMat4v(anglerad, axis, m) {
        var ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);
        var s = Math.sin(anglerad);
        var c = Math.cos(anglerad);
        var q = 1.0 - c;

        var x = ax[0];
        var y = ax[1];
        var z = ax[2];

        var xy;
        var yz;
        var zx;
        var xs;
        var ys;
        var zs;

        //xx = x * x; used once
        //yy = y * y; used once
        //zz = z * z; used once
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        m = m || math.mat4();

        m[0] = (q * x * x) + c;
        m[1] = (q * xy) + zs;
        m[2] = (q * zx) - ys;
        m[3] = 0.0;

        m[4] = (q * xy) - zs;
        m[5] = (q * y * y) + c;
        m[6] = (q * yz) + xs;
        m[7] = 0.0;

        m[8] = (q * zx) + ys;
        m[9] = (q * yz) - xs;
        m[10] = (q * z * z) + c;
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        return m;
    },

    /**
     * Returns 4x4 rotation matrix.
     * @method rotationMat4c
     * @static
     */
    rotationMat4c: function rotationMat4c(anglerad, x, y, z, mat) {
        return math.rotationMat4v(anglerad, [x, y, z], mat);
    },

    /**
     * Returns 4x4 scale matrix.
     * @method scalingMat4v
     * @static
     */
    scalingMat4v: function scalingMat4v(v, m) {
        if ( m === void 0 ) m = math.identityMat4();

        m[0] = v[0];
        m[5] = v[1];
        m[10] = v[2];
        return m;
    },

    /**
     * Returns 3x3 scale matrix.
     * @method scalingMat3v
     * @static
     */
    scalingMat3v: function scalingMat3v(v, m) {
        if ( m === void 0 ) m = math.identityMat3();

        m[0] = v[0];
        m[4] = v[1];
        return m;
    },

    /**
     * Returns 4x4 scale matrix.
     * @method scalingMat4c
     * @static
     */
    scalingMat4c: ((function () {
        var xyz = new FloatArrayType(3);
        return function (x, y, z, dest) {
            xyz[0] = x;
            xyz[1] = y;
            xyz[2] = z;
            return math.scalingMat4v(xyz, dest);
        };
    }))(),

    /**
     * Efficiently post-concatenates a scaling to the given matrix.
     * @method scaleMat4c
     * @param x
     * @param y
     * @param z
     * @param m
     */
    scaleMat4c: function scaleMat4c(x, y, z, m) {

        m[0] *= x;
        m[4] *= y;
        m[8] *= z;

        m[1] *= x;
        m[5] *= y;
        m[9] *= z;

        m[2] *= x;
        m[6] *= y;
        m[10] *= z;

        m[3] *= x;
        m[7] *= y;
        m[11] *= z;
        return m;
    },

    /**
     * Efficiently post-concatenates a scaling to the given matrix.
     * @method scaleMat4c
     * @param xyz
     * @param m
     */
    scaleMat4v: function scaleMat4v(xyz, m) {

        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];

        m[0] *= x;
        m[4] *= y;
        m[8] *= z;
        m[1] *= x;
        m[5] *= y;
        m[9] *= z;
        m[2] *= x;
        m[6] *= y;
        m[10] *= z;
        m[3] *= x;
        m[7] *= y;
        m[11] *= z;

        return m;
    },

    /**
     * Returns 4x4 scale matrix.
     * @method scalingMat4s
     * @static
     */
    scalingMat4s: function scalingMat4s(s) {
        return math.scalingMat4c(s, s, s);
    },

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     *
     * @param {Number[]} q Rotation quaternion
     * @param {Number[]} v Translation vector
     * @param {Number[]} dest Destination matrix
     * @returns {Number[]} dest
     */
    rotationTranslationMat4: function rotationTranslationMat4(q, v, dest) {
        if ( dest === void 0 ) dest = math.mat4();

        var x = q[0];
        var y = q[1];
        var z = q[2];
        var w = q[3];

        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = v[0];
        dest[13] = v[1];
        dest[14] = v[2];
        dest[15] = 1;

        return dest;
    },

    /**
     * Gets Euler angles from a 4x4 matrix.
     *
     * @param {Number[]} mat The 4x4 matrix.
     * @param {String} order Desired Euler angle order: "XYZ", "YXZ", "ZXY" etc.
     * @param {Number[]} [dest] Destination Euler angles, created by default.
     * @returns {Number[]} The Euler angles.
     */
    mat4ToEuler: function mat4ToEuler(mat, order, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        var clamp = math.clamp;

        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var m11 = mat[0];

        var m12 = mat[4];
        var m13 = mat[8];
        var m21 = mat[1];
        var m22 = mat[5];
        var m23 = mat[9];
        var m31 = mat[2];
        var m32 = mat[6];
        var m33 = mat[10];

        if (order === 'XYZ') {

            dest[1] = Math.asin(clamp(m13, -1, 1));

            if (Math.abs(m13) < 0.99999) {
                dest[0] = Math.atan2(-m23, m33);
                dest[2] = Math.atan2(-m12, m11);
            } else {
                dest[0] = Math.atan2(m32, m22);
                dest[2] = 0;

            }

        } else if (order === 'YXZ') {

            dest[0] = Math.asin(-clamp(m23, -1, 1));

            if (Math.abs(m23) < 0.99999) {
                dest[1] = Math.atan2(m13, m33);
                dest[2] = Math.atan2(m21, m22);
            } else {
                dest[1] = Math.atan2(-m31, m11);
                dest[2] = 0;
            }

        } else if (order === 'ZXY') {

            dest[0] = Math.asin(clamp(m32, -1, 1));

            if (Math.abs(m32) < 0.99999) {
                dest[1] = Math.atan2(-m31, m33);
                dest[2] = Math.atan2(-m12, m22);
            } else {
                dest[1] = 0;
                dest[2] = Math.atan2(m21, m11);
            }

        } else if (order === 'ZYX') {

            dest[1] = Math.asin(-clamp(m31, -1, 1));

            if (Math.abs(m31) < 0.99999) {
                dest[0] = Math.atan2(m32, m33);
                dest[2] = Math.atan2(m21, m11);
            } else {
                dest[0] = 0;
                dest[2] = Math.atan2(-m12, m22);
            }

        } else if (order === 'YZX') {

            dest[2] = Math.asin(clamp(m21, -1, 1));

            if (Math.abs(m21) < 0.99999) {
                dest[0] = Math.atan2(-m23, m22);
                dest[1] = Math.atan2(-m31, m11);
            } else {
                dest[0] = 0;
                dest[1] = Math.atan2(m13, m33);
            }

        } else if (order === 'XZY') {

            dest[2] = Math.asin(-clamp(m12, -1, 1));

            if (Math.abs(m12) < 0.99999) {
                dest[0] = Math.atan2(m32, m22);
                dest[1] = Math.atan2(m13, m11);
            } else {
                dest[0] = Math.atan2(-m23, m33);
                dest[1] = 0;
            }
        }

        return dest;
    },

    composeMat4: function composeMat4(position, quaternion, scale, mat) {
        if ( mat === void 0 ) mat = math.mat4();

        math.quaternionToRotationMat4(quaternion, mat);
        math.scaleMat4v(scale, mat);
        math.translateMat4v(position, mat);

        return mat;
    },

    decomposeMat4: (function () {

        var vec = new FloatArrayType(3);
        var matrix = new FloatArrayType(16);

        return function decompose(mat, position, quaternion, scale) {

            vec[0] = mat[0];
            vec[1] = mat[1];
            vec[2] = mat[2];

            var sx = math.lenVec3(vec);

            vec[0] = mat[4];
            vec[1] = mat[5];
            vec[2] = mat[6];

            var sy = math.lenVec3(vec);

            vec[8] = mat[8];
            vec[9] = mat[9];
            vec[10] = mat[10];

            var sz = math.lenVec3(vec);

            // if determine is negative, we need to invert one scale
            var det = math.determinantMat4(mat);

            if (det < 0) {
                sx = -sx;
            }

            position[0] = mat[12];
            position[1] = mat[13];
            position[2] = mat[14];

            // scale the rotation part
            matrix.set(mat);

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix[0] *= invSX;
            matrix[1] *= invSX;
            matrix[2] *= invSX;

            matrix[4] *= invSY;
            matrix[5] *= invSY;
            matrix[6] *= invSY;

            matrix[8] *= invSZ;
            matrix[9] *= invSZ;
            matrix[10] *= invSZ;

            math.mat4ToQuaternion(matrix, quaternion);

            scale[0] = sx;
            scale[1] = sy;
            scale[2] = sz;

            return this;

        };

    })(),

    /** @private */
    getColMat4: function getColMat4(mat, c) {
        var i = c * 4;
        return [mat[i], mat[i + 1], mat[i + 2], mat[i + 3]];
    },

    /** @private */
    setRowMat4: function setRowMat4(mat, r, v) {
        mat[r] = v[0];
        mat[r + 4] = v[1];
        mat[r + 8] = v[2];
        mat[r + 12] = v[3];
    },

    /**
     * Returns a 4x4 'lookat' viewing transform matrix.
     * @method lookAtMat4v
     * @param pos vec3 position of the viewer
     * @param target vec3 point the viewer is looking at
     * @param up vec3 pointing "up"
     * @param dest mat4 Optional, mat4 matrix will be written into
     *
     * @return {mat4} dest if specified, a new mat4 otherwise
     */
    lookAtMat4v: function lookAtMat4v(pos, target, up, dest) {
        if (!dest) {
            dest = math.mat4();
        }

        var posx = pos[0];
        var posy = pos[1];
        var posz = pos[2];
        var upx = up[0];
        var upy = up[1];
        var upz = up[2];
        var targetx = target[0];
        var targety = target[1];
        var targetz = target[2];

        if (posx === targetx && posy === targety && posz === targetz) {
            return math.identityMat4();
        }

        var z0;
        var z1;
        var z2;
        var x0;
        var x1;
        var x2;
        var y0;
        var y1;
        var y2;
        var len;

        //vec3.direction(eye, center, z);
        z0 = posx - targetx;
        z1 = posy - targety;
        z2 = posz - targetz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
        dest[15] = 1;

        return dest;
    },

    /**
     * Returns a 4x4 'lookat' viewing transform matrix.
     * @method lookAtMat4c
     * @static
     */
    lookAtMat4c: function lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {
        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);
    },

    /**
     * Returns a 4x4 orthographic projection matrix.
     * @method orthoMat4c
     * @static
     */
    orthoMat4c: function orthoMat4c(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = math.mat4();
        }
        var rl = (right - left);
        var tb = (top - bottom);
        var fn = (far - near);

        dest[0] = 2.0 / rl;
        dest[1] = 0.0;
        dest[2] = 0.0;
        dest[3] = 0.0;

        dest[4] = 0.0;
        dest[5] = 2.0 / tb;
        dest[6] = 0.0;
        dest[7] = 0.0;

        dest[8] = 0.0;
        dest[9] = 0.0;
        dest[10] = -2.0 / fn;
        dest[11] = 0.0;

        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1.0;

        return dest;
    },

    /**
     * Returns a 4x4 perspective projection matrix.
     * @method frustumMat4v
     * @static
     */
    frustumMat4v: function frustumMat4v(fmin, fmax, m) {
        if (!m) {
            m = math.mat4();
        }

        var fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];
        var fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];

        math.addVec4(fmax4, fmin4, tempMat1);
        math.subVec4(fmax4, fmin4, tempMat2);

        var t = 2.0 * fmin4[2];

        var tempMat20 = tempMat2[0];
        var tempMat21 = tempMat2[1];
        var tempMat22 = tempMat2[2];

        m[0] = t / tempMat20;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = t / tempMat21;
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = tempMat1[0] / tempMat20;
        m[9] = tempMat1[1] / tempMat21;
        m[10] = -tempMat1[2] / tempMat22;
        m[11] = -1.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = -t * fmax4[2] / tempMat22;
        m[15] = 0.0;

        return m;
    },

    /**
     * Returns a 4x4 perspective projection matrix.
     * @method frustumMat4v
     * @static
     */
    frustumMat4: function frustumMat4(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = math.mat4();
        }
        var rl = (right - left);
        var tb = (top - bottom);
        var fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    },

    /**
     * Returns a 4x4 perspective projection matrix.
     * @method perspectiveMat4v
     * @static
     */
    perspectiveMat4: function perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {
        var pmin = [];
        var pmax = [];

        pmin[2] = znear;
        pmax[2] = zfar;

        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
        pmin[1] = -pmax[1];

        pmax[0] = pmax[1] * aspectratio;
        pmin[0] = -pmax[0];

        return math.frustumMat4v(pmin, pmax, m);
    },

    /**
     * Returns true if the two 4x4 matrices are the same.
     * @param m1
     * @param m2
     * @returns {boolean}
     */
    compareMat4: function compareMat4(m1, m2) {
        return m1[0] === m2[0] &&
            m1[1] === m2[1] &&
            m1[2] === m2[2] &&
            m1[3] === m2[3] &&
            m1[4] === m2[4] &&
            m1[5] === m2[5] &&
            m1[6] === m2[6] &&
            m1[7] === m2[7] &&
            m1[8] === m2[8] &&
            m1[9] === m2[9] &&
            m1[10] === m2[10] &&
            m1[11] === m2[11] &&
            m1[12] === m2[12] &&
            m1[13] === m2[13] &&
            m1[14] === m2[14] &&
            m1[15] === m2[15];
    },

    /**
     * Transforms a three-element position by a 4x4 matrix.
     * @method transformPoint3
     * @static
     */
    transformPoint3: function transformPoint3(m, p, dest) {
        if ( dest === void 0 ) dest = math.vec3();


        var x = p[0];
        var y = p[1];
        var z = p[2];

        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];
        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];
        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];

        return dest;
    },

    /**
     * Transforms a homogeneous coordinate by a 4x4 matrix.
     * @method transformPoint3
     * @static
     */
    transformPoint4: function transformPoint4(m, v, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];

        return dest;
    },


    /**
     * Transforms an array of three-element positions by a 4x4 matrix.
     * @method transformPoints3
     * @static
     */
    transformPoints3: function transformPoints3(m, points, points2) {
        var result = points2 || [];
        var len = points.length;
        var p0;
        var p1;
        var p2;
        var pi;

        // cache values
        var m0 = m[0];

        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        var r;

        for (var i = 0; i < len; ++i) {

            // cache values
            pi = points[i];

            p0 = pi[0];
            p1 = pi[1];
            p2 = pi[2];

            r = result[i] || (result[i] = [0, 0, 0]);

            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;
            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;
            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;
            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;
        }

        result.length = len;

        return result;
    },

    /**
     * Transforms an array of positions by a 4x4 matrix.
     * @method transformPositions3
     * @static
     */
    transformPositions3: function transformPositions3(m, p, p2) {
        if ( p2 === void 0 ) p2 = p;

        var i;
        var len = p.length;

        var x;
        var y;
        var z;

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        for (i = 0; i < len; i += 3) {

            x = p[i + 0];
            y = p[i + 1];
            z = p[i + 2];

            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
        }

        return p2;
    },

    /**
     * Transforms an array of positions by a 4x4 matrix.
     * @method transformPositions4
     * @static
     */
    transformPositions4: function transformPositions4(m, p, p2) {
        if ( p2 === void 0 ) p2 = p;

        var i;
        var len = p.length;

        var x;
        var y;
        var z;

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        for (i = 0; i < len; i += 4) {

            x = p[i + 0];
            y = p[i + 1];
            z = p[i + 2];

            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
        }

        return p2;
    },

    /**
     * Transforms a three-element vector by a 4x4 matrix.
     * @method transformVec3
     * @static
     */
    transformVec3: function transformVec3(m, v, dest) {
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dest = dest || this.vec3();
        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);
        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);
        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);
        return dest;
    },

    /**
     * Transforms a four-element vector by a 4x4 matrix.
     * @method transformVec4
     * @static
     */
    transformVec4: function transformVec4(m, v, dest) {
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        var v3 = v[3];
        dest = dest || math.vec4();
        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
        return dest;
    },

    /**
     * Rotate a 3D vector around the x-axis
     *
     * @method rotateVec3X
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */
    rotateVec3X: function rotateVec3X(a, b, c, dest) {
        var p = [];
        var r = [];

        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[0];
        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

        //translate to correct position
        dest[0] = r[0] + b[0];
        dest[1] = r[1] + b[1];
        dest[2] = r[2] + b[2];

        return dest;
    },

    /**
     * Rotate a 3D vector around the y-axis
     *
     * @method rotateVec3Y
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */
    rotateVec3Y: function rotateVec3Y(a, b, c, dest) {
        var p = [];
        var r = [];

        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

        //translate to correct position
        dest[0] = r[0] + b[0];
        dest[1] = r[1] + b[1];
        dest[2] = r[2] + b[2];

        return dest;
    },

    /**
     * Rotate a 3D vector around the z-axis
     *
     * @method rotateVec3Z
     * @param {Number[]} a The vec3 point to rotate
     * @param {Number[]} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @param {Number[]} dest The receiving vec3
     * @returns {Number[]} dest
     * @static
     */
    rotateVec3Z: function rotateVec3Z(a, b, c, dest) {
        var p = [];
        var r = [];

        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
        r[2] = p[2];

        //translate to correct position
        dest[0] = r[0] + b[0];
        dest[1] = r[1] + b[1];
        dest[2] = r[2] + b[2];

        return dest;
    },

    /**
     * Transforms a four-element vector by a 4x4 projection matrix.
     *
     * @method projectVec4
     * @param {Number[]} p 3D View-space coordinate
     * @param {Number[]} q 2D Projected coordinate
     * @returns {Number[]} 2D Projected coordinate
     * @static
     */
    projectVec4: function projectVec4(p, q) {
        var f = 1.0 / p[3];
        q = q || math.vec2();
        q[0] = p[0] * f;
        q[1] = p[1] * f;
        return q;
    },

    /**
     * Unprojects a three-element vector.
     *
     * @method unprojectVec3
     * @param {Number[]} p 3D Projected coordinate
     * @param {Number[]} viewMat View matrix
     * @returns {Number[]} projMat Projection matrix
     * @static
     */
    unprojectVec3: ((function () {
        var mat = new FloatArrayType(16);
        var mat2 = new FloatArrayType(16);
        var mat3 = new FloatArrayType(16);
        return function (p, viewMat, projMat, q) {
            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)
        };
    }))(),

    /**
     * Linearly interpolates between two 3D vectors.
     * @method lerpVec3
     * @static
     */
    lerpVec3: function lerpVec3(t, t1, t2, p1, p2, dest) {
        var result = dest || math.vec3();
        var f = (t - t1) / (t2 - t1);
        result[0] = p1[0] + (f * (p2[0] - p1[0]));
        result[1] = p1[1] + (f * (p2[1] - p1[1]));
        result[2] = p1[2] + (f * (p2[2] - p1[2]));
        return result;
    },

    /**
     * Linearly interpolates between two 4x4 matrices.
     * @method lerpMat4
     * @static
     */
    lerpMat4: function lerpMat4(t, t1, t2, m1, m2, dest) {
        var result = dest || math.mat4();
        var f = (t - t1) / (t2 - t1);
        result[0] = m1[0] + (f * (m2[0] - m1[0]));
        result[1] = m1[1] + (f * (m2[1] - m1[1]));
        result[2] = m1[2] + (f * (m2[2] - m1[2]));
        result[3] = m1[3] + (f * (m2[3] - m1[3]));
        result[4] = m1[4] + (f * (m2[4] - m1[4]));
        result[5] = m1[5] + (f * (m2[5] - m1[5]));
        result[6] = m1[6] + (f * (m2[6] - m1[6]));
        result[7] = m1[7] + (f * (m2[7] - m1[7]));
        result[8] = m1[8] + (f * (m2[8] - m1[8]));
        result[9] = m1[9] + (f * (m2[9] - m1[9]));
        result[10] = m1[10] + (f * (m2[10] - m1[10]));
        result[11] = m1[11] + (f * (m2[11] - m1[11]));
        result[12] = m1[12] + (f * (m2[12] - m1[12]));
        result[13] = m1[13] + (f * (m2[13] - m1[13]));
        result[14] = m1[14] + (f * (m2[14] - m1[14]));
        result[15] = m1[15] + (f * (m2[15] - m1[15]));
        return result;
    },


    /**
     * Flattens a two-dimensional array into a one-dimensional array.
     *
     * @method flatten
     * @static
     * @param {Array of Arrays} a A 2D array
     * @returns Flattened 1D array
     */
    flatten: function flatten(a) {

        var result = [];

        var i;
        var leni;
        var j;
        var lenj;
        var item;

        for (i = 0, leni = a.length; i < leni; i++) {
            item = a[i];
            for (j = 0, lenj = item.length; j < lenj; j++) {
                result.push(item[j]);
            }
        }

        return result;
    },


    identityQuaternion: function identityQuaternion(dest) {
        if ( dest === void 0 ) dest = math.vec4();

        dest[0] = 0.0;
        dest[1] = 0.0;
        dest[2] = 0.0;
        dest[3] = 1.0;
        return dest;
    },

    /**
     * Initializes a quaternion from Euler angles.
     *
     * @param {Number[]} euler The Euler angles.
     * @param {String} order Euler angle order: "XYZ", "YXZ", "ZXY" etc.
     * @param {Number[]} [dest] Destination quaternion, created by default.
     * @returns {Number[]} The quaternion.
     */
    eulerToQuaternion: function eulerToQuaternion(euler, order, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var a = (euler[0] * math.DEGTORAD) / 2;
        var b = (euler[1] * math.DEGTORAD) / 2;
        var c = (euler[2] * math.DEGTORAD) / 2;

        var c1 = Math.cos(a);
        var c2 = Math.cos(b);
        var c3 = Math.cos(c);
        var s1 = Math.sin(a);
        var s2 = Math.sin(b);
        var s3 = Math.sin(c);

        if (order === 'XYZ') {

            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

        } else if (order === 'YXZ') {

            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;

        } else if (order === 'ZXY') {

            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

        } else if (order === 'ZYX') {

            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;

        } else if (order === 'YZX') {

            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

        } else if (order === 'XZY') {

            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;
        }

        return dest;
    },

    mat4ToQuaternion: function mat4ToQuaternion(m, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var m11 = m[0];
        var m12 = m[4];
        var m13 = m[8];
        var m21 = m[1];
        var m22 = m[5];
        var m23 = m[9];
        var m31 = m[2];
        var m32 = m[6];
        var m33 = m[10];
        var s;

        var trace = m11 + m22 + m33;

        if (trace > 0) {

            s = 0.5 / Math.sqrt(trace + 1.0);

            dest[3] = 0.25 / s;
            dest[0] = (m32 - m23) * s;
            dest[1] = (m13 - m31) * s;
            dest[2] = (m21 - m12) * s;

        } else if (m11 > m22 && m11 > m33) {

            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

            dest[3] = (m32 - m23) / s;
            dest[0] = 0.25 * s;
            dest[1] = (m12 + m21) / s;
            dest[2] = (m13 + m31) / s;

        } else if (m22 > m33) {

            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

            dest[3] = (m13 - m31) / s;
            dest[0] = (m12 + m21) / s;
            dest[1] = 0.25 * s;
            dest[2] = (m23 + m32) / s;

        } else {

            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

            dest[3] = (m21 - m12) / s;
            dest[0] = (m13 + m31) / s;
            dest[1] = (m23 + m32) / s;
            dest[2] = 0.25 * s;
        }

        return dest;
    },

    vec3PairToQuaternion: function vec3PairToQuaternion(u, v, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        var norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));
        var real_part = norm_u_norm_v + math.dotVec3(u, v);

        if (real_part < 0.00000001 * norm_u_norm_v) {

            // If u and v are exactly opposite, rotate 180 degrees
            // around an arbitrary orthogonal axis. Axis normalisation
            // can happen later, when we normalise the quaternion.

            real_part = 0.0;

            if (Math.abs(u[0]) > Math.abs(u[2])) {

                dest[0] = -u[1];
                dest[1] = u[0];
                dest[2] = 0;

            } else {
                dest[0] = 0;
                dest[1] = -u[2];
                dest[2] = u[1];
            }

        } else {

            // Otherwise, build quaternion the standard way.
            math.cross3Vec3(u, v, dest);
        }

        dest[3] = real_part;

        return math.normalizeQuaternion(dest);
    },

    angleAxisToQuaternion: function angleAxisToQuaternion(angleAxis, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        var halfAngle = angleAxis[3] / 2.0;
        var fsin = Math.sin(halfAngle);
        dest[0] = fsin * angleAxis[0];
        dest[1] = fsin * angleAxis[1];
        dest[2] = fsin * angleAxis[2];
        dest[3] = Math.cos(halfAngle);
        return dest;
    },

    quaternionToEuler: ((function () {
        var mat = new FloatArrayType(16);
        return function (q, order, dest) {
            dest = dest || math.vec3();
            math.quaternionToRotationMat4(q, mat);
            math.mat4ToEuler(mat, order, dest);
            return dest;
        };
    }))(),

    mulQuaternions: function mulQuaternions(p, q, dest) {
        if ( dest === void 0 ) dest = math.vec4();

        var p0 = p[0];
        var p1 = p[1];
        var p2 = p[2];
        var p3 = p[3];
        var q0 = q[0];
        var q1 = q[1];
        var q2 = q[2];
        var q3 = q[3];
        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;
        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;
        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;
        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;
        return dest;
    },

    vec3ApplyQuaternion: function vec3ApplyQuaternion(q, vec, dest) {
        if ( dest === void 0 ) dest = math.vec3();

        var x = vec[0];
        var y = vec[1];
        var z = vec[2];

        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    },

    quaternionToMat4: function quaternionToMat4(q, dest) {

        dest = math.identityMat4(dest);

        var q0 = q[0];  //x
        var q1 = q[1];  //y
        var q2 = q[2];  //z
        var q3 = q[3];  //w

        var tx = 2.0 * q0;
        var ty = 2.0 * q1;
        var tz = 2.0 * q2;

        var twx = tx * q3;
        var twy = ty * q3;
        var twz = tz * q3;

        var txx = tx * q0;
        var txy = ty * q0;
        var txz = tz * q0;

        var tyy = ty * q1;
        var tyz = tz * q1;
        var tzz = tz * q2;

        dest[0] = 1.0 - (tyy + tzz);
        dest[1] = txy + twz;
        dest[2] = txz - twy;

        dest[4] = txy - twz;
        dest[5] = 1.0 - (txx + tzz);
        dest[6] = tyz + twx;

        dest[8] = txz + twy;
        dest[9] = tyz - twx;

        dest[10] = 1.0 - (txx + tyy);

        return dest;
    },

    quaternionToRotationMat4: function quaternionToRotationMat4(q, m) {
        var x = q[0];
        var y = q[1];
        var z = q[2];
        var w = q[3];

        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;

        m[0] = 1 - (yy + zz);
        m[4] = xy - wz;
        m[8] = xz + wy;

        m[1] = xy + wz;
        m[5] = 1 - (xx + zz);
        m[9] = yz - wx;

        m[2] = xz - wy;
        m[6] = yz + wx;
        m[10] = 1 - (xx + yy);

        // last column
        m[3] = 0;
        m[7] = 0;
        m[11] = 0;

        // bottom row
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;

        return m;
    },

    normalizeQuaternion: function normalizeQuaternion(q, dest) {
        if ( dest === void 0 ) dest = q;

        var len = math.lenVec4([q[0], q[1], q[2], q[3]]);
        dest[0] = q[0] / len;
        dest[1] = q[1] / len;
        dest[2] = q[2] / len;
        dest[3] = q[3] / len;
        return dest;
    },

    conjugateQuaternion: function conjugateQuaternion(q, dest) {
        if ( dest === void 0 ) dest = q;

        dest[0] = -q[0];
        dest[1] = -q[1];
        dest[2] = -q[2];
        dest[3] = q[3];
        return dest;
    },

    inverseQuaternion: function inverseQuaternion(q, dest) {
        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));
    },

    quaternionToAngleAxis: function quaternionToAngleAxis(q, angleAxis) {
        if ( angleAxis === void 0 ) angleAxis = math.vec4();

        q = math.normalizeQuaternion(q, tempVec4$6);
        var q3 = q[3];
        var angle = 2 * Math.acos(q3);
        var s = Math.sqrt(1 - q3 * q3);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            angleAxis[0] = q[0];
            angleAxis[1] = q[1];
            angleAxis[2] = q[2];
        } else {
            angleAxis[0] = q[0] / s;
            angleAxis[1] = q[1] / s;
            angleAxis[2] = q[2] / s;
        }
        angleAxis[3] = angle; // * 57.295779579;
        return angleAxis;
    },

    //------------------------------------------------------------------------------------------------------------------
    // Boundaries
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns a new, uninitialized 3D axis-aligned bounding box.
     *
     * @private
     */
    AABB3: function AABB3(values) {
        return new FloatArrayType(values || 6);
    },

    /**
     * Returns a new, uninitialized 2D axis-aligned bounding box.
     *
     * @private
     */
    AABB2: function AABB2(values) {
        return new FloatArrayType(values || 4);
    },

    /**
     * Returns a new, uninitialized 3D oriented bounding box (OBB).
     *
     * @private
     */
    OBB3: function OBB3(values) {
        return new FloatArrayType(values || 32);
    },

    /**
     * Returns a new, uninitialized 2D oriented bounding box (OBB).
     *
     * @private
     */
    OBB2: function OBB2(values) {
        return new FloatArrayType(values || 16);
    },

    /** Returns a new 3D bounding sphere */
    Sphere3: function Sphere3(x, y, z, r) {
        return new FloatArrayType([x, y, z, r]);
    },

    /**
     * Transforms an OBB3 by a 4x4 matrix.
     *
     * @private
     */
    transformOBB3: function transformOBB3(m, p, p2) {
        if ( p2 === void 0 ) p2 = p;

        var i;
        var len = p.length;

        var x;
        var y;
        var z;

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        for (i = 0; i < len; i += 4) {

            x = p[i + 0];
            y = p[i + 1];
            z = p[i + 2];

            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
        }

        return p2;
    },

    /** Returns true if the first AABB contains the second AABB.
     * @param aabb1
     * @param aabb2
     * @returns {boolean}
     */
    containsAABB3: function (aabb1, aabb2) {
        var result = (
            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&
            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&
            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);
        return result;
    },


    /**
     * Gets the diagonal size of an AABB3 given as minima and maxima.
     *
     * @private
     */
    getAABB3Diag: ((function () {

        var min = new FloatArrayType(3);
        var max = new FloatArrayType(3);
        var tempVec3 = new FloatArrayType(3);

        return function (aabb) {

            min[0] = aabb[0];
            min[1] = aabb[1];
            min[2] = aabb[2];

            max[0] = aabb[3];
            max[1] = aabb[4];
            max[2] = aabb[5];

            math.subVec3(max, min, tempVec3);

            return Math.abs(math.lenVec3(tempVec3));
        };
    }))(),

    /**
     * Get a diagonal boundary size that is symmetrical about the given point.
     *
     * @private
     */
    getAABB3DiagPoint: ((function () {

        var min = new FloatArrayType(3);
        var max = new FloatArrayType(3);
        var tempVec3 = new FloatArrayType(3);

        return function (aabb, p) {

            min[0] = aabb[0];
            min[1] = aabb[1];
            min[2] = aabb[2];

            max[0] = aabb[3];
            max[1] = aabb[4];
            max[2] = aabb[5];

            var diagVec = math.subVec3(max, min, tempVec3);

            var xneg = p[0] - aabb[0];
            var xpos = aabb[3] - p[0];
            var yneg = p[1] - aabb[1];
            var ypos = aabb[4] - p[1];
            var zneg = p[2] - aabb[2];
            var zpos = aabb[5] - p[2];

            diagVec[0] += (xneg > xpos) ? xneg : xpos;
            diagVec[1] += (yneg > ypos) ? yneg : ypos;
            diagVec[2] += (zneg > zpos) ? zneg : zpos;

            return Math.abs(math.lenVec3(diagVec));
        };
    }))(),

    /**
     * Gets the area of an AABB.
     *
     * @private
     */
    getAABB3Area: function getAABB3Area(aabb) {
        var width = (aabb[3] - aabb[0]);
        var height = (aabb[4] - aabb[1]);
        var depth = (aabb[5] - aabb[2]);
        return (width * height * depth);
    },

    /**
     * Gets the center of an AABB.
     *
     * @private
     */
    getAABB3Center: function getAABB3Center(aabb, dest) {
        var r = dest || math.vec3();

        r[0] = (aabb[0] + aabb[3]) / 2;
        r[1] = (aabb[1] + aabb[4]) / 2;
        r[2] = (aabb[2] + aabb[5]) / 2;

        return r;
    },

    /**
     * Gets the center of a 2D AABB.
     *
     * @private
     */
    getAABB2Center: function getAABB2Center(aabb, dest) {
        var r = dest || math.vec2();

        r[0] = (aabb[2] + aabb[0]) / 2;
        r[1] = (aabb[3] + aabb[1]) / 2;

        return r;
    },

    /**
     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */
    collapseAABB3: function collapseAABB3(aabb) {
        if ( aabb === void 0 ) aabb = math.AABB3();

        aabb[0] = math.MAX_DOUBLE;
        aabb[1] = math.MAX_DOUBLE;
        aabb[2] = math.MAX_DOUBLE;
        aabb[3] = math.MIN_DOUBLE;
        aabb[4] = math.MIN_DOUBLE;
        aabb[5] = math.MIN_DOUBLE;

        return aabb;
    },

    /**
     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
     * an array of eight 3D positions, one for each corner of the boundary.
     *
     * @private
     */
    AABB3ToOBB3: function AABB3ToOBB3(aabb, obb) {
        if ( obb === void 0 ) obb = math.OBB3();

        obb[0] = aabb[0];
        obb[1] = aabb[1];
        obb[2] = aabb[2];
        obb[3] = 1;

        obb[4] = aabb[3];
        obb[5] = aabb[1];
        obb[6] = aabb[2];
        obb[7] = 1;

        obb[8] = aabb[3];
        obb[9] = aabb[4];
        obb[10] = aabb[2];
        obb[11] = 1;

        obb[12] = aabb[0];
        obb[13] = aabb[4];
        obb[14] = aabb[2];
        obb[15] = 1;

        obb[16] = aabb[0];
        obb[17] = aabb[1];
        obb[18] = aabb[5];
        obb[19] = 1;

        obb[20] = aabb[3];
        obb[21] = aabb[1];
        obb[22] = aabb[5];
        obb[23] = 1;

        obb[24] = aabb[3];
        obb[25] = aabb[4];
        obb[26] = aabb[5];
        obb[27] = 1;

        obb[28] = aabb[0];
        obb[29] = aabb[4];
        obb[30] = aabb[5];
        obb[31] = 1;

        return obb;
    },

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */
    positions3ToAABB3: ((function () {

        var p = new FloatArrayType(3);

        return function (positions, aabb, positionsDecodeMatrix) {
            aabb = aabb || math.AABB3();

            var xmin = math.MAX_DOUBLE;
            var ymin = math.MAX_DOUBLE;
            var zmin = math.MAX_DOUBLE;
            var xmax = math.MIN_DOUBLE;
            var ymax = math.MIN_DOUBLE;
            var zmax = math.MIN_DOUBLE;

            var x;
            var y;
            var z;

            for (var i = 0, len = positions.length; i < len; i += 3) {

                if (positionsDecodeMatrix) {

                    p[0] = positions[i + 0];
                    p[1] = positions[i + 1];
                    p[2] = positions[i + 2];

                    math.decompressPosition(p, positionsDecodeMatrix, p);

                    x = p[0];
                    y = p[1];
                    z = p[2];

                } else {
                    x = positions[i + 0];
                    y = positions[i + 1];
                    z = positions[i + 2];
                }

                if (x < xmin) {
                    xmin = x;
                }

                if (y < ymin) {
                    ymin = y;
                }

                if (z < zmin) {
                    zmin = z;
                }

                if (x > xmax) {
                    xmax = x;
                }

                if (y > ymax) {
                    ymax = y;
                }

                if (z > zmax) {
                    zmax = z;
                }
            }

            aabb[0] = xmin;
            aabb[1] = ymin;
            aabb[2] = zmin;
            aabb[3] = xmax;
            aabb[4] = ymax;
            aabb[5] = zmax;

            return aabb;
        };
    }))(),

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */
    OBB3ToAABB3: function OBB3ToAABB3(obb, aabb) {
        if ( aabb === void 0 ) aabb = math.AABB3();

        var xmin = math.MAX_DOUBLE;
        var ymin = math.MAX_DOUBLE;
        var zmin = math.MAX_DOUBLE;
        var xmax = math.MIN_DOUBLE;
        var ymax = math.MIN_DOUBLE;
        var zmax = math.MIN_DOUBLE;

        var x;
        var y;
        var z;

        for (var i = 0, len = obb.length; i < len; i += 4) {

            x = obb[i + 0];
            y = obb[i + 1];
            z = obb[i + 2];

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (z < zmin) {
                zmin = z;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }

            if (z > zmax) {
                zmax = z;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = zmin;
        aabb[3] = xmax;
        aabb[4] = ymax;
        aabb[5] = zmax;

        return aabb;
    },

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.
     *
     * @private
     */
    points3ToAABB3: function points3ToAABB3(points, aabb) {
        if ( aabb === void 0 ) aabb = math.AABB3();

        var xmin = math.MAX_DOUBLE;
        var ymin = math.MAX_DOUBLE;
        var zmin = math.MAX_DOUBLE;
        var xmax = math.MIN_DOUBLE;
        var ymax = math.MIN_DOUBLE;
        var zmax = math.MIN_DOUBLE;

        var x;
        var y;
        var z;

        for (var i = 0, len = points.length; i < len; i++) {

            x = points[i][0];
            y = points[i][1];
            z = points[i][2];

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (z < zmin) {
                zmin = z;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }

            if (z > zmax) {
                zmax = z;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = zmin;
        aabb[3] = xmax;
        aabb[4] = ymax;
        aabb[5] = zmax;

        return aabb;
    },

    /**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */
    points3ToSphere3: ((function () {

        var tempVec3 = new FloatArrayType(3);

        return function (points, sphere) {

            sphere = sphere || math.vec4();

            var x = 0;
            var y = 0;
            var z = 0;

            var i;
            var numPoints = points.length;

            for (i = 0; i < numPoints; i++) {
                x += points[i][0];
                y += points[i][1];
                z += points[i][2];
            }

            sphere[0] = x / numPoints;
            sphere[1] = y / numPoints;
            sphere[2] = z / numPoints;

            var radius = 0;
            var dist;

            for (i = 0; i < numPoints; i++) {

                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));

                if (dist > radius) {
                    radius = dist;
                }
            }

            sphere[3] = radius;

            return sphere;
        };
    }))(),

    /**
     * Finds the minimum boundary sphere enclosing the given 3D positions.
     *
     * @private
     */
    positions3ToSphere3: ((function () {

        var tempVec3a = new FloatArrayType(3);
        var tempVec3b = new FloatArrayType(3);

        return function (positions, sphere) {

            sphere = sphere || math.vec4();

            var x = 0;
            var y = 0;
            var z = 0;

            var i;
            var lenPositions = positions.length;
            var radius = 0;

            for (i = 0; i < lenPositions; i += 3) {
                x += positions[i];
                y += positions[i + 1];
                z += positions[i + 2];
            }

            var numPositions = lenPositions / 3;

            sphere[0] = x / numPositions;
            sphere[1] = y / numPositions;
            sphere[2] = z / numPositions;

            var dist;

            for (i = 0; i < lenPositions; i += 3) {

                tempVec3a[0] = positions[i];
                tempVec3a[1] = positions[i + 1];
                tempVec3a[2] = positions[i + 2];

                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));

                if (dist > radius) {
                    radius = dist;
                }
            }

            sphere[3] = radius;

            return sphere;
        };
    }))(),

    /**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */
    OBB3ToSphere3: ((function () {

        var point = new FloatArrayType(3);
        var tempVec3 = new FloatArrayType(3);

        return function (points, sphere) {

            sphere = sphere || math.vec4();

            var x = 0;
            var y = 0;
            var z = 0;

            var i;
            var lenPoints = points.length;
            var numPoints = lenPoints / 4;

            for (i = 0; i < lenPoints; i += 4) {
                x += points[i + 0];
                y += points[i + 1];
                z += points[i + 2];
            }

            sphere[0] = x / numPoints;
            sphere[1] = y / numPoints;
            sphere[2] = z / numPoints;

            var radius = 0;
            var dist;

            for (i = 0; i < lenPoints; i += 4) {

                point[0] = points[i + 0];
                point[1] = points[i + 1];
                point[2] = points[i + 2];

                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));

                if (dist > radius) {
                    radius = dist;
                }
            }

            sphere[3] = radius;

            return sphere;
        };
    }))(),

    /**
     * Gets the center of a bounding sphere.
     *
     * @private
     */
    getSphere3Center: function getSphere3Center(sphere, dest) {
        if ( dest === void 0 ) dest = math.vec3();

        dest[0] = sphere[0];
        dest[1] = sphere[1];
        dest[2] = sphere[2];

        return dest;
    },

    /**
     * Gets the 3D center of the given flat array of 3D positions.
     *
     * @private
     */
    getPositionsCenter: function getPositionsCenter(positions, center) {
        if ( center === void 0 ) center = math.vec3();

        var xCenter = 0;
        var yCenter = 0;
        var zCenter = 0;
        for (var i = 0, len = positions.length; i < len; i += 3) {
            xCenter += positions[i + 0];
            yCenter += positions[i + 1];
            zCenter += positions[i + 2];
        }
        var numPositions = positions.length / 3;
        center[0] = xCenter / numPositions;
        center[1] = yCenter / numPositions;
        center[2] = zCenter / numPositions;
        return center;
    },

    /**
     * Expands the first axis-aligned 3D boundary to enclose the second, if required.
     *
     * @private
     */
    expandAABB3: function expandAABB3(aabb1, aabb2) {

        if (aabb1[0] > aabb2[0]) {
            aabb1[0] = aabb2[0];
        }

        if (aabb1[1] > aabb2[1]) {
            aabb1[1] = aabb2[1];
        }

        if (aabb1[2] > aabb2[2]) {
            aabb1[2] = aabb2[2];
        }

        if (aabb1[3] < aabb2[3]) {
            aabb1[3] = aabb2[3];
        }

        if (aabb1[4] < aabb2[4]) {
            aabb1[4] = aabb2[4];
        }

        if (aabb1[5] < aabb2[5]) {
            aabb1[5] = aabb2[5];
        }

        return aabb1;
    },

    /**
     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.
     *
     * @private
     */
    expandAABB3Point3: function expandAABB3Point3(aabb, p) {

        if (aabb[0] > p[0]) {
            aabb[0] = p[0];
        }

        if (aabb[1] > p[1]) {
            aabb[1] = p[1];
        }

        if (aabb[2] > p[2]) {
            aabb[2] = p[2];
        }

        if (aabb[3] < p[0]) {
            aabb[3] = p[0];
        }

        if (aabb[4] < p[1]) {
            aabb[4] = p[1];
        }

        if (aabb[5] < p[2]) {
            aabb[5] = p[2];
        }

        return aabb;
    },

    /**
     * Expands an axis-aligned 3D boundary to enclose the given points, if needed.
     *
     * @private
     */
    expandAABB3Points3: function expandAABB3Points3(aabb, positions) {
        var x;
        var y;
        var z;
        for (var i = 0, len = positions.length; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (aabb[0] > x) {
                aabb[0] = x;
            }
            if (aabb[1] > y) {
                aabb[1] = y;
            }
            if (aabb[2] > z) {
                aabb[2] = z;
            }
            if (aabb[3] < x) {
                aabb[3] = x;
            }
            if (aabb[4] < y) {
                aabb[4] = y;
            }
            if (aabb[5] < z) {
                aabb[5] = z;
            }
        }
        return aabb;
    },

    /**
     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */
    collapseAABB2: function collapseAABB2(aabb) {
        if ( aabb === void 0 ) aabb = math.AABB2();

        aabb[0] = math.MAX_DOUBLE;
        aabb[1] = math.MAX_DOUBLE;
        aabb[2] = math.MIN_DOUBLE;
        aabb[3] = math.MIN_DOUBLE;

        return aabb;
    },

    point3AABB3Intersect: function point3AABB3Intersect(aabb, p) {
        return aabb[0] > p[0] || aabb[3] < p[0] || aabb[1] > p[1] || aabb[4] < p[1] || aabb[2] > p[2] || aabb[5] < p[2];
    },

    /**
     *
     * @param dir
     * @param constant
     * @param aabb
     * @returns {number}
     */
    planeAABB3Intersect: function planeAABB3Intersect(dir, constant, aabb) {
        var min, max;
        if (dir[0] > 0) {
            min = dir[0] * aabb[0];
            max = dir[0] * aabb[3];
        } else {
            min = dir[0] * aabb[3];
            max = dir[0] * aabb[0];
        }
        if (dir[1] > 0) {
            min += dir[1] * aabb[1];
            max += dir[1] * aabb[4];
        } else {
            min += dir[1] * aabb[4];
            max += dir[1] * aabb[1];
        }
        if (dir[2] > 0) {
            min += dir[2] * aabb[2];
            max += dir[2] * aabb[5];
        } else {
            min += dir[2] * aabb[5];
            max += dir[2] * aabb[2];
        }
        var outside = (min <= -constant) && (max <= -constant);
        if (outside) {
            return -1;
        }

        var inside = (min >= -constant) && (max >= -constant);
        if (inside) {
            return 1;
        }

        return 0;
    },

    /**
     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.
     *
     * @private
     */
    OBB3ToAABB2: function OBB3ToAABB2(points, aabb) {
        if ( aabb === void 0 ) aabb = math.AABB2();

        var xmin = math.MAX_DOUBLE;
        var ymin = math.MAX_DOUBLE;
        var xmax = math.MIN_DOUBLE;
        var ymax = math.MIN_DOUBLE;

        var x;
        var y;
        var w;
        var f;

        for (var i = 0, len = points.length; i < len; i += 4) {

            x = points[i + 0];
            y = points[i + 1];
            w = points[i + 3] || 1.0;

            f = 1.0 / w;

            x *= f;
            y *= f;

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = xmax;
        aabb[3] = ymax;

        return aabb;
    },

    /**
     * Expands the first axis-aligned 2D boundary to enclose the second, if required.
     *
     * @private
     */
    expandAABB2: function expandAABB2(aabb1, aabb2) {

        if (aabb1[0] > aabb2[0]) {
            aabb1[0] = aabb2[0];
        }

        if (aabb1[1] > aabb2[1]) {
            aabb1[1] = aabb2[1];
        }

        if (aabb1[2] < aabb2[2]) {
            aabb1[2] = aabb2[2];
        }

        if (aabb1[3] < aabb2[3]) {
            aabb1[3] = aabb2[3];
        }

        return aabb1;
    },

    /**
     * Expands an axis-aligned 2D boundary to enclose the given point, if required.
     *
     * @private
     */
    expandAABB2Point2: function expandAABB2Point2(aabb, p) {

        if (aabb[0] > p[0]) {
            aabb[0] = p[0];
        }

        if (aabb[1] > p[1]) {
            aabb[1] = p[1];
        }

        if (aabb[2] < p[0]) {
            aabb[2] = p[0];
        }

        if (aabb[3] < p[1]) {
            aabb[3] = p[1];
        }

        return aabb;
    },

    AABB2ToCanvas: function AABB2ToCanvas(aabb, canvasWidth, canvasHeight, aabb2) {
        if ( aabb2 === void 0 ) aabb2 = aabb;

        var xmin = (aabb[0] + 1.0) * 0.5;
        var ymin = (aabb[1] + 1.0) * 0.5;
        var xmax = (aabb[2] + 1.0) * 0.5;
        var ymax = (aabb[3] + 1.0) * 0.5;

        aabb2[0] = Math.floor(xmin * canvasWidth);
        aabb2[1] = canvasHeight - Math.floor(ymax * canvasHeight);
        aabb2[2] = Math.floor(xmax * canvasWidth);
        aabb2[3] = canvasHeight - Math.floor(ymin * canvasHeight);

        return aabb2;
    },

    //------------------------------------------------------------------------------------------------------------------
    // Curves
    //------------------------------------------------------------------------------------------------------------------

    tangentQuadraticBezier: function tangentQuadraticBezier(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
    },

    tangentQuadraticBezier3: function tangentQuadraticBezier3(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) +
            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
            6 * t * p2 * (1 - t) - 3 * t * t * p2 +
            3 * t * t * p3;
    },

    tangentSpline: function tangentSpline(t) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
    },

    catmullRomInterpolate: function catmullRomInterpolate(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    },

// Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve

// Quad Bezier Functions

    b2p0: function b2p0(t, p) {
        var k = 1 - t;
        return k * k * p;

    },

    b2p1: function b2p1(t, p) {
        return 2 * (1 - t) * t * p;
    },

    b2p2: function b2p2(t, p) {
        return t * t * p;
    },

    b2: function b2(t, p0, p1, p2) {
        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
    },

// Cubic Bezier Functions

    b3p0: function b3p0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    },

    b3p1: function b3p1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    },

    b3p2: function b3p2(t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
    },

    b3p3: function b3p3(t, p) {
        return t * t * t * p;
    },

    b3: function b3(t, p0, p1, p2, p3) {
        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
    },

    //------------------------------------------------------------------------------------------------------------------
    // Geometry
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Calculates the normal vector of a triangle.
     *
     * @private
     */
    triangleNormal: function triangleNormal(a, b, c, normal) {
        if ( normal === void 0 ) normal = math.vec3();

        var p1x = b[0] - a[0];
        var p1y = b[1] - a[1];
        var p1z = b[2] - a[2];

        var p2x = c[0] - a[0];
        var p2y = c[1] - a[1];
        var p2z = c[2] - a[2];

        var p3x = p1y * p2z - p1z * p2y;
        var p3y = p1z * p2x - p1x * p2z;
        var p3z = p1x * p2y - p1y * p2x;

        var mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);
        if (mag === 0) {
            normal[0] = 0;
            normal[1] = 0;
            normal[2] = 0;
        } else {
            normal[0] = p3x / mag;
            normal[1] = p3y / mag;
            normal[2] = p3z / mag;
        }

        return normal
    },

    /**
     * Finds the intersection of a 3D ray with a 3D triangle.
     *
     * @private
     */
    rayTriangleIntersect: ((function () {

        var tempVec3 = new FloatArrayType(3);
        var tempVec3b = new FloatArrayType(3);
        var tempVec3c = new FloatArrayType(3);
        var tempVec3d = new FloatArrayType(3);
        var tempVec3e = new FloatArrayType(3);

        return function (origin, dir, a, b, c, isect) {

            isect = isect || math.vec3();

            var EPSILON = 0.000001;

            var edge1 = math.subVec3(b, a, tempVec3);
            var edge2 = math.subVec3(c, a, tempVec3b);

            var pvec = math.cross3Vec3(dir, edge2, tempVec3c);
            var det = math.dotVec3(edge1, pvec);
            if (det < EPSILON) {
                return null;
            }

            var tvec = math.subVec3(origin, a, tempVec3d);
            var u = math.dotVec3(tvec, pvec);
            if (u < 0 || u > det) {
                return null;
            }

            var qvec = math.cross3Vec3(tvec, edge1, tempVec3e);
            var v = math.dotVec3(dir, qvec);
            if (v < 0 || u + v > det) {
                return null;
            }

            var t = math.dotVec3(edge2, qvec) / det;
            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        };
    }))(),

    /**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @private
     */
    rayPlaneIntersect: ((function () {

        var tempVec3 = new FloatArrayType(3);
        var tempVec3b = new FloatArrayType(3);
        var tempVec3c = new FloatArrayType(3);
        var tempVec3d = new FloatArrayType(3);

        return function (origin, dir, a, b, c, isect) {

            isect = isect || math.vec3();

            dir = math.normalizeVec3(dir, tempVec3);

            var edge1 = math.subVec3(b, a, tempVec3b);
            var edge2 = math.subVec3(c, a, tempVec3c);

            var n = math.cross3Vec3(edge1, edge2, tempVec3d);
            math.normalizeVec3(n, n);

            var d = -math.dotVec3(a, n);

            var t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);

            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        };
    }))(),

    /**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @private
     */
    cartesianToBarycentric: ((function () {

        var tempVec3 = new FloatArrayType(3);
        var tempVec3b = new FloatArrayType(3);
        var tempVec3c = new FloatArrayType(3);

        return function (cartesian, a, b, c, dest) {

            var v0 = math.subVec3(c, a, tempVec3);
            var v1 = math.subVec3(b, a, tempVec3b);
            var v2 = math.subVec3(cartesian, a, tempVec3c);

            var dot00 = math.dotVec3(v0, v0);
            var dot01 = math.dotVec3(v0, v1);
            var dot02 = math.dotVec3(v0, v2);
            var dot11 = math.dotVec3(v1, v1);
            var dot12 = math.dotVec3(v1, v2);

            var denom = (dot00 * dot11 - dot01 * dot01);

            // Colinear or singular triangle

            if (denom === 0) {

                // Arbitrary location outside of triangle

                return null;
            }

            var invDenom = 1 / denom;

            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

            dest[0] = 1 - u - v;
            dest[1] = v;
            dest[2] = u;

            return dest;
        };
    }))(),

    /**
     * Returns true if the given barycentric coordinates are within their triangle.
     *
     * @private
     */
    barycentricInsideTriangle: function barycentricInsideTriangle(bary) {

        var v = bary[1];
        var u = bary[2];

        return (u >= 0) && (v >= 0) && (u + v < 1);
    },

    /**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @private
     */
    barycentricToCartesian: function barycentricToCartesian(bary, a, b, c, cartesian) {
        if ( cartesian === void 0 ) cartesian = math.vec3();

        var u = bary[0];
        var v = bary[1];
        var w = bary[2];

        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

        return cartesian;
    },


    /**
     * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns
     * modified arrays that have duplicate vertices removed.
     *
     * Note: does not work well when co-incident vertices have same positions but different normals and UVs.
     *
     * @param positions
     * @param normals
     * @param uv
     * @param indices
     * @returns {{positions: Array, indices: Array}}
     * @private
     */
    mergeVertices: function mergeVertices(positions, normals, uv, indices) {
        var positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var indicesLookup = [];
        var uniquePositions = [];
        var uniqueNormals = normals ? [] : null;
        var uniqueUV = uv ? [] : null;
        var indices2 = [];
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i;
        var len;
        var uvi = 0;
        for (i = 0, len = positions.length; i < len; i += 3) {
            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];
            key = (Math.round(vx * precision)) + "_" + (Math.round(vy * precision)) + "_" + (Math.round(vz * precision));
            if (positionsMap[key] === undefined) {
                positionsMap[key] = uniquePositions.length / 3;
                uniquePositions.push(vx);
                uniquePositions.push(vy);
                uniquePositions.push(vz);
                if (normals) {
                    uniqueNormals.push(normals[i]);
                    uniqueNormals.push(normals[i + 1]);
                    uniqueNormals.push(normals[i + 2]);
                }
                if (uv) {
                    uniqueUV.push(uv[uvi]);
                    uniqueUV.push(uv[uvi + 1]);
                }
            }
            indicesLookup[i / 3] = positionsMap[key];
            uvi += 2;
        }
        for (i = 0, len = indices.length; i < len; i++) {
            indices2[i] = indicesLookup[indices[i]];
        }
        var result = {
            positions: uniquePositions,
            indices: indices2
        };
        if (uniqueNormals) {
            result.normals = uniqueNormals;
        }
        if (uniqueUV) {
            result.uv = uniqueUV;

        }
        return result;
    },

    /**
     * Builds normal vectors from positions and indices.
     *
     * @private
     */
    buildNormals: ((function () {

        var a = new FloatArrayType(3);
        var b = new FloatArrayType(3);
        var c = new FloatArrayType(3);
        var ab = new FloatArrayType(3);
        var ac = new FloatArrayType(3);
        var crossVec = new FloatArrayType(3);

        return function (positions, indices, normals) {

            var i;
            var len;
            var nvecs = new Array(positions.length / 3);
            var j0;
            var j1;
            var j2;

            for (i = 0, len = indices.length; i < len; i += 3) {

                j0 = indices[i];
                j1 = indices[i + 1];
                j2 = indices[i + 2];

                a[0] = positions[j0 * 3];
                a[1] = positions[j0 * 3 + 1];
                a[2] = positions[j0 * 3 + 2];

                b[0] = positions[j1 * 3];
                b[1] = positions[j1 * 3 + 1];
                b[2] = positions[j1 * 3 + 2];

                c[0] = positions[j2 * 3];
                c[1] = positions[j2 * 3 + 1];
                c[2] = positions[j2 * 3 + 2];

                math.subVec3(b, a, ab);
                math.subVec3(c, a, ac);

                var normVec = math.vec3();

                math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);

                if (!nvecs[j0]) {
                    nvecs[j0] = [];
                }
                if (!nvecs[j1]) {
                    nvecs[j1] = [];
                }
                if (!nvecs[j2]) {
                    nvecs[j2] = [];
                }

                nvecs[j0].push(normVec);
                nvecs[j1].push(normVec);
                nvecs[j2].push(normVec);
            }

            normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);

            var count;
            var x;
            var y;
            var z;

            for (i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything

                count = nvecs[i].length;

                x = 0;
                y = 0;
                z = 0;

                for (var j = 0; j < count; j++) {
                    x += nvecs[i][j][0];
                    y += nvecs[i][j][1];
                    z += nvecs[i][j][2];
                }

                normals[i * 3] = (x / count);
                normals[i * 3 + 1] = (y / count);
                normals[i * 3 + 2] = (z / count);
            }

            return normals;
        };
    }))(),

    /**
     * Builds vertex tangent vectors from positions, UVs and indices.
     *
     * @private
     */
    buildTangents: ((function () {

        var tempVec3 = new FloatArrayType(3);
        var tempVec3b = new FloatArrayType(3);
        var tempVec3c = new FloatArrayType(3);
        var tempVec3d = new FloatArrayType(3);
        var tempVec3e = new FloatArrayType(3);
        var tempVec3f = new FloatArrayType(3);
        var tempVec3g = new FloatArrayType(3);

        return function (positions, indices, uv) {

            var tangents = new Float32Array(positions.length);

            // The vertex arrays needs to be calculated
            // before the calculation of the tangents

            for (var location = 0; location < indices.length; location += 3) {

                // Recontructing each vertex and UV coordinate into the respective vectors

                var index = indices[location];

                var v0 = positions.subarray(index * 3, index * 3 + 3);
                var uv0 = uv.subarray(index * 2, index * 2 + 2);

                index = indices[location + 1];

                var v1 = positions.subarray(index * 3, index * 3 + 3);
                var uv1 = uv.subarray(index * 2, index * 2 + 2);

                index = indices[location + 2];

                var v2 = positions.subarray(index * 3, index * 3 + 3);
                var uv2 = uv.subarray(index * 2, index * 2 + 2);

                var deltaPos1 = math.subVec3(v1, v0, tempVec3);
                var deltaPos2 = math.subVec3(v2, v0, tempVec3b);

                var deltaUV1 = math.subVec2(uv1, uv0, tempVec3c);
                var deltaUV2 = math.subVec2(uv2, uv0, tempVec3d);

                var r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));

                var tangent = math.mulVec3Scalar(
                    math.subVec3(
                        math.mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),
                        math.mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),
                        tempVec3g
                    ),
                    r,
                    tempVec3f
                );

                // Average the value of the vectors

                var addTo = (void 0);

                for (var v = 0; v < 3; v++) {
                    addTo = indices[location + v] * 3;
                    tangents[addTo] += tangent[0];
                    tangents[addTo + 1] += tangent[1];
                    tangents[addTo + 2] += tangent[2];
                }
            }

            return tangents;
        };
    }))(),

    /**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @private
     */
    buildPickTriangles: function buildPickTriangles(positions, indices, compressGeometry) {

        var numIndices = indices.length;
        var pickPositions = compressGeometry ? new Uint16Array(numIndices * 9) : new Float32Array(numIndices * 9);
        var pickColors = new Uint8Array(numIndices * 12);
        var primIndex = 0;
        var vi;// Positions array index
        var pvi = 0;// Picking positions array index
        var pci = 0; // Picking color array index

        // Triangle indices
        var i;
        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            i = indices[location];
            vi = i * 3;

            pickPositions[pvi++] = positions[vi];
            pickPositions[pvi++] = positions[vi + 1];
            pickPositions[pvi++] = positions[vi + 2];

            pickColors[pci++] = r;
            pickColors[pci++] = g;
            pickColors[pci++] = b;
            pickColors[pci++] = a;

            // B

            i = indices[location + 1];
            vi = i * 3;

            pickPositions[pvi++] = positions[vi];
            pickPositions[pvi++] = positions[vi + 1];
            pickPositions[pvi++] = positions[vi + 2];

            pickColors[pci++] = r;
            pickColors[pci++] = g;
            pickColors[pci++] = b;
            pickColors[pci++] = a;

            // C

            i = indices[location + 2];
            vi = i * 3;

            pickPositions[pvi++] = positions[vi];
            pickPositions[pvi++] = positions[vi + 1];
            pickPositions[pvi++] = positions[vi + 2];

            pickColors[pci++] = r;
            pickColors[pci++] = g;
            pickColors[pci++] = b;
            pickColors[pci++] = a;

            primIndex++;
        }

        return {
            positions: pickPositions,
            colors: pickColors
        };
    },

    /**
     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles
     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and
     * averaging their normal vectors.
     *
     * @returns {{positions: Array, normals: *}}
     */
    faceToVertexNormals: function faceToVertexNormals(positions, normals, options) {
        if ( options === void 0 ) options = {};

        var smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;
        var vertexMap = {};
        var vertexNormals = [];
        var vertexNormalAccum = {};
        var acc;
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var posi;
        var i;
        var j;
        var len;
        var a;
        var b;

        for (i = 0, len = positions.length; i < len; i += 3) {

            posi = i / 3;

            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];

            key = (Math.round(vx * precision)) + "_" + (Math.round(vy * precision)) + "_" + (Math.round(vz * precision));

            if (vertexMap[key] === undefined) {
                vertexMap[key] = [posi];
            } else {
                vertexMap[key].push(posi);
            }

            var normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);

            vertexNormals[posi] = normal;

            acc = math.vec4([normal[0], normal[1], normal[2], 1]);

            vertexNormalAccum[posi] = acc;
        }

        for (key in vertexMap) {

            if (vertexMap.hasOwnProperty(key)) {

                var vertices = vertexMap[key];
                var numVerts = vertices.length;

                for (i = 0; i < numVerts; i++) {

                    var ii = vertices[i];

                    acc = vertexNormalAccum[ii];

                    for (j = 0; j < numVerts; j++) {

                        if (i === j) {
                            continue;
                        }

                        var jj = vertices[j];

                        a = vertexNormals[ii];
                        b = vertexNormals[jj];

                        var angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);

                        if (angle < smoothNormalsAngleThreshold) {

                            acc[0] += b[0];
                            acc[1] += b[1];
                            acc[2] += b[2];
                            acc[3] += 1.0;
                        }
                    }
                }
            }
        }

        for (i = 0, len = normals.length; i < len; i += 3) {

            acc = vertexNormalAccum[i / 3];

            normals[i + 0] = acc[0] / acc[3];
            normals[i + 1] = acc[1] / acc[3];
            normals[i + 2] = acc[2] / acc[3];

        }
    },

    //------------------------------------------------------------------------------------------------------------------
    // Ray casting
    //------------------------------------------------------------------------------------------------------------------

    /**
     Transforms a ray by a matrix.
     @method transformRay
     @static
     @param {Number[]} matrix 4x4 matrix
     @param {Number[]} rayOrigin The ray origin
     @param {Number[]} rayDir The ray direction
     @param {Number[]} rayOriginDest The transformed ray origin
     @param {Number[]} rayDirDest The transformed ray direction
     */
    transformRay: ((function () {

        var tempVec4a = new FloatArrayType(4);
        var tempVec4b = new FloatArrayType(4);

        return function (matrix, rayOrigin, rayDir, rayOriginDest, rayDirDest) {

            tempVec4a[0] = rayOrigin[0];
            tempVec4a[1] = rayOrigin[1];
            tempVec4a[2] = rayOrigin[2];
            tempVec4a[3] = 1;

            math.transformVec4(matrix, tempVec4a, tempVec4b);

            rayOriginDest[0] = tempVec4b[0];
            rayOriginDest[1] = tempVec4b[1];
            rayOriginDest[2] = tempVec4b[2];

            tempVec4a[0] = rayDir[0];
            tempVec4a[1] = rayDir[1];
            tempVec4a[2] = rayDir[2];

            math.transformVec3(matrix, tempVec4a, tempVec4b);

            math.normalizeVec3(tempVec4b);

            rayDirDest[0] = tempVec4b[0];
            rayDirDest[1] = tempVec4b[1];
            rayDirDest[2] = tempVec4b[2];
        };
    }))(),

    /**
     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.
     @method canvasPosToWorldRay
     @static
     @param {Number[]} viewMatrix View matrix
     @param {Number[]} projMatrix Projection matrix
     @param {Number[]} canvasPos The Canvas-space position.
     @param {Number[]} worldRayOrigin The World-space ray origin.
     @param {Number[]} worldRayDir The World-space ray direction.
     */
    canvasPosToWorldRay: ((function () {

        var tempMat4b = new FloatArrayType(16);
        var tempMat4c = new FloatArrayType(16);
        var tempVec4a = new FloatArrayType(4);
        var tempVec4b = new FloatArrayType(4);
        var tempVec4c = new FloatArrayType(4);
        var tempVec4d = new FloatArrayType(4);

        return function (canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir) {

            var pvMat = math.mulMat4(projMatrix, viewMatrix, tempMat4b);
            var pvMatInverse = math.inverseMat4(pvMat, tempMat4c);

            // Calculate clip space coordinates, which will be in range
            // of x=[-1..1] and y=[-1..1], with y=(+1) at top

            var canvasWidth = canvas.width;
            var canvasHeight = canvas.height;

            var clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
            var clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);

            tempVec4a[0] = clipX;
            tempVec4a[1] = clipY;
            tempVec4a[2] = -1;
            tempVec4a[3] = 1;

            math.transformVec4(pvMatInverse, tempVec4a, tempVec4b);
            math.mulVec4Scalar(tempVec4b, 1 / tempVec4b[3]);

            tempVec4c[0] = clipX;
            tempVec4c[1] = clipY;
            tempVec4c[2] = 1;
            tempVec4c[3] = 1;

            math.transformVec4(pvMatInverse, tempVec4c, tempVec4d);
            math.mulVec4Scalar(tempVec4d, 1 / tempVec4d[3]);

            worldRayOrigin[0] = tempVec4d[0];
            worldRayOrigin[1] = tempVec4d[1];
            worldRayOrigin[2] = tempVec4d[2];

            math.subVec3(tempVec4d, tempVec4b, worldRayDir);

            math.normalizeVec3(worldRayDir);
        };
    }))(),

    /**
     Transforms a Canvas-space position to a Mesh's Local-space coordinate system, in the context of a Camera.
     @method canvasPosToLocalRay
     @static
     @param {Camera} camera The Camera.
     @param {Mesh} mesh The Mesh.
     @param {Number[]} viewMatrix View matrix
     @param {Number[]} projMatrix Projection matrix
     @param {Number[]} worldMatrix Modeling matrix
     @param {Number[]} canvasPos The Canvas-space position.
     @param {Number[]} localRayOrigin The Local-space ray origin.
     @param {Number[]} localRayDir The Local-space ray direction.
     */
    canvasPosToLocalRay: ((function () {

        var worldRayOrigin = new FloatArrayType(3);
        var worldRayDir = new FloatArrayType(3);

        return function (canvas, viewMatrix, projMatrix, worldMatrix, canvasPos, localRayOrigin, localRayDir) {
            math.canvasPosToWorldRay(canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir);
            math.worldRayToLocalRay(worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);
        };
    }))(),

    /**
     Transforms a ray from World-space to a Mesh's Local-space coordinate system.
     @method worldRayToLocalRay
     @static
     @param {Number[]} worldMatrix The World transform matrix
     @param {Number[]} worldRayOrigin The World-space ray origin.
     @param {Number[]} worldRayDir The World-space ray direction.
     @param {Number[]} localRayOrigin The Local-space ray origin.
     @param {Number[]} localRayDir The Local-space ray direction.
     */
    worldRayToLocalRay: ((function () {

        var tempMat4 = new FloatArrayType(16);
        var tempVec4a = new FloatArrayType(4);
        var tempVec4b = new FloatArrayType(4);

        return function (worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) {

            var modelMatInverse = math.inverseMat4(worldMatrix, tempMat4);

            tempVec4a[0] = worldRayOrigin[0];
            tempVec4a[1] = worldRayOrigin[1];
            tempVec4a[2] = worldRayOrigin[2];
            tempVec4a[3] = 1;

            math.transformVec4(modelMatInverse, tempVec4a, tempVec4b);

            localRayOrigin[0] = tempVec4b[0];
            localRayOrigin[1] = tempVec4b[1];
            localRayOrigin[2] = tempVec4b[2];

            math.transformVec3(modelMatInverse, worldRayDir, localRayDir);
        };
    }))(),

    buildKDTree: ((function () {

        var KD_TREE_MAX_DEPTH = 10;
        var KD_TREE_MIN_TRIANGLES = 20;

        var dimLength = new Float32Array();

        function buildNode(triangles, indices, positions, depth) {
            var aabb = new FloatArrayType(6);

            var node = {
                triangles: null,
                left: null,
                right: null,
                leaf: false,
                splitDim: 0,
                aabb: aabb
            };

            aabb[0] = aabb[1] = aabb[2] = Number.POSITIVE_INFINITY;
            aabb[3] = aabb[4] = aabb[5] = Number.NEGATIVE_INFINITY;

            var t;
            var len;

            for (t = 0, len = triangles.length; t < len; ++t) {
                var ii = triangles[t] * 3;
                for (var j = 0; j < 3; ++j) {
                    var pi = indices[ii + j] * 3;
                    if (positions[pi] < aabb[0]) {
                        aabb[0] = positions[pi];
                    }
                    if (positions[pi] > aabb[3]) {
                        aabb[3] = positions[pi];
                    }
                    if (positions[pi + 1] < aabb[1]) {
                        aabb[1] = positions[pi + 1];
                    }
                    if (positions[pi + 1] > aabb[4]) {
                        aabb[4] = positions[pi + 1];
                    }
                    if (positions[pi + 2] < aabb[2]) {
                        aabb[2] = positions[pi + 2];
                    }
                    if (positions[pi + 2] > aabb[5]) {
                        aabb[5] = positions[pi + 2];
                    }
                }
            }

            if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {
                node.triangles = triangles;
                node.leaf = true;
                return node;
            }

            dimLength[0] = aabb[3] - aabb[0];
            dimLength[1] = aabb[4] - aabb[1];
            dimLength[2] = aabb[5] - aabb[2];

            var dim = 0;

            if (dimLength[1] > dimLength[dim]) {
                dim = 1;
            }

            if (dimLength[2] > dimLength[dim]) {
                dim = 2;
            }

            node.splitDim = dim;

            var mid = (aabb[dim] + aabb[dim + 3]) / 2;
            var left = new Array(triangles.length);
            var numLeft = 0;
            var right = new Array(triangles.length);
            var numRight = 0;

            for (t = 0, len = triangles.length; t < len; ++t) {

                var ii = triangles[t] * 3;
                var i0 = indices[ii];
                var i1 = indices[ii + 1];
                var i2 = indices[ii + 2];

                var pi0 = i0 * 3;
                var pi1 = i1 * 3;
                var pi2 = i2 * 3;

                if (positions[pi0 + dim] <= mid || positions[pi1 + dim] <= mid || positions[pi2 + dim] <= mid) {
                    left[numLeft++] = triangles[t];
                } else {
                    right[numRight++] = triangles[t];
                }
            }

            left.length = numLeft;
            right.length = numRight;

            node.left = buildNode(left, indices, positions, depth + 1);
            node.right = buildNode(right, indices, positions, depth + 1);

            return node;
        }

        return function (indices, positions) {
            var numTris = indices.length / 3;
            var triangles = new Array(numTris);
            for (var i = 0; i < numTris; ++i) {
                triangles[i] = i;
            }
            return buildNode(triangles, indices, positions, 0);
        };
    }))(),


    decompressPosition: function decompressPosition(position, decodeMatrix, dest) {
        dest = dest || position;
        dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];
        dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];
        dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
    },

    decompressPositions: function decompressPositions(positions, decodeMatrix, dest) {
        if ( dest === void 0 ) dest = new Float32Array(positions.length);

        for (var i = 0, len = positions.length; i < len; i += 3) {
            dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];
            dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];
            dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];
        }
        return dest;
    },

    decompressUV: function decompressUV(uv, decodeMatrix, dest) {
        dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];
        dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];
    },

    decompressUVs: function decompressUVs(uvs, decodeMatrix, dest) {
        if ( dest === void 0 ) dest = new Float32Array(uvs.length);

        for (var i = 0, len = uvs.length; i < len; i += 3) {
            dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];
            dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];
        }
        return dest;
    },

    octDecodeVec2: function octDecodeVec2(oct, result) {
        var x = oct[0];
        var y = oct[1];
        x = (2 * x + 1) / 255;
        y = (2 * y + 1) / 255;
        var z = 1 - Math.abs(x) - Math.abs(y);
        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }
        var length = Math.sqrt(x * x + y * y + z * z);
        result[0] = x / length;
        result[1] = y / length;
        result[2] = z / length;
        return result;
    },

    octDecodeVec2s: function octDecodeVec2s(octs, result) {
        for (var i = 0, j = 0, len = octs.length; i < len; i += 2) {
            var x = octs[i + 0];
            var y = octs[i + 1];
            x = (2 * x + 1) / 255;
            y = (2 * y + 1) / 255;
            var z = 1 - Math.abs(x) - Math.abs(y);
            if (z < 0) {
                x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
                y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
            }
            var length = Math.sqrt(x * x + y * y + z * z);
            result[j + 0] = x / length;
            result[j + 1] = y / length;
            result[j + 2] = z / length;
            j += 3;
        }
        return result;
    }
};

math.buildEdgeIndices = (function () {

    var uniquePositions = [];
    var indicesLookup = [];
    var indicesReverseLookup = [];
    var weldedIndices = [];

    // TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions

    var faces = [];
    var numFaces = 0;
    var compa = new Uint16Array(3);
    var compb = new Uint16Array(3);
    var compc = new Uint16Array(3);
    var a = math.vec3();
    var b = math.vec3();
    var c = math.vec3();
    var cb = math.vec3();
    var ab = math.vec3();
    var cross = math.vec3();
    var normal = math.vec3();

    function weldVertices(positions, indices) {
        var positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i;
        var len;
        var lenUniquePositions = 0;
        for (i = 0, len = positions.length; i < len; i += 3) {
            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];
            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);
            if (positionsMap[key] === undefined) {
                positionsMap[key] = lenUniquePositions / 3;
                uniquePositions[lenUniquePositions++] = vx;
                uniquePositions[lenUniquePositions++] = vy;
                uniquePositions[lenUniquePositions++] = vz;
            }
            indicesLookup[i / 3] = positionsMap[key];
        }
        for (i = 0, len = indices.length; i < len; i++) {
            weldedIndices[i] = indicesLookup[indices[i]];
            indicesReverseLookup[weldedIndices[i]] = indices[i];
        }
    }

    function buildFaces(numIndices, positionsDecodeMatrix) {
        numFaces = 0;
        for (var i = 0, len = numIndices; i < len; i += 3) {
            var ia = ((weldedIndices[i]) * 3);
            var ib = ((weldedIndices[i + 1]) * 3);
            var ic = ((weldedIndices[i + 2]) * 3);
            if (positionsDecodeMatrix) {
                compa[0] = uniquePositions[ia];
                compa[1] = uniquePositions[ia + 1];
                compa[2] = uniquePositions[ia + 2];
                compb[0] = uniquePositions[ib];
                compb[1] = uniquePositions[ib + 1];
                compb[2] = uniquePositions[ib + 2];
                compc[0] = uniquePositions[ic];
                compc[1] = uniquePositions[ic + 1];
                compc[2] = uniquePositions[ic + 2];
                // Decode
                math.decompressPosition(compa, positionsDecodeMatrix, a);
                math.decompressPosition(compb, positionsDecodeMatrix, b);
                math.decompressPosition(compc, positionsDecodeMatrix, c);
            } else {
                a[0] = uniquePositions[ia];
                a[1] = uniquePositions[ia + 1];
                a[2] = uniquePositions[ia + 2];
                b[0] = uniquePositions[ib];
                b[1] = uniquePositions[ib + 1];
                b[2] = uniquePositions[ib + 2];
                c[0] = uniquePositions[ic];
                c[1] = uniquePositions[ic + 1];
                c[2] = uniquePositions[ic + 2];
            }
            math.subVec3(c, b, cb);
            math.subVec3(a, b, ab);
            math.cross3Vec3(cb, ab, cross);
            math.normalizeVec3(cross, normal);
            var face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});
            face.normal[0] = normal[0];
            face.normal[1] = normal[1];
            face.normal[2] = normal[2];
            numFaces++;
        }
    }

    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {
        weldVertices(positions, indices);
        buildFaces(indices.length, positionsDecodeMatrix);
        var edgeIndices = [];
        var thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);
        var edges = {};
        var edge1;
        var edge2;
        var index1;
        var index2;
        var key;
        var largeIndex = false;
        var edge;
        var normal1;
        var normal2;
        var dot;
        var ia;
        var ib;
        for (var i = 0, len = indices.length; i < len; i += 3) {
            var faceIndex = i / 3;
            for (var j = 0; j < 3; j++) {
                edge1 = weldedIndices[i + j];
                edge2 = weldedIndices[i + ((j + 1) % 3)];
                index1 = Math.min(edge1, edge2);
                index2 = Math.max(edge1, edge2);
                key = index1 + "," + index2;
                if (edges[key] === undefined) {
                    edges[key] = {
                        index1: index1,
                        index2: index2,
                        face1: faceIndex,
                        face2: undefined
                    };
                } else {
                    edges[key].face2 = faceIndex;
                }
            }
        }
        for (key in edges) {
            edge = edges[key];
            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
            if (edge.face2 !== undefined) {
                normal1 = faces[edge.face1].normal;
                normal2 = faces[edge.face2].normal;
                dot = math.dotVec3(normal1, normal2);
                if (dot > thresholdDot) {
                    continue;
                }
            }
            ia = indicesReverseLookup[edge.index1];
            ib = indicesReverseLookup[edge.index2];
            if (!largeIndex && ia > 65535 || ib > 65535) {
                largeIndex = true;
            }
            edgeIndices.push(ia);
            edgeIndices.push(ib);
        }
        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);
    };
})();

// Fast queue that avoids using potentially inefficient array .shift() calls
// Based on https://github.com/creationix/fastqueue

/** @private */
var Queue = function Queue() {

    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
};

var prototypeAccessors$d = { length: { configurable: true } };

prototypeAccessors$d.length.get = function () {
    return this._length;
};

Queue.prototype.shift = function shift () {
    if (this._index >= this._headLength) {
        var t = this._head;
        t.length = 0;
        this._head = this._tail;
        this._tail = t;
        this._index = 0;
        this._headLength = this._head.length;
        if (!this._headLength) {
            return;
        }
    }
    var value = this._head[this._index];
    if (this._index < 0) {
        delete this._head[this._index++];
    }
    else {
        this._head[this._index++] = undefined;
    }
    this._length--;
    return value;
};

Queue.prototype.push = function push (item) {
    this._length++;
    this._tail.push(item);
    return this;
};
Queue.prototype.unshift = function unshift (item) {
    this._head[--this._index] = item;
    this._length++;
    return this;
};

Object.defineProperties( Queue.prototype, prototypeAccessors$d );

/**
 * xeokit runtime statistics.
 * @private
 * @type {{components: {models: number, objects: number, scenes: number, meshes: number}, memory: {indices: number, uvs: number, textures: number, materials: number, transforms: number, positions: number, programs: number, normals: number, meshes: number, colors: number}, build: {version: string}, client: {browser: string}, frame: {frameCount: number, useProgram: number, bindTexture: number, drawElements: number, bindArray: number, tasksRun: number, fps: number, drawArrays: number, tasksScheduled: number}}}
 */
var stats = {
    build: {
        version: "0.8"
    },
    client: {
        browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
    },

    components: {
        scenes: 0,
        models: 0,
        meshes: 0,
        objects: 0
    },
    memory: {
        meshes: 0,
        positions: 0,
        colors: 0,
        normals: 0,
        uvs: 0,
        indices: 0,
        textures: 0,
        transforms: 0,
        materials: 0,
        programs: 0
    },
    frame: {
        frameCount: 0,
        fps: 0,
        useProgram: 0,
        bindTexture: 0,
        bindArray: 0,
        drawElements: 0,
        drawArrays: 0,
        tasksRun: 0,
        tasksScheduled: 0
    }
};

/**
 * @private
 */
function xmlToJson(node, attributeRenamer) {
    if (node.nodeType === node.TEXT_NODE) {
        var v = node.nodeValue;
        if (v.match(/^\s+$/) === null) {
            return v;
        }
    } else if (node.nodeType === node.ELEMENT_NODE ||
        node.nodeType === node.DOCUMENT_NODE) {
        var json = {type: node.nodeName, children: []};

        if (node.nodeType === node.ELEMENT_NODE) {
            for (var j = 0; j < node.attributes.length; j++) {
                var attribute = node.attributes[j];
                var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;
                json[nm] = attribute.nodeValue;
            }
        }

        for (var i = 0; i < node.childNodes.length; i++) {
            var item = node.childNodes[i];
            var j = xmlToJson(item, attributeRenamer);
            if (j) { json.children.push(j); }
        }

        return json;
    }
}

/**
 * @private
 */
function clone(ob) {
    return JSON.parse(JSON.stringify(ob));
}

/**
 * @private
 */
var guidChars = [["0", 10], ["A", 26], ["a", 26], ["_", 1], ["$", 1]].map(function (a) {
    var li = [];
    var st = a[0].charCodeAt(0);
    var en = st + a[1];
    for (var i = st; i < en; ++i) {
        li.push(i);
    }
    return String.fromCharCode.apply(null, li);
}).join("");

/**
 * @private
 */
function b64(v, len) {
    var r = (!len || len === 4) ? [0, 6, 12, 18] : [0, 6];
    return r.map(function (i) {
        return guidChars.substr(parseInt(v / (1 << i)) % 64, 1)
    }).reverse().join("");
}

/**
 * @private
 */
function compressGuid(g) {
    var bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function (i) {
        return parseInt(g.substr(i, 2), 16);
    });
    return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function (i) {
        return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2]);
    }).join("");
}

/**
 * @private
 */
function findNodeOfType(m, t) {
    var li = [];
    var _ = function (n) {
        if (n.type === t) { li.push(n); }
        (n.children || []).forEach(function (c) {
            _(c);
        });
    };
    _(m);
    return li;
}

/**
 * @private
 */
function timeout(dt) {
    return new Promise(function (resolve, reject) {
        setTimeout(resolve, dt);
    });
}

/**
 * @private
 */
function httpRequest(args) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open(args.method || "GET", args.url, true);
        xhr.onload = function (e) {
            console.log(args.url, xhr.readyState, xhr.status);
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(xhr.responseXML);
                } else {
                    reject(xhr.statusText);
                }
            }
        };
        xhr.send(null);
    });
}

/**
 * @private
 */
var queryString = function () {
    // This function is anonymous, is executed immediately and
    // the return value is assigned to QueryString!
    var query_string = {};
    var query = window.location.search.substring(1);
    var vars = query.split("&");
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split("=");
        // If first entry with this name
        if (typeof query_string[pair[0]] === "undefined") {
            query_string[pair[0]] = decodeURIComponent(pair[1]);
            // If second entry with this name
        } else if (typeof query_string[pair[0]] === "string") {
            var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];
            query_string[pair[0]] = arr;
            // If third or later entry with this name
        } else {
            query_string[pair[0]].push(decodeURIComponent(pair[1]));
        }
    }
    return query_string;
}();

/**
 * @private
 */
function loadJSON(url, ok, err) {
    // Avoid checking ok and err on each use.
    var defaultCallback = function (_value) { return undefined; };
    ok = ok || defaultCallback;
    err = err || defaultCallback;

    var request = new XMLHttpRequest();
    request.overrideMimeType("application/json");
    request.open('GET', url, true);
    request.addEventListener('load', function (event) {
        var response = event.target.response;
        if (this.status === 200) {
            var json;
            try {
                json = JSON.parse(response);
            } catch (e) {
                err(("utils.loadJSON(): Failed to parse JSON response - " + e));
            }
            ok(json);
        } else if (this.status === 0) {
            // Some browsers return HTTP Status 0 when using non-http protocol
            // e.g. 'file://' or 'data://'. Handle as success.
            console.warn('loadFile: HTTP Status 0 received.');
            try {
                ok(JSON.parse(response));
            } catch (e$1) {
                err(("utils.loadJSON(): Failed to parse JSON response - " + e$1));
            }
        } else {
            err(event);
        }
    }, false);

    request.addEventListener('error', function (event) {
        err(event);
    }, false);
    request.send(null);
}

/**
 * @private
 */
function loadArraybuffer$1(url, ok, err) {
    // Check for data: URI
    var defaultCallback = function (_value) { return undefined; };
    ok = ok || defaultCallback;
    err = err || defaultCallback;
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex);
    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest
        var isBase64 = !!dataUriRegexResult[2];
        var data = dataUriRegexResult[3];
        data = window.decodeURIComponent(data);
        if (isBase64) {
            data = window.atob(data);
        }
        try {
            var buffer = new ArrayBuffer(data.length);
            var view = new Uint8Array(buffer);
            for (var i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
            }
            window.setTimeout(function () {
                ok(buffer);
            }, 0);
        } catch (error) {
            window.setTimeout(function () {
                err(error);
            }, 0);
        }
    } else {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    ok(request.response);
                } else {
                    err('loadArrayBuffer error : ' + request.response);
                }
            }
        };
        request.send(null);
    }
}

/**
 Tests if the given object is an array
 @private
 */
function isArray(value) {
    return value && !(value.propertyIsEnumerable('length')) && typeof value === 'object' && typeof value.length === 'number';
}

/**
 Tests if the given value is a string
 @param value
 @returns {boolean}
 @private
 */
function isString(value) {
    return (typeof value === 'string' || value instanceof String);
}

/**
 Tests if the given value is a number
 @param value
 @returns {boolean}
 @private
 */
function isNumeric(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}

/**
 Tests if the given value is an ID
 @param value
 @returns {boolean}
 @private
 */
function isID(value) {
    return utils.isString(value) || utils.isNumeric(value);
}

/**
 Tests if the given components are the same, where the components can be either IDs or instances.
 @param c1
 @param c2
 @returns {boolean}
 @private
 */
function isSameComponent(c1, c2) {
    if (!c1 || !c2) {
        return false;
    }
    var id1 = (utils.isNumeric(c1) || utils.isString(c1)) ? ("" + c1) : c1.id;
    var id2 = (utils.isNumeric(c2) || utils.isString(c2)) ? ("" + c2) : c2.id;
    return id1 === id2;
}

/**
 Tests if the given value is a function
 @param value
 @returns {boolean}
 @private
 */
function isFunction(value) {
    return (typeof value === "function");
}

/**
 Tests if the given value is a JavaScript JSON object, eg, ````{ foo: "bar" }````.
 @param value
 @returns {boolean}
 @private
 */
function isObject(value) {
    var objectConstructor = {}.constructor;
    return (!!value && value.constructor === objectConstructor);
}

/** Returns a shallow copy
 */
function copy(o) {
    return utils.apply(o, {});
}

/** Add properties of o to o2, overwriting them on o2 if already there
 */
function apply(o, o2) {
    for (var name in o) {
        if (o.hasOwnProperty(name)) {
            o2[name] = o[name];
        }
    }
    return o2;
}

/**
 Add non-null/defined properties of o to o2
 @private
 */
function apply2(o, o2) {
    for (var name in o) {
        if (o.hasOwnProperty(name)) {
            if (o[name] !== undefined && o[name] !== null) {
                o2[name] = o[name];
            }
        }
    }
    return o2;
}

/**
 Add properties of o to o2 where undefined or null on o2
 @private
 */
function applyIf(o, o2) {
    for (var name in o) {
        if (o.hasOwnProperty(name)) {
            if (o2[name] === undefined || o2[name] === null) {
                o2[name] = o[name];
            }
        }
    }
    return o2;
}

/**
 Returns true if the given map is empty.
 @param obj
 @returns {boolean}
 @private
 */
function isEmptyObject(obj) {
    for (var name in obj) {
        if (obj.hasOwnProperty(name)) {
            return false;
        }
    }
    return true;
}

/**
 Returns the given ID as a string, in quotes if the ID was a string to begin with.

 This is useful for logging IDs.

 @param {Number| String} id The ID
 @returns {String}
 @private
 */
function inQuotes(id) {
    return utils.isNumeric(id) ? (("" + id)) : (("'" + id + "'"));
}

/**
 Returns the concatenation of two typed arrays.
 @param a
 @param b
 @returns {*|a}
 @private
 */
function concat(a, b) {
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}

function flattenParentChildHierarchy(root) {
    var list = [];

    function visit(node) {
        node.id = node.uuid;
        delete node.oid;
        list.push(node);
        var children = node.children;

        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                var child = children[i];
                child.parent = node.id;
                visit(children[i]);
            }
        }
        node.children = [];
    }

    visit(root);
    return list;
}

/**
 * @private
 */
var utils = {
    xmlToJson: xmlToJson,
    clone: clone,
    compressGuid: compressGuid,
    findNodeOfType: findNodeOfType,
    timeout: timeout,
    httpRequest: httpRequest,
    loadJSON: loadJSON,
    loadArraybuffer: loadArraybuffer$1,
    queryString: queryString,
    isArray: isArray,
    isString: isString,
    isNumeric: isNumeric,
    isID: isID,
    isSameComponent: isSameComponent,
    isFunction: isFunction,
    isObject: isObject,
    copy: copy,
    apply: apply,
    apply2: apply2,
    applyIf: applyIf,
    isEmptyObject: isEmptyObject,
    inQuotes: inQuotes,
    concat: concat,
    flattenParentChildHierarchy: flattenParentChildHierarchy
};

var scenesRenderInfo = {}; // Used for throttling FPS for each Scene
var sceneIDMap = new Map(); // Ensures unique scene IDs
var taskQueue = new Queue(); // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule
var tickEvent = {sceneId: null, time: null, startTime: null, prevTime: null, deltaTime: null};
var taskBudget = 10; // Millisecs we're allowed to spend on tasks in each frame
var fpsSamples = [];
var numFPSSamples = 30;
var lastTime = 0;
var elapsedTime;
var totalFPS = 0;

/**
 * @private
 */
function Core() {

    /**
     Semantic version number. The value for this is set by an expression that's concatenated to
     the end of the built binary by the xeokit build script.
     @property version
     @namespace xeokit
     @type {String}
     */
    this.version = "1.0.0";

    /**
     Existing {@link Scene}s , mapped to their IDs
     @property scenes
     @namespace xeokit
     @type {{Scene}}
     */
    this.scenes = {};

    this._superTypes = {}; // For each component type, a list of its supertypes, ordered upwards in the hierarchy.

    /**
     * Registers a scene on xeokit.
     * This is called within the xeokit.Scene constructor.
     * @private
     */
    this._addScene = function (scene) {
        if (scene.id) { // User-supplied ID
            if (core.scenes[scene.id]) {
                console.error(("[ERROR] Scene " + (utils.inQuotes(scene.id)) + " already exists"));
                return;
            }
        } else { // Auto-generated ID
            scene.id = sceneIDMap.addItem({});
        }
        core.scenes[scene.id] = scene;
        var ticksPerOcclusionTest = scene.ticksPerOcclusionTest;
        var ticksPerRender = scene.ticksPerRender;
        scenesRenderInfo[scene.id] = {
            ticksPerOcclusionTest: ticksPerOcclusionTest,
            ticksPerRender: ticksPerRender,
            renderCountdown: ticksPerRender
        };
        stats.components.scenes++;
        scene.once("destroyed", function () { // Unregister destroyed scenes
            sceneIDMap.removeItem(scene.id);
            delete core.scenes[scene.id];
            delete scenesRenderInfo[scene.id];
            stats.components.scenes--;
        });
    };

    /**
     * @private
     */
    this.clear = function () {
        var scene;
        for (var id in core.scenes) {
            if (core.scenes.hasOwnProperty(id)) {
                scene = core.scenes[id];
                // Only clear the default Scene
                // but destroy all the others
                if (id === "default.scene") {
                    scene.clear();
                } else {
                    scene.destroy();
                    delete core.scenes[scene.id];
                }
            }
        }
    };

    /**
     * Schedule a task to run at the next frame.
     *
     * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeokit processes the queue
     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
     * get a chance to run during the task are left in the queue to be run next time.
     *
     * @param {Function} callback Callback that runs the task.
     * @param {Object} [scope] Scope for the callback.
     */
    this.scheduleTask = function (callback, scope) {
        taskQueue.push(callback);
        taskQueue.push(scope);
    };

    this.runTasks = function (until) {
        if ( until === void 0 ) until = -1;
 // Pops and processes tasks in the queue, until the given number of milliseconds has elapsed.
        var time = (new Date()).getTime();
        var callback;
        var scope;
        var tasksRun = 0;
        while (taskQueue.length > 0 && (until < 0 || time < until)) {
            callback = taskQueue.shift();
            scope = taskQueue.shift();
            if (scope) {
                callback.call(scope);
            } else {
                callback();
            }
            time = (new Date()).getTime();
            tasksRun++;
        }
        return tasksRun;
    };

    this.getNumTasks = function () {
        return taskQueue.length;
    };
}

/**
 * @private
 * @type {Core}
 */
var core = new Core();


var frame = function () {
    var time = Date.now();
    if (lastTime > 0) { // Log FPS stats
        elapsedTime = time - lastTime;
        var newFPS = 1000 / elapsedTime; // Moving average of FPS
        totalFPS += newFPS;
        fpsSamples.push(newFPS);
        if (fpsSamples.length >= numFPSSamples) {
            totalFPS -= fpsSamples.shift();
        }
        stats.frame.fps = Math.round(totalFPS / fpsSamples.length);
    }
    runTasks(time);
    fireTickEvents(time);
    renderScenes();
    lastTime = time;
    window.requestAnimationFrame(frame);
};

function runTasks(time) { // Process as many enqueued tasks as we can within the per-frame task budget
    var tasksRun = core.runTasks(time + taskBudget);
    var tasksScheduled = core.getNumTasks();
    stats.frame.tasksRun = tasksRun;
    stats.frame.tasksScheduled = tasksScheduled;
    stats.frame.tasksBudget = taskBudget;
}

function fireTickEvents(time) { // Fire tick event on each Scene
    tickEvent.time = time;
    for (var id in core.scenes) {
        if (core.scenes.hasOwnProperty(id)) {
            var scene = core.scenes[id];
            tickEvent.sceneId = id;
            tickEvent.startTime = scene.startTime;
            tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;
            /**
             * Fired on each game loop iteration.
             *
             * @event tick
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.
             * @param {Number} time The time in seconds since 1970 of this "tick" event.
             * @param {Number} prevTime The time of the previous "tick" event from this Scene.
             * @param {Number} deltaTime The time in seconds since the previous "tick" event from this Scene.
             */
            scene.fire("tick", tickEvent, true);
        }
    }
    tickEvent.prevTime = time;
}

function renderScenes() {
    var scenes = core.scenes;
    var forceRender = false;
    var scene;
    var renderInfo;
    var ticksPerOcclusionTest;
    var ticksPerRender;
    var id;
    for (id in scenes) {
        if (scenes.hasOwnProperty(id)) {

            scene = scenes[id];
            renderInfo = scenesRenderInfo[id];

            if (!renderInfo) {
                renderInfo = scenesRenderInfo[id] = {}; // FIXME
            }

            ticksPerOcclusionTest = scene.ticksPerOcclusionTest;
            if (renderInfo.ticksPerOcclusionTest !== ticksPerOcclusionTest) {
                renderInfo.ticksPerOcclusionTest = ticksPerOcclusionTest;
                renderInfo.renderCountdown = ticksPerOcclusionTest;
            }
            if (--scene.occlusionTestCountdown <= 0) {
                scene.doOcclusionTest();
                scene.occlusionTestCountdown = ticksPerOcclusionTest;
            }

            ticksPerRender = scene.ticksPerRender;
            if (renderInfo.ticksPerRender !== ticksPerRender) {
                renderInfo.ticksPerRender = ticksPerRender;
                renderInfo.renderCountdown = ticksPerRender;
            }
            if (--renderInfo.renderCountdown === 0) {
                scene.render(forceRender);
                renderInfo.renderCountdown = ticksPerRender;
            }
        }
    }
}

window.requestAnimationFrame(frame);

/**
 * @desc Base class for all xeokit components.
 *
 * ## Component IDs
 *
 * Every Component has an ID that's unique within the parent {@link Scene}. xeokit generates
 * the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a
 * scene comprised of {@link Scene}, {@link Material}, {@link ReadableGeometry} and
 * {@link Mesh} components, while letting xeokit generate its own ID for
 * the {@link ReadableGeometry}:
 *
 *````JavaScript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas"
 *    });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          id: "myMaterial",
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          specularFresnel: new Fresnel(viewer.scene, {
 *              leftColor: [1.0, 1.0, 1.0],
 *              rightColor: [0.0, 0.0, 0.0],
 *              power: 4
 *          })
 *     })
 * });
 *````
 *
 * We can then find those components like this:
 *
 * ````javascript
 * // Find the Material
 * var material = viewer.scene.components["myMaterial"];
 *
 * // Find all PhongMaterials in the Scene
 * var phongMaterials = viewer.scene.types["PhongMaterial"];
 *
 * // Find our Material within the PhongMaterials
 * var materialAgain = phongMaterials["myMaterial"];
 * ````
 *
 * ## Restriction on IDs
 *
 * Auto-generated IDs are of the form ````"__0"````, ````"__1"````, ````"__2"```` ... and so on.
 *
 * Scene maintains a map of these IDs, along with a counter that it increments each time it generates a new ID.
 *
 * If Scene has created the IDs listed above, and we then destroy the ````Component```` with ID ````"__1"````,
 * Scene will mark that ID as available, and will reuse it for the next default ID.
 *
 * Therefore, two restrictions your on IDs:
 *
 * * don't use IDs that begin with two underscores, and
 * * don't reuse auto-generated IDs of destroyed Components.
 *
 * ## Logging
 *
 * Components have methods to log ID-prefixed messages to the JavaScript console:
 *
 * ````javascript
 * material.log("Everything is fine, situation normal.");
 * material.warn("Wait, whats that red light?");
 * material.error("Aw, snap!");
 * ````
 *
 * The logged messages will look like this in the console:
 *
 * ````text
 * [LOG]   myMaterial: Everything is fine, situation normal.
 * [WARN]  myMaterial: Wait, whats that red light..
 * [ERROR] myMaterial: Aw, snap!
 * ````
 *
 * ## Destruction
 *
 * Get notification of destruction of Components:
 *
 * ````javascript
 * material.once("destroyed", function() {
 *     this.log("Component was destroyed: " + this.id);
 * });
 * ````
 *
 * Or get notification of destruction of any Component within its {@link Scene}:
 *
 * ````javascript
 * scene.on("componentDestroyed", function(component) {
 *     this.log("Component was destroyed: " + component.id);
 * });
 * ````
 *
 * Then destroy a component like this:
 *
 * ````javascript
 * material.destroy();
 * ````
 */
var Component = function Component(owner, cfg) {
    if ( owner === void 0 ) owner = null;
    if ( cfg === void 0 ) cfg = {};


    /**
     * The parent {@link Scene} that contains this Component.
     *
     * @property scene
     * @type {Scene}
     * @final
     */
    this.scene = null;

    if (this.type === "Scene") {
        this.scene = this;
        /**
         * The viewer that contains this Scene.
         * @property viewer
         * @type {Viewer}
         */
        this.viewer = cfg.viewer;
    } else {
        if (owner.type === "Scene") {
            this.scene = owner;
        } else if (owner instanceof Component) {
            this.scene = owner.scene;
        } else {
            throw "Invalid param: owner must be a Component"
        }
        this._owner = owner;
        this._renderer = this.scene._renderer;
    }

    this._dontClear = !!cfg.dontClear; // Prevent Scene#clear from destroying this component

    this._renderer = this.scene._renderer;

    /**
     Arbitrary, user-defined metadata on this component.

     @property metadata
     @type Object
     */
    this.meta = cfg.meta || {};


    /**
     * ID of this Component, unique within the {@link Scene}.
     *
     * Components are mapped by this ID in {@link Scene#components}.
     *
     * @property id
     * @type {String|Number}
     */
    this.id = cfg.id; // Auto-generated by Scene by default

    /**
     True as soon as this Component has been destroyed

     @property destroyed
     @type {Boolean}
     */
    this.destroyed = false;

    this._attached = {}; // Attached components with names.
    this._attachments = null; // Attached components keyed to IDs - lazy-instantiated
    this._subIdMap = null; // Subscription subId pool
    this._subIdEvents = null; // Subscription subIds mapped to event names
    this._eventSubs = null; // Event names mapped to subscribers
    this._eventSubsNum = null;
    this._events = null; // Maps names to events
    this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events
    this._ownedComponents = null; // // Components created with #create - lazy-instantiated

    if (this !== this.scene) { // Don't add scene to itself
        this.scene._addComponent(this); // Assigns this component an automatic ID if not yet assigned
    }

    this._updateScheduled = false; // True when #_update will be called on next tick

    if (owner) {
        owner._own(this);
    }
};

var prototypeAccessors$c = { type: { configurable: true },isComponent: { configurable: true },owner: { configurable: true } };

// /**
//  * Unique ID for this Component within its {@link Scene}.
//  *
//  * @property
//  * @type {String}
//  */
// get id() {
// return this._id;
// }

/**
 Indicates that we need to redraw the scene.

 This is called by certain subclasses after they have made some sort of state update that requires the
 renderer to perform a redraw.

 For example: a {@link Mesh} calls this on itself whenever you update its
 {@link Mesh#layer} property, which manually controls its render order in
 relation to other Meshes.

 If this component has a ````castsShadow```` property that's set ````true````, then this will also indicate
 that the renderer needs to redraw shadow map associated with this component. Components like
 {@link DirLight} have that property set when they produce light that creates shadows, while
 components like {@link Mesh"}}layer{{/crossLink}} have that property set when they cast shadows.

 @protected
 */
prototypeAccessors$c.type.get = function () {
    return "Component";
};

/**
 * @private
 */
prototypeAccessors$c.isComponent.get = function () {
    return true;
};

Component.prototype.glRedraw = function glRedraw () {
    if (!this._renderer) { // Called from a constructor
        return;
    }
    this._renderer.imageDirty();
    if (this.castsShadow) { // Light source or object
        this._renderer.shadowsDirty();
    }
};

/**
 Indicates that we need to re-sort the renderer's state-ordered drawables list.

 For efficiency, the renderer keeps its list of drawables ordered so that runs of the same state updates can be
 combined.  This method is called by certain subclasses after they have made some sort of state update that would
 require re-ordering of the drawables list.

 For example: a {@link DirLight} calls this on itself whenever you update {@link DirLight#dir}.

 @protected
 */
Component.prototype.glResort = function glResort () {
    if (!this._renderer) { // Called from a constructor
        return;
    }
    this._renderer.needStateSort();
};

/**
 * The {@link Component} that owns the lifecycle of this Component, if any.
 *
 * When that component is destroyed, this component will be automatically destroyed also.
 *
 * Will be null if this Component has no owner.
 *
 * @property owner
 * @type {Component}
 */
prototypeAccessors$c.owner.get = function () {
    return this._owner;
};

/**
 * Tests if this component is of the given type, or is a subclass of the given type.
 * @type {Boolean}
 */
Component.prototype.isType = function isType (type) {
    return this.type === type;
};

/**
 * Fires an event on this component.
 *
 * Notifies existing subscribers to the event, optionally retains the event to give to
 * any subsequent notifications on the event as they are made.
 *
 * @param {String} event The event type name
 * @param {Object} value The event parameters
 * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
 */
Component.prototype.fire = function fire (event, value, forget) {
    if (!this._events) {
        this._events = {};
    }
    if (!this._eventSubs) {
        this._eventSubs = {};
        this._eventSubsNum = {};
    }
    if (forget !== true) {
        this._events[event] = value || true; // Save notification
    }
    var subs = this._eventSubs[event];
    var sub;
    if (subs) { // Notify subscriptions
        for (var subId in subs) {
            if (subs.hasOwnProperty(subId)) {
                sub = subs[subId];
                this._eventCallDepth++;
                if (this._eventCallDepth < 300) {
                    sub.callback.call(sub.scope, value);
                } else {
                    this.error("fire: potential stack overflow from recursive event '" + event + "' - dropping this event");
                }
                this._eventCallDepth--;
            }
        }
    }
};

/**
 * Subscribes to an event on this component.
 *
 * The callback is be called with this component as scope.
 *
 * @param {String} event The event
 * @param {Function} callback Called fired on the event
 * @param {Object} [scope=this] Scope for the callback
 * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
 */
Component.prototype.on = function on (event, callback, scope) {
    if (!this._events) {
        this._events = {};
    }
    if (!this._subIdMap) {
        this._subIdMap = new Map(); // Subscription subId pool
    }
    if (!this._subIdEvents) {
        this._subIdEvents = {};
    }
    if (!this._eventSubs) {
        this._eventSubs = {};
    }
    if (!this._eventSubsNum) {
        this._eventSubsNum = {};
    }
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = {};
        this._eventSubs[event] = subs;
        this._eventSubsNum[event] = 1;
    } else {
        this._eventSubsNum[event]++;
    }
    var subId = this._subIdMap.addItem(); // Create unique subId
    subs[subId] = {
        callback: callback,
        scope: scope || this
    };
    this._subIdEvents[subId] = event;
    var value = this._events[event];
    if (value !== undefined) { // A publication exists, notify callback immediately
        callback.call(scope || this, value);
    }
    return subId;
};

/**
 * Cancels an event subscription that was previously made with {@link Component#on} or {@link Component#once}.
 *
 * @param {String} subId Subscription ID
 */
Component.prototype.off = function off (subId) {
    if (subId === undefined || subId === null) {
        return;
    }
    if (!this._subIdEvents) {
        return;
    }
    var event = this._subIdEvents[subId];
    if (event) {
        delete this._subIdEvents[subId];
        var subs = this._eventSubs[event];
        if (subs) {
            delete subs[subId];
            this._eventSubsNum[event]--;
        }
        this._subIdMap.removeItem(subId); // Release subId
    }
};

/**
 * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.
 *
 * This is equivalent to calling {@link Component#on}, and then calling {@link Component#off} inside the callback function.
 *
 * @param {String} event Data event to listen to
 * @param {Function} callback Called when fresh data is available at the event
 * @param {Object} [scope=this] Scope for the callback
 */
Component.prototype.once = function once (event, callback, scope) {
    var self = this;
    var subId = this.on(event,
        function (value) {
            self.off(subId);
            callback.call(scope || this, value);
        },
        scope);
};

/**
 * Returns true if there are any subscribers to the given event on this component.
 *
 * @param {String} event The event
 * @return {Boolean} True if there are any subscribers to the given event on this component.
 */
Component.prototype.hasSubs = function hasSubs (event) {
    return (this._eventSubsNum && (this._eventSubsNum[event] > 0));
};

/**
 * Logs a console debugging message for this component.
 *
 * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
 *
 * Also fires the message as a "log" event on the parent {@link Scene}.
 *
 * @param {String} message The message to log
 */
Component.prototype.log = function log (message) {
    message = "[LOG]" + this._message(message);
    window.console.log(message);
    this.scene.fire("log", message);
};

Component.prototype._message = function _message (message) {
    return " [" + this.type + " " + utils.inQuotes(this.id) + "]: " + message;
};

/**
 * Logs a warning for this component to the JavaScript console.
 *
 * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
 *
 * Also fires the message as a "warn" event on the parent {@link Scene}.
 *
 * @param {String} message The message to log
 */
Component.prototype.warn = function warn (message) {
    message = "[WARN]" + this._message(message);
    window.console.warn(message);
    this.scene.fire("warn", message);
};

/**
 * Logs an error for this component to the JavaScript console.
 *
 * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
 *
 * Also fires the message as an "error" event on the parent {@link Scene}.
 *
 * @param {String} message The message to log
 */
Component.prototype.error = function error (message) {
    message = "[ERROR]" + this._message(message);
    window.console.error(message);
    this.scene.fire("error", message);
};

/**
 * Adds a child component to this.
 *
 * When component not given, attaches the scene's default instance for the given name (if any).
 * Publishes the new child component on this component, keyed to the given name.
 *
 * @param {*} params
 * @param {String} params.name component name
 * @param {Component} [params.component] The component
 * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will
 * cause an exception if the given child is not the same type or a subtype of this.
 * @param {Boolean} [params.sceneDefault=false]
 * @param {Boolean} [params.sceneSingleton=false]
 * @param {Function} [params.onAttached] Optional callback called when component attached
 * @param {Function} [params.onAttached.callback] Callback function
 * @param {Function} [params.onAttached.scope] Optional scope for callback
 * @param {Function} [params.onDetached] Optional callback called when component is detached
 * @param {Function} [params.onDetached.callback] Callback function
 * @param {Function} [params.onDetached.scope] Optional scope for callback
 * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component
 * @param {Boolean} [params.recompiles=true] When true, fires "dirty" events on this component
 * @private
 */
Component.prototype._attach = function _attach (params) {

    var name = params.name;

    if (!name) {
        this.error("Component 'name' expected");
        return;
    }

    var component = params.component;
    var sceneDefault = params.sceneDefault;
    var sceneSingleton = params.sceneSingleton;
    var type = params.type;
    var on = params.on;
    var recompiles = params.recompiles !== false;

    // True when child given as config object, where parent manages its instantiation and destruction
    var managingLifecycle = false;

    if (component) {

        if (utils.isNumeric(component) || utils.isString(component)) {

            // Component ID given
            // Both numeric and string IDs are supported

            var id = component;

            component = this.scene.components[id];

            if (!component) {

                // Quote string IDs in errors

                this.error("Component not found: " + utils.inQuotes(id));
                return;
            }
        }
    }

    if (!component) {

        if (sceneSingleton === true) {

            // Using the first instance of the component type we find

            var instances = this.scene.types[type];
            for (var id2 in instances) {
                if (instances.hasOwnProperty) {
                    component = instances[id2];
                    break;
                }
            }

            if (!component) {
                this.error("Scene has no default component for '" + name + "'");
                return null;
            }

        } else if (sceneDefault === true) {

            // Using a default scene component

            component = this.scene[name];

            if (!component) {
                this.error("Scene has no default component for '" + name + "'");
                return null;
            }
        }
    }

    if (component) {

        if (component.scene.id !== this.scene.id) {
            this.error("Not in same scene: " + component.type + " " + utils.inQuotes(component.id));
            return;
        }

        if (type) {

            if (!component.isType(type)) {
                this.error("Expected a " + type + " type or subtype: " + component.type + " " + utils.inQuotes(component.id));
                return;
            }
        }
    }

    if (!this._attachments) {
        this._attachments = {};
    }

    var oldComponent = this._attached[name];
    var subs;
    var i;
    var len;

    if (oldComponent) {

        if (component && oldComponent.id === component.id) {

            // Reject attempt to reattach same component
            return;
        }

        var oldAttachment = this._attachments[oldComponent.id];

        // Unsubscribe from events on old component

        subs = oldAttachment.subs;

        for (i = 0, len = subs.length; i < len; i++) {
            oldComponent.off(subs[i]);
        }

        delete this._attached[name];
        delete this._attachments[oldComponent.id];

        var onDetached = oldAttachment.params.onDetached;
        if (onDetached) {
            if (utils.isFunction(onDetached)) {
                onDetached(oldComponent);
            } else {
                onDetached.scope ? onDetached.callback.call(onDetached.scope, oldComponent) : onDetached.callback(oldComponent);
            }
        }

        if (oldAttachment.managingLifecycle) {

            // Note that we just unsubscribed from all events fired by the child
            // component, so destroying it won't fire events back at us now.

            oldComponent.destroy();
        }
    }

    if (component) {

        // Set and publish the new component on this component

        var attachment = {
            params: params,
            component: component,
            subs: [],
            managingLifecycle: managingLifecycle
        };

        attachment.subs.push(
            component.once("destroyed",
                function () {
                    attachment.params.component = null;
                    this._attach(attachment.params);
                },
                this));

        if (recompiles) {
            attachment.subs.push(
                component.on("dirty",
                    function () {
                        this.fire("dirty", this);
                    },
                    this));
        }

        this._attached[name] = component;
        this._attachments[component.id] = attachment;

        // Bind destruct listener to new component to remove it
        // from this component when destroyed

        var onAttached = params.onAttached;
        if (onAttached) {
            if (utils.isFunction(onAttached)) {
                onAttached(component);
            } else {
                onAttached.scope ? onAttached.callback.call(onAttached.scope, component) : onAttached.callback(component);
            }
        }

        if (on) {

            var event;
            var subIdr;
            var callback;
            var scope;

            for (event in on) {
                if (on.hasOwnProperty(event)) {

                    subIdr = on[event];

                    if (utils.isFunction(subIdr)) {
                        callback = subIdr;
                        scope = null;
                    } else {
                        callback = subIdr.callback;
                        scope = subIdr.scope;
                    }

                    if (!callback) {
                        continue;
                    }

                    attachment.subs.push(component.on(event, callback, scope));
                }
            }
        }
    }

    if (recompiles) {
        this.fire("dirty", this); // FIXME: May trigger spurous mesh recompilations unless able to limit with param?
    }

    this.fire(name, component); // Component can be null

    return component;
};

Component.prototype._checkComponent = function _checkComponent (expectedType, component) {
    if (!component.isComponent) {
        if (utils.isID(component)) {
            var id = component;
            component = this.scene.components[id];
            if (!component) {
                this.error("Component not found: " + id);
                return;
            }
        } else {
            this.error("Expected a Component or ID");
            return;
        }
    }
    if (expectedType !== component.type) {
        this.error("Expected a " + expectedType + " Component");
        return;
    }
    if (component.scene.id !== this.scene.id) {
        this.error("Not in same scene: " + component.type);
        return;
    }
    return component;
};

Component.prototype._checkComponent2 = function _checkComponent2 (expectedTypes, component) {
    if (!component.isComponent) {
        if (utils.isID(component)) {
            var id = component;
            component = this.scene.components[id];
            if (!component) {
                this.error("Component not found: " + id);
                return;
            }
        } else {
            this.error("Expected a Component or ID");
            return;
        }
    }
    if (component.scene.id !== this.scene.id) {
        this.error("Not in same scene: " + component.type);
        return;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (expectedTypes[i] === component.type) {
            return component;
        }
    }
    this.error("Expected component types: " + expectedTypes);
    return null;
};

Component.prototype._own = function _own (component) {
        var this$1 = this;

    if (!this._ownedComponents) {
        this._ownedComponents = {};
    }
    if (!this._ownedComponents[component.id]) {
        this._ownedComponents[component.id] = component;
    }
    component.once("destroyed", function () {
        delete this$1._ownedComponents[component.id];
    }, this);
};

/**
 * Protected method, called by sub-classes to queue a call to _update().
 * @protected
 * @param {Number} [priority=1]
 */
Component.prototype._needUpdate = function _needUpdate (priority) {
    if (!this._updateScheduled) {
        this._updateScheduled = true;
        if (priority === 0) {
            this._doUpdate();
        } else {
            core.scheduleTask(this._doUpdate, this);
        }
    }
};

/**
 * @private
 */
Component.prototype._doUpdate = function _doUpdate () {
    if (this._updateScheduled) {
        this._updateScheduled = false;
        if (this._update) {
            this._update();
        }
    }
};

/**
 * Protected virtual template method, optionally implemented
 * by sub-classes to perform a scheduled task.
 *
 * @protected
 */
Component.prototype._update = function _update () {
};

/**
 * Destroys all {@link Component}s that are owned by this. These are Components that were instantiated with
 * this Component as their first constructor argument.
 */
Component.prototype.clear = function clear () {
    if (this._ownedComponents) {
        for (var id in this._ownedComponents) {
            if (this._ownedComponents.hasOwnProperty(id)) {
                var component = this._ownedComponents[id];
                component.destroy();
                delete this._ownedComponents[id];
            }
        }
    }
};

/**
 * Destroys this component.
 */
Component.prototype.destroy = function destroy () {

    if (this.destroyed) {
        return;
    }

    /**
     * Fired when this Component is destroyed.
     * @event destroyed
     */
    this.fire("destroyed", this.destroyed = true); // Must fire before we blow away subscription maps, below

    // Unsubscribe from child components and destroy then

    var id;
    var attachment;
    var component;
    var subs;
    var i;
    var len;

    if (this._attachments) {
        for (id in this._attachments) {
            if (this._attachments.hasOwnProperty(id)) {
                attachment = this._attachments[id];
                component = attachment.component;
                subs = attachment.subs;
                for (i = 0, len = subs.length; i < len; i++) {
                    component.off(subs[i]);
                }
                if (attachment.managingLifecycle) {
                    component.destroy();
                }
            }
        }
    }

    if (this._ownedComponents) {
        for (id in this._ownedComponents) {
            if (this._ownedComponents.hasOwnProperty(id)) {
                component = this._ownedComponents[id];
                component.destroy();
                delete this._ownedComponents[id];
            }
        }
    }

    this.scene._removeComponent(this);

    // Memory leak avoidance
    this._attached = {};
    this._attachments = null;
    this._subIdMap = null;
    this._subIdEvents = null;
    this._eventSubs = null;
    this._events = null;
    this._eventCallDepth = 0;
    this._ownedComponents = null;
    this._updateScheduled = false;
};

Object.defineProperties( Component.prototype, prototypeAccessors$c );

/**
 * @private
 * @type {{PICKABLE: number, CLIPPABLE: number, BACKFACES: number, VISIBLE: number, SELECTED: number, OUTLINED: number, CULLED: number, RECEIVE_SHADOW: number, COLLIDABLE: number, XRAYED: number, CAST_SHADOW: number, EDGES: number, HIGHLIGHTED: number}}
 */
var ENTITY_FLAGS = {
    VISIBLE: 1,
    CULLED: 1 << 2,
    PICKABLE: 1 << 3,
    CLIPPABLE: 1 << 4,
    COLLIDABLE: 1 << 5,
    CAST_SHADOW: 1 << 6,
    RECEIVE_SHADOW: 1 << 7,
    XRAYED: 1 << 8,
    HIGHLIGHTED: 1 << 9,
    SELECTED: 1 << 10,
    EDGES: 1 << 11,
    BACKFACES: 1 << 12,
    TRANSPARENT: 1 << 13
};

var tempFloatRGB = new Float32Array([0, 0, 0]);
var tempIntRGB = new Uint16Array([0, 0, 0]);

/**
 * @private
 */
var PerformanceNode = function PerformanceNode(model, isObject, id, meshes, flags, aabb) {

    this._isObject = isObject;

    /**
     * The {@link Scene} that contains this PerformanceNode.
     *
     * @property scene
     * @type {Scene}
     * @final
     */
    this.scene = model.scene;

    /**
     * The PerformanceModel that contains this PerformanceNode.
     * @property model
     * @type {PerformanceModel}
     * @final
     */
    this.model = model;

    /**
     * The PerformanceModelMesh instances contained by this PerformanceNode
     * @property meshes
     * @type {{Array of PerformanceModelMesh}}
     * @final
     */
    this.meshes = meshes;

    this._numTriangles = 0;

    for (var i = 0, len = this.meshes.length; i < len; i++) {  // TODO: tidier way? Refactor?
        var mesh = this.meshes[i];
        mesh.parent = this;
        this._numTriangles += mesh.numTriangles;
    }

    /**
     * ID of this PerformanceNode, unique within the {@link Scene}.
     * @property id
     * @type {String|Number}
     * @final
     */
    this.id = id;

    /**
     * ID of the corresponding object within the originating system.
     *
     * @type {String}
     * @abstract
     */
    this.originalSystemId = math.unglobalizeObjectId(model.id, id);

    this._flags = flags;
    this._aabb = aabb;
    this._offsetAABB = math.AABB3(aabb);

    this._offset = math.vec3();

    if (this._isObject) {
        model.scene._registerObject(this);
    }
};

var prototypeAccessors$b = { isEntity: { configurable: true },isModel: { configurable: true },isObject: { configurable: true },aabb: { configurable: true },numTriangles: { configurable: true },visible: { configurable: true },highlighted: { configurable: true },xrayed: { configurable: true },selected: { configurable: true },edges: { configurable: true },culled: { configurable: true },clippable: { configurable: true },collidable: { configurable: true },pickable: { configurable: true },colorize: { configurable: true },opacity: { configurable: true },offset: { configurable: true },castsShadow: { configurable: true },receivesShadow: { configurable: true },saoEnabled: { configurable: true } };

//------------------------------------------------------------------------------------------------------------------
// Entity members
//------------------------------------------------------------------------------------------------------------------

/**
 * Returns true to indicate that PerformanceNode is an {@link Entity}.
 * @type {Boolean}
 */
prototypeAccessors$b.isEntity.get = function () {
    return true;
};

/**
 * Always returns ````false```` because a PerformanceNode can never represent a model.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.isModel.get = function () {
    return false;
};

/**
 * Returns ````true```` if this PerformanceNode represents an object.
 *
 * When ````true```` the PerformanceNode will be registered by {@link PerformanceNode#id} in
 * {@link Scene#objects} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.isObject.get = function () {
    return this._isObject;
};

/**
 * World-space 3D axis-aligned bounding box (AABB) of this PerformanceNode.
 *
 * Represented by a six-element Float64Array containing the min/max extents of the
 * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
 *
 * @type {Float64Array}
 */
prototypeAccessors$b.aabb.get = function () {
    return this._offsetAABB;
};

/**
 * The approximate number of triangles in this PerformanceNode.
 *
 * @type {Number}
 */
prototypeAccessors$b.numTriangles.get = function () {
    return this._numTriangles;
};

/**
 * Sets if this PerformanceNode is visible.
 *
 * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#visible} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#visibleObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.visible.set = function (visible) {
    if (!!(this._flags & ENTITY_FLAGS.VISIBLE) === visible) {
        return; // Redundant update
    }
    if (visible) {
        this._flags = this._flags | ENTITY_FLAGS.VISIBLE;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.VISIBLE;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setVisible(this._flags);
    }
    if (this._isObject) {
        this.model.scene._objectVisibilityUpdated(this);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode is visible.
 *
 * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#visible} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#visibleObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.visible.get = function () {
    return this._getFlag(ENTITY_FLAGS.VISIBLE);
};

PerformanceNode.prototype._getFlag = function _getFlag (flag) {
    return !!(this._flags & flag);
};

/**
 * Sets if this PerformanceNode is highlighted.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#highlighted} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#highlightedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.highlighted.set = function (highlighted) {
    if (!!(this._flags & ENTITY_FLAGS.HIGHLIGHTED) === highlighted) {
        return; // Redundant update
    }
    if (highlighted) {
        this._flags = this._flags | ENTITY_FLAGS.HIGHLIGHTED;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.HIGHLIGHTED;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setHighlighted(this._flags);
    }
    if (this._isObject) {
        this.model.scene._objectHighlightedUpdated(this);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode is highlighted.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#highlighted} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#highlightedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.highlighted.get = function () {
    return this._getFlag(ENTITY_FLAGS.HIGHLIGHTED);
};

/**
 * Sets if this PerformanceNode is xrayed.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#xrayed} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#xrayedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.xrayed.set = function (xrayed) {
    if (!!(this._flags & ENTITY_FLAGS.XRAYED) === xrayed) {
        return; // Redundant update
    }
    if (xrayed) {
        this._flags = this._flags | ENTITY_FLAGS.XRAYED;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.XRAYED;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setXRayed(this._flags);
    }
    if (this._isObject) {
        this.model.scene._objectXRayedUpdated(this);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode is xrayed.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#xrayed} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#xrayedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.xrayed.get = function () {
    return this._getFlag(ENTITY_FLAGS.XRAYED);
};

/**
 * Gets if this PerformanceNode is selected.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#selected} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#selectedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.selected.set = function (selected) {
    if (!!(this._flags & ENTITY_FLAGS.SELECTED) === selected) {
        return; // Redundant update
    }
    if (selected) {
        this._flags = this._flags | ENTITY_FLAGS.SELECTED;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.SELECTED;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setSelected(this._flags);
    }
    if (this._isObject) {
        this.model.scene._objectSelectedUpdated(this);
    }
    this.model.glRedraw();
};

/**
 * Sets if this PerformanceNode is selected.
 *
 * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#selected} are ````true```` the PerformanceNode will be
 * registered by {@link PerformanceNode#id} in {@link Scene#selectedObjects}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.selected.get = function () {
    return this._getFlag(ENTITY_FLAGS.SELECTED);
};

/**
 * Sets if this PerformanceNode's edges are enhanced.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.edges.set = function (edges) {
    if (!!(this._flags & ENTITY_FLAGS.EDGES) === edges) {
        return; // Redundant update
    }
    if (edges) {
        this._flags = this._flags | ENTITY_FLAGS.EDGES;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.EDGES;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setEdges(this._flags);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode's edges are enhanced.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.edges.get = function () {
    return this._getFlag(ENTITY_FLAGS.EDGES);
};

/**
 * Sets if this PerformanceNode is culled.
 *
 * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.culled.set = function (culled) {
    if (!!(this._flags & ENTITY_FLAGS.CULLED) === culled) {
        return; // Redundant update
    }
    if (culled) {
        this._flags = this._flags | ENTITY_FLAGS.CULLED;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.CULLED;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setCulled(this._flags);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode is culled.
 *
 * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.culled.get = function () {
    return this._getFlag(ENTITY_FLAGS.CULLED);
};

/**
 * Sets if this PerformanceNode is clippable.
 *
 * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.clippable.set = function (clippable) {
    if ((!!(this._flags & ENTITY_FLAGS.CLIPPABLE)) === clippable) {
        return; // Redundant update
    }
    if (clippable) {
        this._flags = this._flags | ENTITY_FLAGS.CLIPPABLE;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.CLIPPABLE;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setClippable(this._flags);
    }
    this.model.glRedraw();
};

/**
 * Gets if this PerformanceNode is clippable.
 *
 * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.clippable.get = function () {
    return this._getFlag(ENTITY_FLAGS.CLIPPABLE);
};

/**
 * Sets if this PerformanceNode is included in boundary calculations.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.collidable.set = function (collidable) {
    if (!!(this._flags & ENTITY_FLAGS.COLLIDABLE) === collidable) {
        return; // Redundant update
    }
    if (collidable) {
        this._flags = this._flags | ENTITY_FLAGS.COLLIDABLE;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.COLLIDABLE;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setCollidable(this._flags);
    }
};

/**
 * Gets if this PerformanceNode is included in boundary calculations.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.collidable.get = function () {
    return this._getFlag(ENTITY_FLAGS.COLLIDABLE);
};

/**
 * Sets if this PerformanceNode is pickable.
 *
 * Picking is done via calls to {@link Scene#pick}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.pickable.set = function (pickable) {
    if (!!(this._flags & ENTITY_FLAGS.PICKABLE) === pickable) {
        return; // Redundant update
    }
    if (pickable) {
        this._flags = this._flags | ENTITY_FLAGS.PICKABLE;
    } else {
        this._flags = this._flags & ~ENTITY_FLAGS.PICKABLE;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setPickable(this._flags);
    }
};

/**
 * Gets if this PerformanceNode is pickable.
 *
 * Picking is done via calls to {@link Scene#pick}.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.pickable.get = function () {
    return this._getFlag(ENTITY_FLAGS.PICKABLE);
};

/**
 * Sets the PerformanceNode's RGB colorize color.
 *
 * Each element of the color is in range ````[0..1]````.
 *
 * @type {Number[]}
 */
prototypeAccessors$b.colorize.set = function (color) { // [0..1, 0..1, 0..1]
    if (color) {
        tempIntRGB[0] = Math.floor(color[0] * 255.0); // Quantize
        tempIntRGB[1] = Math.floor(color[1] * 255.0);
        tempIntRGB[2] = Math.floor(color[2] * 255.0);
        for (var i = 0, len = this.meshes.length; i < len; i++) {
            this.meshes[i]._setColorize(tempIntRGB);
        }
    } else {
        for (var i$1 = 0, len$1 = this.meshes.length; i$1 < len$1; i$1++) {
            this.meshes[i$1]._setColorize(null);
        }
    }
    if (this._isObject) {
        var colorized = (!!color);
        this.scene._objectColorizeUpdated(this, colorized);
    }
    this.model.glRedraw();
};

/**
 * Gets the PerformanceNode's RGB colorize color.
 *
 * Each element of the color is in range ````[0..1]````.
 *
 * @type {Number[]}
 */
prototypeAccessors$b.colorize.get = function () { // [0..1, 0..1, 0..1]
    if (this.meshes.length === 0) {
        return null;
    }
    var colorize = this.meshes[0]._colorize;
    tempFloatRGB[0] = colorize[0] / 255.0; // Unquantize
    tempFloatRGB[1] = colorize[1] / 255.0;
    tempFloatRGB[2] = colorize[2] / 255.0;
    return tempFloatRGB;
};

/**
 * Sets the PerformanceNode's opacity factor, multiplies by the PerformanceNode's rendered fragment alphas.
 *
 * This is a factor in range ````[0..1]````.
 *
 * @type {Number}
 */
prototypeAccessors$b.opacity.set = function (opacity) {
    if (this.meshes.length === 0) {
        return;
    }
    var opacityUpdated = (opacity !== null && opacity !== undefined);
    var lastOpacityQuantized = this.meshes[0]._colorize[3];
    var opacityQuantized = 255;
    if (opacityUpdated) {
        if (opacity < 0) {
            opacity = 0;
        } else if (opacity > 1) {
            opacity = 1;
        }
        opacityQuantized = Math.floor(opacity * 255.0); // Quantize
        if (lastOpacityQuantized === opacityQuantized) {
            return;
        }
    } else {
        opacityQuantized = 255.0;
        if (lastOpacityQuantized === opacityQuantized) {
            return;
        }
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setOpacity(opacityQuantized, this._flags);
    }
    if (this._isObject) {
        this.scene._objectOpacityUpdated(this, opacityUpdated);
    }
    this.model.glRedraw();
};

/**
 * Gets the PerformanceNode's opacity factor.
 *
 * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
 *
 * @type {Number}
 */
prototypeAccessors$b.opacity.get = function () {
    if (this.meshes.length > 0) {
        return (this.meshes[0]._colorize[3] / 255.0);
    } else {
        return 1.0;
    }
};

/**
 * Sets the PerformanceNode's 3D World-space offset.
 *
 * The offset dynamically translates the PerformanceNode in World-space.
 *
 * Default value is ````[0, 0, 0]````.
 *
 * Provide a null or undefined value to reset to the default value.
 *
 * @type {Number[]}
 */
prototypeAccessors$b.offset.set = function (offset) {
    if (offset) {
        this._offset[0] = offset[0];
        this._offset[1] = offset[1];
        this._offset[2] = offset[2];
    } else {
        this._offset[0] = 0;
        this._offset[1] = 0;
        this._offset[2] = 0;
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._setOffset(this._offset);
    }
    this._offsetAABB[0] = this._aabb[0] + this._offset[0];
    this._offsetAABB[1] = this._aabb[1] + this._offset[1];
    this._offsetAABB[2] = this._aabb[2] + this._offset[2];
    this._offsetAABB[3] = this._aabb[3] + this._offset[0];
    this._offsetAABB[4] = this._aabb[4] + this._offset[1];
    this._offsetAABB[5] = this._aabb[5] + this._offset[2];
    this.scene._aabbDirty = true;
    this.scene._objectOffsetUpdated(this, offset);
    this.model._aabbDirty = true;
    this.model.glRedraw();
};

/**
 * Gets the PerformanceNode's 3D World-space offset.
 *
 * Default value is ````[0,0,0]````.
 *
 * @type {Number[]}
 */
prototypeAccessors$b.offset.get = function () {
    return this._offset;
};

/**
 * Sets if to this PerformanceNode casts shadows.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.castsShadow.set = function (pickable) { // TODO

};

/**
 * Gets if this PerformanceNode casts shadows.
 *
 * @type {Boolean}
 */
prototypeAccessors$b.castsShadow.get = function () { // TODO
    return false;
};

/**
 * Whether or not this PerformanceNode can have shadows cast upon it
 *
 * @type {Boolean}
 */
prototypeAccessors$b.receivesShadow.set = function (pickable) { // TODO

};

/**
 * Whether or not this PerformanceNode can have shadows cast upon it
 *
 * @type {Boolean}
 */
prototypeAccessors$b.receivesShadow.get = function () { // TODO
    return false;
};

/**
 * Gets if Scalable Ambient Obscurance (SAO) will apply to this PerformanceNode.
 *
 * SAO is configured by the Scene's {@link SAO} component.
 *
 * @type {Boolean}
 * @abstract
 */
prototypeAccessors$b.saoEnabled.get = function () {
    return this.model.saoEnabled;
};

PerformanceNode.prototype._finalize = function _finalize () {
    var scene = this.model.scene;
    if (this._isObject) {
        if (this.visible) {
            scene._objectVisibilityUpdated(this);
        }
        if (this.highlighted) {
            scene._objectHighlightedUpdated(this);
        }
        if (this.xrayed) {
            scene._objectXRayedUpdated(this);
        }
        if (this.selected) {
            scene._objectSelectedUpdated(this);
        }
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._finalize(this._flags);
    }
};

PerformanceNode.prototype._destroy = function _destroy () { // Called by PerformanceModel
    var scene = this.model.scene;
    if (this._isObject) {
        scene._deregisterObject(this);
        if (this.visible) {
            scene._objectVisibilityUpdated(this, false);
        }
        if (this.xrayed) {
            scene._objectXRayedUpdated(this);
        }
        if (this.selected) {
            scene._objectSelectedUpdated(this);
        }
        if (this.highlighted) {
            scene._objectHighlightedUpdated(this);
        }
        this.scene._objectColorizeUpdated(this, false);
        this.scene._objectOpacityUpdated(this, false);
        this.scene._objectOffsetUpdated(this, false);
    }
    for (var i = 0, len = this.meshes.length; i < len; i++) {
        this.meshes[i]._destroy();
    }
    scene._aabbDirty = true;
};

Object.defineProperties( PerformanceNode.prototype, prototypeAccessors$b );

var tempVec3a$$ = math.vec3();

/**
 * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix
 * to transform RTC coordinates to View-space.
 *
 * The returned view matrix is
 *
 * @private
 */
var createRTCViewMat = (function () {

    var tempMat = new Float32Array(16);
    var rtcCenterWorld = new Float64Array(4);
    var rtcCenterView = new Float64Array(4);

    return function (viewMat, rtcCenter, rtcViewMat) {
        if ( rtcViewMat === void 0 ) rtcViewMat = tempMat;

        rtcCenterWorld[0] = rtcCenter[0];
        rtcCenterWorld[1] = rtcCenter[1];
        rtcCenterWorld[2] = rtcCenter[2];
        rtcCenterWorld[3] = 1;
        math.transformVec4(viewMat, rtcCenterWorld, rtcCenterView);
        math.setMat4Translation(viewMat, rtcCenterView, rtcViewMat);
        return rtcViewMat;
    }
}());

/**
 * Converts a World-space 3D position to RTC.
 *
 * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos
 * and a single-precision offset fom that center.
 * @private
 * @param {Float64Array} worldPos The World-space position.
 * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param {Float32Array} rtcPos Single-precision offset fom that center.
 */
function worldToRTCPos(worldPos, rtcCenter, rtcPos) {

    var xHigh = Float32Array.from([worldPos[0]])[0];
    var xLow = worldPos[0] - xHigh;

    var yHigh = Float32Array.from([worldPos[1]])[0];
    var yLow = worldPos[1] - yHigh;

    var zHigh = Float32Array.from([worldPos[2]])[0];
    var zLow = worldPos[2] - zHigh;

    rtcCenter[0] = xHigh;
    rtcCenter[1] = yHigh;
    rtcCenter[2] = zHigh;

    rtcPos[0] = xLow;
    rtcPos[1] = yLow;
    rtcPos[2] = zLow;
}


/**
 * Converts a flat array of double-precision positions to RTC positions.
 *
 * Returns the RTC positions, along with a computed RTC center for those positions.
 *
 * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,
 * identical RTC positions are reused for different positions arrays.
 *
 * @private
 * @param {Float64Array} worldPositions Flat array of World-space 3D positions.
 * @param {Float64Array} rtcPositions Outputs the computed flat array of 3D RTC positions.
 * @param {Float64Array} rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.
 * @param {Number} [cellSize=10000000] The size of each coordinate cell within the RTC coordinate system.
 * @returns {Boolean} ````True```` if the positions actually needed conversion to RTC, else ````false````. When
 * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,
 * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.
 */
function worldToRTCPositions(worldPositions, rtcPositions, rtcCenter, cellSize) {
    if ( cellSize === void 0 ) cellSize = 10000000;


    var center = math.getPositionsCenter(worldPositions, tempVec3a$$);

    var rtcCenterX = Math.round(center[0] / cellSize) * cellSize;
    var rtcCenterY = Math.round(center[1] / cellSize) * cellSize;
    var rtcCenterZ = Math.round(center[2] / cellSize) * cellSize;

    for (var i = 0, len = worldPositions.length; i < len; i += 3) {
        rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;
        rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;
        rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;
    }

    rtcCenter[0] = rtcCenterX;
    rtcCenter[1] = rtcCenterY;
    rtcCenter[2] = rtcCenterZ;

    var rtcNeeded = (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0);

    return rtcNeeded;
}

/**
 * Given a 3D plane defined by distance from origin and direction, and an RTC center position,
 * return a plane position that is relative to the RTC center.
 *
 * @private
 * @param dist
 * @param dir
 * @param rtcCenter
 * @param rtcPlanePos
 * @returns {*}
 */
function getPlaneRTCPos(dist, dir, rtcCenter, rtcPlanePos) {
    var rtcCenterToPlaneDist = math.dotVec3(dir, rtcCenter) + dist;
    var dirNormalized = math.normalizeVec3(dir, tempVec3a$$);
    math.mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);
    return rtcPlanePos;
}

var tempVec4a$8 = math.vec4();
var tempVec4b$8 = math.vec4();


/**
 * @desc Tracks the World, View and Canvas coordinates, and visibility, of a position within a {@link Scene}.
 *
 * ## Position
 *
 * A Marker holds its position in the World, View and Canvas coordinate systems in three properties:
 *
 * * {@link Marker#worldPos} holds the Marker's 3D World-space coordinates. This property can be dynamically updated. The Marker will fire a "worldPos" event whenever this property changes.
 * * {@link Marker#viewPos} holds the Marker's 3D View-space coordinates. This property is read-only, and is automatically updated from {@link Marker#worldPos} and the current {@link Camera} position. The Marker will fire a "viewPos" event whenever this property changes.
 * * {@link Marker#canvasPos} holds the Marker's 2D Canvas-space coordinates. This property is read-only, and is automatically updated from {@link Marker#canvasPos} and the current {@link Camera} position and projection. The Marker will fire a "canvasPos" event whenever this property changes.
 *
 * ## Visibility
 *
 * {@link Marker#visible} indicates if the Marker is currently visible. The Marker will fire a "visible" event whenever {@link Marker#visible} changes.
 *
 * This property will be ````false```` when:
 *
 * * {@link Marker#entity} is set to an {@link Entity}, and {@link Entity#visible} is ````false````,
 * * {@link Marker#occludable} is ````true```` and the Marker is occluded by some {@link Entity} in the 3D view, or
 * * {@link Marker#canvasPos} is outside the boundary of the {@link Canvas}.
 *
 * ## Usage
 *
 * In the example below, we'll create a Marker that's associated with a {@link Mesh} (which a type of {@link Entity}).
 *
 * We'll configure our Marker to
 * become invisible whenever it's occluded by any Entities in the canvas.
 *
 * We'll also demonstrate how to query the Marker's visibility status and position (in the World, View and
 * Canvas coordinate systems), and how to subscribe to change events on those properties.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#Markers_SimpleExample)]
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin, Marker} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Create the torus Mesh
 * // Recall that a Mesh is an Entity
 * new Mesh(viewer.scene, {
 *     geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *         center: [0,0,0],
 *         radius: 1.0,
 *         tube: 0.5,
 *         radialSegments: 32,
 *         tubeSegments: 24,
 *         arc: Math.PI * 2.0
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         }),
 *         backfaces: true
 *     })
 * });
 *
 * // Create the Marker, associated with our Mesh Entity
 * const myMarker = new Marker({
 *      entity: entity,
 *      worldPos: [10,0,0],
 *      occludable: true
 * });
 *
 * // Get the Marker's current World, View and Canvas coordinates
 * const worldPos   = myMarker.worldPos;     // 3D World-space position
 * const viewPos    = myMarker.viewPos;      // 3D View-space position
 * const canvasPos  = myMarker.canvasPos;    // 2D Canvas-space position
 *
 * const visible = myMarker.visible;
 *
 * // Listen for change of the Marker's 3D World-space position
 * myMarker.on("worldPos", function(worldPos) {
 *    //...
 * });
 *
 * // Listen for change of the Marker's 3D View-space position, which happens
 * // when either worldPos was updated or the Camera was moved
 * myMarker.on("viewPos", function(viewPos) {
 *    //...
 * });
 *
 * // Listen for change of the Marker's 2D Canvas-space position, which happens
 * // when worldPos or viewPos was updated, or Camera's projection was updated
 * myMarker.on("canvasPos", function(canvasPos) {
 *    //...
 * });
 *
 * // Listen for change of Marker visibility. The Marker becomes invisible when it falls outside the canvas,
 * // has an Entity that is also invisible, or when an Entity occludes the Marker's position in the 3D view.
 * myMarker.on("visible", function(visible) { // Marker visibility has changed
 *    if (visible) {
 *        this.log("Marker is visible");
 *    } else {
 *        this.log("Marker is invisible");
 *    }
 * });
 *
 * // Listen for destruction of Marker
 * myMarker.on("destroyed", () => {
 *      //...
 * });
 * ````
 */
var Marker = /*@__PURE__*/(function (Component) {
    function Marker(owner, cfg) {
        var this$1 = this;


        Component.call(this, owner, cfg);

        this._entity = null;
        this._visible = null;
        this._worldPos = math.vec3();
        this._rtcCenter = math.vec3();
        this._rtcPos = math.vec3();
        this._viewPos = math.vec3();
        this._canvasPos = math.vec2();
        this._occludable = false;

        this._onCameraViewMatrix = this.scene.camera.on("matrix", function () {
            this$1._viewPosDirty = true;
            this$1._needUpdate();
        });

        this._onCameraProjMatrix = this.scene.camera.on("projMatrix", function () {
            this$1._canvasPosDirty = true;
            this$1._needUpdate();
        });

        this._onEntityDestroyed = null;
        this._onEntityModelDestroyed = null;

        this._renderer.addMarker(this);

        this.entity = cfg.entity;
        this.worldPos = cfg.worldPos;
        this.occludable = cfg.occludable;
    }

    if ( Component ) Marker.__proto__ = Component;
    Marker.prototype = Object.create( Component && Component.prototype );
    Marker.prototype.constructor = Marker;

    var prototypeAccessors = { entity: { configurable: true },occludable: { configurable: true },worldPos: { configurable: true },rtcCenter: { configurable: true },rtcPos: { configurable: true },viewPos: { configurable: true },canvasPos: { configurable: true },visible: { configurable: true } };

    Marker.prototype._update = function _update () { // this._needUpdate() schedules this for next tick
        if (this._viewPosDirty) {
            math.transformPoint3(this.scene.camera.viewMatrix, this._worldPos, this._viewPos);
            this._viewPosDirty = false;
            this._canvasPosDirty = true;
            this.fire("viewPos", this._viewPos);
        }
        if (this._canvasPosDirty) {
            tempVec4a$8.set(this._viewPos);
            tempVec4a$8[3] = 1.0;
            math.transformPoint4(this.scene.camera.projMatrix, tempVec4a$8, tempVec4b$8);
            var aabb = this.scene.canvas.boundary;
            this._canvasPos[0] = Math.floor((1 + tempVec4b$8[0] / tempVec4b$8[3]) * aabb[2] / 2);
            this._canvasPos[1] = Math.floor((1 - tempVec4b$8[1] / tempVec4b$8[3]) * aabb[3] / 2);
            this._canvasPosDirty = false;
            this.fire("canvasPos", this._canvasPos);
        }
    };

    Marker.prototype._setVisible = function _setVisible (visible) { // Called by VisibilityTester and this._entity.on("destroyed"..)
        if (this._visible === visible) ;
        this._visible = visible;
        this.fire("visible", this._visible);
    };

    /**
     * Sets the {@link Entity} this Marker is associated with.
     *
     * An Entity is optional. When the Marker has an Entity, then {@link Marker#visible} will always be ````false````
     * if {@link Entity#visible} is false.
     *
     * @type {Entity}
     */
    prototypeAccessors.entity.set = function (entity) {
        var this$1 = this;

        if (this._entity) {
            if (this._entity === entity) {
                return;
            }
            if (this._onEntityDestroyed !== null) {
                this._entity.off(this._onEntityDestroyed);
                this._onEntityDestroyed = null;
            }
            if (this._onEntityModelDestroyed !== null) {
                this._entity.model.off(this._onEntityModelDestroyed);
                this._onEntityModelDestroyed = null;
            }
        }
        this._entity = entity;
        if (this._entity) {
            if (this._entity instanceof PerformanceNode) {
                this._onEntityModelDestroyed = this._entity.model.on("destroyed", function () { // PerformanceNode does not fire events, and cannot exist beyond its PerformanceModel
                    this$1._entity = null; // Marker now may become visible, if it was synched to invisible Entity
                    this$1._onEntityModelDestroyed = null;
                });
            } else {
                this._onEntityDestroyed = this._entity.on("destroyed", function () {
                    this$1._entity = null;
                    this$1._onEntityDestroyed = null;
                });
            }
        }
        this.fire("entity", this._entity, true /* forget */);
    };

    /**
     * Gets the {@link Entity} this Marker is associated with.
     *
     * @type {Entity}
     */
    prototypeAccessors.entity.get = function () {
        return this._entity;
    };

    /**
     * Sets whether occlusion testing is performed for this Marker.
     *
     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.
     *
     * The {@link Scene} periodically occlusion-tests all Markers on every 20th "tick" (which represents a rendered frame). We
     * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.occludable.set = function (occludable) {
        occludable = !!occludable;
        if (occludable === this._occludable) {
            return;
        }
        this._occludable = occludable;
    };

    /**
     * Gets whether occlusion testing is performed for this Marker.
     *
     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.
     *
     * @type {Boolean}
     */
    prototypeAccessors.occludable.get = function () {
        return this._occludable;
    };

    /**
     * Sets the World-space 3D position of this Marker.
     *
     * Fires a "worldPos" event with new World position.
     *
     * @type {Number[]}
     */
    prototypeAccessors.worldPos.set = function (worldPos) {
        this._worldPos.set(worldPos || [0, 0, 0]);
        worldToRTCPos(this._worldPos, this._rtcCenter, this._rtcPos);
        if (this._occludable) {
            this._renderer.markerWorldPosUpdated(this);
        }
        this._viewPosDirty = true;
        this.fire("worldPos", this._worldPos);
    };

    /**
     * Gets the World-space 3D position of this Marker.
     *
     * @type {Number[]}
     */
    prototypeAccessors.worldPos.get = function () {
        return this._worldPos;
    };

    /**
     * Gets the RTC center of this Marker.
     *
     * This is automatically calculated from {@link Marker#worldPos}.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rtcCenter.get = function () {
        return this._rtcCenter;
    };

    /**
     * Gets the RTC position of this Marker.
     *
     * This is automatically calculated from {@link Marker#worldPos}.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rtcPos.get = function () {
        return this._rtcPos;
    };

    /**
     * View-space 3D coordinates of this Marker.
     *
     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position.
     *
     * The Marker fires a "viewPos" event whenever this property changes.
     *
     * @type {Number[]}
     * @final
     */
    prototypeAccessors.viewPos.get = function () {
        this._update();
        return this._viewPos;
    };

    /**
     * Canvas-space 2D coordinates of this Marker.
     *
     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position and projection.
     *
     * The Marker fires a "canvasPos" event whenever this property changes.
     *
     * @type {Number[]}
     * @final
     */
    prototypeAccessors.canvasPos.get = function () {
        this._update();
        return this._canvasPos;
    };

    /**
     * Indicates if this Marker is currently visible.
     *
     * This is read-only and is automatically calculated.
     *
     * The Marker is **invisible** whenever:
     *
     * * {@link Marker#canvasPos} is currently outside the canvas,
     * * {@link Marker#entity} is set to an {@link Entity} that has {@link Entity#visible} ````false````, or
     * * or {@link Marker#occludable} is ````true```` and the Marker is currently occluded by an Entity in the 3D view.
     *
     * The Marker fires a "visible" event whenever this property changes.
     *
     * @type {Boolean}
     * @final
     */
    prototypeAccessors.visible.get = function () {
        return !!this._visible;
    };

    /**
     * Destroys this Marker.
     */
    Marker.prototype.destroy = function destroy () {
        this.fire("destroyed", true);
        this.scene.camera.off(this._onCameraViewMatrix);
        this.scene.camera.off(this._onCameraProjMatrix);
        if (this._entity) {
            if (this._onEntityDestroyed !== null) {
                this._entity.off(this._onEntityDestroyed);
            }
            if (this._onEntityModelDestroyed !== null) {
                this._entity.model.off(this._onEntityModelDestroyed);
            }
        }
        this._renderer.removeMarker(this);
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( Marker.prototype, prototypeAccessors );

    return Marker;
}(Component));

/** @private */
var Wire = function Wire(parentElement, cfg) {
    if ( cfg === void 0 ) cfg = {};


    this._wire = document.createElement('div');
    this._wire.className += this._wire.className ? ' viewer-ruler-wire' : 'viewer-ruler-wire';
    this._visible = true;

    var wire = this._wire;
    var style = wire.style;

    this._thickness = cfg.thickness || 1.0;

    style.border = "solid " + this._thickness + "px " + (cfg.color || "black");
    style.position = "absolute";
    style["z-index"] = "2000001";
    style.width = 0 + "px";
    style.height = 0 + "px";
    style.visibility = "visible";
    style.top = 0 + "px";
    style.left = 0 + "px";
    style["pointer-events"] = "none";
    style['-webkit-transform-origin'] = "0 0";
    style['-moz-transform-origin'] = "0 0";
    style['-ms-transform-origin'] = "0 0";
    style['-o-transform-origin'] = "0 0";
    style['transform-origin'] = "0 0";
    style['-webkit-transform'] = 'rotate(0deg)';
    style['-moz-transform'] = 'rotate(0deg)';
    style['-ms-transform'] = 'rotate(0deg)';
    style['-o-transform'] = 'rotate(0deg)';
    style['transform'] = 'rotate(0deg)';
    style["opacity"] = 1.0;

    parentElement.appendChild(wire);

    this._x1 = 0;
    this._y1 = 0;
    this._x2 = 0;
    this._y2 = 0;

    this._update();
};

Wire.prototype._update = function _update () {

    var length = Math.abs(Math.sqrt((this._x1 - this._x2) * (this._x1 - this._x2) + (this._y1 - this._y2) * (this._y1 - this._y2)));
    var angle = Math.atan2(this._y2 - this._y1, this._x2 - this._x1) * 180.0 / Math.PI;

    var style = this._wire.style;
    style["width"] = Math.round(length) + 'px';
    style["left"] = Math.round(this._x1) + 'px';
    style["top"] = Math.round(this._y1) + 'px';
    style['-webkit-transform'] = 'rotate(' + angle + 'deg)';
    style['-moz-transform'] = 'rotate(' + angle + 'deg)';
    style['-ms-transform'] = 'rotate(' + angle + 'deg)';
    style['-o-transform'] = 'rotate(' + angle + 'deg)';
    style['transform'] = 'rotate(' + angle + 'deg)';
    style["pointer-events"] = "none";
};

Wire.prototype.setStartAndEnd = function setStartAndEnd (x1, y1, x2, y2) {
    this._x1 = x1;
    this._y1 = y1;
    this._x2 = x2;
    this._y2 = y2;
    this._update();
};

Wire.prototype.setColor = function setColor (color) {
    this._wire.style.border = "solid " + this._thickness + "px " + (color || "black");
};

Wire.prototype.setOpacity = function setOpacity (opacity) {
    this._wire.style.opacity = opacity;
};

Wire.prototype.setVisible = function setVisible (visible) {
    visible = !!visible;
    if (this._visible === visible) {
        return;
    }
    this._visible = visible;
    this._wire.style.visibility = this._visible ? "visible" : "hidden";
};

Wire.prototype.destroy = function destroy (visible) {
    this._wire.parentElement.removeChild(this._wire);
};

/** @private */
var Dot = function Dot(parentElement, cfg) {
    if ( cfg === void 0 ) cfg = {};


    this._x = 0;
    this._y = 0;

    this._visible = true;
    this._dot = document.createElement('div');
    this._dot.className += this._dot.className ? ' viewer-ruler-dot' : 'viewer-ruler-dot';

    var dot = this._dot;
    var style = dot.style;

    style["border-radius"] = 25 + "px";
    style.border = "solid 2px white";
    style.background = "lightgreen";
    style.position = "absolute";
    style["z-index"] = "40000005";
    style.width = 8 + "px";
    style.height = 8 + "px";
    style.visibility = "visible";
    style.top = 0 + "px";
    style.left = 0 + "px";
    style["box-shadow"] = "0 2px 5px 0 #182A3D;";
    style["pointer-events"] = "none";
    style["opacity"] = 1.0;

    parentElement.appendChild(dot);

    this.setPos(cfg.x || 0, cfg.y || 0);
    this.setFillColor(cfg.fillColor);
    this.setBorderColor(cfg.borderColor);
    this.setClickable(false);
};

Dot.prototype.setPos = function setPos (x, y) {
    this._x = x;
    this._y = y;
    var style = this._dot.style;
    style["left"] = (Math.round(x) - 5) + 'px';
    style["top"] = (Math.round(y) - 5) + 'px';
};

Dot.prototype.setFillColor = function setFillColor (color) {
    this._dot.style.background = color || "lightgreen";
};

Dot.prototype.setBorderColor = function setBorderColor (color) {
    this._dot.style.border = "solid 2px" + (color || "black");
};

Dot.prototype.setOpacity = function setOpacity (opacity) {
    this._dot.style.opacity = opacity;
};

Dot.prototype.setVisible = function setVisible (visible) {
    if (this._visible === visible) {
        return;
    }
    this._visible = !!visible;
    this._dot.style.visibility = this._visible ? "visible" : "hidden";
};

Dot.prototype.setClickable = function setClickable (clickable) {
    this._dot.style["pointer-events"] = (!!clickable) ? "all" : "none";
};

Dot.prototype.destroy = function destroy () {
    this.setVisible(false);
    this._dot.parentElement.removeChild(this._dot);
};

/** @private */
var Label = function Label(parentElement, cfg) {
    if ( cfg === void 0 ) cfg = {};


    this._prefix = cfg.prefix || "";
    this._x = 0;
    this._y = 0;
    this._visible = true;

    this._label = document.createElement('div');
    this._label.className += this._label.className ? ' viewer-ruler-label' : 'viewer-ruler-label';

    var label = this._label;
    var style = label.style;

    style["border-radius"] = 5 + "px";
    style.color = "white";
    style.padding = "4px";
    style.border = "solid 0px white";
    style.background = "lightgreen";
    style.position = "absolute";
    style["z-index"] = "5000005";
    style.width = "auto";
    style.height = "auto";
    style.visibility = "visible";
    style.top = 0 + "px";
    style.left = 0 + "px";
    style["pointer-events"] = "none";
    style["opacity"] = 1.0;
    label.innerText = "";

    parentElement.appendChild(label);

    this.setPos(cfg.x || 0, cfg.y || 0);
    this.setFillColor(cfg.fillColor);
    this.setBorderColor(cfg.borderColor);
    this.setText(cfg.text);
};

Label.prototype.setPos = function setPos (x, y) {
    this._x = x;
    this._y = y;
    var style = this._label.style;
    style["left"] = (Math.round(x) - 20) + 'px';
    style["top"] = (Math.round(y) - 12) + 'px';
};

Label.prototype.setPosOnWire = function setPosOnWire (x1, y1, x2, y2) {
    var x = x1 + ((x2 - x1) * 0.5);
    var y = y1 + ((y2 - y1) * 0.5);
    var style = this._label.style;
    style["left"] = (Math.round(x) - 20) + 'px';
    style["top"] = (Math.round(y) - 12) + 'px';
};

Label.prototype.setPosBetweenWires = function setPosBetweenWires (x1, y1, x2, y2, x3, y3) {
    var x = (x1 + x2 + x3) / 3;
    var y = (y1 + y2 + y3) / 3;
    var style = this._label.style;
    style["left"] = (Math.round(x) - 20) + 'px';
    style["top"] = (Math.round(y) - 12) + 'px';
};

Label.prototype.setText = function setText (text) {
    this._label.innerHTML = this._prefix + (text || "");
};

Label.prototype.setFillColor = function setFillColor (color) {
    this._label.style.background = color || "lightgreen";
};

Label.prototype.setBorderColor = function setBorderColor (color) {
    this._label.style.border = "solid 2px" + (color || "black");
};

Label.prototype.setOpacity = function setOpacity (opacity) {
    this._label.style.opacity = opacity;
};

Label.prototype.setVisible = function setVisible (visible) {
    if (this._visible === visible) {
        return;
    }
    this._visible = !!visible;
    this._label.style.visibility = this._visible ? "visible" : "hidden";
};

Label.prototype.destroy = function destroy () {
    this._label.parentElement.removeChild(this._label);
};

var originVec = math.vec3();
var targetVec = math.vec3();

/**
 * @desc Measures the angle indicated by three 3D points.
 *
 * See {@link AngleMeasurementsPlugin} for more info.
 */
var AngleMeasurement = /*@__PURE__*/(function (Component) {
    function AngleMeasurement(plugin, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, plugin.viewer.scene, cfg);

        /**
         * The {@link AngleMeasurementsPlugin} that owns this AngleMeasurement.
         * @type {AngleMeasurementsPlugin}
         */
        this.plugin = plugin;

        this._container = cfg.container;
        if (!this._container) {
            throw "config missing: container";
        }

        var scene = this.plugin.viewer.scene;

        this._originMarker = new Marker(scene, cfg.origin);
        this._cornerMarker = new Marker(scene, cfg.corner);
        this._targetMarker = new Marker(scene, cfg.target);

        this._originWorld = math.vec3();
        this._cornerWorld = math.vec3();
        this._targetWorld = math.vec3();

        this._wp = new Float64Array(12);
        this._vp = new Float64Array(12);
        this._pp = new Float64Array(12);
        this._cp = new Int16Array(6);

        this._originDot = new Dot(this._container, {});
        this._cornerDot = new Dot(this._container, {});
        this._targetDot = new Dot(this._container, {});

        this._originWire = new Wire(this._container, {color: "blue", thickness: 1});
        this._targetWire = new Wire(this._container, {color: "red", thickness: 1});

        this._angleLabel = new Label(this._container, {fillColor: "#00BBFF", prefix: "", text: ""});

        this._wpDirty = false;
        this._vpDirty = false;
        this._cpDirty = false;

        this._visible = false;
        this._originVisible = false;
        this._cornerVisible = false;
        this._targetVisible = false;

        this._originWireVisible = false;
        this._targetWireVisible = false;

        this._angleVisible = false;

        this._originMarker.on("worldPos", function (value) {
            this$1._originWorld.set(value || [0, 0, 0]);
            this$1._wpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._cornerMarker.on("worldPos", function (value) {
            this$1._cornerWorld.set(value || [0, 0, 0]);
            this$1._wpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._targetMarker.on("worldPos", function (value) {
            this$1._targetWorld.set(value || [0, 0, 0]);
            this$1._wpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._onViewMatrix = scene.camera.on("viewMatrix", function () {
            this$1._vpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._onProjMatrix = scene.camera.on("projMatrix", function () {
            this$1._cpDirty = true;
            this$1._needUpdate();
        });

        this._onCanvasBoundary = scene.canvas.on("boundary", function () {
            this$1._cpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this.approximate = cfg.approximate;
        this.visible = cfg.visible;

        this.originVisible = cfg.originVisible;
        this.cornerVisible = cfg.cornerVisible;
        this.targetVisible = cfg.targetVisible;

        this.originWireVisible = cfg.originWireVisible;
        this.targetWireVisible = cfg.targetWireVisible;

        this.angleVisible = cfg.angleVisible;
    }

    if ( Component ) AngleMeasurement.__proto__ = Component;
    AngleMeasurement.prototype = Object.create( Component && Component.prototype );
    AngleMeasurement.prototype.constructor = AngleMeasurement;

    var prototypeAccessors = { approximate: { configurable: true },origin: { configurable: true },corner: { configurable: true },target: { configurable: true },angle: { configurable: true },visible: { configurable: true },originVisible: { configurable: true },cornerVisible: { configurable: true },targetVisible: { configurable: true },originWireVisible: { configurable: true },targetWireVisible: { configurable: true },angleVisible: { configurable: true } };

    AngleMeasurement.prototype._update = function _update () {

        if (!this._visible) {
            return;
        }

        var scene = this.plugin.viewer.scene;

        if (this._wpDirty) {

            this._wp[0] = this._originWorld[0];
            this._wp[1] = this._originWorld[1];
            this._wp[2] = this._originWorld[2];
            this._wp[3] = 1.0;

            this._wp[4] = this._cornerWorld[0];
            this._wp[5] = this._cornerWorld[1];
            this._wp[6] = this._cornerWorld[2];
            this._wp[7] = 1.0;

            this._wp[8] = this._targetWorld[0];
            this._wp[9] = this._targetWorld[1];
            this._wp[10] = this._targetWorld[2];
            this._wp[11] = 1.0;

            this._wpDirty = false;
            this._vpDirty = true;
        }

        if (this._vpDirty) {

            math.transformPositions4(scene.camera.viewMatrix, this._wp, this._vp);

            this._vp[3] = 1.0;
            this._vp[7] = 1.0;
            this._vp[11] = 1.0;

            this._vpDirty = false;
            this._cpDirty = true;
        }

        if (this._cpDirty) {

            var near = -0.3;
            var zOrigin = this._originMarker.viewPos[2];
            var zCorner = this._cornerMarker.viewPos[2];
            var zTarget = this._targetMarker.viewPos[2];

            if (zOrigin > near || zCorner > near || zTarget > near) {

                this._originDot.setVisible(false);
                this._cornerDot.setVisible(false);
                this._targetDot.setVisible(false);

                this._originWire.setVisible(false);
                this._targetWire.setVisible(false);

                this._angleLabel.setVisible(false);

                return;
            }

            math.transformPositions4(scene.camera.project.matrix, this._vp, this._pp);

            var pp = this._pp;
            var cp = this._cp;

            var canvas = scene.canvas.canvas;
            var offsets = canvas.getBoundingClientRect();
            var top = offsets.top;
            var left = offsets.left;
            var aabb = scene.canvas.boundary;
            var canvasWidth = aabb[2];
            var canvasHeight = aabb[3];
            var j = 0;

            for (var i = 0, len = pp.length; i < len; i += 4) {
                cp[j] = left + Math.floor((1 + pp[i + 0] / pp[i + 3]) * canvasWidth / 2);
                cp[j + 1] = top + Math.floor((1 - pp[i + 1] / pp[i + 3]) * canvasHeight / 2);
                j += 2;
            }

            this._originDot.setPos(cp[0], cp[1]);
            this._cornerDot.setPos(cp[2], cp[3]);
            this._targetDot.setPos(cp[4], cp[5]);

            this._originWire.setStartAndEnd(cp[0], cp[1], cp[2], cp[3]);
            this._targetWire.setStartAndEnd(cp[2], cp[3], cp[4], cp[5]);

            this._angleLabel.setPosBetweenWires(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);

            math.subVec3(this._originWorld, this._cornerWorld, originVec);
            math.subVec3(this._targetWorld, this._cornerWorld, targetVec);

            var validVecs =
                (originVec[0] !== 0 || originVec[1] !== 0 || originVec[2] !== 0) &&
                (targetVec[0] !== 0 || targetVec[1] !== 0 || targetVec[2] !== 0);

            if (validVecs) {

                var tilde = this._approximate ? " ~ " : " = ";

                math.normalizeVec3(originVec);
                math.normalizeVec3(targetVec);
                var angle = Math.abs(math.angleVec3(originVec, targetVec));
                this._angle = angle / math.DEGTORAD;
                this._angleLabel.setText(tilde + this._angle.toFixed(2) + "");
            } else {
                this._angleLabel.setText("");
            }

            // this._angleLabel.setText((Math.abs(math.lenVec3(math.subVec3(this._targetWorld, this._originWorld, distVec3)) * scale).toFixed(2)) + unitAbbrev);

            this._originDot.setVisible(this._visible && this._originVisible);
            this._cornerDot.setVisible(this._visible && this._cornerVisible);
            this._targetDot.setVisible(this._visible && this._targetVisible);

            this._originWire.setVisible(this._visible && this._originWireVisible);
            this._targetWire.setVisible(this._visible && this._targetWireVisible);

            this._angleLabel.setVisible(this._visible && this._angleVisible);

            this._cpDirty = false;
        }
    };

    /**
     * Sets whether this AngleMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */
    prototypeAccessors.approximate.set = function (approximate) {
        approximate = approximate !== false;
        if (this._approximate === approximate) {
            return;
        }
        this._approximate = approximate;
        this._cpDirty = true;
        this._needUpdate(0);
    };

    /**
     * Gets whether this AngleMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */
    prototypeAccessors.approximate.get = function () {
        return this._approximate;
    };

    /**
     * Gets the origin {@link Marker}.
     *
     * @type {Marker}
     */
    prototypeAccessors.origin.get = function () {
        return this._originMarker;
    };

    /**
     * Gets the corner {@link Marker}.
     *
     * @type {Marker}
     */
    prototypeAccessors.corner.get = function () {
        return this._cornerMarker;
    };

    /**
     * Gets the target {@link Marker}.
     *
     * @type {Marker}
     */
    prototypeAccessors.target.get = function () {
        return this._targetMarker;
    };

    /**
     * Gets the angle between two connected 3D line segments, given
     * as three positions on the surface(s) of one or more {@link Entity}s.
     *
     * @type {Number}
     */
    prototypeAccessors.angle.get = function () {
        this._update();
        return this._angle;
    };

    /**
     * Sets whether this AngleMeasurement is visible or not.
     *
     * @type Boolean
     */
    prototypeAccessors.visible.set = function (value) {
        value = value !== false;
        this._visible = value;
        this._originDot.setVisible(this._visible && this._originVisible);
        this._cornerDot.setVisible(this._visible && this._cornerVisible);
        this._targetDot.setVisible(this._visible && this._targetVisible);
        this._originWire.setVisible(this._visible && this._originWireVisible);
        this._targetWire.setVisible(this._visible && this._targetWireVisible);
        this._angleLabel.setVisible(this._visible && this._angleVisible);
    };

    /**
     * Gets whether this AngleMeasurement is visible or not.
     *
     * @type Boolean
     */
    prototypeAccessors.visible.get = function () {
        return this._visible;
    };

    /**
     * Sets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originVisible.set = function (value) {
        value = value !== false;
        this._originVisible = value;
        this._originDot.setVisible(this._visible && this._originVisible);
    };

    /**
     * Gets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originVisible.get = function () {
        return this._originVisible;
    };

    /**
     * Sets if the corner {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.cornerVisible.set = function (value) {
        value = value !== false;
        this._cornerVisible = value;
        this._cornerDot.setVisible(this._visible && this._cornerVisible);
    };

    /**
     * Gets if the corner {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.cornerVisible.get = function () {
        return this._cornerVisible;
    };

    /**
     * Sets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetVisible.set = function (value) {
        value = value !== false;
        this._targetVisible = value;
        this._targetDot.setVisible(this._visible && this._targetVisible);
    };

    /**
     * Gets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetVisible.get = function () {
        return this._targetVisible;
    };

    /**
     * Sets if the wire between the origin and the corner is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originWireVisible.set = function (value) {
        value = value !== false;
        this._originWireVisible = value;
        this._originWire.setVisible(this._visible && this._originWireVisible);
    };

    /**
     * Gets if the wire between the origin and the corner is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originWireVisible.get = function () {
        return this._originWireVisible;
    };

    /**
     * Sets if the wire between the target and the corner is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetWireVisible.set = function (value) {
        value = value !== false;
        this._targetWireVisible = value;
        this._targetWire.setVisible(this._visible && this._targetWireVisible);
    };

    /**
     * Gets if the wire between the target and the corner is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetWireVisible.get = function () {
        return this._targetWireVisible;
    };

    /**
     * Sets if the angle label is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.angleVisible.set = function (value) {
        value = value !== false;
        this._angleVisible = value;
        this._angleLabel.setVisible(this._visible && this._angleVisible);
    };

    /**
     * Gets if the angle label is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.angleVisible.get = function () {
        return this._angleVisible;
    };

    /**
     * @private
     */
    AngleMeasurement.prototype.destroy = function destroy () {

        var scene = this.plugin.viewer.scene;

        if (this._onViewMatrix) {
            scene.camera.off(this._onViewMatrix);
        }
        if (this._onProjMatrix) {
            scene.camera.off(this._onProjMatrix);
        }
        if (this._onCanvasBoundary) {
            scene.canvas.off(this._onCanvasBoundary);
        }

        this._originDot.destroy();
        this._cornerDot.destroy();
        this._targetDot.destroy();

        this._originWire.destroy();
        this._targetWire.destroy();

        this._angleLabel.destroy();

        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( AngleMeasurement.prototype, prototypeAccessors );

    return AngleMeasurement;
}(Component));

var HOVERING$1 = 0;
var FINDING_ORIGIN$1 = 1;
var FINDING_CORNER = 2;
var FINDING_TARGET$1 = 3;

/**
 * Creates {@link AngleMeasurement}s from mouse and touch input.
 *
 * Belongs to a {@link AngleMeasurementsPlugin}. Located at {@link AngleMeasurementsPlugin#control}.
 *
 * Once the AngleMeasurementControl is activated, the first click on any {@link Entity} begins constructing a {@link AngleMeasurement}, fixing its origin to that Entity. The next click on any Entity will complete the AngleMeasurement, fixing its target to that second Entity. The AngleMeasurementControl will then wait for the next click on any Entity, to begin constructing another AngleMeasurement, and so on, until deactivated.
 *
 * See {@link AngleMeasurementsPlugin} for more info.
 */
var AngleMeasurementsControl = /*@__PURE__*/(function (Component) {
    function AngleMeasurementsControl(plugin) {

        Component.call(this, plugin.viewer.scene);

        /**
         * The {@link AngleMeasurementsPlugin} that owns this AngleMeasurementsControl.
         * @type {AngleMeasurementsPlugin}
         */
        this.plugin = plugin;

        this._active = false;
        this._state = HOVERING$1;
        this._currentAngleMeasurement = null;
        this._previousAngleMeasurement = null;
        this._onhoverSurface = null;
        this._onHoverNothing = null;
    }

    if ( Component ) AngleMeasurementsControl.__proto__ = Component;
    AngleMeasurementsControl.prototype = Object.create( Component && Component.prototype );
    AngleMeasurementsControl.prototype.constructor = AngleMeasurementsControl;

    var prototypeAccessors = { active: { configurable: true } };

    /** Gets if this AngleMeasurementsControl is currently active, where it is responding to input.
     *
     * @returns {boolean}
     */
    prototypeAccessors.active.get = function () {
        return this._active;
    };

    /**
     * Activates this AngleMeasurementsControl, ready to respond to input.
     */
    AngleMeasurementsControl.prototype.activate = function activate () {
        var this$1 = this;


        if (this._active) {
            return;
        }

        var cameraControl = this.plugin.viewer.cameraControl;

        var over = false;
        var entity = null;
        var worldPos = math.vec3();
        var hoverCanvasPos = math.vec2();

        var pickSurfacePrecisionEnabled = this.plugin.viewer.scene.pickSurfacePrecisionEnabled;

        this._onhoverSurface = cameraControl.on("hoverSurface", function (e) {

            over = true;
            entity = e.entity;
            worldPos.set(e.worldPos);
            hoverCanvasPos.set(e.canvasPos);

            if (this$1._state === HOVERING$1) {
                document.body.style.cursor = "pointer";
                return;
            }

            if (this$1._currentAngleMeasurement) {
                switch (this$1._state) {
                    case FINDING_CORNER:
                        this$1._currentAngleMeasurement.originWireVisible = true;
                        this$1._currentAngleMeasurement.targetWireVisible = false;
                        this$1._currentAngleMeasurement.cornerVisible = true;
                        this$1._currentAngleMeasurement.angleVisible = false;
                        this$1._currentAngleMeasurement.corner.entity = e.entity;
                        this$1._currentAngleMeasurement.corner.worldPos = e.worldPos;
                        document.body.style.cursor = "pointer";
                        break;
                    case FINDING_TARGET$1:
                        this$1._currentAngleMeasurement.targetWireVisible = true;
                        this$1._currentAngleMeasurement.targetVisible = true;
                        this$1._currentAngleMeasurement.angleVisible = true;
                        this$1._currentAngleMeasurement.target.entity = e.entity;
                        this$1._currentAngleMeasurement.target.worldPos = e.worldPos;
                        document.body.style.cursor = "pointer";
                        break;
                }
            }
        });

        var lastX;
        var lastY;
        var tolerance = 5;

        this._onInputMouseDown = this.plugin.viewer.scene.input.on("mousedown", function (coords) {
            lastX = coords[0];
            lastY = coords[1];
        });

        this._onInputMouseUp = this.plugin.viewer.scene.input.on("mouseup", function (coords) {

            if (coords[0] > lastX + tolerance || coords[0] < lastX - tolerance || coords[1] > lastY + tolerance || coords[1] < lastY - tolerance) {
                return;
            }

            switch (this$1._state) {

                case HOVERING$1:
                    if (this$1._previousAngleMeasurement) {
                        this$1._previousAngleMeasurement.originVisible = true;
                        this$1._previousAngleMeasurement.cornerVisible = true;
                        this$1._previousAngleMeasurement.targetVisible = true;
                    }
                    if (over) {
                        if (pickSurfacePrecisionEnabled) {
                            var pickResult = this$1.plugin.viewer.scene.pick({
                                canvasPos: hoverCanvasPos,
                                pickSurface: true,
                                pickSurfacePrecision: true
                            });
                            if (pickResult && pickResult.worldPos) {
                                worldPos.set(pickResult.worldPos);
                            }
                        }
                        this$1._currentAngleMeasurement = this$1.plugin.createMeasurement({
                            id: math.createUUID(),
                            origin: {
                                entity: entity,
                                worldPos: worldPos
                            },
                            corner: {
                                entity: entity,
                                worldPos: worldPos
                            },
                            target: {
                                entity: entity,
                                worldPos: worldPos
                            },
                            approximate: true
                        });
                        this$1._currentAngleMeasurement.originVisible = true;
                        this$1._currentAngleMeasurement.originWireVisible = true;
                        this$1._currentAngleMeasurement.cornerVisible = false;
                        this$1._currentAngleMeasurement.targetWireVisible = false;
                        this$1._currentAngleMeasurement.targetVisible = false;
                        this$1._currentAngleMeasurement.angleVisible = false;
                        this$1._previousAngleMeasurement = this$1._currentAngleMeasurement;
                        this$1._state = FINDING_CORNER;
                    }
                    break;

                case FINDING_CORNER:
                    if (over) {
                        if (pickSurfacePrecisionEnabled) {
                            var pickResult$1 = this$1.plugin.viewer.scene.pick({
                                canvasPos: hoverCanvasPos,
                                pickSurface: true,
                                pickSurfacePrecision: true
                            });
                            if (pickResult$1 && pickResult$1.worldPos) {
                                this$1._currentAngleMeasurement.corner.worldPos = pickResult$1.worldPos;
                            }
                        }
                        this$1._currentAngleMeasurement.targetWireVisible = false;
                        this$1._currentAngleMeasurement.targetVisible = true;
                        this$1._currentAngleMeasurement.angleVisible = true;
                        this$1._state = FINDING_TARGET$1;
                    } else {
                        if (this$1._currentAngleMeasurement) {
                            this$1._currentAngleMeasurement.destroy();
                            this$1._currentAngleMeasurement = null;
                            this$1._previousAngleMeasurement = null;
                            this$1._state = HOVERING$1;
                        }
                    }
                    break;

                case FINDING_TARGET$1:
                    if (over) {
                        if (pickSurfacePrecisionEnabled) {
                            var pickResult$2 = this$1.plugin.viewer.scene.pick({
                                canvasPos: hoverCanvasPos,
                                pickSurface: true,
                                pickSurfacePrecision: true
                            });
                            if (pickResult$2 && pickResult$2.worldPos) {
                                this$1._currentAngleMeasurement.target.worldPos = pickResult$2.worldPos;
                                this$1._currentAngleMeasurement.approximate = false;
                            }
                        }
                        this$1._currentAngleMeasurement.targetVisible = true;
                        this$1._currentAngleMeasurement.angleVisible = true;
                        this$1._currentAngleMeasurement = null;
                        this$1._previousAngleMeasurement = null;
                        this$1._state = HOVERING$1;
                    } else {
                        if (this$1._currentAngleMeasurement) {
                            this$1._currentAngleMeasurement.destroy();
                            this$1._currentAngleMeasurement = null;
                            this$1._previousAngleMeasurement = null;
                            this$1._state = HOVERING$1;
                        }
                    }
                    break;
            }
        });

        this._onHoverNothing = cameraControl.on("hoverOff", function (e) {
            over = false;
            if (this$1._currentAngleMeasurement) {
                switch (this$1._state) {
                    case HOVERING$1:
                    case FINDING_ORIGIN$1:
                        this$1._currentAngleMeasurement.originVisible = false;
                        break;
                    case FINDING_CORNER:
                        this$1._currentAngleMeasurement.cornerVisible = false;
                        this$1._currentAngleMeasurement.originWireVisible = false;
                        this$1._currentAngleMeasurement.targetVisible = false;
                        this$1._currentAngleMeasurement.targetWireVisible = false;
                        this$1._currentAngleMeasurement.angleVisible = false;
                        break;
                    case FINDING_TARGET$1:
                        this$1._currentAngleMeasurement.targetVisible = false;
                        this$1._currentAngleMeasurement.targetWireVisible = false;
                        this$1._currentAngleMeasurement.angleVisible = false;
                        break;

                }
                document.body.style.cursor = "default";
            }
        });

        this._active = true;
    };

    /**
     * Deactivates this AngleMeasurementsControl, making it unresponsive to input.
     *
     * Destroys any {@link AngleMeasurement} under construction.
     */
    AngleMeasurementsControl.prototype.deactivate = function deactivate () {

        if (!this._active) {
            return;
        }

        this.reset();

        var cameraControl = this.plugin.viewer.cameraControl;
        var input = this.plugin.viewer.scene.input;

        input.off(this._onInputMouseDown);
        input.off(this._onInputMouseUp);

        cameraControl.off(this._onhoverSurface);
        cameraControl.off(this._onHoverNothing);

        this._currentAngleMeasurement = null;

        this._active = false;
    };

    /**
     * Resets this AngleMeasurementsControl.
     *
     * Destroys any {@link AngleMeasurement} under construction.
     *
     * Does nothing if the AngleMeasurementsControl is not active.
     */
    AngleMeasurementsControl.prototype.reset = function reset () {
        
        if (!this._active) {
            return;
        }
        
        if (this._currentAngleMeasurement) {
            this._currentAngleMeasurement.destroy();
            this._currentAngleMeasurement = null;
        }
        
        this._previousAngleMeasurement = null;
        
        this._state = HOVERING$1;
    };

    /**
     * @private
     */
    AngleMeasurementsControl.prototype.destroy = function destroy () {
        this.deactivate();
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( AngleMeasurementsControl.prototype, prototypeAccessors );

    return AngleMeasurementsControl;
}(Component));

/**
 * {@link Viewer} plugin for measuring angles.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/63641903-61488180-c6b6-11e9-8e00-895b9d16dc4b.gif">](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)
 *
 * * [[Example 1: Model with angle measurements](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_modelWithMeasurements)]
 * * [[Example 2: Create angle measurements with mouse](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)]
 *
 * ## Overview
 *
 * * An {@link AngleMeasurement} shows the angle between two connected 3D line segments, given
 * as three positions on the surface(s) of one or more {@link Entity}s.
 * * As shown on the screen capture above, a AngleMeasurement has two wires that show the line segments, with a label that shows the angle between them.
 * * Create AngleMeasurements programmatically with {@link AngleMeasurementsPlugin#createMeasurement}.
 * * Create AngleMeasurements interactively using the {@link AngleMeasurementsControl}, located at {@link AngleMeasurementsPlugin#control}.
 * * Existing AngleMeasurements are registered by ID in {@link AngleMeasurementsPlugin#measurements}.
 * * Destroy AngleMeasurements using {@link AngleMeasurementsPlugin#destroyMeasurement}.
 * * Configure global measurement units and scale via {@link Metrics}, located at {@link Scene#metrics}
 *
 * ## Example 1: Creating AngleMeasurements Programmatically
 *
 * In our first example, we'll use an {@link XKTLoaderPlugin} to load a model, and then use a AngleMeasurementsPlugin to programmatically create two {@link AngleMeasurement}s.
 *
 * Note how each AngleMeasurement has ````origin````, ````corner```` and  ````target````, which each indicate a 3D World-space
 * position on the surface of an {@link Entity}. These can be aon the same Entity, or on different Entitys.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_modelWithMeasurements)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const myMeasurement1 = angleMeasurements.createMeasurement({
 *          id: "myAngleMeasurement1",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          corner: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [4.738, 3.172, 17.768]
 *          },
 *          visible: true
 *      });
 *
 *      const myMeasurement2 = angleMeasurements.createMeasurement({
 *          id: "myAngleMeasurement2",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          corner: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *              worldPos: [0.436, 0.001, 22.135]
 *          },
 *          visible: true
 *      });
 * });
 * ````
 *
 * ## Example 2: Creating AngleMeasurements Interactively
 *
 * In our second example, we'll use an {@link XKTLoaderPlugin} to load a model, then we'll use the AngleMeasurementsPlugin's {@link AngleMeasurementsControl} to interactively create {@link AngleMeasurement}s with mouse or touch input.
 *
 * After we've activated the AngleMeasurementsControl, the first click on any {@link Entity} begins constructing a AngleMeasurement, fixing its
 * origin to that Entity. The next click on any Entity will fix the AngleMeasurement's corner, and the next click after
 * that will fix its target and complete the AngleMeasurement.
 *
 * The AngleMeasurementControl will then wait for the next click on any Entity, to begin constructing
 * another AngleMeasurement, and so on, until deactivated again.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_angle_createWithMouse)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, AngleMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const angleMeasurements = new AngleMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * angleMeasurements.control.activate();  // <------------ Activate the AngleMeasurementsControl
 * ````
 */
var AngleMeasurementsPlugin = /*@__PURE__*/(function (Plugin) {
    function AngleMeasurementsPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "AngleMeasurements", viewer);

        this._container = cfg.container || document.body;

        this._control = new AngleMeasurementsControl(this);

        this._measurements = {};
    }

    if ( Plugin ) AngleMeasurementsPlugin.__proto__ = Plugin;
    AngleMeasurementsPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    AngleMeasurementsPlugin.prototype.constructor = AngleMeasurementsPlugin;

    var prototypeAccessors = { control: { configurable: true },measurements: { configurable: true } };

    /**
     * @private
     */
    AngleMeasurementsPlugin.prototype.send = function send (name, value) {

    };

    /**
     * Gets the {@link AngleMeasurementsControl}, which creates {@link AngleMeasurement}s from user input.
     *
     * @type {AngleMeasurementsControl}
     */
    prototypeAccessors.control.get = function () {
        return this._control;
    };

    /**
     * Gets the existing {@link AngleMeasurement}s, each mapped to its {@link AngleMeasurement#id}.
     *
     * @type {{String:AngleMeasurement}}
     */
    prototypeAccessors.measurements.get = function () {
        return this._measurements;
    };

    /**
     * Creates an {@link AngleMeasurement}.
     *
     * The AngleMeasurement is then registered by {@link AngleMeasurement#id} in {@link AngleMeasurementsPlugin#measurements}.
     *
     * @param {Object} params {@link AngleMeasurement} configuration.
     * @param {String} params.id Unique ID to assign to {@link AngleMeasurement#id}. The AngleMeasurement will be registered by this in {@link AngleMeasurementsPlugin#measurements} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {Number[]} params.origin.worldPos Origin World-space 3D position.
     * @param {Entity} params.origin.entity Origin Entity.
     * @param {Number[]} params.corner.worldPos Corner World-space 3D position.
     * @param {Entity} params.corner.entity Corner Entity.
     * @param {Number[]} params.target.worldPos Target World-space 3D position.
     * @param {Entity} params.target.entity Target Entity.
     * @param {Boolean} [params.visible=true] Whether to initially show the {@link AngleMeasurement}.
     * @returns {AngleMeasurement} The new {@link AngleMeasurement}.
     */
    AngleMeasurementsPlugin.prototype.createMeasurement = function createMeasurement (params) {
        var this$1 = this;
        if ( params === void 0 ) params = {};

        if (this.viewer.scene.components[params.id]) {
            this.error("Viewer scene component with this ID already exists: " + params.id);
            delete params.id;
        }
        var origin = params.origin;
        var corner = params.corner;
        var target = params.target;
        var measurement = new AngleMeasurement(this, {
            id: params.id,
            plugin: this,
            container: this._container,
            origin: {
                entity: origin.entity,
                worldPos: origin.worldPos
            },
            corner: {
                entity: corner.entity,
                worldPos: corner.worldPos
            },
            target: {
                entity: target.entity,
                worldPos: target.worldPos
            },

            visible: params.visible,
            originVisible: true,
            originWireVisible: true,
            cornerVisible: true,
            targetWireVisible: true,
            targetVisible: true,
        });
        this._measurements[measurement.id] = measurement;
        measurement.on("destroyed", function () {
            delete this$1._measurements[measurement.id];
        });
        return measurement;
    };

    /**
     * Destroys a {@link AngleMeasurement}.
     *
     * @param {String} id ID of AngleMeasurement to destroy.
     */
    AngleMeasurementsPlugin.prototype.destroyMeasurement = function destroyMeasurement (id) {
        var measurement = this._measurements[id];
        if (!measurement) {
            this.log("AngleMeasurement not found: " + id);
            return;
        }
        measurement.destroy();
    };

    /**
     * Destroys all {@link AngleMeasurement}s.
     */
    AngleMeasurementsPlugin.prototype.clear = function clear () {
        var ids = Object.keys(this._measurements);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroyMeasurement(ids[i]);
        }
    };

    /**
     * Destroys this AngleMeasurementsPlugin.
     *
     * Destroys all {@link AngleMeasurement}s first.
     */
    AngleMeasurementsPlugin.prototype.destroy = function destroy () {
        this.clear();
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( AngleMeasurementsPlugin.prototype, prototypeAccessors );

    return AngleMeasurementsPlugin;
}(Plugin));

/**
 * A {@link Marker} with an HTML label attached to it, managed by an {@link AnnotationsPlugin}.
 *
 * See {@link AnnotationsPlugin} for more info.
 */
var Annotation = /*@__PURE__*/(function (Marker) {
    function Annotation(owner, cfg) {
        var this$1 = this;


        Marker.call(this, owner, cfg);

        /**
         * The {@link AnnotationsPlugin} this Annotation was created by.
         * @type {AnnotationsPlugin}
         */
        this.plugin = cfg.plugin;

        this._container = cfg.container;
        if (!this._container) {
            throw "config missing: container";
        }

        if ((!cfg.markerElement) && (!cfg.markerHTML)) {
            throw "config missing: need either markerElement or markerHTML";
        }
        if ((!cfg.labelElement) && (!cfg.labelHTML)) {
            throw "config missing: need either labelElement or labelHTML";
        }

        this._htmlDirty = false;

        if (cfg.markerElement) {
            this._marker = cfg.markerElement;
            this._marker.addEventListener("click", this._onMouseClickedExternalMarker = function () {
                this$1.plugin.fire("markerClicked", this$1);
            });
            this._marker.addEventListener("mouseenter", this._onMouseEnterExternalMarker = function () {
                this$1.plugin.fire("markerMouseEnter", this$1);
            });
            this._marker.addEventListener("mouseleave", this._onMouseLeaveExternalMarker = function () {
                this$1.plugin.fire("markerMouseLeave", this$1);
            });
            this._markerExternal = true; // Don't destroy marker when destroying Annotation
        } else {
            this._markerHTML = cfg.markerHTML;
            this._htmlDirty = true;
            this._markerExternal = false;
        }

        if (cfg.labelElement) {
            this._label = cfg.labelElement;
            this._labelExternal = true; // Don't destroy marker when destroying Annotation
        } else {
            this._labelHTML = cfg.labelHTML;
            this._htmlDirty = true;
            this._labelExternal = false;
        }

        this._markerShown = !!cfg.markerShown;
        this._labelShown = !!cfg.labelShown;
        this._values = cfg.values || {};
        this._layoutDirty = true;
        this._visibilityDirty = true;

        this._buildHTML();

        this._onTick = this.scene.on("tick", function () {
            if (this$1._htmlDirty) {
                this$1._buildHTML();
                this$1._htmlDirty = false;
                this$1._layoutDirty = true;
                this$1._visibilityDirty = true;
            }
            if (this$1._layoutDirty || this$1._visibilityDirty) {
                if (this$1._markerShown || this$1._labelShown) {
                    this$1._updatePosition();
                    this$1._layoutDirty = false;
                }
            }
            if (this$1._visibilityDirty) {
                this$1._marker.style.visibility = (this$1.visible && this$1._markerShown) ? "visible" : "hidden";
                this$1._label.style.visibility = (this$1.visible && this$1._markerShown && this$1._labelShown) ? "visible" : "hidden";
                this$1._visibilityDirty = false;
            }
        });

        this.on("canvasPos", function () {
            this$1._layoutDirty = true;
        });

        this.on("visible", function () {
            this$1._visibilityDirty = true;
        });

        this.setMarkerShown(cfg.markerShown !== false);
        this.setLabelShown(cfg.labelShown);

        /**
         * Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} Eye position.
         */
        this.eye = cfg.eye ? cfg.eye.slice() : null;

        /**
         * Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} The "look" vector.
         */
        this.look = cfg.look ? cfg.look.slice() : null;

        /**
         * Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {Number[]} The "up" vector.
         */
        this.up = cfg.up ? cfg.up.slice() : null;

        /**
         * Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.
         *
         * Undefined by default.
         *
         * @type {String} The projection type - "perspective" or "ortho"..
         */
        this.projection = cfg.projection;
    }

    if ( Marker ) Annotation.__proto__ = Marker;
    Annotation.prototype = Object.create( Marker && Marker.prototype );
    Annotation.prototype.constructor = Annotation;

    /**
     * @private
     */
    Annotation.prototype._buildHTML = function _buildHTML () {
        var this$1 = this;

        if (!this._markerExternal) {
            if (this._marker) {
                this._container.removeChild(this._marker);
                this._marker = null;
            }
            var markerHTML = this._markerHTML || "<p></p>"; // Make marker
            if (utils.isArray(markerHTML)) {
                markerHTML = markerHTML.join("");
            }
            markerHTML = this._renderTemplate(markerHTML);
            var markerFragment = document.createRange().createContextualFragment(markerHTML);
            this._marker = markerFragment.firstChild;
            this._container.appendChild(this._marker);
            this._marker.style.visibility = this._markerShown ? "visible" : "hidden";
            this._marker.addEventListener("click", function () {
                this$1.plugin.fire("markerClicked", this$1);
            });
            this._marker.addEventListener("mouseenter", function () {
                this$1.plugin.fire("markerMouseEnter", this$1);
            });
            this._marker.addEventListener("mouseleave", function () {
                this$1.plugin.fire("markerMouseLeave", this$1);
            });
        }
        if (!this._labelExternal) {
            if (this._label) {
                this._container.removeChild(this._label);
                this._label = null;
            }
            var labelHTML = this._labelHTML || "<p></p>"; // Make label
            if (utils.isArray(labelHTML)) {
                labelHTML = labelHTML.join("");
            }
            labelHTML = this._renderTemplate(labelHTML);
            var labelFragment = document.createRange().createContextualFragment(labelHTML);
            this._label = labelFragment.firstChild;
            this._container.appendChild(this._label);
            this._label.style.visibility = (this._markerShown && this._labelShown) ? "visible" : "hidden";
        }
    };

    /**
     * @private
     */
    Annotation.prototype._updatePosition = function _updatePosition () {
        var boundary = this.scene.canvas.boundary;
        var left = boundary[0];
        var top = boundary[1];
        var canvasPos = this.canvasPos;
        this._marker.style.left = (Math.floor(left + canvasPos[0]) - 12) + "px";
        this._marker.style.top = (Math.floor(top + canvasPos[1]) - 12) + "px";
        this._marker.style["z-index"] = 90005 + Math.floor(this._viewPos[2]) + 1;
        var offsetX = 20;
        var offsetY = -17;
        this._label.style.left = 20 + Math.floor(left + canvasPos[0] + offsetX) + "px";
        this._label.style.top = Math.floor(top + canvasPos[1] + offsetY) + "px";
        this._label.style["z-index"] = 90005 + Math.floor(this._viewPos[2]) + 1;
    };

    /**
     * @private
     */
    Annotation.prototype._renderTemplate = function _renderTemplate (template) {
        for (var key in this._values) {
            if (this._values.hasOwnProperty(key)) {
                var value = this._values[key];
                template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);
            }
        }
        return template;
    };

    /**
     * Sets whether or not to show this Annotation's marker.
     *
     * The marker shows the Annotation's position.
     *
     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {Boolean} shown Whether to show the marker.
     */
    Annotation.prototype.setMarkerShown = function setMarkerShown (shown) {
        shown = !!shown;
        if (this._markerShown === shown) {
            return;
        }
        this._markerShown = shown;
        this._visibilityDirty = true;
    };

    /**
     * Gets whether or not to show this Annotation's marker.
     *
     * The marker shows the Annotation's position.
     *
     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @returns {Boolean} Whether to show the marker.
     */
    Annotation.prototype.getMarkerShown = function getMarkerShown () {
        return this._markerShown;
    };

    /**
     * Sets whether or not to show this Annotation's label.
     *
     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {Boolean} shown Whether to show the label.
     */
    Annotation.prototype.setLabelShown = function setLabelShown (shown) {
        shown = !!shown;
        if (this._labelShown === shown) {
            return;
        }
        this._labelShown = shown;
        this._visibilityDirty = true;
    };

    /**
     * Gets whether or not to show this Annotation's label.
     *
     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @returns {Boolean} Whether to show the label.
     */
    Annotation.prototype.getLabelShown = function getLabelShown () {
        return this._labelShown;
    };

    /**
     * Sets the value of a field within the HTML templates for either the Annotation's marker or label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {String} key Identifies the field.
     * @param {String} value The field's value.
     */
    Annotation.prototype.setField = function setField (key, value) {
        this._values[key] = value || "";
        this._htmlDirty = true;
    };

    /**
     * Gets the value of a field within the HTML templates for either the Annotation's marker or label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {String} key Identifies the field.
     * @returns {String} The field's value.
     */
    Annotation.prototype.getField = function getField (key) {
        return this._values[key];
    };

    /**
     * Sets values for multiple placeholders within the Annotation's HTML templates for marker and label.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @param {{String:(String|Number)}} values Map of field values.
     */
    Annotation.prototype.setValues = function setValues (values) {
        for (var key in values) {
            if (values.hasOwnProperty(key)) {
                var value = values[key];
                this.setField(key, value);
            }
        }
    };

    /**
     * Gets the values that were set for the placeholders within this Annotation's HTML marker and label templates.
     *
     * See {@link AnnotationsPlugin} for more info.
     *
     * @RETURNS {{String:(String|Number)}} Map of field values.
     */
    Annotation.prototype.getValues = function getValues () {
        return this._values;
    };

    /**
     * Destroys this Annotation.
     *
     * You can also call {@link AnnotationsPlugin#destroyAnnotation}.
     */
    Annotation.prototype.destroy = function destroy () {
        if (this._marker) {
            if (!this._markerExternal) {
                this._marker.parentNode.removeChild(this._marker);
            } else {
                this._marker.removeEventListener("click", this._onMouseClickedExternalMarker);
                this._marker.removeEventListener("mouseenter", this._onMouseEnterExternalMarker);
                this._marker.removeEventListener("mouseleave", this._onMouseLeaveExternalMarker);
                this._marker = null;
            }
        }
        if (this._label) {
            if (!this._labelExternal) {
                this._label.parentNode.removeChild(this._label);
            }
            this._label = null;
        }
        this.scene.off(this._onTick);
        Marker.prototype.destroy.call(this);
    };

    return Annotation;
}(Marker));

var tempVec3a$_ = math.vec3();
var tempVec3b$9 = math.vec3();
var tempVec3c$6 = math.vec3();

/**
 * {@link Viewer} plugin that creates {@link Annotation}s.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/58403089-26589280-8062-11e9-8652-aed61a4e8c64.gif">](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)
 *
 * * [[Example 1: Create annotations with mouse](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]
 * * [[Example 2: Click annotations to toggle labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]
 * * [[Example 3: Hover annotations to show labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_hoverShowLabels)]
 * * [[Example 4: Click annotations to fly to viewpoint](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)]
 * * [[Example 5: Create Annotations with externally-created elements](https://xeokit.github.io/xeokit-sdk/examples/#annotations_externalElements)]
 *
 * ## Overview
 *
 * * An {@link Annotation} is a 3D position with a label attached.
 * * Annotations render themselves with HTML elements that float over the canvas; customize the appearance of
 * individual Annotations using HTML template; configure default appearance by setting templates on the AnnotationsPlugin.
 * * Dynamically insert data values into each Annotation's HTML templates; configure default values on the AnnotationsPlugin.
 * * Optionally configure Annotation with externally-created DOM elements for markers and labels; these override templates and data values.
 * * Optionally configure Annotations to hide themselves whenever occluded by {@link Entity}s.
 * * Optionally configure each Annotation with a position we can jump or fly the {@link Camera} to.
 *
 * ## Example 1: Loading a model and creating an annotation
 *
 * In the example below, we'll use an {@link XKTLoaderPlugin} to load a model, and an AnnotationsPlugin
 * to create an {@link Annotation} on it.
 *
 * We'll configure the AnnotationsPlugin with default HTML templates for each Annotation's position (its "marker") and
 * label, along with some default data values to insert into them.
 *
 * When we create our Annotation, we'll give it some specific data values to insert into the templates, overriding some of
 * the defaults we configured on the plugin. Note the correspondence between the placeholders in the templates
 * and the keys in the values map.
 *
 * We'll also configure the Annotation to hide itself whenever it's position is occluded by any {@link Entity}s (this is default behavior). The
 * {@link Scene} periodically occlusion-tests all Annotations on every 20th "tick" (which represents a rendered frame). We
 * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
 *
 * Finally, we'll query the Annotation's position occlusion/visibility status, and subscribe to change events on those properties.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin,AnnotationsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const annotations = new AnnotationsPlugin(viewer, {
 *
 *      // Default HTML template for marker position
 *      markerHTML: "<div class='annotation-marker' style='background-color: {{markerBGColor}};'>{{glyph}}</div>",
 *
 *      // Default HTML template for label
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>" +
 *      "<div class='annotation-title'>{{title}}</div><div class='annotation-desc'>{{description}}</div></div>",
 *
 *      // Default values to insert into the marker and label templates
 *      values: {
 *          markerBGColor: "red",
 *          labelBGColor: "red",
 *          glyph: "X",
 *          title: "Untitled",
 *          description: "No description"
 *      }
 * });
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/geometry.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const entity = viewer.scene.meshes[""];
 *
 *      // Create an annotation
 *      const myAnnotation1 = annotations.createAnnotation({
 *
 *          id: "myAnnotation",
 *
 *          entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"], // Optional, associate with an Entity
 *
 *          worldPos: [0, 0, 0],        // 3D World-space position
 *
 *          occludable: true,           // Optional, default, makes Annotation invisible when occluded by Entities
 *          markerShown: true,          // Optional, default is true, makes position visible (when not occluded)
 *          labelShown: true            // Optional, default is false, makes label visible (when not occluded)
 *
 *          values: {                   // Optional, overrides AnnotationPlugin's defaults
 *              glyph: "A",
 *              title: "My Annotation",
 *              description: "This is my annotation."
 *          }
 *      });
 *
 *      // Listen for change of the Annotation's 3D World-space position
 *
 *      myAnnotation1.on("worldPos", function(worldPos) {
 *          //...
 *      });
 *
 *      // Listen for change of the Annotation's 3D View-space position, which happens
 *      // when either worldPos was updated or the Camera was moved
 *
 *      myAnnotation1.on("viewPos", function(viewPos) {
 *          //...
 *      });
 *
 *      // Listen for change of the Annotation's 2D Canvas-space position, which happens
 *      // when worldPos or viewPos was updated, or Camera's projection was updated
 *
 *      myAnnotation1.on("canvasPos", function(canvasPos) {
 *          //...
 *      });
 *
 *      // Listen for change of Annotation visibility. The Annotation becomes invisible when it falls outside the canvas,
 *      // or its position is occluded by some Entity. Note that, when not occluded, the position is only
 *      // shown when Annotation#markerShown is true, and the label is only shown when Annotation#labelShown is true.
 *
 *      myAnnotation1.on("visible", function(visible) { // Marker visibility has changed
 *          if (visible) {
 *              this.log("Annotation is visible");
 *          } else {
 *              this.log("Annotation is invisible");
 *          }
 *      });
 *
 *      // Listen for destruction of the Annotation
 *
 *      myAnnotation1.on("destroyed", () => {
 *          //...
 *      });
 * });
 * ````
 *
 * Let's query our {@link Annotation}'s current position in the World, View and Canvas coordinate systems:
 *
 * ````javascript
 * const worldPos  = myAnnotation.worldPos;  // [x,y,z]
 * const viewPos   = myAnnotation.viewPos;   // [x,y,z]
 * const canvasPos = myAnnotation.canvasPos; // [x,y]
 * ````
 *
 * We can query it's current visibility, which is ````false```` when its position is occluded by some {@link Entity}:
 *
 * ````
 * const visible = myAnnotation1.visible;
 * ````
 *
 * To listen for change events on our Annotation's position and visibility:
 *
 * ````javascript
 * // World-space position changes when we assign a new value to Annotation#worldPos
 * myAnnotation1.on("worldPos", (worldPos) => {
 *     //...
 * });
 *
 * // View-space position changes when either worldPos was updated or the Camera was moved
 * myAnnotation1.on("viewPos", (viewPos) => {
 *     //...
 * });
 *
 * // Canvas-space position changes when worldPos or viewPos was updated, or Camera's projection was updated
 * myAnnotation1.on("canvasPos", (canvasPos) => {
 *     //...
 * });
 *
 * // Annotation is invisible when its position falls off the canvas or is occluded by some Entity
 * myAnnotation1.on("visible", (visible) => {
 *     //...
 * });
 * ````
 *
 * Finally, let's dynamically update the values for a couple of placeholders in our Annotation's label:
 *
 * ```` javascript
 * myAnnotation1.setValues({
 *      title: "Here's a new title",
 *      description: "Here's a new description"
 * });
 * ````
 *
 *
 * ## Example 2: Creating an Annotation with a unique appearance
 *
 * Now let's create a second {@link Annotation}, this time with its own custom HTML label template, which includes
 * an image. In the Annotation's values, we'll also provide a new title and description, custom colors for the marker
 * and label, plus a URL for the image in the label template. To render its marker, the Annotation will fall back
 * on the AnnotationPlugin's default marker template.
 *
 * ````javascript
 * const myAnnotation2 = annotations.createAnnotation({
 *
 *      id: "myAnnotation2",
 *
 *      worldPos: [-0.163, 1.810, 7.977],
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      // Custom label template is the same as the Annotation's, with the addition of an image element
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>\
 *          <div class='annotation-title'>{{title}}</div>\
 *          <div class='annotation-desc'>{{description}}</div>\
 *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\
 *          </div>",
 *
 *      // Custom template values override all the AnnotationPlugin's defaults, and includes an additional value
 *      // for the image element's URL
 *      values: {
 *          glyph: "A3",
 *          title: "The West wall",
 *          description: "Annotations can contain<br>custom HTML like this<br>image:",
 *          markerBGColor: "green",
 *          labelBGColor: "green",
 *          imageSrc: "https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png"
 *      }
 * });
 * ````
 *
 * ## Example 3: Creating an Annotation with a camera position
 *
 * We can optionally configure each {@link Annotation} with a position to fly or jump the {@link Camera} to.
 *
 * Let's create another Annotation, this time providing it with ````eye````, ````look```` and ````up```` properties
 * indicating a viewpoint on whatever it's annotating:
 *
 * ````javascript
 * const myAnnotation3 = annotations.createAnnotation({
 *
 *      id: "myAnnotation3",
 *
 *      worldPos: [-0.163, 3.810, 7.977],
 *
 *      eye: [0,0,-10],
 *      look: [-0.163, 3.810, 7.977],
 *      up: [0,1,0];
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      labelHTML: "<div class='annotation-label' style='background-color: {{labelBGColor}};'>\
 *          <div class='annotation-title'>{{title}}</div>\
 *          <div class='annotation-desc'>{{description}}</div>\
 *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\
 *          </div>",
 *
 *      values: {
 *          glyph: "A3",
 *          title: "The West wall",
 *          description: "Annotations can contain<br>custom HTML like this<br>image:",
 *          markerBGColor: "green",
 *          labelBGColor: "green",
 *          imageSrc: "https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png"
 *      }
 * });
 * ````
 *
 * Now we can fly the {@link Camera} to the Annotation's viewpoint, like this:
 *
 * ````javascript
 * viewer.cameraFlight.flyTo(myAnnotation3);
 * ````
 *
 * Or jump the Camera, like this:
 *
 * ````javascript
 * viewer.cameraFlight.jumpTo(myAnnotation3);
 * ````
 *
 * ## Example 4: Creating an Annotation using externally-created DOM elements
 *
 * Now let's create another {@link Annotation}, this time providing it with pre-existing DOM elements for its marker
 * and label. Note that AnnotationsPlugin will ignore any ````markerHTML````, ````labelHTML````
 * or ````values```` properties when provide  ````markerElementId```` or ````labelElementId````.
 *
 * ````javascript
 * const myAnnotation2 = annotations.createAnnotation({
 *
 *      id: "myAnnotation2",
 *
 *      worldPos: [-0.163, 1.810, 7.977],
 *
 *      occludable: true,
 *      markerShown: true,
 *      labelShown: true,
 *
 *      markerElementId: "myMarkerElement",
 *      labelElementId: "myLabelElement"
 * });
 * ````
 *
 * ## Example 5: Creating annotations by clicking on objects
 *
 * AnnotationsPlugin makes it easy to create {@link Annotation}s on the surfaces of {@link Entity}s as we click on them.
 *
 * The {@link AnnotationsPlugin#createAnnotation} method can accept a {@link PickResult} returned
 * by {@link Scene#pick}, from which it initializes the {@link Annotation}'s {@link Annotation#worldPos} and
 * {@link Annotation#entity}. Note that this only works when {@link Scene#pick} was configured to perform a 3D
 * surface-intersection pick (see {@link Scene#pick} for more info).
 *
 * Let's now extend our example to create an Annotation wherever we click on the surface of of our model:
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]
 *
 * ````javascript
 * var i = 1; // Used to create unique Annotation IDs
 *
 * viewer.scene.input.on("mouseclicked", (coords) => {
 *
 *     var pickRecord = viewer.scene.pick({
 *         canvasPos: coords,
 *         pickSurface: true  // <<------ This causes picking to find the intersection point on the entity
 *     });
 *
 *     if (pickRecord) {
 *
 *         const annotation = annotations.createAnnotation({
 *              id: "myAnnotationOnClick" + i,
 *              pickRecord: pickRecord,
 *              occludable: true,           // Optional, default is true
 *              markerShown: true,          // Optional, default is true
 *              labelShown: true,           // Optional, default is true
 *              values: {                   // HTML template values
 *                  glyph: "A" + i,
 *                  title: "My annotation " + i,
 *                  description: "My description " + i
 *              },
           });
 *
 *         i++;
 *      }
 * });
 * ````
 *
 * Note that when the Annotation is occludable, there is potential for the {@link Annotation#worldPos} to become
 * visually embedded within the surface of its Entity when viewed from a distance. This happens as a result of limited
 * GPU accuracy GPU accuracy, especially when the near and far view-space clipping planes, specified by {@link Perspective#near}
 * and {@link Perspective#far}, or {@link Ortho#near} and {@link Perspective#far}, are far away from each other.
 *
 * To prevent this, we can offset Annotations from their Entity surfaces by an amount that we set
 * on {@link AnnotationsPlugin#surfaceOffset}:
 *
 * ````javascript
 * annotations.surfaceOffset = 0.3; // Default value
 * ````
 *
 * Annotations subsequently created with {@link AnnotationsPlugin#createAnnotation} using a {@link PickResult} will then
 * be offset by that amount.
 *
 * Another thing we can do to prevent this unwanted occlusion is keep the distance between the view-space clipping
 * planes to a minimum, which improves the accuracy of the Annotation occlusion test. In general, a good default
 * value for ````Perspective#far```` and ````Ortho#far```` is around ````2.000````.
 */
var AnnotationsPlugin = /*@__PURE__*/(function (Plugin) {
    function AnnotationsPlugin(viewer, cfg) {

        Plugin.call(this, "Annotations", viewer);

        this._labelHTML = cfg.labelHTML || "<div></div>";
        this._markerHTML = cfg.markerHTML || "<div></div>";
        this._container = cfg.container || document.body;
        this._values = cfg.values || {};

        /**
         * The {@link Annotation}s created by {@link AnnotationsPlugin#createAnnotation}, each mapped to its {@link Annotation#id}.
         * @type {{String:Annotation}}
         */
        this.annotations = {};

        this.surfaceOffset = cfg.surfaceOffset;
    }

    if ( Plugin ) AnnotationsPlugin.__proto__ = Plugin;
    AnnotationsPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    AnnotationsPlugin.prototype.constructor = AnnotationsPlugin;

    var prototypeAccessors = { surfaceOffset: { configurable: true } };

    /**
     * @private
     */
    AnnotationsPlugin.prototype.send = function send (name, value) {
        switch (name) {
            case "clearAnnotations":
                this.clear();
                break;
        }
    };

    /**
     * Sets the amount by which each {@link Annotation} is offset from the surface of its {@link Entity}, when we
     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.
     *
     * See the class comments for more info.
     *
     * This is ````0.3```` by default.
     *
     * @param {Number} surfaceOffset The surface offset.
     */
    prototypeAccessors.surfaceOffset.set = function (surfaceOffset) {
        if (surfaceOffset === undefined || surfaceOffset === null) {
            surfaceOffset = 0.3;
        }
        this._surfaceOffset = surfaceOffset;
    };

    /**
     * Gets the amount by which an {@link Annotation} is offset from the surface of its {@link Entity} when
     * created by {@link AnnotationsPlugin#createAnnotation}, when we
     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.
     *
     * This is ````0.3```` by default.
     *
     * @returns {Number} The surface offset.
     */
    prototypeAccessors.surfaceOffset.get = function () {
        return this._surfaceOffset;
    };

    /**
     * Creates an {@link Annotation}.
     *
     * The Annotation is then registered by {@link Annotation#id} in {@link AnnotationsPlugin#annotations}.
     *
     * @param {Object} params Annotation configuration.
     * @param {String} params.id Unique ID to assign to {@link Annotation#id}. The Annotation will be registered by this in {@link AnnotationsPlugin#annotations} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {String} [params.markerElementId] ID of pre-existing DOM element to render the marker. This overrides ````markerHTML```` and does not support ````values```` (data is baked into the label DOM element).
     * @param {String} [params.labelElementId] ID of pre-existing DOM element to render the label. This overrides ````labelHTML```` and does not support ````values```` (data is baked into the label DOM element).
     * @param {String} [params.markerHTML] HTML text template for the Annotation marker. Defaults to the marker HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````markerElementId````.
     * @param {String} [params.labelHTML] HTML text template for the Annotation label. Defaults to the label HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````labelElementId````.
     * @param {Number[]} [params.worldPos=[0,0,0]] World-space position of the Annotation marker, assigned to {@link Annotation#worldPos}.
     * @param {Entity} [params.entity] Optional {@link Entity} to associate the Annotation with. Causes {@link Annotation#visible} to be ````false```` whenever {@link Entity#visible} is also ````false````.
     * @param {PickResult} [params.pickResult] Sets the Annotation's World-space position and direction vector from the given {@link PickResult}'s {@link PickResult#worldPos} and {@link PickResult#worldNormal}, and the Annotation's Entity from {@link PickResult#entity}. Causes ````worldPos```` and ````entity```` parameters to be ignored, if they are also given.
     * @param {Boolean} [params.occludable=false] Indicates whether or not the {@link Annotation} marker and label are hidden whenever the marker occluded by {@link Entity}s in the {@link Scene}. The
     * {@link Scene} periodically occlusion-tests all Annotations on every 20th "tick" (which represents a rendered frame). We can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.
     * @param  {{String:(String|Number)}} [params.values={}] Map of values to insert into the HTML templates for the marker and label. These will be inserted in addition to any values given to the AnnotationsPlugin constructor.
     * @param {Boolean} [params.markerShown=true] Whether to initially show the {@link Annotation} marker.
     * @param {Boolean} [params.labelShown=false] Whether to initially show the {@link Annotation} label.
     * @param {Number[]} [params.eye] Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.
     * @param {Number[]} [params.look] Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.
     * @param {Number[]} [params.up] Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.
     * @param {String} [params.projection] Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.
     * @returns {Annotation} The new {@link Annotation}.
     */
    AnnotationsPlugin.prototype.createAnnotation = function createAnnotation (params) {
        var this$1 = this;

        if (this.viewer.scene.components[params.id]) {
            this.error("Viewer component with this ID already exists: " + params.id);
            delete params.id;
        }
        var worldPos;
        var entity;
        params.pickResult = params.pickResult || params.pickRecord;
        if (params.pickResult) {
            var pickResult = params.pickResult;
            if (!pickResult.worldPos || !pickResult.worldNormal) {
                this.error("Param 'pickResult' does not have both worldPos and worldNormal");
            } else {
                var normalizedWorldNormal = math.normalizeVec3(pickResult.worldNormal, tempVec3a$_);
                var offsetVec = math.mulVec3Scalar(normalizedWorldNormal, this._surfaceOffset, tempVec3b$9);
                var offsetWorldPos = math.addVec3(pickResult.worldPos, offsetVec, tempVec3c$6);
                worldPos = offsetWorldPos;
                entity = pickResult.entity;
            }
        } else {
            worldPos = params.worldPos;
            entity = params.entity;
        }

        var markerElement = null;
        if (params.markerElementId) {
            markerElement = document.getElementById(params.markerElementId);
            if (!markerElement) {
                this.error("Can't find DOM element for 'markerElementId' value '" + params.markerElementId + "' - defaulting to internally-generated empty DIV");
            }
        }

        var labelElement = null;
        if (params.labelElementId) {
            labelElement = document.getElementById(params.labelElementId);
            if (!labelElement) {
                this.error("Can't find DOM element for 'labelElementId' value '" + params.labelElementId + "' - defaulting to internally-generated empty DIV");
            }
        }

        var annotation = new Annotation(this.viewer.scene, {
            id: params.id,
            plugin: this,
            entity: entity,
            worldPos: worldPos,
            container: this._container,
            markerElement: markerElement,
            labelElement: labelElement,
            markerHTML: params.markerHTML || this._markerHTML,
            labelHTML: params.labelHTML || this._labelHTML,
            occludable: params.occludable,
            values: utils.apply(params.values, utils.apply(this._values, {})),
            markerShown: params.markerShown,
            labelShown: params.labelShown,
            eye: params.eye,
            look: params.look,
            up: params.up,
            projection: params.projection,
            visible: (params.visible !== false)
        });
        this.annotations[annotation.id] = annotation;
        annotation.on("destroyed", function () {
            delete this$1.annotations[annotation.id];
            this$1.fire("annotationDestroyed", annotation.id);
        });
        this.fire("annotationCreated", annotation.id);
        return annotation;
    };

    /**
     * Destroys an {@link Annotation}.
     *
     * @param {String} id ID of Annotation to destroy.
     */
    AnnotationsPlugin.prototype.destroyAnnotation = function destroyAnnotation (id) {
        var annotation = this.annotations[id];
        if (!annotation) {
            this.log("Annotation not found: " + id);
            return;
        }
        annotation.destroy();
    };

    /**
     * Destroys all {@link Annotation}s.
     */
    AnnotationsPlugin.prototype.clear = function clear () {
        var ids = Object.keys(this.annotations);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroyAnnotation(ids[i]);
        }
    };

    /**
     * Destroys this AnnotationsPlugin.
     *
     * Destroys all {@link Annotation}s first.
     */
    AnnotationsPlugin.prototype.destroy = function destroy () {
        this.clear();
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( AnnotationsPlugin.prototype, prototypeAccessors );

    return AnnotationsPlugin;
}(Plugin));

var defaultCSS = ".sk-fading-circle {\
        background: transparent;\
        margin: 20px auto;\
        width: 50px;\
        height:50px;\
        position: relative;\
        }\
        .sk-fading-circle .sk-circle {\
        width: 120%;\
        height: 120%;\
        position: absolute;\
        left: 0;\
        top: 0;\
        }\
        .sk-fading-circle .sk-circle:before {\
        content: '';\
        display: block;\
        margin: 0 auto;\
        width: 15%;\
        height: 15%;\
        background-color: #ff8800;\
        border-radius: 100%;\
        -webkit-animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        }\
        .sk-fading-circle .sk-circle2 {\
        -webkit-transform: rotate(30deg);\
        -ms-transform: rotate(30deg);\
        transform: rotate(30deg);\
    }\
    .sk-fading-circle .sk-circle3 {\
        -webkit-transform: rotate(60deg);\
        -ms-transform: rotate(60deg);\
        transform: rotate(60deg);\
    }\
    .sk-fading-circle .sk-circle4 {\
        -webkit-transform: rotate(90deg);\
        -ms-transform: rotate(90deg);\
        transform: rotate(90deg);\
    }\
    .sk-fading-circle .sk-circle5 {\
        -webkit-transform: rotate(120deg);\
        -ms-transform: rotate(120deg);\
        transform: rotate(120deg);\
    }\
    .sk-fading-circle .sk-circle6 {\
        -webkit-transform: rotate(150deg);\
        -ms-transform: rotate(150deg);\
        transform: rotate(150deg);\
    }\
    .sk-fading-circle .sk-circle7 {\
        -webkit-transform: rotate(180deg);\
        -ms-transform: rotate(180deg);\
        transform: rotate(180deg);\
    }\
    .sk-fading-circle .sk-circle8 {\
        -webkit-transform: rotate(210deg);\
        -ms-transform: rotate(210deg);\
        transform: rotate(210deg);\
    }\
    .sk-fading-circle .sk-circle9 {\
        -webkit-transform: rotate(240deg);\
        -ms-transform: rotate(240deg);\
        transform: rotate(240deg);\
    }\
    .sk-fading-circle .sk-circle10 {\
        -webkit-transform: rotate(270deg);\
        -ms-transform: rotate(270deg);\
        transform: rotate(270deg);\
    }\
    .sk-fading-circle .sk-circle11 {\
        -webkit-transform: rotate(300deg);\
        -ms-transform: rotate(300deg);\
        transform: rotate(300deg);\
    }\
    .sk-fading-circle .sk-circle12 {\
        -webkit-transform: rotate(330deg);\
        -ms-transform: rotate(330deg);\
        transform: rotate(330deg);\
    }\
    .sk-fading-circle .sk-circle2:before {\
        -webkit-animation-delay: -1.1s;\
        animation-delay: -1.1s;\
    }\
    .sk-fading-circle .sk-circle3:before {\
        -webkit-animation-delay: -1s;\
        animation-delay: -1s;\
    }\
    .sk-fading-circle .sk-circle4:before {\
        -webkit-animation-delay: -0.9s;\
        animation-delay: -0.9s;\
    }\
    .sk-fading-circle .sk-circle5:before {\
        -webkit-animation-delay: -0.8s;\
        animation-delay: -0.8s;\
    }\
    .sk-fading-circle .sk-circle6:before {\
        -webkit-animation-delay: -0.7s;\
        animation-delay: -0.7s;\
    }\
    .sk-fading-circle .sk-circle7:before {\
        -webkit-animation-delay: -0.6s;\
        animation-delay: -0.6s;\
    }\
    .sk-fading-circle .sk-circle8:before {\
        -webkit-animation-delay: -0.5s;\
        animation-delay: -0.5s;\
    }\
    .sk-fading-circle .sk-circle9:before {\
        -webkit-animation-delay: -0.4s;\
        animation-delay: -0.4s;\
    }\
    .sk-fading-circle .sk-circle10:before {\
        -webkit-animation-delay: -0.3s;\
        animation-delay: -0.3s;\
    }\
    .sk-fading-circle .sk-circle11:before {\
        -webkit-animation-delay: -0.2s;\
        animation-delay: -0.2s;\
    }\
    .sk-fading-circle .sk-circle12:before {\
        -webkit-animation-delay: -0.1s;\
        animation-delay: -0.1s;\
    }\
    @-webkit-keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }\
    @keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }";

/**
 * @desc Displays a progress animation at the center of its {@link Canvas} while things are loading or otherwise busy.
 *
 *
 * * Located at {@link Canvas#spinner}.
 * * Automatically shown while things are loading, however may also be shown by application code wanting to indicate busyness.
 * * {@link Spinner#processes} holds the count of active processes. As a process starts, it increments {@link Spinner#processes}, then decrements it on completion or failure.
 * * A Spinner is only visible while {@link Spinner#processes} is greater than zero.
 *
 * ````javascript
 * var spinner = viewer.scene.canvas.spinner;
 *
 * // Increment count of busy processes represented by the spinner;
 * // assuming the count was zero, this now shows the spinner
 * spinner.processes++;
 *
 * // Increment the count again, by some other process; spinner already visible, now requires two decrements
 * // before it becomes invisible again
 * spinner.processes++;
 *
 * // Decrement the count; count still greater than zero, so spinner remains visible
 * spinner.process--;
 *
 * // Decrement the count; count now zero, so spinner becomes invisible
 * spinner.process--;
 * ````
 */
var Spinner = /*@__PURE__*/(function (Component) {
    function Spinner(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._canvas = cfg.canvas;
        this._element = null;
        this._isCustom = false; // True when the element is custom HTML

        if (cfg.elementId) { // Custom spinner element supplied
            this._element = document.getElementById(cfg.elementId);
            if (!this._element) {
                this.error("Can't find given Spinner HTML element: '" + cfg.elementId + "' - will automatically create default element");
            } else {
                this._adjustPosition();
            }
        }

        if (!this._element) {
            this._createDefaultSpinner();
        }

        this.processes = 0;
    }

    if ( Component ) Spinner.__proto__ = Component;
    Spinner.prototype = Object.create( Component && Component.prototype );
    Spinner.prototype.constructor = Spinner;

    var prototypeAccessors = { type: { configurable: true },processes: { configurable: true } };

    /** @private */
    prototypeAccessors.type.get = function () {
        return "Spinner";
    };

    Spinner.prototype._createDefaultSpinner = function _createDefaultSpinner () {
        this._injectDefaultCSS();
        var element = document.createElement('div');
        var style = element.style;
        style["z-index"] = "9000";
        style.position = "absolute";
        element.innerHTML = '<div class="sk-fading-circle">\
                <div class="sk-circle1 sk-circle"></div>\
                <div class="sk-circle2 sk-circle"></div>\
                <div class="sk-circle3 sk-circle"></div>\
                <div class="sk-circle4 sk-circle"></div>\
                <div class="sk-circle5 sk-circle"></div>\
                <div class="sk-circle6 sk-circle"></div>\
                <div class="sk-circle7 sk-circle"></div>\
                <div class="sk-circle8 sk-circle"></div>\
                <div class="sk-circle9 sk-circle"></div>\
                <div class="sk-circle10 sk-circle"></div>\
                <div class="sk-circle11 sk-circle"></div>\
                <div class="sk-circle12 sk-circle"></div>\
                </div>';
        this._canvas.parentElement.appendChild(element);
        this._element = element;
        this._isCustom = false;
        this._adjustPosition();
    };

    /**
     * @private
     */
    Spinner.prototype._injectDefaultCSS = function _injectDefaultCSS () {
        var elementId = "xeokit-spinner-css";
        if (document.getElementById(elementId)) {
            return;
        }
        var defaultCSSNode = document.createElement('style');
        defaultCSSNode.innerHTML = defaultCSS;
        defaultCSSNode.id = elementId;
        document.body.appendChild(defaultCSSNode);
    };

    /**
     * @private
     */
    Spinner.prototype._adjustPosition = function _adjustPosition () { // (Re)positions spinner DIV over the center of the canvas - called by Canvas
        if (this._isCustom) {
            return;
        }
        var canvas = this._canvas;
        var element = this._element;
        var style = element.style;
        style["left"] = (canvas.offsetLeft + (canvas.clientWidth * 0.5) - (element.clientWidth * 0.5)) + "px";
        style["top"] = (canvas.offsetTop + (canvas.clientHeight * 0.5) - (element.clientHeight * 0.5)) + "px";
    };

    /**
     * Sets the number of processes this Spinner represents.
     *
     * The Spinner is visible while this property is greater than zero.
     *
     * Increment this property whenever you commence some process during which you want the Spinner to be visible, then decrement it again when the process is complete.
     *
     * Clamps to zero if you attempt to set to to a negative value.
     *
     * Fires a {@link Spinner#processes:event} event on change.

     * Default value is ````0````.
     *
     * @param {Number} value New processes count.
     */
    prototypeAccessors.processes.set = function (value) {
        value = value || 0;
        if (this._processes === value) {
            return;
        }
        if (value < 0) {
            return;
        }
        var prevValue = this._processes;
        this._processes = value;
        var element = this._element;
        if (element) {
            element.style["visibility"] = (this._processes > 0) ? "visible" : "hidden";
        }
        /**
         Fired whenever this Spinner's {@link Spinner#visible} property changes.

         @event processes
         @param value The property's new value
         */
        this.fire("processes", this._processes);
        if (this._processes === 0 && this._processes !== prevValue) {
            /**
             Fired whenever this Spinner's {@link Spinner#visible} property becomes zero.

             @event zeroProcesses
             */
            this.fire("zeroProcesses", this._processes);
        }
    };

    /**
     * Gets the number of processes this Spinner represents.
     *
     * The Spinner is visible while this property is greater than zero.
     *
     * @returns {Number} Current processes count.
     */
    prototypeAccessors.processes.get = function () {
        return this._processes;
    };

    Spinner.prototype._destroy = function _destroy () {
        if (this._element && (!this._isCustom)) {
            this._element.parentNode.removeChild(this._element);
            this._element = null;
        }
        var styleElement = document.getElementById("xeokit-spinner-css");
        if (styleElement) {
            styleElement.parentNode.removeChild(styleElement);
        }
    };

    Object.defineProperties( Spinner.prototype, prototypeAccessors );

    return Spinner;
}(Component));

/**
 * @private
 * @type {{WEBGL: boolean, SUPPORTED_EXTENSIONS: {}}}
 */
var WEBGL_INFO$1 = {
    WEBGL: false,
    SUPPORTED_EXTENSIONS: {}
};

var canvas = document.createElement("canvas");

if (canvas) {

    var gl = canvas.getContext("webgl", {antialias: true}) || canvas.getContext("experimental-webgl", {antialias: true});

    WEBGL_INFO$1.WEBGL = !!gl;

    if (WEBGL_INFO$1.WEBGL) {
        WEBGL_INFO$1.ANTIALIAS = gl.getContextAttributes().antialias;
        if (gl.getShaderPrecisionFormat) {
            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                WEBGL_INFO$1.FS_MAX_FLOAT_PRECISION = "highp";
            } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                WEBGL_INFO$1.FS_MAX_FLOAT_PRECISION = "mediump";
            } else {
                WEBGL_INFO$1.FS_MAX_FLOAT_PRECISION = "lowp";
            }
        } else {
            WEBGL_INFO$1.FS_MAX_FLOAT_PRECISION = "mediump";
        }
        WEBGL_INFO$1.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);
        WEBGL_INFO$1.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        WEBGL_INFO$1.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        WEBGL_INFO$1.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
        WEBGL_INFO$1.MAX_TEXTURE_UNITS = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        WEBGL_INFO$1.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        WEBGL_INFO$1.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        WEBGL_INFO$1.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        WEBGL_INFO$1.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        WEBGL_INFO$1.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);
        gl.getSupportedExtensions().forEach(function (ext) {
            WEBGL_INFO$1.SUPPORTED_EXTENSIONS[ext] = true;
        });
        WEBGL_INFO$1.depthTexturesSupported = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"];
    }
}

var WEBGL_CONTEXT_NAMES = [
    "webgl",
    "experimental-webgl",
    "webkit-3d",
    "moz-webgl",
    "moz-glweb20"
];

/**
 * @desc Manages its {@link Scene}'s HTML canvas.
 *
 * * Provides the HTML canvas element in {@link Canvas#canvas}.
 * * Has a {@link Spinner}, provided at {@link Canvas#spinner}, which manages the loading progress indicator.
 */
var Canvas = /*@__PURE__*/(function (Component) {
    function Canvas(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._backgroundColor = math.vec3([
            cfg.backgroundColor ? cfg.backgroundColor[0] : 1,
            cfg.backgroundColor ? cfg.backgroundColor[1] : 1,
            cfg.backgroundColor ? cfg.backgroundColor[2] : 1]);
        this._backgroundColorFromAmbientLight = !!cfg.backgroundColorFromAmbientLight;

        /**
         * The HTML canvas.
         *
         * @property canvas
         * @type {HTMLCanvasElement}
         * @final
         */
        this.canvas = cfg.canvas;

        /**
         * The WebGL rendering context.
         *
         * @property gl
         * @type {WebGLRenderingContext}
         * @final
         */
        this.gl = null;

        /**
         * True when WebGL 2 support is enabled.
         *
         * @property webgl2
         * @type {Boolean}
         * @final
         */
        this.webgl2 = false; // Will set true in _initWebGL if WebGL is requested and we succeed in getting it.

        /**
         * Indicates if this Canvas is transparent.
         *
         * @property transparent
         * @type {Boolean}
         * @default {false}
         * @final
         */
        this.transparent = !!cfg.transparent;

        /**
         * Attributes for the WebGL context
         *
         * @type {{}|*}
         */
        this.contextAttr = cfg.contextAttr || {};
        this.contextAttr.alpha = this.transparent;

        this.contextAttr.preserveDrawingBuffer = !!this.contextAttr.preserveDrawingBuffer;
        this.contextAttr.stencil = false;
        this.contextAttr.premultipliedAlpha = (!!this.contextAttr.premultipliedAlpha);  // False by default: https://github.com/xeokit/xeokit-sdk/issues/251
        this.contextAttr.antialias = (this.contextAttr.antialias !== false);

        // If the canvas uses css styles to specify the sizes make sure the basic
        // width and height attributes match or the WebGL context will use 300 x 150

        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;

        /**
         * Boundary of the Canvas in absolute browser window coordinates.
         *
         * ### Usage:
         *
         * ````javascript
         * var boundary = myScene.canvas.boundary;
         *
         * var xmin = boundary[0];
         * var ymin = boundary[1];
         * var width = boundary[2];
         * var height = boundary[3];
         * ````
         *
         * @property boundary
         * @type {{Number[]}}
         * @final
         */
        this.boundary = [
            this.canvas.offsetLeft, this.canvas.offsetTop,
            this.canvas.clientWidth, this.canvas.clientHeight
        ];

        // Get WebGL context

        this._initWebGL(cfg);

        // Bind context loss and recovery handlers

        var self = this;

        this.canvas.addEventListener("webglcontextlost", this._webglcontextlostListener = function (event) {
                console.time("webglcontextrestored");
                self.scene._webglContextLost();
                /**
                 * Fired whenever the WebGL context has been lost
                 * @event webglcontextlost
                 */
                self.fire("webglcontextlost");
                event.preventDefault();
            },
            false);

        this.canvas.addEventListener("webglcontextrestored", this._webglcontextrestoredListener = function (event) {
                self._initWebGL();
                if (self.gl) {
                    self.scene._webglContextRestored(self.gl);
                    /**
                     * Fired whenever the WebGL context has been restored again after having previously being lost
                     * @event webglContextRestored
                     * @param value The WebGL context object
                     */
                    self.fire("webglcontextrestored", self.gl);
                    event.preventDefault();
                }
                console.timeEnd("webglcontextrestored");
            },
            false);

        // Publish canvas size and position changes on each scene tick

        var lastWindowWidth = null;
        var lastWindowHeight = null;

        var lastCanvasWidth = null;
        var lastCanvasHeight = null;

        var lastCanvasOffsetLeft = null;
        var lastCanvasOffsetTop = null;

        var lastParent = null;

        this._tick = this.scene.on("tick", function () {

            var canvas = self.canvas;

            var newWindowSize = (window.innerWidth !== lastWindowWidth || window.innerHeight !== lastWindowHeight);
            var newCanvasSize = (canvas.clientWidth !== lastCanvasWidth || canvas.clientHeight !== lastCanvasHeight);
            var newCanvasPos = (canvas.offsetLeft !== lastCanvasOffsetLeft || canvas.offsetTop !== lastCanvasOffsetTop);

            var parent = canvas.parentElement;
            var newParent = (parent !== lastParent);

            if (newWindowSize || newCanvasSize || newCanvasPos || newParent) {

                self._spinner._adjustPosition();

                if (newCanvasSize || newCanvasPos) {

                    var newWidth = canvas.clientWidth;
                    var newHeight = canvas.clientHeight;

                    // TODO: Wasteful to re-count pixel size of each canvas on each canvas' resize
                    if (newCanvasSize) {
                        var countPixels = 0;
                        var scene;
                        for (var sceneId in core.scenes) {
                            if (core.scenes.hasOwnProperty(sceneId)) {
                                scene = core.scenes[sceneId];
                                countPixels += scene.canvas.canvas.clientWidth * scene.canvas.canvas.clientHeight;
                            }
                        }
                        stats.memory.pixels = countPixels;

                        canvas.width = canvas.clientWidth;
                        canvas.height = canvas.clientHeight;
                    }

                    var boundary = self.boundary;

                    boundary[0] = canvas.offsetLeft;
                    boundary[1] = canvas.offsetTop;
                    boundary[2] = newWidth;
                    boundary[3] = newHeight;

                    /**
                     * Fired whenever this Canvas's {@link Canvas/boundary} property changes.
                     *
                     * @event boundary
                     * @param value The property's new value
                     */
                    self.fire("boundary", boundary);

                    lastCanvasWidth = newWidth;
                    lastCanvasHeight = newHeight;
                }

                if (newWindowSize) {
                    lastWindowWidth = window.innerWidth;
                    lastWindowHeight = window.innerHeight;
                }

                if (newCanvasPos) {
                    lastCanvasOffsetLeft = canvas.offsetLeft;
                    lastCanvasOffsetTop = canvas.offsetTop;
                }

                lastParent = parent;
            }
        });

        this._spinner = new Spinner(this.scene, {
            canvas: this.canvas,
            elementId: cfg.spinnerElementId
        });
    }

    if ( Component ) Canvas.__proto__ = Component;
    Canvas.prototype = Object.create( Component && Component.prototype );
    Canvas.prototype.constructor = Canvas;

    var prototypeAccessors = { type: { configurable: true },backgroundColorFromAmbientLight: { configurable: true },backgroundColor: { configurable: true },spinner: { configurable: true } };

    /**
     * Creates a default canvas in the DOM.
     * @private
     */
    prototypeAccessors.type.get = function () {
        return "Canvas";
    };

    Canvas.prototype._createCanvas = function _createCanvas () {

        var canvasId = "xeokit-canvas-" + math.createUUID();
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');

        var style = div.style;
        style.height = "100%";
        style.width = "100%";
        style.padding = "0";
        style.margin = "0";
        style.background = "rgba(0,0,0,0);";
        style.float = "left";
        style.left = "0";
        style.top = "0";
        style.position = "absolute";
        style.opacity = "1.0";
        style["z-index"] = "-10000";

        div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>';

        body.appendChild(div);

        this.canvas = document.getElementById(canvasId);
    };

    Canvas.prototype._getElementXY = function _getElementXY (e) {
        var x = 0, y = 0;
        while (e) {
            x += (e.offsetLeft - e.scrollLeft);
            y += (e.offsetTop - e.scrollTop);
            e = e.offsetParent;
        }
        return {x: x, y: y};
    };

    /**
     * Initialises the WebGL context
     * @private
     */
    Canvas.prototype._initWebGL = function _initWebGL () {

        // Default context attribute values

        if (!this.gl) {
            for (var i = 0; !this.gl && i < WEBGL_CONTEXT_NAMES.length; i++) {
                try {
                    this.gl = this.canvas.getContext(WEBGL_CONTEXT_NAMES[i], this.contextAttr);
                } catch (e) { // Try with next context name
                }
            }
        }

        if (!this.gl) {

            this.error('Failed to get a WebGL context');

            /**
             * Fired whenever the canvas failed to get a WebGL context, which probably means that WebGL
             * is either unsupported or has been disabled.
             * @event webglContextFailed
             */
            this.fire("webglContextFailed", true, true);
        }

        if (this.gl) {
            // Setup extension (if necessary) and hints for fragment shader derivative functions
            if (this.webgl2) {
                this.gl.hint(this.gl.FRAGMENT_SHADER_DERIVATIVE_HINT, this.gl.FASTEST);
            } else {
                if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_standard_derivatives"]) {
                    var ext = this.gl.getExtension("OES_standard_derivatives");
                    this.gl.hint(ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, this.gl.FASTEST);
                }
                if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
                    this.gl.getExtension('EXT_frag_depth');
                }
                if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
                    this.gl.getExtension('WEBGL_depth_texture');
                }
            }
        }
    };

    /**
     * Sets if the canvas background color is derived from an {@link AmbientLight}.
     *
     * This only has effect when the canvas is not transparent. When not enabled, the background color
     * will be the canvas element's HTML/CSS background color.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backgroundColorFromAmbientLight.set = function (backgroundColorFromAmbientLight) {
        this._backgroundColorFromAmbientLight = (backgroundColorFromAmbientLight !== false);
    };

    /**
     * Gets whether the canvas clear color will be derived from {@link AmbientLight} or {@link Canvas#backgroundColor}
     * when {@link Canvas#transparent} is ```true```.
     *
     * When {@link Canvas#transparent} is ```true``` and this is ````true````, then the canvas clear color will
     * be taken from the {@link Scene}'s ambient light color.
     *
     * When {@link Canvas#transparent} is ```true``` and this is ````false````, then the canvas clear color will
     * be taken from {@link Canvas#backgroundColor}.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backgroundColorFromAmbientLight.get = function () {
        return this._backgroundColorFromAmbientLight;
    };

    /**
     * Sets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.backgroundColor.set = function (value) {
        if (value) {
            this._backgroundColor[0] = value[0];
            this._backgroundColor[1] = value[1];
            this._backgroundColor[2] = value[2];
        } else {
            this._backgroundColor[0] = 1.0;
            this._backgroundColor[1] = 1.0;
            this._backgroundColor[2] = 1.0;
        }
        this.glRedraw();
    };

    /**
     * Gets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.backgroundColor.get = function () {
        return this._backgroundColor;
    };

    /**
     * @private
     * @deprecated
     */
    Canvas.prototype.getSnapshot = function getSnapshot (params) {
        throw "Canvas#getSnapshot() has been replaced by Viewer#getSnapshot() - use that method instead.";
    };

    /**
     * Reads colors of pixels from the last rendered frame.
     *
     * Call this method like this:
     *
     * ````JavaScript
     *
     * // Ignore transparent pixels (default is false)
     * var opaqueOnly = true;
     *
     * var colors = new Float32Array(8);
     *
     * viewer.scene.canvas.readPixels([ 100, 22, 12, 33 ], colors, 2, opaqueOnly);
     * ````
     *
     * Then the r,g,b components of the colors will be set to the colors at those pixels.
     *
     * @param {Number[]} pixels
     * @param {Number[]} colors
     * @param {Number} size
     * @param {Boolean} opaqueOnly
     */
    Canvas.prototype.readPixels = function readPixels (pixels, colors, size, opaqueOnly) {
        return this.scene._renderer.readPixels(pixels, colors, size, opaqueOnly);
    };

    /**
     * Simulates lost WebGL context.
     */
    Canvas.prototype.loseWebGLContext = function loseWebGLContext () {
        if (this.canvas.loseContext) {
            this.canvas.loseContext();
        }
    };

    /**
     * The busy {@link Spinner} for this Canvas.
     *
     * @property spinner
     * @type Spinner
     * @final
     */
    prototypeAccessors.spinner.get = function () {
        return this._spinner;
    };

    Canvas.prototype.destroy = function destroy () {
        this.scene.off(this._tick);
        this._spinner._destroy();
        // Memory leak avoidance
        this.canvas.removeEventListener("webglcontextlost", this._webglcontextlostListener);
        this.canvas.removeEventListener("webglcontextrestored", this._webglcontextrestoredListener);
        this.gl = null;
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( Canvas.prototype, prototypeAccessors );

    return Canvas;
}(Component));

/**
 * @desc Provides rendering context to {@link Drawable"}s as xeokit renders them for a frame.
 *
 * Also creates RTC viewing and picking matrices, caching and reusing matrices within each frame.
 *
 * @private
 */
var FrameContext = function FrameContext(scene) {

    this._scene = scene;

    this._matPool = [];
    this._matPoolNextFreeIndex = 0;

    this._rtcViewMats = {};
    this._rtcPickViewMats = {};

    this.reset();
};

/**
 * Called by the renderer before each frame.
 * @private
 */
FrameContext.prototype.reset = function reset () {

    this._matPoolNextFreeIndex = 0;
    this._rtcViewMats = {};
    this._rtcPickViewMats = {};

    /**
     * The WebGL rendering context.
     * @type {WebGLRenderingContext}
     */
    this.gl = this._scene.canvas.gl;

    /**
     * ID of the last {@link WebGLProgram} that was bound during the current frame.
     * @property lastProgramId
     * @type {Number}
     */
    this.lastProgramId = null;

    /**
     * Whether to render a quality representation for triangle surfaces.
     *
     * When ````false````, we'll render them with a fast vertex-shaded Gouraud-shaded representation, which
     * is great for zillions of objects.
     *
     * When ````true````, we'll render them at a better visual quality, using smooth, per-fragment shading
     * and a more realistic lighting model.
     *
     * @property quality
     * @default false
     * @type {Boolean}
     */
    this.pbrEnabled = false;

    /**
     * Whether SAO is currently enabled during the current frame.
     * @property withSAO
     * @default false
     * @type {Boolean}
     */
    this.withSAO = false;

    /**
     * Whether backfaces are currently enabled during the current frame.
     * @property backfaces
     * @default false
     * @type {Boolean}
     */
    this.backfaces = false;

    /**
     * The vertex winding order for what we currently consider to be a backface during current
     * frame: true == "cw", false == "ccw".
     * @property frontFace
     * @default true
     * @type {Boolean}
     */
    this.frontface = true;

    /**
     * The next available texture unit to bind a {@link Texture} to.
     * @defauilt 0
     * @property textureUnit
     * @type {number}
     */
    this.textureUnit = 0;

    /**
     * Performance statistic that counts how many times the renderer has called ````gl.drawElements()```` has been
     * called so far within the current frame.
     * @default 0
     * @property drawElements
     * @type {number}
     */
    this.drawElements = 0;

    /**
     * Performance statistic that counts how many times ````gl.drawArrays()```` has been called so far within
     * the current frame.
     * @default 0
     * @property drawArrays
     * @type {number}
     */
    this.drawArrays = 0;

    /**
     * Performance statistic that counts how many times ````gl.useProgram()```` has been called so far within
     * the current frame.
     * @default 0
     * @property useProgram
     * @type {number}
     */
    this.useProgram = 0;

    /**
     * Statistic that counts how many times ````gl.bindTexture()```` has been called so far within the current frame.
     * @default 0
     * @property bindTexture
     * @type {number}
     */
    this.bindTexture = 0;

    /**
     * Counts how many times the renderer has called ````gl.bindArray()```` so far within the current frame.
     * @defaulr 0
     * @property bindArray
     * @type {number}
     */
    this.bindArray = 0;

    /**
     * Indicates which pass the renderer is currently rendering.
     *
     * See {@link Scene/passes:property"}}Scene#passes{{/crossLink}}, which configures how many passes we render
     * per frame, which typically set to ````2```` when rendering a stereo view.
     *
     * @property pass
     * @type {number}
     */
    this.pass = 0;

    /**
     * The 4x4 viewing transform matrix the renderer is currently using when rendering castsShadows.
     *
     * This sets the viewpoint to look from the point of view of each {@link DirLight}
     * or {@link PointLight} that casts a shadow.
     *
     * @property shadowViewMatrix
     * @type {Number[]}
     */
    this.shadowViewMatrix = null;

    /**
     * The 4x4 viewing projection matrix the renderer is currently using when rendering shadows.
     *
     * @property shadowProjMatrix
     * @type {Number[]}
     */
    this.shadowProjMatrix = null;

    /**
     * The 4x4 viewing transform matrix the renderer is currently using when rendering a ray-pick.
     *
     * This sets the viewpoint to look along the ray given to {@link Scene/pick:method"}}Scene#pick(){{/crossLink}}
     * when picking with a ray.
     *
     * @property pickViewMatrix
     * @type {Number[]}
     */
    this.pickViewMatrix = null;

    /**
     * The 4x4 orthographic projection transform matrix the renderer is currently using when rendering a ray-pick.
     *
     * @property pickProjMatrix
     * @type {Number[]}
     */
    this.pickProjMatrix = null;

    /**
     * Distance to the near clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
     *
     * @property pickZNear
     * @type {Number|*}
     */
    this.pickZNear = 0.01;

    /**
     * Distance to the far clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
     *
     * @property pickZFar
     * @type {Number|*}
     */
    this.pickZFar = 5000;

    /**
     * Whether or not the renderer is currently picking invisible objects.
     *
     * @property pickInvisible
     * @type {Number}
     */
    this.pickInvisible = false;

    /** The current line width.
     *
     * @property lineWidth
     * @type Number
     */
    this.lineWidth = 1;
};

/**
 * Get View matrix for the given RTC center.
 */
FrameContext.prototype.getRTCViewMatrix = function getRTCViewMatrix (rtcCenterHash, rtcCenter) {
    var rtcViewMat = this._rtcViewMats[rtcCenterHash];
    if (!rtcViewMat) {
        rtcViewMat = this._getNewMat();
        createRTCViewMat(this._scene.camera.viewMatrix, rtcCenter, rtcViewMat);
        this._rtcViewMats[rtcCenterHash] = rtcViewMat;
    }
    return rtcViewMat;
};

/**
 * Get picking View RTC matrix for the given RTC center.
 */
FrameContext.prototype.getRTCPickViewMatrix = function getRTCPickViewMatrix (rtcCenterHash, rtcCenter) {
    var rtcPickViewMat = this._rtcPickViewMats[rtcCenterHash];
    if (!rtcPickViewMat) {
        rtcPickViewMat = this._getNewMat();
        var pickViewMat = this.pickViewMatrix || this._scene.camera.viewMatrix;
        createRTCViewMat(pickViewMat, rtcCenter, rtcPickViewMat);
        this._rtcPickViewMats[rtcCenterHash] = rtcPickViewMat;
    }
    return rtcPickViewMat;
};

FrameContext.prototype._getNewMat = function _getNewMat () {
    var mat = this._matPool[this._matPoolNextFreeIndex];
    if (!mat) {
        mat = math.mat4();
        this._matPool[this._matPoolNextFreeIndex] = mat;
    }
    this._matPoolNextFreeIndex++;
    return mat;
};

/*
 * Canvas2Image v0.1
 * Copyright (c) 2008 Jacob Seidelin, cupboy@gmail.com
 * MIT License [http://www.opensource.org/licenses/mit-license.php]
 *
 * Modified by @xeolabs to permit vertical flipping, so that snapshot can be taken from WebGL frame buffers,
 * which vertically flip image data as part of the way that WebGL renders textures.
 */

/**
 * @private
 */
var Canvas2Image = (function () {
    // check if we have canvas support
    var oCanvas = document.createElement("canvas"), sc = String.fromCharCode;

    // no canvas, bail out.
    if (!oCanvas.getContext) {
        return {
            saveAsBMP: function () {
            },
            saveAsPNG: function () {
            },
            saveAsJPEG: function () {
            }
        }
    }

    var bHasImageData = !!(oCanvas.getContext("2d").getImageData), bHasDataURL = !!(oCanvas.toDataURL),
        bHasBase64 = !!(window.btoa);

    // ok, we're good
    var readCanvasData = function (oCanvas) {
        var iWidth = parseInt(oCanvas.width), iHeight = parseInt(oCanvas.height);
        return oCanvas.getContext("2d").getImageData(0, 0, iWidth, iHeight);
    };

    // base64 encodes either a string or an array of charcodes
    var encodeData = function (data) {
        var i, aData, strData = "";

        if (typeof data == "string") {
            strData = data;
        } else {
            aData = data;
            for (i = 0; i < aData.length; i++) {
                strData += sc(aData[i]);
            }
        }
        return btoa(strData);
    };

    // creates a base64 encoded string containing BMP data takes an imagedata object as argument
    var createBMP = function (oData) {
        var strHeader = '';
        var iWidth = oData.width;
        var iHeight = oData.height;

        strHeader += 'BM';

        var iFileSize = iWidth * iHeight * 4 + 54; // total header size = 54 bytes
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);

        strHeader += sc(0, 0, 0, 0, 54, 0, 0, 0); // data offset
        strHeader += sc(40, 0, 0, 0); // info header size

        var iImageWidth = iWidth;
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);

        var iImageHeight = iHeight;
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);

        strHeader += sc(1, 0, 32, 0); // num of planes & num of bits per pixel
        strHeader += sc(0, 0, 0, 0); // compression = none

        var iDataSize = iWidth * iHeight * 4;
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);

        strHeader += sc(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // these bytes are not used

        var aImgData = oData.data;
        var strPixelData = "";
        var x;
        var y = iHeight;
        var iOffsetX;
        var iOffsetY;
        var strPixelRow;

        do {
            iOffsetY = iWidth * (y - 1) * 4;
            strPixelRow = "";
            for (x = 0; x < iWidth; x++) {
                iOffsetX = 4 * x;
                strPixelRow += sc(
                    aImgData[iOffsetY + iOffsetX + 2], // B
                    aImgData[iOffsetY + iOffsetX + 1], // G
                    aImgData[iOffsetY + iOffsetX],     // R
                    aImgData[iOffsetY + iOffsetX + 3]  // A
                );
            }
            strPixelData += strPixelRow;
        } while (--y);

        return encodeData(strHeader + strPixelData);
    };

    // sends the generated file to the client
    var saveFile = function (strData) {
        if (!window.open(strData)) {
            document.location.href = strData;
        }
    };

    var makeDataURI = function (strData, strMime) {
        return "data:" + strMime + ";base64," + strData;
    };

    // generates a <img> object containing the imagedata
    var makeImageObject = function (strSource) {
        var oImgElement = document.createElement("img");
        oImgElement.src = strSource;
        return oImgElement;
    };

    var scaleCanvas = function (oCanvas, iWidth, iHeight, flipy) {
        if (iWidth && iHeight) {
            var oSaveCanvas = document.createElement("canvas");
            oSaveCanvas.width = iWidth;
            oSaveCanvas.height = iHeight;
            oSaveCanvas.style.width = iWidth + "px";
            oSaveCanvas.style.height = iHeight + "px";
            var oSaveCtx = oSaveCanvas.getContext("2d");
            if (flipy) {
                oSaveCtx.save();
                oSaveCtx.scale(1.0, -1.0);
                oSaveCtx.imageSmoothingEnabled = true;
                oSaveCtx.drawImage(oCanvas, 0, 0, oCanvas.width, oCanvas.height, 0, 0, iWidth, -iHeight);
                oSaveCtx.restore();
            } else {
                oSaveCtx.imageSmoothingEnabled = true;
                oSaveCtx.drawImage(oCanvas, 0, 0, oCanvas.width, oCanvas.height, 0, 0, iWidth, iHeight);
            }
            return oSaveCanvas;
        }
        return oCanvas;
    };

    return {
        saveAsPNG: function (oCanvas, bReturnImg, iWidth, iHeight, flipy) {
            if (!bHasDataURL) { return false; }
            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight, flipy);
            var strMime = "image/png";
            var strData = oScaledCanvas.toDataURL(strMime);
            if (bReturnImg) {
                return makeImageObject(strData);
            } else {
                saveFile(strData);
            }
            return true;
        },

        saveAsJPEG: function (oCanvas, bReturnImg, iWidth, iHeight, flipy) {
            if (!bHasDataURL) { return false; }
            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight, flipy);
            var strMime = "image/jpeg";
            var strData = oScaledCanvas.toDataURL(strMime);
            // check if browser actually supports jpeg by looking for the mime type in the data uri. if not, return false
            if (strData.indexOf(strMime) != 5) { return false; }
            if (bReturnImg) {
                return makeImageObject(strData);
            } else {
                saveFile(strData);
            }
            return true;
        },

        saveAsBMP: function (oCanvas, bReturnImg, iWidth, iHeight, flipy) {
            if (!(bHasDataURL && bHasImageData && bHasBase64)) { return false; }
            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight, flipy);
            var strMime = "image/bmp";
            var oData = readCanvasData(oScaledCanvas), strImgData = createBMP(oData);
            if (bReturnImg) {
                return makeImageObject(makeDataURI(strImgData, strMime));
            } else {
                saveFile(makeDataURI(strImgData, strMime));
            }
            return true;
        }
    };
})();

/**
 * @desc Represents a WebGL render buffer.
 * @private
 */
var RenderBuffer = function RenderBuffer(canvas, gl, options) {
    options = options || {};
    this.gl = gl;
    this.allocated = false;
    this.canvas = canvas;
    this.buffer = null;
    this.bound = false;
    this.size = options.size;
    this._hasDepthTexture = !!options.depthTexture;
};

RenderBuffer.prototype.setSize = function setSize (size) {
    this.size = size;
};

RenderBuffer.prototype.webglContextRestored = function webglContextRestored (gl) {
    this.gl = gl;
    this.buffer = null;
    this.allocated = false;
    this.bound = false;
};

RenderBuffer.prototype.bind = function bind () {
    this._touch();
    if (this.bound) {
        return;
    }
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.buffer.framebuf);
    this.bound = true;
};

RenderBuffer.prototype._touch = function _touch () {

    var width;
    var height;
    var gl = this.gl;

    if (this.size) {
        width = this.size[0];
        height = this.size[1];

    } else {
        width = gl.drawingBufferWidth;
        height = gl.drawingBufferHeight;
    }

    if (this.buffer) {

        if (this.buffer.width === width && this.buffer.height === height) {
            return;

        } else {
            gl.deleteTexture(this.buffer.texture);
            gl.deleteFramebuffer(this.buffer.framebuf);
            gl.deleteRenderbuffer(this.buffer.renderbuf);
        }
    }

    var colorTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    var depthTexture;

    if (this._hasDepthTexture) {
        depthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
    }

    var renderbuf = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuf);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    var framebuf = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);

    if (this._hasDepthTexture) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
    } else {
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuf);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Verify framebuffer is OK

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    if (!gl.isFramebuffer(framebuf)) {
        throw "Invalid framebuffer";
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (status) {

        case gl.FRAMEBUFFER_COMPLETE:
            break;

        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

        case gl.FRAMEBUFFER_UNSUPPORTED:
            throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";

        default:
            throw "Incomplete framebuffer: " + status;
    }

    this.buffer = {
        framebuf: framebuf,
        renderbuf: renderbuf,
        texture: colorTexture,
        depthTexture: depthTexture,
        width: width,
        height: height
    };

    this.bound = false;
};

RenderBuffer.prototype.clear = function clear () {
    if (!this.bound) {
        throw "Render buffer not bound";
    }
    var gl = this.gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

RenderBuffer.prototype.read = function read (pickX, pickY) {
    var x = pickX;
    var y = this.gl.drawingBufferHeight - pickY;
    var pix = new Uint8Array(4);
    var gl = this.gl;
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pix);
    return pix;
};

RenderBuffer.prototype.readImage = function readImage (params) {

    var gl = this.gl;
    var imageDataCache = this._getImageDataCache();
    var pixelData = imageDataCache.pixelData;
    var canvas = imageDataCache.canvas;
    var imageData = imageDataCache.imageData;
    var context = imageDataCache.context;

    gl.readPixels(0, 0, this.buffer.width, this.buffer.height, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

    imageData.data.set(pixelData);
    context.putImageData(imageData, 0, 0);

    var imageWidth = params.width || canvas.width;
    var imageHeight = params.height || canvas.height;
    var format = params.format || "jpeg";
    var flipy = true; // Account for WebGL texture flipping

    var image;

    switch (format) {
        case "jpeg":
            image = Canvas2Image.saveAsJPEG(canvas, true, imageWidth, imageHeight, flipy);
            break;
        case "png":
            image = Canvas2Image.saveAsPNG(canvas, true, imageWidth, imageHeight, flipy);
            break;
        case "bmp":
            image = Canvas2Image.saveAsBMP(canvas, true, imageWidth, imageHeight, flipy);
            break;
        default:
            console.error("Unsupported image format: '" + format + "' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'jpeg'");
            image = Canvas2Image.saveAsJPEG(canvas, true, imageWidth, imageHeight, flipy);
    }

    return image.src;
};

RenderBuffer.prototype._getImageDataCache = function _getImageDataCache () {

    var bufferWidth = this.buffer.width;
    var bufferHeight = this.buffer.height;

    var imageDataCache = this._imageDataCache;

    if (imageDataCache) {
        if (imageDataCache.width !== bufferWidth || imageDataCache.height !== bufferHeight) {
            this._imageDataCache = null;
            imageDataCache = null;
        }
    }

    if (!imageDataCache) {

        var canvas = document.createElement('canvas');
        canvas.width = bufferWidth;
        canvas.height = bufferHeight;

        var context = canvas.getContext('2d');
        var imageData = context.createImageData(bufferWidth, bufferHeight);

        imageDataCache = {
            pixelData: new Uint8Array(bufferWidth * bufferHeight * 4),
            canvas: canvas,
            context: context,
            imageData: imageData,
            width: bufferWidth,
            height: bufferHeight
        };

        this._imageDataCache = imageDataCache;
    }

    return imageDataCache;
};

RenderBuffer.prototype.unbind = function unbind () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.bound = false;
};

RenderBuffer.prototype.getTexture = function getTexture () {
    var self = this;
    return this._texture || (this._texture = {
        renderBuffer: this,
        bind: function (unit) {
            if (self.buffer && self.buffer.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, self.buffer.texture);
                return true;
            }
            return false;
        },
        unbind: function (unit) {
            if (self.buffer && self.buffer.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, null);
            }
        }
    });
};

RenderBuffer.prototype.hasDepthTexture = function hasDepthTexture () {
    return this._hasDepthTexture;
};

RenderBuffer.prototype.getDepthTexture = function getDepthTexture () {
    if (!this._hasDepthTexture) {
        return null;
    }
    var self = this;
    return this._depthTexture || (this._dethTexture = {
        renderBuffer: this,
        bind: function (unit) {
            if (self.buffer && self.buffer.depthTexture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, self.buffer.depthTexture);
                return true;
            }
            return false;
        },
        unbind: function (unit) {
            if (self.buffer && self.buffer.depthTexture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, null);
            }
        }
    });
};

RenderBuffer.prototype.destroy = function destroy () {
    if (this.allocated) {
        var gl = this.gl;
        gl.deleteTexture(this.buffer.texture);
        gl.deleteTexture(this.buffer.depthTexture);
        gl.deleteFramebuffer(this.buffer.framebuf);
        gl.deleteRenderbuffer(this.buffer.renderbuf);
        this.allocated = false;
        this.buffer = null;
        this.bound = false;
    }
    this._imageDataCache = null;
    this._texture = null;
    this._depthTexture = null;
};

/**
 * @desc Pick result returned by {@link Scene#pick}.
 *
 */
var PickResult = function PickResult() {

    /**
     * Picked entity.
     * Null when no entity was picked.
     * @property entity
     * @type {Entity|*}
     */
    this.entity = null;

    /**
     * Type of primitive that was picked - usually "triangle".
     * Null when no primitive was picked.
     * @property primitive
     * @type {String}
     */
    this.primitive = null;

    /**
     * Index of primitive that was picked.
     * -1 when no entity was picked.
     * @property primIndex
     * @type {number}
     */
    this.primIndex = -1;

    /**
     * True when the picked surface position is full precision.
     * When false, the picked surface position should be regarded as approximate.
     * Full-precision surface picking is performed with the {@link Scene#pick} method's ````pickSurfacePrecision```` option.
     * @property pickSurfacePrecision
     * @type {Boolean}
     */
    this.pickSurfacePrecision = false;

    this._canvasPos = new Int16Array([0, 0]);
    this._origin = new Float64Array([0, 0, 0]);
    this._direction = new Float64Array([0, 0, 0]);
    this._indices = new Int32Array(3);
    this._localPos = new Float64Array([0, 0, 0]);
    this._worldPos = new Float64Array([0, 0, 0]);
    this._viewPos = new Float64Array([0, 0, 0]);
    this._bary = new Float64Array([0, 0, 0]);
    this._worldNormal = new Float64Array([0, 0, 0]);
    this._uv = new Float64Array([0, 0]);

    this.reset();
};

var prototypeAccessors$a = { canvasPos: { configurable: true },origin: { configurable: true },direction: { configurable: true },indices: { configurable: true },localPos: { configurable: true },worldPos: { configurable: true },viewPos: { configurable: true },bary: { configurable: true },worldNormal: { configurable: true },uv: { configurable: true } };

/**
 * Canvas coordinates when picking with a 2D pointer.
 * @property canvasPos
 * @type {Number[]}
 */
prototypeAccessors$a.canvasPos.get = function () {
    return this._gotCanvasPos ? this._canvasPos : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.canvasPos.set = function (value) {
    if (value) {
        this._canvasPos[0] = value[0];
        this._canvasPos[1] = value[1];
        this._gotCanvasPos = true;
    } else {
        this._gotCanvasPos = false;
    }
};

/**
 * World-space 3D ray origin when raypicked.
 * @property origin
 * @type {Number[]}
 */
prototypeAccessors$a.origin.get = function () {
    return this._gotOrigin ? this._origin : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.origin.set = function (value) {
    if (value) {
        this._origin[0] = value[0];
        this._origin[1] = value[1];
        this._origin[2] = value[2];
        this._gotOrigin = true;
    } else {
        this._gotOrigin = false;
    }
};

/**
 * World-space 3D ray direction when raypicked.
 * @property direction
 * @type {Number[]}
 */
prototypeAccessors$a.direction.get = function () {
    return this._gotDirection ? this._direction : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.direction.set = function (value) {
    if (value) {
        this._direction[0] = value[0];
        this._direction[1] = value[1];
        this._direction[2] = value[2];
        this._gotDirection = true;
    } else {
        this._gotDirection = false;
    }
};
    
/**
 * Picked triangle's vertex indices.
 * Only defined when an entity and triangle was picked.
 * @property indices
 * @type {Int32Array}
 */
prototypeAccessors$a.indices.get = function () {
    return this.entity && this._gotIndices ? this._indices : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.indices.set = function (value) {
    if (value) {
        this._indices[0] = value[0];
        this._indices[1] = value[1];
        this._indices[2] = value[2];
        this._gotIndices = true;
    } else {
        this._gotIndices = false;
    }
};

/**
 * Picked Local-space point on surface.
 * Only defined when an entity and a point on its surface was picked.
 * @property localPos
 * @type {Number[]}
 */
prototypeAccessors$a.localPos.get = function () {
    return this.entity && this._gotLocalPos ? this._localPos : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.localPos.set = function (value) {
    if (value) {
        this._localPos[0] = value[0];
        this._localPos[1] = value[1];
        this._localPos[2] = value[2];
        this._gotLocalPos = true;
    } else {
        this._gotLocalPos = false;
    }
};

/**
 * Picked World-space point on surface.
 * Only defined when an entity and a point on its surface was picked.
 * @property worldPos
 * @type {Number[]}
 */
prototypeAccessors$a.worldPos.get = function () {
    return this.entity && this._gotWorldPos ? this._worldPos : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.worldPos.set = function (value) {
    if (value) {
        this._worldPos[0] = value[0];
        this._worldPos[1] = value[1];
        this._worldPos[2] = value[2];
        this._gotWorldPos = true;
    } else {
        this._gotWorldPos = false;
    }
};

/**
 * Picked View-space point on surface.
 * Only defined when an entity and a point on its surface was picked.
 * @property viewPos
 * @type {Number[]}
 */
prototypeAccessors$a.viewPos.get = function () {
    return this.entity && this._gotViewPos ? this._viewPos : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.viewPos.set = function (value) {
    if (value) {
        this._viewPos[0] = value[0];
        this._viewPos[1] = value[1];
        this._viewPos[2] = value[2];
        this._gotViewPos = true;
    } else {
        this._gotViewPos = false;
    }
};

/**
 * Barycentric coordinate within picked triangle.
 * Only defined when an entity and a point on its surface was picked.
 * @property bary
 * @type {Number[]}
 */
prototypeAccessors$a.bary.get = function () {
    return this.entity && this._gotBary ? this._bary : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.bary.set = function (value) {
    if (value) {
        this._bary[0] = value[0];
        this._bary[1] = value[1];
        this._bary[2] = value[2];
        this._gotBary = true;
    } else {
        this._gotBary = false;
    }
};

/**
 * Normal vector at picked position on surface.
 * Only defined when an entity and a point on its surface was picked.
 * @property worldNormal
 * @type {Number[]}
 */
prototypeAccessors$a.worldNormal.get = function () {
    return this.entity && this._gotWorldNormal ? this._worldNormal : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.worldNormal.set = function (value) {
    if (value) {
        this._worldNormal[0] = value[0];
        this._worldNormal[1] = value[1];
        this._worldNormal[2] = value[2];
        this._gotWorldNormal = true;
    } else {
        this._gotWorldNormal = false;
    }
};

/**
 * UV coordinates at picked position on surface.
 * Only defined when an entity and a point on its surface was picked.
 * @property uv
 * @type {Number[]}
 */
prototypeAccessors$a.uv.get = function () {
    return this.entity && this._gotUV ? this._uv : null;
};

/**
 * @private
 * @param value
 */
prototypeAccessors$a.uv.set = function (value) {
    if (value) {
        this._uv[0] = value[0];
        this._uv[1] = value[1];
        this._gotUV = true;
    } else {
        this._gotUV = false;
    }
};

/**
 * @private
 */
PickResult.prototype.reset = function reset () {
    this.entity = null;
    this.primIndex = -1;
    this.primitive = null;
    this.pickSurfacePrecision = false;
    this._gotCanvasPos = false;
    this._gotOrigin = false;
    this._gotDirection = false;
    this._gotIndices = false;
    this._gotLocalPos = false;
    this._gotWorldPos = false;
    this._gotViewPos = false;
    this._gotBary = false;
    this._gotWorldNormal = false;
    this._gotUV = false;
};

Object.defineProperties( PickResult.prototype, prototypeAccessors$a );

/**
 * @desc Represents a vertex or fragment stage within a {@link Program}.
 * @private
 */
var Shader = function Shader(gl, type, source) {

    this.allocated = false;
    this.compiled = false;
    this.handle = gl.createShader(type);

    if (!this.handle) {
        this.errors = [
            "Failed to allocate"
        ];
        return;
    }

    this.allocated = true;

    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);

    this.compiled = gl.getShaderParameter(this.handle, gl.COMPILE_STATUS);

    if (!this.compiled) {

        if (!gl.isContextLost()) { // Handled explicitly elsewhere, so won't re-handle here

            var lines = source.split("\n");
            var numberedLines = [];
            for (var i = 0; i < lines.length; i++) {
                numberedLines.push((i + 1) + ": " + lines[i] + "\n");
            }
            this.errors = [];
            this.errors.push("");
            this.errors.push(gl.getShaderInfoLog(this.handle));
            this.errors = this.errors.concat(numberedLines.join(""));
        }
    }
};

Shader.prototype.destroy = function destroy () {

};

/**
 * @desc A low-level component that represents a WebGL Sampler.
 * @private
 */
var Sampler = function Sampler(gl, location) {
    this.bindTexture = function (texture, unit) {
        if (texture.bind(unit)) {
            gl.uniform1i(location, unit);
            return true;
        }
        return false;
    };
};

/**
 * @desc Represents a WebGL vertex attribute buffer (VBO).
 * @private
 * @param gl {WebGLRenderingContext} The WebGL rendering context.
 */
var Attribute = function Attribute(gl, location) {
    this._gl = gl;
    this.location = location;
};

Attribute.prototype.bindArrayBuffer = function bindArrayBuffer (arrayBuf) {
    if (!arrayBuf) {
        return;
    }
    arrayBuf.bind();
    this._gl.enableVertexAttribArray(this.location);
    this._gl.vertexAttribPointer(this.location, arrayBuf.itemSize, arrayBuf.itemType, arrayBuf.normalized, arrayBuf.stride, arrayBuf.offset);
};

var ids$4 = new Map({});

function joinSansComments(srcLines) {
    var src = [];
    var line;
    var n;
    for (var i = 0, len = srcLines.length; i < len; i++) {
        line = srcLines[i];
        n = line.indexOf("/");
        if (n > 0) {
            if (line.charAt(n + 1) === "/") {
                line = line.substring(0, n);
            }
        }
        src.push(line);
    }
    return src.join("\n");
}

function logErrors(errors) {
    console.error(errors.join("\n"));
}

/**
 * @desc Represents a WebGL program.
 * @private
 */
var Program = function Program(gl, shaderSource) {
    this.id = ids$4.addItem({});
    this.source = shaderSource;
    this.init(gl);
};

Program.prototype.init = function init (gl) {
    this.gl = gl;
    this.allocated = false;
    this.compiled = false;
    this.linked = false;
    this.validated = false;
    this.errors = null;
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this._vertexShader = new Shader(gl, gl.VERTEX_SHADER, joinSansComments(this.source.vertex));
    this._fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, joinSansComments(this.source.fragment));
    if (!this._vertexShader.allocated) {
        this.errors = ["Vertex shader failed to allocate"].concat(this._vertexShader.errors);
        logErrors(this.errors);
        return;
    }
    if (!this._fragmentShader.allocated) {
        this.errors = ["Fragment shader failed to allocate"].concat(this._fragmentShader.errors);
        logErrors(this.errors);
        return;
    }
    this.allocated = true;
    if (!this._vertexShader.compiled) {
        this.errors = ["Vertex shader failed to compile"].concat(this._vertexShader.errors);
        logErrors(this.errors);
        return;
    }
    if (!this._fragmentShader.compiled) {
        this.errors = ["Fragment shader failed to compile"].concat(this._fragmentShader.errors);
        logErrors(this.errors);
        return;
    }
    this.compiled = true;
    var a;
    var i;
    var u;
    var uName;
    var location;
    this.handle = gl.createProgram();
    if (!this.handle) {
        this.errors = ["Failed to allocate program"];
        return;
    }
    gl.attachShader(this.handle, this._vertexShader.handle);
    gl.attachShader(this.handle, this._fragmentShader.handle);
    gl.linkProgram(this.handle);
    this.linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
    // HACK: Disable validation temporarily: https://github.com/xeolabs/xeokit/issues/5
    // Perhaps we should defer validation until render-time, when the program has values set for all inputs?
    this.validated = true;
    if (!this.linked || !this.validated) {
        this.errors = [];
        this.errors.push("");
        this.errors.push(gl.getProgramInfoLog(this.handle));
        this.errors.push("\nVertex shader:\n");
        this.errors = this.errors.concat(this.source.vertex);
        this.errors.push("\nFragment shader:\n");
        this.errors = this.errors.concat(this.source.fragment);
        logErrors(this.errors);
        return;
    }
    var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < numUniforms; ++i) {
        u = gl.getActiveUniform(this.handle, i);
        if (u) {
            uName = u.name;
            if (uName[uName.length - 1] === "\u0000") {
                uName = uName.substr(0, uName.length - 1);
            }
            location = gl.getUniformLocation(this.handle, uName);
            if ((u.type === gl.SAMPLER_2D) || (u.type === gl.SAMPLER_CUBE) || (u.type === 35682)) {
                this.samplers[uName] = new Sampler(gl, location);
            } else {
                this.uniforms[uName] = location;
            }
        }
    }
    var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
    for (i = 0; i < numAttribs; i++) {
        a = gl.getActiveAttrib(this.handle, i);
        if (a) {
            location = gl.getAttribLocation(this.handle, a.name);
            this.attributes[a.name] = new Attribute(gl, location);
        }
    }
    this.allocated = true;
};

Program.prototype.bind = function bind () {
    if (!this.allocated) {
        return;
    }
    this.gl.useProgram(this.handle);
};

Program.prototype.getLocation = function getLocation (name) {
    if (!this.allocated) {
        return;
    }
    return this.uniforms[name];
};

Program.prototype.getAttribute = function getAttribute (name) {
    if (!this.allocated) {
        return;
    }
    return this.attributes[name];
};

Program.prototype.bindTexture = function bindTexture (name, texture, unit) {
    if (!this.allocated) {
        return false;
    }
    var sampler = this.samplers[name];
    if (sampler) {
        return sampler.bindTexture(texture, unit);
    } else {
        return false;
    }
};

Program.prototype.destroy = function destroy () {
    if (!this.allocated) {
        return;
    }
    ids$4.removeItem(this.id);
    this.gl.deleteProgram(this.handle);
    this.gl.deleteShader(this._vertexShader.handle);
    this.gl.deleteShader(this._fragmentShader.handle);
    this.handle = null;
    this.attributes = null;
    this.uniforms = null;
    this.samplers = null;
    this.allocated = false;
};

/**
 * @desc Represents a WebGL ArrayBuffer.
 *
 * @private
 */
var ArrayBuf = function ArrayBuf(gl, type, data, numItems, itemSize, usage, normalized, stride, offset) {

    this._gl = gl;
    this.type = type;
    this.allocated = false;

    switch (data.constructor) {

        case Uint8Array:
            this.itemType = gl.UNSIGNED_BYTE;
            this.itemByteSize = 1;
            break;

        case Int8Array:
            this.itemType = gl.BYTE;
            this.itemByteSize = 1;
            break;

        case  Uint16Array:
            this.itemType = gl.UNSIGNED_SHORT;
            this.itemByteSize = 2;
            break;

        case  Int16Array:
            this.itemType = gl.SHORT;
            this.itemByteSize = 2;
            break;

        case Uint32Array:
            this.itemType = gl.UNSIGNED_INT;
            this.itemByteSize = 4;
            break;

        case Int32Array:
            this.itemType = gl.INT;
            this.itemByteSize = 4;
            break;

        default:
            this.itemType = gl.FLOAT;
            this.itemByteSize = 4;
    }

    this.usage = usage;
    this.length = 0;
    this.dataLength = numItems;
    this.numItems = 0;
    this.itemSize = itemSize;
    this.normalized = !!normalized;
    this.stride = stride || 0;
    this.offset = offset || 0;

    this._allocate(data);
};

ArrayBuf.prototype._allocate = function _allocate (data) {
    this.allocated = false;
    this._handle = this._gl.createBuffer();
    if (!this._handle) {
        throw "Failed to allocate WebGL ArrayBuffer";
    }
    if (this._handle) {
        this._gl.bindBuffer(this.type, this._handle);
        this._gl.bufferData(this.type, data.length > this.dataLength ? data.slice(0, this.dataLength) : data, this.usage);
        this._gl.bindBuffer(this.type, null);
        this.length = data.length;
        this.numItems = this.length / this.itemSize;
        this.allocated = true;
    }
};

ArrayBuf.prototype.setData = function setData (data, offset) {
    if (!this.allocated) {
        return;
    }
    if (data.length + (offset || 0) > this.length) {        // Needs reallocation
        this.destroy();
        this._allocate(data);
    } else {        // No reallocation needed
        this._gl.bindBuffer(this.type, this._handle);
        if (offset || offset === 0) {
            this._gl.bufferSubData(this.type, offset * this.itemByteSize, data);
        } else {
            this._gl.bufferData(this.type, data, this.usage);
        }
        this._gl.bindBuffer(this.type, null);
    }
};

ArrayBuf.prototype.bind = function bind () {
    if (!this.allocated) {
        return;
    }
    this._gl.bindBuffer(this.type, this._handle);
};

ArrayBuf.prototype.unbind = function unbind () {
    if (!this.allocated) {
        return;
    }
    this._gl.bindBuffer(this.type, null);
};

ArrayBuf.prototype.destroy = function destroy () {
    if (!this.allocated) {
        return;
    }
    this._gl.deleteBuffer(this._handle);
    this._handle = null;
    this.allocated = false;
};

var OcclusionLayer = function OcclusionLayer(scene, rtcCenter) {

    this.scene = scene;
    this.aabb = math.AABB3();
    this.rtcCenter = math.vec3(rtcCenter);
    this.rtcCenterHash = this.rtcCenter.join();
    this.numMarkers = 0;
    this.markers = {};
    this.markerList = [];              // Ordered array of Markers
    this.markerIndices = {};           // ID map of Marker indices in _markerList
    this.positions = [];               // Packed array of World-space marker positions
    this.indices = [];                 // Indices corresponding to array above
    this.positionsBuf = null;
    this.lenPositionsBuf = 0;
    this.indicesBuf = null;
    this.sectionPlanesActive = [];
    this.culledBySectionPlanes = false;
    this.occlusionTestList = [];       // List of
    this.lenOcclusionTestList = 0;
    this.pixels = [];
    this.aabbDirty = false;
    this.markerListDirty = false;
    this.positionsDirty = true;
    this.occlusionTestListDirty = false;
};

OcclusionLayer.prototype.addMarker = function addMarker (marker) {
    this.markers[marker.id] = marker;
    this.markerListDirty = true;
    this.numMarkers++;
};

OcclusionLayer.prototype.markerWorldPosUpdated = function markerWorldPosUpdated (marker) {
    if (!this.markers[marker.id]) { // Not added
        return;
    }
    var i = this.markerIndices[marker.id];
    this.positions[i * 3 + 0] = marker.worldPos[0];
    this.positions[i * 3 + 1] = marker.worldPos[1];
    this.positions[i * 3 + 2] = marker.worldPos[2];
    this.positionsDirty = true; // TODO: avoid reallocating VBO each time
};

OcclusionLayer.prototype.removeMarker = function removeMarker (marker) {
    delete this.markers[marker.id];
    this.markerListDirty = true;
    this.numMarkers--;
};

OcclusionLayer.prototype.update = function update () {
    if (this.markerListDirty) {
        this._buildMarkerList();
        this.markerListDirty = false;
        this.positionsDirty = true;
        this.occlusionTestListDirty = true;
    }
    if (this.positionsDirty) { //////////////  TODO: Don't rebuild this when positions change, very wasteful
        this._buildPositions();
        this.positionsDirty = false;
        this.aabbDirty = true;
        this.vbosDirty = true;
    }
    if (this.aabbDirty) {
        this._buildAABB();
        this.aabbDirty = false;
    }
    if (this.vbosDirty) {
        this._buildVBOs();
        this.vbosDirty = false;
    }
    if (this.occlusionTestListDirty) {
        this._buildOcclusionTestList();
    }
    this._updateActiveSectionPlanes();
};

OcclusionLayer.prototype._buildMarkerList = function _buildMarkerList () {
    this.numMarkers = 0;
    for (var id in this.markers) {
        if (this.markers.hasOwnProperty(id)) {
            this.markerList[this.numMarkers] = this.markers[id];
            this.markerIndices[id] = this.numMarkers;
            this.numMarkers++;
        }
    }
    this.markerList.length = this.numMarkers;
};

OcclusionLayer.prototype._buildPositions = function _buildPositions () {
    var j = 0;
    for (var i = 0; i < this.numMarkers; i++) {
        if (this.markerList[i]) {
            var marker = this.markerList[i];
            var worldPos = marker.worldPos;
            this.positions[j++] = worldPos[0];
            this.positions[j++] = worldPos[1];
            this.positions[j++] = worldPos[2];
            this.indices[i] = i;
        }
    }
    this.positions.length = this.numMarkers * 3;
    this.indices.length = this.numMarkers;
};

OcclusionLayer.prototype._buildAABB = function _buildAABB () {
    var aabb = this.aabb;
    math.collapseAABB3(aabb);
    math.expandAABB3Points3(aabb, this.positions);
    var rtcCenter = this.rtcCenter;
    aabb[0] += rtcCenter[0];
    aabb[1] += rtcCenter[1];
    aabb[2] += rtcCenter[2];
    aabb[3] += rtcCenter[0];
    aabb[4] += rtcCenter[1];
    aabb[5] += rtcCenter[2];
};

OcclusionLayer.prototype._buildVBOs = function _buildVBOs () {
    if (this.positionsBuf) {
        if (this.lenPositionsBuf === this.positions.length) { // Just updating buffer elements, don't need to reallocate
            this.positionsBuf.setData(this.positions); // Indices don't need updating
            return;
        }
        this.positionsBuf.destroy();
        this.positionsBuf = null;
        this.indicesBuf.destroy();
        this.indicesBuf = null;
    }
    var gl = this.scene.canvas.gl;
    var lenPositions = this.numMarkers * 3;
    var lenIndices = this.numMarkers;
    this.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.positions), lenPositions, 3, gl.STATIC_DRAW);
    this.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), lenIndices, 1, gl.STATIC_DRAW);
    this.lenPositionsBuf = this.positions.length;
};

OcclusionLayer.prototype._buildOcclusionTestList = function _buildOcclusionTestList () {
    var canvas = this.scene.canvas;
    var near = this.scene.camera.perspective.near; // Assume near enough to ortho near
    var boundary = canvas.boundary;
    var canvasWidth = boundary[2];
    var canvasHeight = boundary[3];
    var lenPixels = 0;
    this.lenOcclusionTestList = 0;
    for (var i = 0; i < this.numMarkers; i++) {
        var marker = this.markerList[i];
        var viewPos = marker.viewPos;
        if (viewPos[2] > -near) { // Clipped by near plane
            marker._setVisible(false);
            continue;
        }
        var canvasPos = marker.canvasPos;
        var canvasX = canvasPos[0];
        var canvasY = canvasPos[1];
        if ((canvasX + 10) < 0 || (canvasY + 10) < 0 || (canvasX - 10) > canvasWidth || (canvasY - 10) > canvasHeight) {
            marker._setVisible(false);
            continue;
        }
        if (marker.entity && !marker.entity.visible) {
            marker._setVisible(false);
            continue;
        }
        if (marker.occludable) {
            this.occlusionTestList[this.lenOcclusionTestList++] = marker;
            this.pixels[lenPixels++] = canvasX;
            this.pixels[lenPixels++] = canvasY;
            continue;
        }
        marker._setVisible(true);
    }
};

OcclusionLayer.prototype._updateActiveSectionPlanes = function _updateActiveSectionPlanes () {
    var sectionPlanes = this.scene._sectionPlanesState.sectionPlanes;
    var numSectionPlanes = sectionPlanes.length;
    if (numSectionPlanes > 0) {
        for (var i = 0; i < numSectionPlanes; i++) {
            var sectionPlane = sectionPlanes[i];
            if (!sectionPlane.active) {
                this.sectionPlanesActive[i] = false;
            } else {
                var intersect = math.planeAABB3Intersect(sectionPlane.dir, sectionPlane.dist, this.aabb);
                var outside = (intersect === -1);
                if (outside) {
                    this.culledBySectionPlanes = true;
                    return;
                }
                var intersecting = (intersect === 0);
                this.sectionPlanesActive[i] = intersecting;
            }
        }
    }
    this.culledBySectionPlanes = false;
};

OcclusionLayer.prototype.destroy = function destroy () {
    this.markers = {};
    this.markerList.length = 0;
    if (this.positionsBuf) {
        this.positionsBuf.destroy();
    }
    if (this.indicesBuf) {
        this.indicesBuf.destroy();
    }
};

var MARKER_COLOR = math.vec3([1.0, 0.0, 0.0]);
var POINT_SIZE = 20;

var tempVec3a$Z = math.vec3();

/**
 * Manages occlusion testing. Private member of a Renderer.
 */
var OcclusionTester = function OcclusionTester(scene) {
    var this$1 = this;


    this._scene = scene;

    this._occlusionLayers = {};
    this._occlusionLayersList = [];
    this._occlusionLayersListDirty = false;

    this._shaderSource = null;
    this._program = null;

    this._shaderSourceHash = null;

    this._shaderSourceDirty = true;     // Need to build shader source code ?
    this._programDirty = false;         // Need to build shader program ?

    this._markersToOcclusionLayersMap = {};

    this._onCameraViewMatrix = scene.camera.on("viewMatrix", function () {
        this$1._occlusionTestListDirty = true;
    });

    this._onCameraProjMatrix = scene.camera.on("projMatrix", function () {
        this$1._occlusionTestListDirty = true;
    });

    this._onCanvasBoundary = scene.canvas.on("boundary", function () {
        this$1._occlusionTestListDirty = true;
    });
};

var prototypeAccessors$9 = { needOcclusionTest: { configurable: true } };

/**
 * Adds a Marker for occlusion testing.
 * @param marker
 */
OcclusionTester.prototype.addMarker = function addMarker (marker) {
    var rtcCenterHash = marker.rtcCenter.join();
    var occlusionLayer = this._occlusionLayers[rtcCenterHash];
    if (!occlusionLayer) {
        occlusionLayer = new OcclusionLayer(this._scene, marker.rtcCenter);
        this._occlusionLayers[occlusionLayer.rtcCenterHash] = occlusionLayer;
        this._occlusionLayersListDirty = true;
    }
    occlusionLayer.addMarker(marker);
    this._markersToOcclusionLayersMap[marker.id] = occlusionLayer;
    this._occlusionTestListDirty = true;
};

/**
 * Notifies OcclusionTester that a Marker has updated its World-space position.
 * @param marker
 */
OcclusionTester.prototype.markerWorldPosUpdated = function markerWorldPosUpdated (marker) {
    var occlusionLayer = this._markersToOcclusionLayersMap[marker.id];
    if (!occlusionLayer) {
        marker.error("Marker has not been added to OcclusionTester");
        return;
    }
    var rtcCenterHash = marker.rtcCenter.join();
    if (rtcCenterHash !== occlusionLayer.rtcCenterHash) {
        if (occlusionLayer.numMarkers === 1) {
            occlusionLayer.destroy();
            delete this._occlusionLayers[occlusionLayer.rtcCenterHash];
            this._occlusionLayersListDirty = true;
        } else {
            occlusionLayer.removeMarker(marker);
        }
        var newOcclusionLayer = this._occlusionLayers[rtcCenterHash];
        if (!newOcclusionLayer) {
            newOcclusionLayer = new OcclusionLayer(this._scene, marker.rtcCenter);
            this._occlusionLayers[rtcCenterHash] = occlusionLayer;
            this._occlusionLayersListDirty = true;
        }
        newOcclusionLayer.addMarker(marker);
        this._markersToOcclusionLayersMap[marker.id] = newOcclusionLayer;
    } else {
        occlusionLayer.markerWorldPosUpdated(marker);
    }
};

/**
 * Removes a Marker from occlusion testing.
 * @param marker
 */
OcclusionTester.prototype.removeMarker = function removeMarker (marker) {
    var rtcCenterHash = marker.rtcCenter.join();
    var occlusionLayer = this._occlusionLayers[rtcCenterHash];
    if (!occlusionLayer) {
        return;
    }
    if (occlusionLayer.numMarkers === 1) {
        occlusionLayer.destroy();
        delete this._occlusionLayers[occlusionLayer.rtcCenterHash];
        this._occlusionLayersListDirty = true;
    } else {
        occlusionLayer.removeMarker(marker);
    }
    delete this._markersToOcclusionLayersMap[marker.id];
};

/**
 * Returns true if an occlusion test is needed.
 *
 * @returns {boolean}
 */
prototypeAccessors$9.needOcclusionTest.get = function () {
    return this._occlusionTestListDirty;
};

/**
 * Binds the render buffer. After calling this, the caller then renders object silhouettes to the render buffer,
 * then calls drawMarkers() and doOcclusionTest().
 */
OcclusionTester.prototype.bindRenderBuf = function bindRenderBuf () {

    var shaderSourceHash = [this._scene.canvas.canvas.id, this._scene._sectionPlanesState.getHash()].join(";");

    if (shaderSourceHash !== this._shaderSourceHash) {
        this._shaderSourceHash = shaderSourceHash;
        this._shaderSourceDirty = true;
    }

    if (this._shaderSourceDirty) {
        this._buildShaderSource();
        this._shaderSourceDirty = false;
        this._programDirty = true;
    }

    if (this._programDirty) {
        this._buildProgram();
        this._programDirty = false;
        this._occlusionTestListDirty = true;
    }

    if (this._occlusionLayersListDirty) {
        this._buildOcclusionLayersList();
        this._occlusionLayersListDirty = false;
    }

    if (this._occlusionTestListDirty) {
        for (var i = 0, len = this._occlusionLayersList.length; i < len; i++) {
            var occlusionLayer = this._occlusionLayersList[i];
            occlusionLayer.occlusionTestListDirty = true;
        }
        this._occlusionTestListDirty = false;
    }

    {
        this._readPixelBuf = this._readPixelBuf || (this._readPixelBuf = new RenderBuffer(this._scene.canvas.canvas, this._scene.canvas.gl));
        this._readPixelBuf.bind();
        this._readPixelBuf.clear();
    }
};

OcclusionTester.prototype._buildOcclusionLayersList = function _buildOcclusionLayersList () {
    var numOcclusionLayers = 0;
    for (var rtcCenterHash in this._occlusionLayers) {
        if (this._occlusionLayers.hasOwnProperty(rtcCenterHash)) {
            this._occlusionLayersList[numOcclusionLayers++] = this._occlusionLayers[rtcCenterHash];
        }
    }
    this._occlusionLayersList.length = numOcclusionLayers;
};

OcclusionTester.prototype._buildShaderSource = function _buildShaderSource () {
    this._shaderSource = {
        vertex: this._buildVertexShaderSource(),
        fragment: this._buildFragmentShaderSource()
    };
};

OcclusionTester.prototype._buildVertexShaderSource = function _buildVertexShaderSource () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// OcclusionTester vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    src.push("void main(void) {");
    src.push("vec4 worldPosition = vec4(position, 1.0); ");
    src.push("   vec4 viewPosition = viewMatrix * worldPosition;");
    if (clipping) {
        src.push("   vWorldPosition = worldPosition;");
    }
    src.push("   vec4 clipPos = projMatrix * viewPosition;");
    src.push("   gl_Position = clipPos;");
    src.push("   gl_PointSize = " + POINT_SIZE + ".0;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("}");
    return src;
};

OcclusionTester.prototype._buildFragmentShaderSource = function _buildFragmentShaderSource () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// OcclusionTester fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); ");
    src.push("}");
    return src;
};

OcclusionTester.prototype._buildProgram = function _buildProgram () {
    if (this._program) {
        this._program.destroy();
    }
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    this._program = new Program(gl, this._shaderSource);
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];
    var sectionPlanes = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

/**
 * Draws {@link Marker}s to the render buffer.
 */
OcclusionTester.prototype.drawMarkers = function drawMarkers () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var sectionPlanesState = scene._sectionPlanesState;
    var camera = scene.camera;
    var project = scene.camera.project;

    if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"] && scene.logarithmicDepthBufferEnabled) {
        gl.getExtension('EXT_frag_depth');
    }

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, camera._project._state.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    for (var i = 0, len = this._occlusionLayersList.length; i < len; i++) {

        var occlusionLayer = this._occlusionLayersList[i];

        occlusionLayer.update();

        if (occlusionLayer.culledBySectionPlanes) {
            continue;
        }

        var rtcCenter = occlusionLayer.rtcCenter;

        gl.uniformMatrix4fv(this._uViewMatrix, false, createRTCViewMat(camera.viewMatrix, rtcCenter));

        var numSectionPlanes = sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = sectionPlanesState.sectionPlanes;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = occlusionLayer.sectionPlanesActive[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$Z));
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }

        this._aPosition.bindArrayBuffer(occlusionLayer.positionsBuf);

        var indicesBuf = occlusionLayer.indicesBuf;
        indicesBuf.bind();
        gl.drawElements(gl.POINTS, indicesBuf.numItems, indicesBuf.itemType, 0);
    }
};

/**
 * Sets visibilities of {@link Marker}s according to whether or not they are obscured by anything in the render buffer.
 */
OcclusionTester.prototype.doOcclusionTest = function doOcclusionTest () {

    {

        var markerR = MARKER_COLOR[0] * 255;
        var markerG = MARKER_COLOR[1] * 255;
        var markerB = MARKER_COLOR[2] * 255;

        for (var i = 0, len = this._occlusionLayersList.length; i < len; i++) {

            var occlusionLayer = this._occlusionLayersList[i];

            for (var i$1 = 0; i$1 < occlusionLayer.lenOcclusionTestList; i$1++) {

                var marker = occlusionLayer.occlusionTestList[i$1];
                var j = i$1 * 2;
                var color = this._readPixelBuf.read(occlusionLayer.pixels[j], occlusionLayer.pixels[j + 1]);
                var visible = (color[0] === markerR) && (color[1] === markerG) && (color[2] === markerB);

                marker._setVisible(visible);
            }
        }
    }
};

/**
 * Unbinds render buffer.
 */
OcclusionTester.prototype.unbindRenderBuf = function unbindRenderBuf () {
    {
        this._readPixelBuf.unbind();
    }
};

/**
 * Destroys this OcclusionTester.
 */
OcclusionTester.prototype.destroy = function destroy () {
    if (this.destroyed) {
        return;
    }
    for (var i = 0, len = this._occlusionLayersList.length; i < len; i++) {
        var occlusionLayer = this._occlusionLayersList[i];
        occlusionLayer.destroy();
    }

    if (this._program) {
        this._program.destroy();
    }

    this._scene.camera.off(this._onCameraViewMatrix);
    this._scene.camera.off(this._onCameraProjMatrix);
    this._scene.canvas.off(this._onCanvasBoundary);
    this.destroyed = true;
};

Object.defineProperties( OcclusionTester.prototype, prototypeAccessors$9 );

var tempVec2 = math.vec2();

/**
 * SAO implementation inspired from previous SAO work in THREE.js by ludobaka / ludobaka.github.io and bhouston
 * @private
 */
var SAOOcclusionRenderer = function SAOOcclusionRenderer(scene) {

    this._scene = scene;

    this._numSamples = null;

    // The program

    this._program = null;
    this._programError = false;

    // Variable locations

    this._aPosition = null;
    this._aUV = null;

    this._uDepthTexture = "uDepthTexture";

    this._uCameraNear = null;
    this._uCameraFar = null;
    this._uCameraProjectionMatrix = null;
    this._uCameraInverseProjectionMatrix = null;

    this._uScale = null;
    this._uIntensity = null;
    this._uBias = null;
    this._uKernelRadius = null;
    this._uMinResolution = null;
    this._uRandomSeed = null;

    // VBOs

    this._uvBuf = null;
    this._positionsBuf = null;
    this._indicesBuf = null;
};

SAOOcclusionRenderer.prototype.render = function render (depthRenderBuffer) {
        var this$1 = this;


    this._build();

    if (this._programError) {
        return;
    }

    if (!this._getInverseProjectMat) { // HACK: scene.camera not defined until render time
        this._getInverseProjectMat = (function () {
            var projMatDirty = true;
            this$1._scene.camera.on("projMatrix", function () {
                projMatDirty = true;
            });
            var inverseProjectMat = math.mat4();
            return function () {
                if (projMatDirty) {
                    math.inverseMat4(scene.camera.projMatrix, inverseProjectMat);
                }
                return inverseProjectMat;
            }
        })();
    }

    var gl = this._scene.canvas.gl;
    var program = this._program;
    var scene = this._scene;
    var sao = scene.sao;
    var viewportWidth = gl.drawingBufferWidth;
    var viewportHeight = gl.drawingBufferHeight;
    var projectState = scene.camera.project._state;
    var near = projectState.near;
    var far = projectState.far;
    var projectionMatrix = projectState.matrix;
    var inverseProjectionMatrix = this._getInverseProjectMat();
    var randomSeed = Math.random();
    var perspective = (scene.camera.projection === "perspective");

    tempVec2[0] = viewportWidth;
    tempVec2[1] = viewportHeight;

    gl.getExtension("OES_standard_derivatives");

    gl.viewport(0, 0, viewportWidth, viewportHeight);
    gl.clearColor(0, 0, 0, 1);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.frontFace(gl.CCW);
    gl.clear(gl.COLOR_BUFFER_BIT);

    program.bind();

    gl.uniform1f(this._uCameraNear, near);
    gl.uniform1f(this._uCameraFar, far);

    gl.uniformMatrix4fv(this._uCameraProjectionMatrix, false, projectionMatrix);
    gl.uniformMatrix4fv(this._uCameraInverseProjectionMatrix, false, inverseProjectionMatrix);

    gl.uniform1i(this._uPerspective, perspective);

    gl.uniform1f(this._uScale, sao.scale * (far / 5));
    gl.uniform1f(this._uIntensity, sao.intensity);
    gl.uniform1f(this._uBias, sao.bias);
    gl.uniform1f(this._uKernelRadius, sao.kernelRadius);
    gl.uniform1f(this._uMinResolution, sao.minResolution);
    gl.uniform2fv(this._uViewport, tempVec2);
    gl.uniform1f(this._uRandomSeed, randomSeed);

    var depthTexture = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]
        ? depthRenderBuffer.getDepthTexture()
        : depthRenderBuffer.getTexture();

    program.bindTexture(this._uDepthTexture, depthTexture, 0);

    this._aUV.bindArrayBuffer(this._uvBuf);
    this._aPosition.bindArrayBuffer(this._positionsBuf);
    this._indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, this._indicesBuf.numItems, this._indicesBuf.itemType, 0);
};

SAOOcclusionRenderer.prototype._build = function _build () {

    var dirty = false;

    var sao = this._scene.sao;

    if (sao.numSamples !== this._numSamples) {
        this._numSamples = Math.floor(sao.numSamples);
        dirty = true;
    }

    if (!dirty) {
        return;
    }

    var gl = this._scene.canvas.gl;

    if (this._program) {
        this._program.destroy();
        this._program = null;
    }

    this._program = new Program(gl, {

        vertex: ["precision highp float;\n                    precision highp int;\n                    \n                    attribute vec3 aPosition;\n                    attribute vec2 aUV;            \n                    \n                    varying vec2 vUV;\n                    \n                    void main () {\n                        gl_Position = vec4(aPosition, 1.0);\n                        vUV = aUV;\n                    }"],

        fragment: [
            "#extension GL_OES_standard_derivatives : require              \n                precision highp float;\n                precision highp int;           \n                \n                #define NORMAL_TEXTURE 0\n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n                #define NUM_SAMPLES " + (this._numSamples) + "\n                #define NUM_RINGS 4              \n            \n                varying vec2        vUV;\n            \n                uniform sampler2D   uDepthTexture;\n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;\n                uniform mat4        uProjectMatrix;\n                uniform mat4        uInverseProjectMatrix;\n                \n                uniform bool        uPerspective;\n\n                uniform float       uScale;\n                uniform float       uIntensity;\n                uniform float       uBias;\n                uniform float       uKernelRadius;\n                uniform float       uMinResolution;\n                uniform vec2        uViewport;\n                uniform float       uRandomSeed;\n\n                float pow2( const in float x ) { return x*x; }\n                \n                highp float rand( const in vec2 uv ) {\n                    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n                    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n                    return fract(sin(sn) * c);\n                }\n\n                vec3 packNormalToRGB( const in vec3 normal ) {\n                    return normalize( normal ) * 0.5 + 0.5;\n                }\n\n                vec3 unpackRGBToNormal( const in vec3 rgb ) {\n                    return 2.0 * rgb.xyz - 1.0;\n                }\n\n                const float packUpscale = 256. / 255.;\n                const float unpackDownScale = 255. / 256.; \n\n                const vec3 packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4 unPackFactors = unpackDownScale / vec4( packFactors, 1. );   \n\n                const float shiftRights = 1. / 256.;\n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float unpackRGBAToFloat( const in vec4 v ) {                   \n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unPackFactors );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n                    return ( near * far ) / ( ( far - near ) * invClipZ - far );\n                }\n\n                float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n                    return linearClipZ * ( near - far ) - near;\n                }\n                \n                float getDepth( const in vec2 screenPosition ) {"
            + (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"] ? "return texture2D(uDepthTexture, screenPosition).r;" : "return unpackRGBAToFloat(texture2D( uDepthTexture, screenPosition));") +
            "}\n\n                float getViewZ( const in float depth ) {\n                     if (uPerspective) {\n                         return perspectiveDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     } else {\n                        return orthographicDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     }\n                }\n\n                vec3 getViewPos( const in vec2 screenPos, const in float depth, const in float viewZ ) {\n                \tfloat clipW = uProjectMatrix[2][3] * viewZ + uProjectMatrix[3][3];\n                \tvec4 clipPosition = vec4( ( vec3( screenPos, depth ) - 0.5 ) * 2.0, 1.0 );\n                \tclipPosition *= clipW; \n                \treturn ( uInverseProjectMatrix * clipPosition ).xyz;\n                }\n\n                vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPos ) {               \n                    return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n                }\n\n                float scaleDividedByCameraFar;\n                float minResolutionMultipliedByCameraFar;\n\n                float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n                \tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n                \tfloat viewDistance = length( viewDelta );\n                \tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n                \treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - uBias) / (1.0 + pow2( scaledScreenDistance ) );\n                }\n\n                const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n                const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n                float getAmbientOcclusion( const in vec3 centerViewPosition ) {\n            \n                \tscaleDividedByCameraFar = uScale / uCameraFar;\n                \tminResolutionMultipliedByCameraFar = uMinResolution * uCameraFar;\n                \tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUV );\n\n                \tfloat angle = rand( vUV + uRandomSeed ) * PI2;\n                \tvec2 radius = vec2( uKernelRadius * INV_NUM_SAMPLES ) / uViewport;\n                \tvec2 radiusStep = radius;\n\n                \tfloat occlusionSum = 0.0;\n                \tfloat weightSum = 0.0;\n\n                \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n                \t\tvec2 sampleUv = vUV + vec2( cos( angle ), sin( angle ) ) * radius;\n                \t\tradius += radiusStep;\n                \t\tangle += ANGLE_STEP;\n\n                \t\tfloat sampleDepth = getDepth( sampleUv );\n                \t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n                \t\t\tcontinue;\n                \t\t}\n\n                \t\tfloat sampleViewZ = getViewZ( sampleDepth );\n                \t\tvec3 sampleViewPosition = getViewPos( sampleUv, sampleDepth, sampleViewZ );\n                \t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n                \t\tweightSum += 1.0;\n                \t}\n\n                \tif( weightSum == 0.0 ) discard;\n\n                \treturn occlusionSum * ( uIntensity / weightSum );\n                }\n\n                void main() {\n                \n                \tfloat centerDepth = getDepth( vUV );\n                \t\n                \tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n                \t\tdiscard;\n                \t}\n\n                \tfloat centerViewZ = getViewZ( centerDepth );\n                \tvec3 viewPosition = getViewPos( vUV, centerDepth, centerViewZ );\n\n                \tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n                \n                \tgl_FragColor = packFloatToRGBA(  1.0- ambientOcclusion );\n                }"]
    });

    if (this._program.errors) {
        console.error(this._program.errors.join("\n"));
        this._programError = true;
        return;
    }

    var uv = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
    var positions = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]);
    var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);

    this._positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
    this._uvBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW);
    this._indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);

    this._program.bind();

    this._uCameraNear = this._program.getLocation("uCameraNear");
    this._uCameraFar = this._program.getLocation("uCameraFar");

    this._uCameraProjectionMatrix = this._program.getLocation("uProjectMatrix");
    this._uCameraInverseProjectionMatrix = this._program.getLocation("uInverseProjectMatrix");

    this._uPerspective = this._program.getLocation("uPerspective");

    this._uScale = this._program.getLocation("uScale");
    this._uIntensity = this._program.getLocation("uIntensity");
    this._uBias = this._program.getLocation("uBias");
    this._uKernelRadius = this._program.getLocation("uKernelRadius");
    this._uMinResolution = this._program.getLocation("uMinResolution");
    this._uViewport = this._program.getLocation("uViewport");
    this._uRandomSeed = this._program.getLocation("uRandomSeed");

    this._aPosition = this._program.getAttribute("aPosition");
    this._aUV = this._program.getAttribute("aUV");

    this._dirty = false;
};

SAOOcclusionRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
        this._program = null;
    }
};

var blurStdDev = 4;
var blurDepthCutoff = 0.01;
var KERNEL_RADIUS = 16;

var sampleOffsetsVert = new Float32Array(createSampleOffsets(KERNEL_RADIUS + 1, [0, 1]));
var sampleOffsetsHor = new Float32Array(createSampleOffsets(KERNEL_RADIUS + 1, [1, 0]));
var sampleWeights = new Float32Array(createSampleWeights(KERNEL_RADIUS + 1, blurStdDev));

var tempVec2a = new Float32Array(2);

/**
 * SAO implementation inspired from previous SAO work in THREE.js by ludobaka / ludobaka.github.io and bhouston
 * @private
 */
var SAODepthLimitedBlurRenderer = function SAODepthLimitedBlurRenderer(scene) {

    this._scene = scene;

    // The program

    this._program = null;
    this._programError = false;

    // Variable locations

    this._aPosition = null;
    this._aUV = null;

    this._uDepthTexture = "uDepthTexture";
    this._uOcclusionTexture = "uOcclusionTexture";

    this._uViewport = null;
    this._uCameraNear = null;
    this._uCameraFar = null;
    this._uCameraProjectionMatrix = null;
    this._uCameraInverseProjectionMatrix = null;

    this._uScale = null;
    this._uIntensity = null;
    this._uBias = null;
    this._uKernelRadius = null;
    this._uMinResolution = null;

    // VBOs

    this._uvBuf = null;
    this._positionsBuf = null;
    this._indicesBuf = null;

    this.init();
};

SAODepthLimitedBlurRenderer.prototype.init = function init () {

    // Create program & VBOs, locate attributes and uniforms

    var gl = this._scene.canvas.gl;

    this._program = new Program(gl, {

        vertex: [
            "precision highp float;\n                precision highp int;\n                    \n                attribute vec3 aPosition;\n                attribute vec2 aUV;\n                uniform vec2 uViewport;\n                varying vec2 vUV;\n                varying vec2 vInvSize;\n                void main () {\n                    vUV = aUV;\n                    vInvSize = 1.0 / uViewport;\n                    gl_Position = vec4(aPosition, 1.0);\n                }"],

        fragment: [
            "precision highp float;\n                precision highp int;\n                    \n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n\n                #define KERNEL_RADIUS " + KERNEL_RADIUS + "\n\n                varying vec2        vUV;\n                varying vec2        vInvSize;\n            \n                uniform sampler2D   uDepthTexture;\n                uniform sampler2D   uOcclusionTexture;              \n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;               \n                uniform float       uDepthCutoff;\n\n                uniform vec2        uSampleOffsets[ KERNEL_RADIUS + 1 ];\n                uniform float       uSampleWeights[ KERNEL_RADIUS + 1 ];\n\n                const float         unpackDownscale = 255. / 256.; \n\n                const vec3          packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4          unpackFactors = unpackDownscale / vec4( packFactors, 1. );   \n\n                const float packUpscale = 256. / 255.;\n       \n                const float shiftRights = 1. / 256.;\n                \n                float unpackRGBAToFloat( const in vec4 v ) {\n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unpackFactors );\n                }               \n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float viewZToOrthographicDepth( const in float viewZ) {\n                    return ( viewZ + uCameraNear ) / ( uCameraNear - uCameraFar );\n                }\n              \n                float orthographicDepthToViewZ( const in float linearClipZ) {\n                    return linearClipZ * ( uCameraNear - uCameraFar ) - uCameraNear;\n                }\n\n                float viewZToPerspectiveDepth( const in float viewZ) {\n                    return (( uCameraNear + viewZ ) * uCameraFar ) / (( uCameraFar - uCameraNear ) * viewZ );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ) {\n                    return ( uCameraNear * uCameraFar ) / ( ( uCameraFar - uCameraNear ) * invClipZ - uCameraFar );\n                }\n\n                float getDepth( const in vec2 screenPosition ) {"
            + (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"] ? "return texture2D(uDepthTexture, screenPosition).r;" : "return unpackRGBAToFloat(texture2D( uDepthTexture, screenPosition));") +
            "}\n\n                float getViewZ( const in float depth ) {\n                     return perspectiveDepthToViewZ( depth );\n                }\n\n                void main() {\n                \n                    float depth = getDepth( vUV );\n                    if( depth >= ( 1.0 - EPSILON ) ) {\n                        discard;\n                    }\n\n                    float centerViewZ = -getViewZ( depth );\n                    bool rBreak = false;\n                    bool lBreak = false;\n\n                    float weightSum = uSampleWeights[0];\n                    float occlusionSum = unpackRGBAToFloat(texture2D( uOcclusionTexture, vUV )) * weightSum;\n\n                    for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n                        float sampleWeight = uSampleWeights[i];\n                        vec2 sampleUVOffset = uSampleOffsets[i] * vInvSize;\n\n                        vec2 sampleUV = vUV + sampleUVOffset;\n                        float viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            rBreak = true;\n                        }\n\n                        if( ! rBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture2D( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n\n                        sampleUV = vUV - sampleUVOffset;\n                        viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            lBreak = true;\n                        }\n\n                        if( ! lBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture2D( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n                    }\n\n                    gl_FragColor = packFloatToRGBA(occlusionSum / weightSum);\n                }"]
    });

    if (this._program.errors) {
        console.error(this._program.errors.join("\n"));
        this._programError = true;
        return;
    }

    var uv = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
    var positions = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]);
    var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);

    this._positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
    this._uvBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW);
    this._indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);

    this._program.bind();

    this._uViewport = this._program.getLocation("uViewport");

    this._uCameraNear = this._program.getLocation("uCameraNear");
    this._uCameraFar = this._program.getLocation("uCameraFar");

    this._uDepthCutoff = this._program.getLocation("uDepthCutoff");

    this._uSampleOffsets = gl.getUniformLocation(this._program.handle, "uSampleOffsets");
    this._uSampleWeights = gl.getUniformLocation(this._program.handle, "uSampleWeights");

    this._aPosition = this._program.getAttribute("aPosition");
    this._aUV = this._program.getAttribute("aUV");
};

SAODepthLimitedBlurRenderer.prototype.render = function render (depthRenderBuffer, occlusionRenderBuffer, direction) {
        var this$1 = this;


    if (this._programError) {
        return;
    }

    if (!this._getInverseProjectMat) { // HACK: scene.camera not defined until render time
        this._getInverseProjectMat = (function () {
            var projMatDirty = true;
            this$1._scene.camera.on("projMatrix", function () {
                projMatDirty = true;
            });
            var inverseProjectMat = math.mat4();
            return function () {
                if (projMatDirty) {
                    math.inverseMat4(scene.camera.projMatrix, inverseProjectMat);
                }
                return inverseProjectMat;
            }
        })();
    }

    var gl = this._scene.canvas.gl;
    var program = this._program;
    var scene = this._scene;
    var viewportWidth = gl.drawingBufferWidth;
    var viewportHeight = gl.drawingBufferHeight;
    var projectState = scene.camera.project._state;
    var near = projectState.near;
    var far = projectState.far;

    gl.viewport(0, 0, viewportWidth, viewportHeight);
    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.frontFace(gl.CCW);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    program.bind();

    tempVec2a[0] = viewportWidth;
    tempVec2a[1] = viewportHeight;

    gl.uniform2fv(this._uViewport, tempVec2a);
    gl.uniform1f(this._uCameraNear, near);
    gl.uniform1f(this._uCameraFar, far);

    gl.uniform1f(this._uDepthCutoff, blurDepthCutoff);

    if (direction === 0) {// Horizontal
        gl.uniform2fv(this._uSampleOffsets, sampleOffsetsHor);
    } else { // Vertical
        gl.uniform2fv(this._uSampleOffsets, sampleOffsetsVert);
    }

    gl.uniform1fv(this._uSampleWeights, sampleWeights);

    var depthTexture = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]
        ? depthRenderBuffer.getDepthTexture()
        : depthRenderBuffer.getTexture();

    var occlusionTexture = occlusionRenderBuffer.getTexture();

    program.bindTexture(this._uDepthTexture, depthTexture, 0);
    program.bindTexture(this._uOcclusionTexture, occlusionTexture, 1);

    this._aUV.bindArrayBuffer(this._uvBuf);
    this._aPosition.bindArrayBuffer(this._positionsBuf);
    this._indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, this._indicesBuf.numItems, this._indicesBuf.itemType, 0);
};

SAODepthLimitedBlurRenderer.prototype.destroy = function destroy () {
    this._program.destroy();
};

function createSampleWeights(kernelRadius, stdDev) {
    var weights = [];
    for (var i = 0; i <= kernelRadius; i++) {
        weights.push(gaussian(i, stdDev));
    }
    return weights; // TODO: Optimize
}

function gaussian(x, stdDev) {
    return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);
}

function createSampleOffsets(kernelRadius, uvIncrement) {
    var offsets = [];
    for (var i = 0; i <= kernelRadius; i++) {
        offsets.push(uvIncrement[0] * i);
        offsets.push(uvIncrement[1] * i);
    }
    return offsets;
}

/**
 * @private
 */
var Renderer = function (scene, options) {

    options = options || {};

    var frameCtx = new FrameContext(scene);
    var canvas = scene.canvas.canvas;
    var gl = scene.canvas.gl;
    var canvasTransparent = (!!options.transparent);
    var alphaDepthMask = options.alphaDepthMask;

    var pickIDs = new Map({});

    var drawableTypeInfo = {};
    var drawables = {};

    var drawableListDirty = true;
    var stateSortDirty = true;
    var imageDirty = true;

    var saoDepthRenderBuffer = new RenderBuffer(canvas, gl, {
        depthTexture: WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]
    });
    var occlusionRenderBuffer1 = new RenderBuffer(canvas, gl);
    var occlusionRenderBuffer2 = new RenderBuffer(canvas, gl);

    var pickBuffer = new RenderBuffer(canvas, gl);
    var snapshotBuffer = new RenderBuffer(canvas, gl);

    var snapshotBound = false;

    var saoOcclusionRenderer = new SAOOcclusionRenderer(scene);
    var saoDepthLimitedBlurRenderer = new SAODepthLimitedBlurRenderer(scene);

    this._occlusionTester = null; // Lazy-created in #addMarker()

    this.needStateSort = function () {
        stateSortDirty = true;
    };

    this.shadowsDirty = function () {
    };

    this.imageDirty = function () {
        imageDirty = true;
    };

    this.webglContextLost = function () {
    };

    this.webglContextRestored = function (gl) {

        pickBuffer.webglContextRestored(gl);
        snapshotBuffer.webglContextRestored(gl);
        saoDepthRenderBuffer.webglContextRestored(gl);
        occlusionRenderBuffer1.webglContextRestored(gl);
        occlusionRenderBuffer2.webglContextRestored(gl);

        saoOcclusionRenderer.init();
        saoDepthLimitedBlurRenderer.init();

        imageDirty = true;
    };

    /**
     * Inserts a drawable into this renderer.
     *  @private
     */
    this.addDrawable = function (id, drawable) {
        var type = drawable.type;
        if (!type) {
            console.error("Renderer#addDrawable() : drawable with ID " + id + " has no 'type' - ignoring");
            return;
        }
        var drawableInfo = drawableTypeInfo[type];
        if (!drawableInfo) {
            drawableInfo = {
                type: drawable.type,
                count: 0,
                isStateSortable: drawable.isStateSortable,
                stateSortCompare: drawable.stateSortCompare,
                drawableMap: {},
                drawableListPreCull: [],
                drawableList: []
            };
            drawableTypeInfo[type] = drawableInfo;
        }
        drawableInfo.count++;
        drawableInfo.drawableMap[id] = drawable;
        drawables[id] = drawable;
        drawableListDirty = true;
    };

    /**
     * Removes a drawable from this renderer.
     *  @private
     */
    this.removeDrawable = function (id) {
        var drawable = drawables[id];
        if (!drawable) {
            console.error("Renderer#removeDrawable() : drawable not found with ID " + id + " - ignoring");
            return;
        }
        var type = drawable.type;
        var drawableInfo = drawableTypeInfo[type];
        if (--drawableInfo.count <= 0) {
            delete drawableTypeInfo[type];
        } else {
            delete drawableInfo.drawableMap[id];
        }
        delete drawables[id];
        drawableListDirty = true;
    };

    /**
     * Gets a unique pick ID for the given Pickable. A Pickable can be a {@link Mesh} or a {@link PerformanceMesh}.
     * @returns {Number} New pick ID.
     */
    this.getPickID = function (entity) {
        return pickIDs.addItem(entity);
    };

    /**
     * Released a pick ID for reuse.
     * @param {Number} pickID Pick ID to release.
     */
    this.putPickID = function (pickID) {
        pickIDs.removeItem(pickID);
    };

    /**
     * Clears the canvas.
     *  @private
     */
    this.clear = function (params) {
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        if (canvasTransparent) {
            gl.clearColor(1, 1, 1, 1);
        } else {
            var backgroundColor = scene.canvas.backgroundColorFromAmbientLight ? this.lights.getAmbientColorAndIntensity() : scene.canvas.backgroundColor;
            gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 1.0);
        }
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };

    /**
     * Renders inserted drawables.
     *  @private
     */
    this.render = function (params) {
        params = params || {};
        if (params.force) {
            imageDirty = true;
        }
        updateDrawlist();
        if (imageDirty) {
            draw(params);
            stats.frame.frameCount++;
            imageDirty = false;
        }
    };

    function updateDrawlist() { // Prepares state-sorted array of drawables from maps of inserted drawables
        if (drawableListDirty) {
            buildDrawableList();
            drawableListDirty = false;
            stateSortDirty = true;
        }
        if (stateSortDirty) {
            sortDrawableList();
            stateSortDirty = false;
            imageDirty = true;
        }
        if (imageDirty) { // Image is usually dirty because the camera moved
            cullDrawableList();
        }
    }

    function buildDrawableList() {
        for (var type in drawableTypeInfo) {
            if (drawableTypeInfo.hasOwnProperty(type)) {
                var drawableInfo = drawableTypeInfo[type];
                var drawableMap = drawableInfo.drawableMap;
                var drawableListPreCull = drawableInfo.drawableListPreCull;
                var lenDrawableList = 0;
                for (var id in drawableMap) {
                    if (drawableMap.hasOwnProperty(id)) {
                        drawableListPreCull[lenDrawableList++] = drawableMap[id];
                    }
                }
                drawableListPreCull.length = lenDrawableList;
            }
        }
    }

    function sortDrawableList() {
        for (var type in drawableTypeInfo) {
            if (drawableTypeInfo.hasOwnProperty(type)) {
                var drawableInfo = drawableTypeInfo[type];
                if (drawableInfo.isStateSortable) {
                    drawableInfo.drawableListPreCull.sort(drawableInfo.stateSortCompare);
                }
            }
        }
    }

    function cullDrawableList() {
        for (var type in drawableTypeInfo) {
            if (drawableTypeInfo.hasOwnProperty(type)) {
                var drawableInfo = drawableTypeInfo[type];
                var drawableListPreCull = drawableInfo.drawableListPreCull;
                var drawableList = drawableInfo.drawableList;
                var lenDrawableList = 0;
                for (var i = 0, len = drawableListPreCull.length; i < len; i++) {
                    var drawable = drawableListPreCull[i];
                    drawable.rebuildRenderFlags();
                    if (!drawable.renderFlags.culled) {
                        drawableList[lenDrawableList++] = drawable;
                    }
                }
                drawableList.length = lenDrawableList;
            }
        }
    }

    function draw(params) {

        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) { // In case context lost/recovered
            gl.getExtension("OES_element_index_uint");
        }

        if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            gl.getExtension('EXT_frag_depth');
        }

        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
            gl.getExtension('WEBGL_depth_texture');
        }

        var sao = scene.sao;

        if (sao.possible) {
            drawSAOBuffers(params);
        }

        drawShadowMaps();

        drawColor(params);
    }

    function drawSAOBuffers(params) {

        var sao = scene.sao;

        // Render depth buffer

        saoDepthRenderBuffer.bind();
        saoDepthRenderBuffer.clear();
        drawDepth(params);
        saoDepthRenderBuffer.unbind();

        // Render occlusion buffer

        occlusionRenderBuffer1.bind();
        occlusionRenderBuffer1.clear();
        saoOcclusionRenderer.render(saoDepthRenderBuffer);
        occlusionRenderBuffer1.unbind();

        if (sao.blur) {

            // Horizontally blur occlusion buffer 1 into occlusion buffer 2

            occlusionRenderBuffer2.bind();
            occlusionRenderBuffer2.clear();
            saoDepthLimitedBlurRenderer.render(saoDepthRenderBuffer, occlusionRenderBuffer1, 0);
            occlusionRenderBuffer2.unbind();

            // Vertically blur occlusion buffer 2 back into occlusion buffer 1

            occlusionRenderBuffer1.bind();
            occlusionRenderBuffer1.clear();
            saoDepthLimitedBlurRenderer.render(saoDepthRenderBuffer, occlusionRenderBuffer2, 1);
            occlusionRenderBuffer1.unbind();
        }
    }

    function drawDepth(params) {

        frameCtx.reset();
        frameCtx.pass = params.pass;

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.frontFace(gl.CCW);
        gl.enable(gl.CULL_FACE);
        gl.depthMask(true);

        if (params.clear !== false) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        for (var type in drawableTypeInfo) {
            if (drawableTypeInfo.hasOwnProperty(type)) {

                var drawableInfo = drawableTypeInfo[type];
                var drawableList = drawableInfo.drawableList;

                for (var i = 0, len = drawableList.length; i < len; i++) {

                    var drawable = drawableList[i];

                    if (drawable.culled === true || drawable.visible === false || !drawable.drawDepth) {
                        continue;
                    }

                    if (drawable.renderFlags.colorOpaque) {
                        drawable.drawDepth(frameCtx);
                    }
                }
            }
        }

        // const numVertexAttribs = WEBGL_INFO.MAX_VERTEX_ATTRIBS; // Fixes https://github.com/xeokit/xeokit-sdk/issues/174
        // for (let ii = 0; ii < numVertexAttribs; ii++) {
        //     gl.disableVertexAttribArray(ii);
        // }

    }

    function drawShadowMaps() {

        var lights = scene._lightsState.lights;

        for (var i = 0, len = lights.length; i < len; i++) {
            var light = lights[i];
            if (!light.castsShadow) {
                continue;
            }
            drawShadowMap(light);
        }
    }

    function drawShadowMap(light) {

        var castsShadow = light.castsShadow;

        if (!castsShadow) {
            return;
        }

        var shadowRenderBuf = light.getShadowRenderBuf();

        if (!shadowRenderBuf) {
            return;
        }

        shadowRenderBuf.bind();

        frameCtx.reset();

        frameCtx.backfaces = true;
        frameCtx.frontface = true;
        frameCtx.shadowViewMatrix = light.getShadowViewMatrix();
        frameCtx.shadowProjMatrix = light.getShadowProjMatrix();

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.clearColor(0, 0, 0, 1);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for (var type in drawableTypeInfo) {

            if (drawableTypeInfo.hasOwnProperty(type)) {

                var drawableInfo = drawableTypeInfo[type];
                var drawableList = drawableInfo.drawableList;

                for (var i = 0, len = drawableList.length; i < len; i++) {

                    var drawable = drawableList[i];

                    if (drawable.visible === false || !drawable.castsShadow || !drawable.drawShadow) {
                        continue;
                    }

                    if (drawable.renderFlags.colorOpaque) { // Transparent objects don't cast shadows (yet)
                        drawable.drawShadow(frameCtx);
                    }
                }
            }
        }

        shadowRenderBuf.unbind();
    }

    var drawColor = (function () { // Draws the drawables in drawableListSorted

        var normalDrawSAOBin = [];
        var normalEdgesOpaqueBin = [];
        var normalFillTransparentBin = [];
        var normalEdgesTransparentBin = [];

        var xrayedFillOpaqueBin = [];
        var xrayEdgesOpaqueBin = [];
        var xrayedFillTransparentBin = [];
        var xrayEdgesTransparentBin = [];

        var highlightedFillOpaqueBin = [];
        var highlightedEdgesOpaqueBin = [];
        var highlightedFillTransparentBin = [];
        var highlightedEdgesTransparentBin = [];

        var selectedFillOpaqueBin = [];
        var selectedEdgesOpaqueBin = [];
        var selectedFillTransparentBin = [];
        var selectedEdgesTransparentBin = [];

        return function (params) {

            var ambientColorAndIntensity = scene._lightsState.getAmbientColorAndIntensity();

            frameCtx.reset();
            frameCtx.pass = params.pass;
            frameCtx.withSAO = false;
            frameCtx.pbrEnabled = !!scene.pbrEnabled;

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            if (canvasTransparent) {
                gl.clearColor(0, 0, 0, 0);
            } else {
                var backgroundColor = scene.canvas.backgroundColorFromAmbientLight ? ambientColorAndIntensity : scene.canvas.backgroundColor;
                gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 1.0);
            }

            gl.enable(gl.DEPTH_TEST);
            gl.frontFace(gl.CCW);
            gl.enable(gl.CULL_FACE);
            gl.depthMask(true);
            gl.lineWidth(1);

            frameCtx.lineWidth = 1;

            var saoPossible = scene.sao.possible;
            frameCtx.occlusionTexture = saoPossible ? occlusionRenderBuffer1.getTexture() : null;

            var i;
            var len;
            var drawable;

            var startTime = Date.now();

            if (params.clear !== false) {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }

            var normalDrawSAOBinLen = 0;
            var normalEdgesOpaqueBinLen = 0;
            var normalFillTransparentBinLen = 0;
            var normalEdgesTransparentBinLen = 0;

            var xrayedFillOpaqueBinLen = 0;
            var xrayEdgesOpaqueBinLen = 0;
            var xrayedFillTransparentBinLen = 0;
            var xrayEdgesTransparentBinLen = 0;

            var highlightedFillOpaqueBinLen = 0;
            var highlightedEdgesOpaqueBinLen = 0;
            var highlightedFillTransparentBinLen = 0;
            var highlightedEdgesTransparentBinLen = 0;

            var selectedFillOpaqueBinLen = 0;
            var selectedEdgesOpaqueBinLen = 0;
            var selectedFillTransparentBinLen = 0;
            var selectedEdgesTransparentBinLen = 0;

            //------------------------------------------------------------------------------------------------------
            // Render normal opaque solids, defer others to bins to render after
            //------------------------------------------------------------------------------------------------------

            for (var type in drawableTypeInfo) {
                if (drawableTypeInfo.hasOwnProperty(type)) {

                    var drawableInfo = drawableTypeInfo[type];
                    var drawableList = drawableInfo.drawableList;

                    for (i = 0, len = drawableList.length; i < len; i++) {

                        drawable = drawableList[i];

                        if (drawable.culled === true || drawable.visible === false) {
                            continue;
                        }

                        var renderFlags = drawable.renderFlags;

                        if (renderFlags.colorOpaque) {
                            if (saoPossible && drawable.saoEnabled) {
                                normalDrawSAOBin[normalDrawSAOBinLen++] = drawable;
                            } else {
                                drawable.drawColorOpaque(frameCtx);
                            }
                        }

                        if (renderFlags.colorTransparent) {
                            normalFillTransparentBin[normalFillTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.xrayedSilhouetteTransparent) {
                            xrayedFillTransparentBin[xrayedFillTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.xrayedSilhouetteOpaque) {
                            xrayedFillOpaqueBin[xrayedFillOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.highlightedSilhouetteTransparent) {
                            highlightedFillTransparentBin[highlightedFillTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.highlightedSilhouetteOpaque) {
                            highlightedFillOpaqueBin[highlightedFillOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.selectedSilhouetteTransparent) {
                            selectedFillTransparentBin[selectedFillTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.selectedSilhouetteOpaque) {
                            selectedFillOpaqueBin[selectedFillOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.edgesOpaque) {
                            normalEdgesOpaqueBin[normalEdgesOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.edgesTransparent) {
                            normalEdgesTransparentBin[normalEdgesTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.selectedEdgesTransparent) {
                            selectedEdgesTransparentBin[selectedEdgesTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.selectedEdgesOpaque) {
                            selectedEdgesOpaqueBin[selectedEdgesOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.xrayedEdgesTransparent) {
                            xrayEdgesTransparentBin[xrayEdgesTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.xrayedEdgesOpaque) {
                            xrayEdgesOpaqueBin[xrayEdgesOpaqueBinLen++] = drawable;
                        }

                        if (renderFlags.highlightedEdgesTransparent) {
                            highlightedEdgesTransparentBin[highlightedEdgesTransparentBinLen++] = drawable;
                        }

                        if (renderFlags.highlightedEdgesOpaque) {
                            highlightedEdgesOpaqueBin[highlightedEdgesOpaqueBinLen++] = drawable;
                        }
                    }
                }
            }

            //------------------------------------------------------------------------------------------------------
            // Render deferred bins
            //------------------------------------------------------------------------------------------------------

            if (normalDrawSAOBinLen > 0) {
                frameCtx.withSAO = true;
                for (i = 0; i < normalDrawSAOBinLen; i++) {
                    normalDrawSAOBin[i].drawColorOpaque(frameCtx);
                }
            }

            if (normalEdgesOpaqueBinLen > 0) {
                for (i = 0; i < normalEdgesOpaqueBinLen; i++) {
                    normalEdgesOpaqueBin[i].drawEdgesColorOpaque(frameCtx);
                }
            }

            if (xrayedFillOpaqueBinLen > 0) {
                for (i = 0; i < xrayedFillOpaqueBinLen; i++) {
                    xrayedFillOpaqueBin[i].drawSilhouetteXRayed(frameCtx);
                }
            }

            if (xrayEdgesOpaqueBinLen > 0) {
                for (i = 0; i < xrayEdgesOpaqueBinLen; i++) {
                    xrayEdgesOpaqueBin[i].drawEdgesXRayed(frameCtx);
                }
            }

            if (xrayedFillTransparentBinLen > 0 || xrayEdgesTransparentBinLen > 0 || normalFillTransparentBinLen > 0 || normalEdgesTransparentBinLen > 0) {
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);

                if (canvasTransparent) {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }

                frameCtx.backfaces = false;
                if (!alphaDepthMask) {
                    gl.depthMask(false);
                }
                if (xrayEdgesTransparentBinLen > 0) {
                    for (i = 0; i < xrayEdgesTransparentBinLen; i++) {
                        xrayEdgesTransparentBin[i].drawEdgesXRayed(frameCtx);
                    }
                }
                if (xrayedFillTransparentBinLen > 0) {
                    for (i = 0; i < xrayedFillTransparentBinLen; i++) {
                        xrayedFillTransparentBin[i].drawSilhouetteXRayed(frameCtx);
                    }
                }
                if (normalFillTransparentBinLen > 0 || normalEdgesTransparentBinLen > 0) {
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                if (normalEdgesTransparentBinLen > 0) {
                    for (i = 0; i < normalEdgesTransparentBinLen; i++) {
                        drawable = normalEdgesTransparentBin[i];
                        drawable.drawEdgesColorTransparent(frameCtx);
                    }
                }
                if (normalFillTransparentBinLen > 0) {
                    for (i = 0; i < normalFillTransparentBinLen; i++) {
                        drawable = normalFillTransparentBin[i];
                        drawable.drawColorTransparent(frameCtx);
                    }
                }
                gl.disable(gl.BLEND);
                if (!alphaDepthMask) {
                    gl.depthMask(true);
                }
            }

            if (highlightedFillOpaqueBinLen > 0 || highlightedEdgesOpaqueBinLen > 0) {
                frameCtx.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);
                if (highlightedEdgesOpaqueBinLen > 0) {
                    for (i = 0; i < highlightedEdgesOpaqueBinLen; i++) {
                        highlightedEdgesOpaqueBin[i].drawEdgesHighlighted(frameCtx);
                    }
                }
                if (highlightedFillOpaqueBinLen > 0) {
                    for (i = 0; i < highlightedFillOpaqueBinLen; i++) {
                        highlightedFillOpaqueBin[i].drawSilhouetteHighlighted(frameCtx);
                    }
                }
            }

            if (highlightedFillTransparentBinLen > 0 || highlightedEdgesTransparentBinLen > 0 || highlightedFillOpaqueBinLen > 0) {
                frameCtx.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);

                if (canvasTransparent) {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }

                if (highlightedEdgesTransparentBinLen > 0) {
                    for (i = 0; i < highlightedEdgesTransparentBinLen; i++) {
                        highlightedEdgesTransparentBin[i].drawEdgesHighlighted(frameCtx);
                    }
                }
                if (highlightedFillTransparentBinLen > 0) {
                    for (i = 0; i < highlightedFillTransparentBinLen; i++) {
                        highlightedFillTransparentBin[i].drawSilhouetteHighlighted(frameCtx);
                    }
                }
                gl.disable(gl.BLEND);
            }

            if (selectedFillOpaqueBinLen > 0 || selectedEdgesOpaqueBinLen > 0) {
                frameCtx.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);
                if (selectedEdgesOpaqueBinLen > 0) {
                    for (i = 0; i < selectedEdgesOpaqueBinLen; i++) {
                        selectedEdgesOpaqueBin[i].drawEdgesSelected(frameCtx);
                    }
                }
                if (selectedFillOpaqueBinLen > 0) {
                    for (i = 0; i < selectedFillOpaqueBinLen; i++) {
                        selectedFillOpaqueBin[i].drawSilhouetteSelected(frameCtx);
                    }
                }
            }

            if (selectedFillTransparentBinLen > 0 || selectedEdgesTransparentBinLen > 0) {
                frameCtx.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);

                if (canvasTransparent) {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }

                if (selectedEdgesTransparentBinLen > 0) {
                    for (i = 0; i < selectedEdgesTransparentBinLen; i++) {
                        selectedEdgesTransparentBin[i].drawEdgesSelected(frameCtx);
                    }
                }
                if (selectedFillTransparentBinLen > 0) {
                    for (i = 0; i < selectedFillTransparentBinLen; i++) {
                        selectedFillTransparentBin[i].drawSilhouetteSelected(frameCtx);
                    }
                }
                gl.disable(gl.BLEND);
            }

            var endTime = Date.now();
            var frameStats = stats.frame;

            frameStats.renderTime = (endTime - startTime) / 1000.0;
            frameStats.drawElements = frameCtx.drawElements;
            frameStats.useProgram = frameCtx.useProgram;
            frameStats.bindTexture = frameCtx.bindTexture;
            frameStats.bindArray = frameCtx.bindArray;

            var numTextureUnits = WEBGL_INFO$1.MAX_TEXTURE_UNITS;
            for (var ii = 0; ii < numTextureUnits; ii++) {
                gl.activeTexture(gl.TEXTURE0 + ii);
            }
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            gl.bindTexture(gl.TEXTURE_2D, null);

            var numVertexAttribs = WEBGL_INFO$1.MAX_VERTEX_ATTRIBS; // Fixes https://github.com/xeokit/xeokit-sdk/issues/174
            for (var ii$1 = 0; ii$1 < numVertexAttribs; ii$1++) {
                gl.disableVertexAttribArray(ii$1);
            }
        };
    })();

    /**
     * Picks an Entity.
     * @private
     */
    this.pick = (function () {

        var tempVec3a = math.vec3();
        var tempMat4a = math.mat4();
        var tempMat4b = math.mat4();

        var up = math.vec3([0, 1, 0]);
        var _pickResult = new PickResult();

        var nearAndFar = math.vec2();

        var canvasPos = math.vec3();

        var worldRayOrigin = math.vec3();
        var worldRayDir = math.vec3();
        var worldSurfacePos = math.vec3();

        return function (params, pickResult) {
            if ( pickResult === void 0 ) pickResult = _pickResult;


            pickResult.reset();

            updateDrawlist();

            if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) { // In case context lost/recovered
                gl.getExtension("OES_element_index_uint");
            }

            if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
                gl.getExtension('EXT_frag_depth');
            }

            if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
                gl.getExtension('WEBGL_depth_texture');
            }

            var look;
            var pickViewMatrix = null;
            var pickProjMatrix = null;

            pickResult.pickSurface = params.pickSurface;

            if (params.canvasPos) {

                canvasPos[0] = params.canvasPos[0];
                canvasPos[1] = params.canvasPos[1];

                pickViewMatrix = scene.camera.viewMatrix;
                pickProjMatrix = scene.camera.projMatrix;

                pickResult.canvasPos = params.canvasPos;

            } else {

                // Picking with arbitrary World-space ray
                // Align camera along ray and fire ray through center of canvas

                var pickFrustumMatrix = math.frustumMat4(-1, 1, -1, 1, scene.camera.project.near, scene.camera.project.far, tempMat4a);

                if (params.matrix) {

                    pickViewMatrix = params.matrix;
                    pickProjMatrix = pickFrustumMatrix;

                } else {

                    worldRayOrigin.set(params.origin || [0, 0, 0]);
                    worldRayDir.set(params.direction || [0, 0, 1]);

                    look = math.addVec3(worldRayOrigin, worldRayDir, tempVec3a);

                    pickViewMatrix = math.lookAtMat4v(worldRayOrigin, look, up, tempMat4b);
                    pickProjMatrix = pickFrustumMatrix;

                    pickResult.origin = worldRayOrigin;
                    pickResult.direction = worldRayDir;
                }

                canvasPos[0] = canvas.clientWidth * 0.5;
                canvasPos[1] = canvas.clientHeight * 0.5;
            }

            pickBuffer.bind();

            var pickable = gpuPickPickable(canvasPos, pickViewMatrix, pickProjMatrix, params);

            if (!pickable) {
                pickBuffer.unbind();
                return null;
            }

            var pickedEntity = (pickable.delegatePickedEntity) ? pickable.delegatePickedEntity() : pickable;

            if (!pickedEntity) {
                pickBuffer.unbind();
                return null;
            }

            if (params.pickSurface) {

                if (params.pickSurfacePrecision && scene.pickSurfacePrecisionEnabled) {

                    // JavaScript-based ray-picking - slow and precise

                    if (params.canvasPos) {
                        math.canvasPosToWorldRay(scene.canvas.canvas, pickViewMatrix, pickProjMatrix, canvasPos, worldRayOrigin, worldRayDir);
                    }

                    if (pickable.precisionRayPickSurface(worldRayOrigin, worldRayDir, worldSurfacePos)) {

                        pickResult.worldPos = worldSurfacePos;

                        if (params.pickSurfaceNormal !== false) {
                            gpuPickWorldNormal(pickable, canvasPos, pickViewMatrix, pickProjMatrix, pickResult);
                        }

                        pickResult.pickSurfacePrecision = true;
                    }

                } else {

                    // GPU-based ray-picking - fast and imprecise

                    if (pickable.canPickTriangle && pickable.canPickTriangle()) {

                        gpuPickTriangle(pickable, canvasPos, pickViewMatrix, pickProjMatrix, pickResult);

                        pickable.pickTriangleSurface(pickViewMatrix, pickProjMatrix, pickResult);

                        pickResult.pickSurfacePrecision = false;

                    } else {

                        if (pickable.canPickWorldPos && pickable.canPickWorldPos()) {

                            nearAndFar[0] = scene.camera.project.near;
                            nearAndFar[1] = scene.camera.project.far;

                            gpuPickWorldPos(pickable, canvasPos, pickViewMatrix, pickProjMatrix, nearAndFar, pickResult);

                            if (params.pickSurfaceNormal !== false) {
                                gpuPickWorldNormal(pickable, canvasPos, pickViewMatrix, pickProjMatrix, pickResult);
                            }

                            pickResult.pickSurfacePrecision = false;
                        }
                    }
                }
            }

            pickBuffer.unbind();

            pickResult.entity = pickedEntity;

            return pickResult;
        };
    })();

    function gpuPickPickable(canvasPos, pickViewMatrix, pickProjMatrix, params) {

        frameCtx.reset();
        frameCtx.backfaces = true;
        frameCtx.frontface = true; // "ccw"
        frameCtx.pickViewMatrix = pickViewMatrix;
        frameCtx.pickProjMatrix = pickProjMatrix;
        frameCtx.pickInvisible = !!params.pickInvisible;

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var includeEntityIds = params.includeEntityIds;
        var excludeEntityIds = params.excludeEntityIds;

        for (var type in drawableTypeInfo) {
            if (drawableTypeInfo.hasOwnProperty(type)) {

                var drawableInfo = drawableTypeInfo[type];
                var drawableList = drawableInfo.drawableList;

                for (var i = 0, len = drawableList.length; i < len; i++) {

                    var drawable = drawableList[i];

                    if (!drawable.drawPickMesh || drawable.culled === true || (params.pickInvisible !== true && drawable.visible === false) || drawable.pickable === false) {
                        continue;
                    }
                    if (includeEntityIds && !includeEntityIds[drawable.id]) { // TODO: push this logic into drawable
                        continue;
                    }
                    if (excludeEntityIds && excludeEntityIds[drawable.id]) {
                        continue;
                    }

                    drawable.drawPickMesh(frameCtx);
                }
            }
        }

        var pix = pickBuffer.read(Math.round(canvasPos[0]), Math.round(canvasPos[1]));
        var pickID = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        if (pickID < 0) {
            return;
        }

        var pickable = pickIDs.items[pickID];

        return pickable;
    }

    function gpuPickTriangle(pickable, canvasPos, pickViewMatrix, pickProjMatrix, pickResult) {

        if (!pickable.drawPickTriangles) {
            return;
        }

        frameCtx.reset();
        frameCtx.backfaces = true;
        frameCtx.frontface = true; // "ccw"
        frameCtx.pickViewMatrix = pickViewMatrix; // Can be null
        frameCtx.pickProjMatrix = pickProjMatrix; // Can be null
        // frameCtx.pickInvisible = !!params.pickInvisible;

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        pickable.drawPickTriangles(frameCtx);

        var pix = pickBuffer.read(canvasPos[0], canvasPos[1]);

        var primIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        primIndex *= 3; // Convert from triangle number to first vertex in indices

        pickResult.primIndex = primIndex;
    }

    var gpuPickWorldPos = (function () {

        var tempVec4a = math.vec4();
        var tempVec4b = math.vec4();
        var tempVec4c = math.vec4();
        var tempVec4d = math.vec4();
        var tempVec4e = math.vec4();
        var tempMat4a = math.mat4();
        var tempMat4b = math.mat4();
        var tempMat4c = math.mat4();

        return function (pickable, canvasPos, pickViewMatrix, pickProjMatrix, nearAndFar, pickResult) {

            frameCtx.reset();
            frameCtx.backfaces = true;
            frameCtx.frontface = true; // "ccw"
            frameCtx.pickViewMatrix = pickViewMatrix;
            frameCtx.pickProjMatrix = pickProjMatrix;
            frameCtx.pickZNear = nearAndFar[0];
            frameCtx.pickZFar = nearAndFar[1];

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            pickable.drawPickDepths(frameCtx); // Draw color-encoded fragment screen-space depths

            var pix = pickBuffer.read(Math.round(canvasPos[0]), Math.round(canvasPos[1]));

            var screenZ = unpackDepth(pix); // Get screen-space Z at the given canvas coords

            // Calculate clip space coordinates, which will be in range of x=[-1..1] and y=[-1..1], with y=(+1) at top
            var x = (canvasPos[0] - canvas.width / 2) / (canvas.width / 2);
            var y = -(canvasPos[1] - canvas.height / 2) / (canvas.height / 2);

            var rtcCenter = pickable.rtcCenter;
            var pvMat;

            if (rtcCenter) {
                var rtcPickViewMat = createRTCViewMat(pickViewMatrix, rtcCenter, tempMat4a);
                pvMat = math.mulMat4(pickProjMatrix, rtcPickViewMat, tempMat4b);

            } else {
                pvMat = math.mulMat4(pickProjMatrix, pickViewMatrix, tempMat4b);
            }

            var pvMatInverse = math.inverseMat4(pvMat, tempMat4c);

            tempVec4a[0] = x;
            tempVec4a[1] = y;
            tempVec4a[2] = -1;
            tempVec4a[3] = 1;

            var world1 = math.transformVec4(pvMatInverse, tempVec4a);
            world1 = math.mulVec4Scalar(world1, 1 / world1[3]);

            tempVec4b[0] = x;
            tempVec4b[1] = y;
            tempVec4b[2] = 1;
            tempVec4b[3] = 1;

            var world2 = math.transformVec4(pvMatInverse, tempVec4b);
            world2 = math.mulVec4Scalar(world2, 1 / world2[3]);

            var dir = math.subVec3(world2, world1, tempVec4c);
            var worldPos = math.addVec3(world1, math.mulVec4Scalar(dir, screenZ, tempVec4d), tempVec4e);

            if (rtcCenter) {
                math.addVec3(worldPos, rtcCenter);
            }

            pickResult.worldPos = worldPos;
        }
    })();

    function unpackDepth(depthZ) {
        var vec = [depthZ[0] / 256.0, depthZ[1] / 256.0, depthZ[2] / 256.0, depthZ[3] / 256.0];
        var bitShift = [1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0];
        return math.dotVec4(vec, bitShift);
    }

    function gpuPickWorldNormal(pickable, canvasPos, pickViewMatrix, pickProjMatrix, pickResult) {

        frameCtx.reset();
        frameCtx.backfaces = true;
        frameCtx.frontface = true; // "ccw"
        frameCtx.pickViewMatrix = pickViewMatrix;
        frameCtx.pickProjMatrix = pickProjMatrix;

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        pickable.drawPickNormals(frameCtx); // Draw color-encoded fragment World-space normals

        var pix = pickBuffer.read(Math.round(canvasPos[0]), Math.round(canvasPos[1]));

        var worldNormal = [(pix[0] / 256.0) - 0.5, (pix[1] / 256.0) - 0.5, (pix[2] / 256.0) - 0.5];

        math.normalizeVec3(worldNormal);

        pickResult.worldNormal = worldNormal;
    }

    /**
     * Adds a {@link Marker} for occlusion testing.
     * @param marker
     */
    this.addMarker = function (marker) {
        this._occlusionTester = this._occlusionTester || new OcclusionTester(scene);
        this._occlusionTester.addMarker(marker);
        scene.occlusionTestCountdown = 0;
    };

    /**
     * Notifies that a {@link Marker#worldPos} has updated.
     * @param marker
     */
    this.markerWorldPosUpdated = function (marker) {
        this._occlusionTester.markerWorldPosUpdated(marker);
    };

    /**
     * Removes a {@link Marker} from occlusion testing.
     * @param marker
     */
    this.removeMarker = function (marker) {
        this._occlusionTester.removeMarker(marker);
    };

    /**
     * Performs an occlusion test for all added {@link Marker}s, updating
     * their {@link Marker#visible} properties accordingly.
     */
    this.doOcclusionTest = function () {

        if (this._occlusionTester && this._occlusionTester.needOcclusionTest) {

            updateDrawlist();

            this._occlusionTester.bindRenderBuf();

            frameCtx.reset();
            frameCtx.backfaces = true;
            frameCtx.frontface = true; // "ccw"

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            for (var type in drawableTypeInfo) {
                if (drawableTypeInfo.hasOwnProperty(type)) {
                    var drawableInfo = drawableTypeInfo[type];
                    var drawableList = drawableInfo.drawableList;
                    for (var i = 0, len = drawableList.length; i < len; i++) {
                        var drawable = drawableList[i];
                        if (!drawable.drawOcclusion || drawable.culled === true || drawable.visible === false || drawable.pickable === false) { // TODO: Option to exclude transparent?
                            continue;
                        }

                        drawable.drawOcclusion(frameCtx);
                    }
                }
            }

            this._occlusionTester.drawMarkers(frameCtx);
            this._occlusionTester.doOcclusionTest(); // Updates Marker "visible" properties
            this._occlusionTester.unbindRenderBuf();
        }
    };

    /**
     * Read pixels from the renderer's current output. Performs a force-render first.
     * @param pixels
     * @param colors
     * @param len
     * @param opaqueOnly
     * @private
     */
    this.readPixels = function (pixels, colors, len, opaqueOnly) {
        snapshotBuffer.bind();
        snapshotBuffer.clear();
        this.render({force: true, opaqueOnly: opaqueOnly});
        var color;
        var i;
        var j;
        var k;
        for (i = 0; i < len; i++) {
            j = i * 2;
            k = i * 4;
            color = snapshotBuffer.read(pixels[j], pixels[j + 1]);
            colors[k] = color[0];
            colors[k + 1] = color[1];
            colors[k + 2] = color[2];
            colors[k + 3] = color[3];
        }
        snapshotBuffer.unbind();
        imageDirty = true;
    };

    /**
     * Enter snapshot mode.
     *
     * Switches rendering to a hidden snapshot canvas.
     *
     * Exit snapshot mode using endSnapshot().
     */
    this.beginSnapshot = function () {
        snapshotBuffer.bind();
        snapshotBuffer.clear();
        snapshotBound = true;
    };

    /**
     * When in snapshot mode, renders a frame of the current Scene state to the snapshot canvas.
     */
    this.renderSnapshot = function () {
        if (!snapshotBound) {
            return;
        }
        snapshotBuffer.clear();
        this.render({force: true, opaqueOnly: false});
        imageDirty = true;
    };

    /**
     * When in snapshot mode, gets an image of the snapshot canvas.
     *
     * @private
     * @returns {String} The image data URI.
     */
    this.readSnapshot = function (params) {
        var imageDataURI = snapshotBuffer.readImage(params);
        return imageDataURI;
    };

    /**
     * Exists snapshot mode.
     *
     * Switches rendering back to the main canvas.
     */
    this.endSnapshot = function () {
        if (!snapshotBound) {
            return;
        }
        snapshotBuffer.unbind();
        snapshotBound = false;
    };

    /**
     * Destroys this renderer.
     * @private
     */
    this.destroy = function () {

        drawableTypeInfo = {};
        drawables = {};

        pickBuffer.destroy();
        snapshotBuffer.destroy();
        saoDepthRenderBuffer.destroy();
        occlusionRenderBuffer1.destroy();
        occlusionRenderBuffer2.destroy();

        saoOcclusionRenderer.destroy();
        saoDepthLimitedBlurRenderer.destroy();

        if (this._occlusionTester) {
            this._occlusionTester.destroy();
        }
    };
};

/**
 * @desc Meditates mouse, touch and keyboard events for various interaction controls.
 *
 * Ordinarily, you would only use this component as a utility to help manage input events and state for your
 * own custom input handlers.
 *
 * * Located at {@link Scene#input}
 * * Used by (at least) {@link CameraControl}
 *
 * ## Usage
 *
 * Subscribing to mouse events on the canvas:
 *
 * ````javascript
 * import {Viewer} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * const input = viewer.scene.input;
 *
 * const onMouseDown = input.on("mousedown", (canvasCoords) => {
 *       console.log("Mouse down at: x=" + canvasCoords[0] + ", y=" + coords[1]);
 * });
 *
 * const onMouseUp = input.on("mouseup", (canvasCoords) => {
 *       console.log("Mouse up at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 *
 * const onMouseClicked = input.on("mouseclicked", (canvasCoords) => {
 *      console.log("Mouse clicked at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 *
 * const onDblClick = input.on("dblclick", (canvasCoords) => {
 *       console.log("Double-click at: x=" + canvasCoords[0] + ", y=" + canvasCoords[1]);
 * });
 * ````
 *
 * Subscribing to keyboard events on the canvas:
 *
 * ````javascript
 * const onKeyDown = input.on("keydown", (keyCode) => {
 *      switch (keyCode) {
 *          case this.KEY_A:
 *              console.log("The 'A' key is down");
 *              break;
 *
 *          case this.KEY_B:
 *              console.log("The 'B' key is down");
 *              break;
 *
 *          case this.KEY_C:
 *              console.log("The 'C' key is down");
 *              break;
 *
 *          default:
 *              console.log("Some other key is down");
 *      }
 * });
 *
 * const onKeyUp = input.on("keyup", (keyCode) => {
 *      switch (keyCode) {
 *          case this.KEY_A:
 *              console.log("The 'A' key is up");
 *              break;
 *
 *          case this.KEY_B:
 *              console.log("The 'B' key is up");
 *              break;
 *
 *          case this.KEY_C:
 *              console.log("The 'C' key is up");
 *              break;
 *
 *          default:
 *              console.log("Some other key is up");
 *      }
 *  });
 * ````
 *
 * Checking if keys are down:
 *
 * ````javascript
 * const isCtrlDown = input.ctrlDown;
 * const isAltDown = input.altDown;
 * const shiftDown = input.shiftDown;
 * //...
 *
 * const isAKeyDown = input.keyDown[input.KEY_A];
 * const isBKeyDown = input.keyDown[input.KEY_B];
 * const isShiftKeyDown = input.keyDown[input.KEY_SHIFT];
 * //...
 *
 * ````
 * Unsubscribing from events:
 *
 * ````javascript
 * input.off(onMouseDown);
 * input.off(onMouseUp);
 * //...
 * ````
 *
 * ## Disabling all events
 *
 * Event handling is enabled by default.
 *
 * To disable all events:
 *
 * ````javascript
 * myViewer.scene.input.setEnabled(false);
 * ````
 * To enable all events again:
 *
 * ````javascript
 * myViewer.scene.input.setEnabled(true);
 * ````
 *
 * ## Disabling keyboard input
 *
 * When the mouse is over the canvas, the canvas will consume keyboard events. Therefore, sometimes we need
 * to disable keyboard control, so that other UI elements can get those events.
 *
 * To disable keyboard events:
 *
 * ````javascript
 * myViewer.scene.input.setKeyboardEnabled(false);
 * ````
 *
 * To enable keyboard events again:
 *
 * ````javascript
 * myViewer.scene.input.setKeyboardEnabled(true)
 * ````
 */
var Input = /*@__PURE__*/(function (Component) {
    function Input(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        /**
         * Code for the BACKSPACE key.
         * @property KEY_BACKSPACE
         * @final
         * @type {Number}
         */
        this.KEY_BACKSPACE = 8;

        /**
         * Code for the TAB key.
         * @property KEY_TAB
         * @final
         * @type {Number}
         */
        this.KEY_TAB = 9;

        /**
         * Code for the ENTER key.
         * @property KEY_ENTER
         * @final
         * @type {Number}
         */
        this.KEY_ENTER = 13;

        /**
         * Code for the SHIFT key.
         * @property KEY_SHIFT
         * @final
         * @type {Number}
         */
        this.KEY_SHIFT = 16;

        /**
         * Code for the CTRL key.
         * @property KEY_CTRL
         * @final
         * @type {Number}
         */
        this.KEY_CTRL = 17;

        /**
         * Code for the ALT key.
         * @property KEY_ALT
         * @final
         * @type {Number}
         */
        this.KEY_ALT = 18;

        /**
         * Code for the PAUSE_BREAK key.
         * @property KEY_PAUSE_BREAK
         * @final
         * @type {Number}
         */
        this.KEY_PAUSE_BREAK = 19;

        /**
         * Code for the CAPS_LOCK key.
         * @property KEY_CAPS_LOCK
         * @final
         * @type {Number}
         */
        this.KEY_CAPS_LOCK = 20;

        /**
         * Code for the ESCAPE key.
         * @property KEY_ESCAPE
         * @final
         * @type {Number}
         */
        this.KEY_ESCAPE = 27;

        /**
         * Code for the PAGE_UP key.
         * @property KEY_PAGE_UP
         * @final
         * @type {Number}
         */
        this.KEY_PAGE_UP = 33;

        /**
         * Code for the PAGE_DOWN key.
         * @property KEY_PAGE_DOWN
         * @final
         * @type {Number}
         */
        this.KEY_PAGE_DOWN = 34;

        /**
         * Code for the END key.
         * @property KEY_END
         * @final
         * @type {Number}
         */
        this.KEY_END = 35;

        /**
         * Code for the HOME key.
         * @property KEY_HOME
         * @final
         * @type {Number}
         */
        this.KEY_HOME = 36;

        /**
         * Code for the LEFT_ARROW key.
         * @property KEY_LEFT_ARROW
         * @final
         * @type {Number}
         */
        this.KEY_LEFT_ARROW = 37;

        /**
         * Code for the UP_ARROW key.
         * @property KEY_UP_ARROW
         * @final
         * @type {Number}
         */
        this.KEY_UP_ARROW = 38;

        /**
         * Code for the RIGHT_ARROW key.
         * @property KEY_RIGHT_ARROW
         * @final
         * @type {Number}
         */
        this.KEY_RIGHT_ARROW = 39;

        /**
         * Code for the DOWN_ARROW key.
         * @property KEY_DOWN_ARROW
         * @final
         * @type {Number}
         */
        this.KEY_DOWN_ARROW = 40;

        /**
         * Code for the INSERT key.
         * @property KEY_INSERT
         * @final
         * @type {Number}
         */
        this.KEY_INSERT = 45;

        /**
         * Code for the DELETE key.
         * @property KEY_DELETE
         * @final
         * @type {Number}
         */
        this.KEY_DELETE = 46;

        /**
         * Code for the 0 key.
         * @property KEY_NUM_0
         * @final
         * @type {Number}
         */
        this.KEY_NUM_0 = 48;

        /**
         * Code for the 1 key.
         * @property KEY_NUM_1
         * @final
         * @type {Number}
         */
        this.KEY_NUM_1 = 49;

        /**
         * Code for the 2 key.
         * @property KEY_NUM_2
         * @final
         * @type {Number}
         */
        this.KEY_NUM_2 = 50;

        /**
         * Code for the 3 key.
         * @property KEY_NUM_3
         * @final
         * @type {Number}
         */
        this.KEY_NUM_3 = 51;

        /**
         * Code for the 4 key.
         * @property KEY_NUM_4
         * @final
         * @type {Number}
         */
        this.KEY_NUM_4 = 52;

        /**
         * Code for the 5 key.
         * @property KEY_NUM_5
         * @final
         * @type {Number}
         */
        this.KEY_NUM_5 = 53;

        /**
         * Code for the 6 key.
         * @property KEY_NUM_6
         * @final
         * @type {Number}
         */
        this.KEY_NUM_6 = 54;

        /**
         * Code for the 7 key.
         * @property KEY_NUM_7
         * @final
         * @type {Number}
         */
        this.KEY_NUM_7 = 55;

        /**
         * Code for the 8 key.
         * @property KEY_NUM_8
         * @final
         * @type {Number}
         */
        this.KEY_NUM_8 = 56;

        /**
         * Code for the 9 key.
         * @property KEY_NUM_9
         * @final
         * @type {Number}
         */
        this.KEY_NUM_9 = 57;

        /**
         * Code for the A key.
         * @property KEY_A
         * @final
         * @type {Number}
         */
        this.KEY_A = 65;

        /**
         * Code for the B key.
         * @property KEY_B
         * @final
         * @type {Number}
         */
        this.KEY_B = 66;

        /**
         * Code for the C key.
         * @property KEY_C
         * @final
         * @type {Number}
         */
        this.KEY_C = 67;

        /**
         * Code for the D key.
         * @property KEY_D
         * @final
         * @type {Number}
         */
        this.KEY_D = 68;

        /**
         * Code for the E key.
         * @property KEY_E
         * @final
         * @type {Number}
         */
        this.KEY_E = 69;

        /**
         * Code for the F key.
         * @property KEY_F
         * @final
         * @type {Number}
         */
        this.KEY_F = 70;

        /**
         * Code for the G key.
         * @property KEY_G
         * @final
         * @type {Number}
         */
        this.KEY_G = 71;

        /**
         * Code for the H key.
         * @property KEY_H
         * @final
         * @type {Number}
         */
        this.KEY_H = 72;

        /**
         * Code for the I key.
         * @property KEY_I
         * @final
         * @type {Number}
         */
        this.KEY_I = 73;

        /**
         * Code for the J key.
         * @property KEY_J
         * @final
         * @type {Number}
         */
        this.KEY_J = 74;

        /**
         * Code for the K key.
         * @property KEY_K
         * @final
         * @type {Number}
         */
        this.KEY_K = 75;

        /**
         * Code for the L key.
         * @property KEY_L
         * @final
         * @type {Number}
         */
        this.KEY_L = 76;

        /**
         * Code for the M key.
         * @property KEY_M
         * @final
         * @type {Number}
         */
        this.KEY_M = 77;

        /**
         * Code for the N key.
         * @property KEY_N
         * @final
         * @type {Number}
         */
        this.KEY_N = 78;

        /**
         * Code for the O key.
         * @property KEY_O
         * @final
         * @type {Number}
         */
        this.KEY_O = 79;

        /**
         * Code for the P key.
         * @property KEY_P
         * @final
         * @type {Number}
         */
        this.KEY_P = 80;

        /**
         * Code for the Q key.
         * @property KEY_Q
         * @final
         * @type {Number}
         */
        this.KEY_Q = 81;

        /**
         * Code for the R key.
         * @property KEY_R
         * @final
         * @type {Number}
         */
        this.KEY_R = 82;

        /**
         * Code for the S key.
         * @property KEY_S
         * @final
         * @type {Number}
         */
        this.KEY_S = 83;

        /**
         * Code for the T key.
         * @property KEY_T
         * @final
         * @type {Number}
         */
        this.KEY_T = 84;

        /**
         * Code for the U key.
         * @property KEY_U
         * @final
         * @type {Number}
         */
        this.KEY_U = 85;

        /**
         * Code for the V key.
         * @property KEY_V
         * @final
         * @type {Number}
         */
        this.KEY_V = 86;

        /**
         * Code for the W key.
         * @property KEY_W
         * @final
         * @type {Number}
         */
        this.KEY_W = 87;

        /**
         * Code for the X key.
         * @property KEY_X
         * @final
         * @type {Number}
         */
        this.KEY_X = 88;

        /**
         * Code for the Y key.
         * @property KEY_Y
         * @final
         * @type {Number}
         */
        this.KEY_Y = 89;

        /**
         * Code for the Z key.
         * @property KEY_Z
         * @final
         * @type {Number}
         */
        this.KEY_Z = 90;

        /**
         * Code for the LEFT_WINDOW key.
         * @property KEY_LEFT_WINDOW
         * @final
         * @type {Number}
         */
        this.KEY_LEFT_WINDOW = 91;

        /**
         * Code for the RIGHT_WINDOW key.
         * @property KEY_RIGHT_WINDOW
         * @final
         * @type {Number}
         */
        this.KEY_RIGHT_WINDOW = 92;

        /**
         * Code for the SELECT key.
         * @property KEY_SELECT
         * @final
         * @type {Number}
         */
        this.KEY_SELECT_KEY = 93;

        /**
         * Code for the number pad 0 key.
         * @property KEY_NUMPAD_0
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_0 = 96;

        /**
         * Code for the number pad 1 key.
         * @property KEY_NUMPAD_1
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_1 = 97;

        /**
         * Code for the number pad 2 key.
         * @property KEY_NUMPAD 2
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_2 = 98;

        /**
         * Code for the number pad 3 key.
         * @property KEY_NUMPAD_3
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_3 = 99;

        /**
         * Code for the number pad 4 key.
         * @property KEY_NUMPAD_4
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_4 = 100;

        /**
         * Code for the number pad 5 key.
         * @property KEY_NUMPAD_5
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_5 = 101;

        /**
         * Code for the number pad 6 key.
         * @property KEY_NUMPAD_6
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_6 = 102;

        /**
         * Code for the number pad 7 key.
         * @property KEY_NUMPAD_7
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_7 = 103;

        /**
         * Code for the number pad 8 key.
         * @property KEY_NUMPAD_8
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_8 = 104;

        /**
         * Code for the number pad 9 key.
         * @property KEY_NUMPAD_9
         * @final
         * @type {Number}
         */
        this.KEY_NUMPAD_9 = 105;

        /**
         * Code for the MULTIPLY key.
         * @property KEY_MULTIPLY
         * @final
         * @type {Number}
         */
        this.KEY_MULTIPLY = 106;

        /**
         * Code for the ADD key.
         * @property KEY_ADD
         * @final
         * @type {Number}
         */
        this.KEY_ADD = 107;

        /**
         * Code for the SUBTRACT key.
         * @property KEY_SUBTRACT
         * @final
         * @type {Number}
         */
        this.KEY_SUBTRACT = 109;

        /**
         * Code for the DECIMAL POINT key.
         * @property KEY_DECIMAL_POINT
         * @final
         * @type {Number}
         */
        this.KEY_DECIMAL_POINT = 110;

        /**
         * Code for the DIVIDE key.
         * @property KEY_DIVIDE
         * @final
         * @type {Number}
         */
        this.KEY_DIVIDE = 111;

        /**
         * Code for the F1 key.
         * @property KEY_F1
         * @final
         * @type {Number}
         */
        this.KEY_F1 = 112;

        /**
         * Code for the F2 key.
         * @property KEY_F2
         * @final
         * @type {Number}
         */
        this.KEY_F2 = 113;

        /**
         * Code for the F3 key.
         * @property KEY_F3
         * @final
         * @type {Number}
         */
        this.KEY_F3 = 114;

        /**
         * Code for the F4 key.
         * @property KEY_F4
         * @final
         * @type {Number}
         */
        this.KEY_F4 = 115;

        /**
         * Code for the F5 key.
         * @property KEY_F5
         * @final
         * @type {Number}
         */
        this.KEY_F5 = 116;

        /**
         * Code for the F6 key.
         * @property KEY_F6
         * @final
         * @type {Number}
         */
        this.KEY_F6 = 117;

        /**
         * Code for the F7 key.
         * @property KEY_F7
         * @final
         * @type {Number}
         */
        this.KEY_F7 = 118;

        /**
         * Code for the F8 key.
         * @property KEY_F8
         * @final
         * @type {Number}
         */
        this.KEY_F8 = 119;

        /**
         * Code for the F9 key.
         * @property KEY_F9
         * @final
         * @type {Number}
         */
        this.KEY_F9 = 120;

        /**
         * Code for the F10 key.
         * @property KEY_F10
         * @final
         * @type {Number}
         */
        this.KEY_F10 = 121;

        /**
         * Code for the F11 key.
         * @property KEY_F11
         * @final
         * @type {Number}
         */
        this.KEY_F11 = 122;

        /**
         * Code for the F12 key.
         * @property KEY_F12
         * @final
         * @type {Number}
         */
        this.KEY_F12 = 123;

        /**
         * Code for the NUM_LOCK key.
         * @property KEY_NUM_LOCK
         * @final
         * @type {Number}
         */
        this.KEY_NUM_LOCK = 144;

        /**
         * Code for the SCROLL_LOCK key.
         * @property KEY_SCROLL_LOCK
         * @final
         * @type {Number}
         */
        this.KEY_SCROLL_LOCK = 145;

        /**
         * Code for the SEMI_COLON key.
         * @property KEY_SEMI_COLON
         * @final
         * @type {Number}
         */
        this.KEY_SEMI_COLON = 186;

        /**
         * Code for the EQUAL_SIGN key.
         * @property KEY_EQUAL_SIGN
         * @final
         * @type {Number}
         */
        this.KEY_EQUAL_SIGN = 187;

        /**
         * Code for the COMMA key.
         * @property KEY_COMMA
         * @final
         * @type {Number}
         */
        this.KEY_COMMA = 188;

        /**
         * Code for the DASH key.
         * @property KEY_DASH
         * @final
         * @type {Number}
         */
        this.KEY_DASH = 189;

        /**
         * Code for the PERIOD key.
         * @property KEY_PERIOD
         * @final
         * @type {Number}
         */
        this.KEY_PERIOD = 190;

        /**
         * Code for the FORWARD_SLASH key.
         * @property KEY_FORWARD_SLASH
         * @final
         * @type {Number}
         */
        this.KEY_FORWARD_SLASH = 191;

        /**
         * Code for the GRAVE_ACCENT key.
         * @property KEY_GRAVE_ACCENT
         * @final
         * @type {Number}
         */
        this.KEY_GRAVE_ACCENT = 192;

        /**
         * Code for the OPEN_BRACKET key.
         * @property KEY_OPEN_BRACKET
         * @final
         * @type {Number}
         */
        this.KEY_OPEN_BRACKET = 219;

        /**
         * Code for the BACK_SLASH key.
         * @property KEY_BACK_SLASH
         * @final
         * @type {Number}
         */
        this.KEY_BACK_SLASH = 220;

        /**
         * Code for the CLOSE_BRACKET key.
         * @property KEY_CLOSE_BRACKET
         * @final
         * @type {Number}
         */
        this.KEY_CLOSE_BRACKET = 221;

        /**
         * Code for the SINGLE_QUOTE key.
         * @property KEY_SINGLE_QUOTE
         * @final
         * @type {Number}
         */
        this.KEY_SINGLE_QUOTE = 222;

        /**
         * Code for the SPACE key.
         * @property KEY_SPACE
         * @final
         * @type {Number}
         */
        this.KEY_SPACE = 32;

        /**
         * The canvas element that mouse and keyboards are bound to.
         *
         * @final
         * @type {HTMLCanvasElement}
         */
        this.element = cfg.element;

        /** True whenever ALT key is down.
         *
         * @type {boolean}
         */
        this.altDown = false;

        /** True whenever CTRL key is down.
         *
         * @type {boolean}
         */
        this.ctrlDown = false;

        /** True whenever left mouse button is down.
         *
         * @type {boolean}
         */
        this.mouseDownLeft = false;

        /**
         * True whenever middle mouse button is down.
         *
         * @type {boolean}
         */
        this.mouseDownMiddle = false;

        /**
         * True whenever the right mouse button is down.
         *
         * @type {boolean}
         */
        this.mouseDownRight = false;

        /**
         * Flag for each key that's down.
         *
         * @type {boolean[]}
         */
        this.keyDown = [];

        /** True while input enabled
         *
         * @type {boolean}
         */
        this.enabled = true;

        /** True while keyboard input is enabled.
         *
         * Default value is ````true````.
         *
         * {@link CameraControl} will not respond to keyboard events while this is ````false````.
         *
         * @type {boolean}
         */
        this.keyboardEnabled = true;

        /** True while the mouse is over the canvas.
         *
         * @type {boolean}
         */
        this.mouseover = false;

        /**
         * Current mouse position within the canvas.
         * @type {Number[]}
         */
        this.mouseCanvasPos = math.vec2();

        this._bindEvents();
    }

    if ( Component ) Input.__proto__ = Component;
    Input.prototype = Object.create( Component && Component.prototype );
    Input.prototype.constructor = Input;

    Input.prototype._bindEvents = function _bindEvents () {
        var this$1 = this;


        if (this._eventsBound) {
            return;
        }

        document.addEventListener("keydown", this._keyDownListener = function (e) {
            if (!this$1.enabled || (!this$1.keyboardEnabled)) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                if (e.keyCode === this$1.KEY_CTRL) {
                    this$1.ctrlDown = true;
                } else if (e.keyCode === this$1.KEY_ALT) {
                    this$1.altDown = true;
                } else if (e.keyCode === this$1.KEY_SHIFT) {
                    this$1.shiftDown = true;
                }
                this$1.keyDown[e.keyCode] = true;
                this$1.fire("keydown", e.keyCode, true);
            }
        }, false);

        document.addEventListener("keyup", this._keyUpListener = function (e) {
            if (!this$1.enabled || (!this$1.keyboardEnabled)) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                if (e.keyCode === this$1.KEY_CTRL) {
                    this$1.ctrlDown = false;
                } else if (e.keyCode === this$1.KEY_ALT) {
                    this$1.altDown = false;
                } else if (e.keyCode === this$1.KEY_SHIFT) {
                    this$1.shiftDown = false;
                }
                this$1.keyDown[e.keyCode] = false;
                this$1.fire("keyup", e.keyCode, true);
            }
        });

        this.element.addEventListener("mouseenter", this._mouseEnterListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            this$1.mouseover = true;
            this$1._getMouseCanvasPos(e);
            this$1.fire("mouseenter", this$1.mouseCanvasPos, true);
        });

        this.element.addEventListener("mouseleave", this._mouseLeaveListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            this$1.mouseover = false;
            this$1._getMouseCanvasPos(e);
            this$1.fire("mouseleave", this$1.mouseCanvasPos, true);
        });

        this.element.addEventListener("mousedown", this._mouseDownListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            switch (e.which) {
                case 1:// Left button
                    this$1.mouseDownLeft = true;
                    break;
                case 2:// Middle/both buttons
                    this$1.mouseDownMiddle = true;
                    break;
                case 3:// Right button
                    this$1.mouseDownRight = true;
                    break;
            }
            this$1._getMouseCanvasPos(e);
            this$1.element.focus();
            this$1.fire("mousedown", this$1.mouseCanvasPos, true);
            if (this$1.mouseover) {
                e.preventDefault();
            }
        });

        document.addEventListener("mouseup", this._mouseUpListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            switch (e.which) {
                case 1:// Left button
                    this$1.mouseDownLeft = false;
                    break;
                case 2:// Middle/both buttons
                    this$1.mouseDownMiddle = false;
                    break;
                case 3:// Right button
                    this$1.mouseDownRight = false;
                    break;
            }
            this$1.fire("mouseup", this$1.mouseCanvasPos, true);
            // if (this.mouseover) {
            //     e.preventDefault();
            // }
        }, true);

        document.addEventListener("click", this._clickListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            switch (e.which) {
                case 1:// Left button
                    this$1.mouseDownLeft = false;
                    this$1.mouseDownRight = false;
                    break;
                case 2:// Middle/both buttons
                    this$1.mouseDownMiddle = false;
                    break;
                case 3:// Right button
                    this$1.mouseDownLeft = false;
                    this$1.mouseDownRight = false;
                    break;
            }
            this$1._getMouseCanvasPos(e);
            this$1.fire("click", this$1.mouseCanvasPos, true);
            if (this$1.mouseover) {
                e.preventDefault();
            }
        });

        document.addEventListener("dblclick", this._dblClickListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            switch (e.which) {
                case 1:// Left button
                    this$1.mouseDownLeft = false;
                    this$1.mouseDownRight = false;
                    break;
                case 2:// Middle/both buttons
                    this$1.mouseDownMiddle = false;
                    break;
                case 3:// Right button
                    this$1.mouseDownLeft = false;
                    this$1.mouseDownRight = false;
                    break;
            }
            this$1._getMouseCanvasPos(e);
            this$1.fire("dblclick", this$1.mouseCanvasPos, true);
            if (this$1.mouseover) {
                e.preventDefault();
            }
        });

        this.element.addEventListener("mousemove", this._mouseMoveListener = function (e) {
            if (!this$1.enabled) {
                return;
            }
            this$1._getMouseCanvasPos(e);
            this$1.fire("mousemove", this$1.mouseCanvasPos, true);
            if (this$1.mouseover) {
                e.preventDefault();
            }
        });

        this.element.addEventListener("wheel", this._mouseWheelListener = function (e, d) {
            if (!this$1.enabled) {
                return;
            }
            var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
            this$1.fire("mousewheel", delta, true);
        }, {passive: true});

        // mouseclicked

        {
            var downX;
            var downY;
            // Tolerance between down and up positions for a mouse click
            var tolerance = 2;
            this.on("mousedown", function (params) {
                downX = params[0];
                downY = params[1];
            });
            this.on("mouseup", function (params) {
                if (downX >= (params[0] - tolerance) &&
                    downX <= (params[0] + tolerance) &&
                    downY >= (params[1] - tolerance) &&
                    downY <= (params[1] + tolerance)) {
                    this$1.fire("mouseclicked", params, true);
                }
            });
        }

        // VR

        {

            var orientationAngleLookup = {
                'landscape-primary': 90,
                'landscape-secondary': -90,
                'portrait-secondary': 180,
                'portrait-primary': 0
            };

            var orientation;
            var orientationAngle;
            var acceleration = math.vec3();
            var accelerationIncludingGravity = math.vec3();

            var orientationChangeEvent = {
                orientation: null,
                orientationAngle: 0
            };

            var deviceMotionEvent = {
                orientationAngle: 0,
                acceleration: null,
                accelerationIncludingGravity: accelerationIncludingGravity,
                rotationRate: math.vec3(),
                interval: 0
            };

            var deviceOrientationEvent = {
                alpha: 0,
                beta: 0,
                gamma: 0,
                absolute: false
            };

            if (window.OrientationChangeEvent) {
                window.addEventListener('orientationchange', this._orientationchangedListener = function () {

                        orientation = window.screen.orientation || window.screen.mozOrientation || window.msOrientation || null;
                        orientationAngle = orientation ? (orientationAngleLookup[orientation] || 0) : 0;

                        orientationChangeEvent.orientation = orientation;
                        orientationChangeEvent.orientationAngle = orientationAngle;

                        /**
                         * Fired when the orientation of the device has changed.
                         *
                         * @event orientationchange
                         * @param orientation The orientation: "landscape-primary", "landscape-secondary", "portrait-secondary" or "portrait-primary"
                         * @param orientationAngle The orientation angle in degrees: 90 for landscape-primary, -90 for landscape-secondary, 180 for portrait-secondary or 0 for portrait-primary.
                         */
                        this$1.fire("orientationchange", orientationChangeEvent);
                    },
                    false);
            }

            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', this._deviceMotionListener = function (e) {

                        deviceMotionEvent.interval = e.interval;
                        deviceMotionEvent.orientationAngle = orientationAngle;

                        var accel = e.acceleration;

                        if (accel) {
                            acceleration[0] = accel.x;
                            acceleration[1] = accel.y;
                            acceleration[2] = accel.z;
                            deviceMotionEvent.acceleration = acceleration;
                        } else {
                            deviceMotionEvent.acceleration = null;
                        }

                        var accelGrav = e.accelerationIncludingGravity;

                        if (accelGrav) {
                            accelerationIncludingGravity[0] = accelGrav.x;
                            accelerationIncludingGravity[1] = accelGrav.y;
                            accelerationIncludingGravity[2] = accelGrav.z;
                            deviceMotionEvent.accelerationIncludingGravity = accelerationIncludingGravity;
                        } else {
                            deviceMotionEvent.accelerationIncludingGravity = null;
                        }

                        deviceMotionEvent.rotationRate = e.rotationRate;

                        /**
                         * Fires on a regular interval and returns data about the rotation
                         * (in degrees per second) and acceleration (in meters per second squared) of the device, at that moment in
                         * time. Some devices do not have the hardware to exclude the effect of gravity.
                         *
                         * @event devicemotion
                         * @param Float32Array acceleration The acceleration of the device, in meters per second squared, as a 3-element vector. This value has taken into account the effect of gravity and removed it from the figures. This value may not exist if the hardware doesn't know how to remove gravity from the acceleration data.
                         * @param Float32Array accelerationIncludingGravity The acceleration of the device, in meters per second squared, as a 3-element vector. This value includes the effect of gravity, and may be the only value available on devices that don't have a gyroscope to allow them to properly remove gravity from the data.
                         * @param, Number interval The interval, in milliseconds, at which this event is fired. The next event will be fired in approximately this amount of time.
                         * @param  Float32Array rotationRate The rates of rotation of the device about each axis, in degrees per second.
                         */
                        this$1.fire("devicemotion", deviceMotionEvent);
                    },
                    false);
            }

            if (window.DeviceOrientationEvent) {
                window.addEventListener("deviceorientation", this._deviceOrientListener = function (e) {

                        deviceOrientationEvent.gamma = e.gamma;
                        deviceOrientationEvent.beta = e.beta;
                        deviceOrientationEvent.alpha = e.alpha;
                        deviceOrientationEvent.absolute = e.absolute;

                        /**
                         * Fired when fresh data is available from an orientation sensor about the current orientation
                         * of the device as compared to the Earth coordinate frame. This data is gathered from a
                         * magnetometer inside the device. See
                         * <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained">Orientation and motion data explained</a> for more info.
                         *
                         * @event deviceorientation
                         * @param Number alpha The current orientation of the device around the Z axis in degrees; that is, how far the device is rotated around a line perpendicular to the device.
                         * @param Number beta The current orientation of the device around the X axis in degrees; that is, how far the device is tipped forward or backward.
                         * @param Number gamma The current orientation of the device around the Y axis in degrees; that is, how far the device is turned left or right.
                         * @param Boolean absolute This value is true if the orientation is provided as a difference between the device coordinate frame and the Earth coordinate frame; if the device can't detect the Earth coordinate frame, this value is false.
                         */
                        this$1.fire("deviceorientation", deviceOrientationEvent);
                    },
                    false);
            }
        }
        this._eventsBound = true;
    };

    Input.prototype._unbindEvents = function _unbindEvents () {
        if (!this._eventsBound) {
            return;
        }
        document.removeEventListener("keydown", this._keyDownListener);
        document.removeEventListener("keyup", this._keyUpListener);
        this.element.removeEventListener("mouseenter", this._mouseEnterListener);
        this.element.removeEventListener("mouseleave", this._mouseLeaveListener);
        this.element.removeEventListener("mousedown", this._mouseDownListener);
        document.removeEventListener("mouseup", this._mouseDownListener);
        document.removeEventListener("click", this._clickListener);
        document.removeEventListener("dblclick", this._dblClickListener);
        this.element.removeEventListener("mousemove", this._mouseMoveListener);
        this.element.removeEventListener("wheel", this._mouseWheelListener);
        if (window.OrientationChangeEvent) {
            window.removeEventListener('orientationchange', this._orientationchangedListener);
        }
        if (window.DeviceMotionEvent) {
            window.removeEventListener('devicemotion', this._deviceMotionListener);
        }
        if (window.DeviceOrientationEvent) {
            window.removeEventListener("deviceorientation", this._deviceOrientListener);
        }
        this._eventsBound = false;
    };

    Input.prototype._getMouseCanvasPos = function _getMouseCanvasPos (event) {
        if (!event) {
            event = window.event;
            this.mouseCanvasPos[0] = event.x;
            this.mouseCanvasPos[1] = event.y;
        } else {
            var element = event.target;
            var totalOffsetLeft = 0;
            var totalOffsetTop = 0;
            while (element.offsetParent) {
                totalOffsetLeft += element.offsetLeft;
                totalOffsetTop += element.offsetTop;
                element = element.offsetParent;
            }
            this.mouseCanvasPos[0] = event.pageX - totalOffsetLeft;
            this.mouseCanvasPos[1] = event.pageY - totalOffsetTop;
        }
    };

    /**
     * Sets whether input handlers are enabled.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} enable Indicates if input handlers are enabled.
     */
    Input.prototype.setEnabled = function setEnabled (enable) {
        if (this.enabled !== enable) {
            this.fire("enabled", this.enabled = enable);
        }
    };

    /**
     * Gets whether input handlers are enabled.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Indicates if input handlers are enabled.
     */
    Input.prototype.getEnabled = function getEnabled () {
        return this.enabled;
    };

    /**
     * Sets whether or not keyboard input is enabled.
     *
     * Default value is ````true````.
     *
     * {@link CameraControl} will not respond to keyboard events while this is set ````false````.
     *
     * @param {Boolean} value Indicates whether keyboard input is enabled.
     */
    Input.prototype.setKeyboardEnabled = function setKeyboardEnabled (value) {
        this.keyboardEnabled = value;
    };

    /**
     * Gets whether keyboard input is enabled.
     *
     * Default value is ````true````.
     *
     * {@link CameraControl} will not respond to keyboard events while this is set ````false````.
     *
     * @returns {Boolean} Returns whether keyboard input is enabled.
     */
    Input.prototype.getKeyboardEnabled = function getKeyboardEnabled () {
        return this.keyboardEnabled;
    };

    /**
     * @private
     */
    Input.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._unbindEvents();
    };

    return Input;
}(Component));

var ids$3 = new Map({});

/**
 * @desc Represents a chunk of state changes applied by the {@link Scene}'s renderer while it renders a frame.
 *
 * * Contains properties that represent the state changes.
 * * Has a unique automatically-generated numeric ID, which the renderer can use to sort these, in order to avoid applying redundant state changes for each frame.
 * * Initialize your own properties on a RenderState via its constructor.
 *
 * @private
 */
var RenderState = function RenderState(cfg) {

    /**
     The RenderState's ID, unique within the renderer.
     @property id
     @type {Number}
     @final
     */
    this.id = ids$3.addItem({});
    for (var key in cfg) {
        if (cfg.hasOwnProperty(key)) {
            this[key] = cfg[key];
        }
    }
};

/**
 Destroys this RenderState.
 */
RenderState.prototype.destroy = function destroy () {
    ids$3.removeItem(this.id);
};

/**
 * @desc controls the canvas viewport for a {@link Scene}.
 *
 * * One Viewport per scene.
 * * You can configure a Scene to render multiple times per frame, while setting the Viewport to different extents on each render.
 * * Make a Viewport automatically size to its {@link Scene} {@link Canvas} by setting its {@link Viewport#autoBoundary} ````true````.
 *
 *
 * Configuring the Scene to render twice on each frame, each time to a separate viewport:
 *
 * ````Javascript
 * // Load glTF model
 * var model = new xeokit.GLTFModel({
    src: "models/gltf/GearboxAssy/glTF-MaterialsCommon/GearboxAssy.gltf"
 });

 var scene = model.scene;
 var viewport = scene.viewport;

 // Configure Scene to render twice for each frame
 scene.passes = 2; // Default is 1
 scene.clearEachPass = false; // Default is false

 // Render to a separate viewport on each render

 var viewport = scene.viewport;
 viewport.autoBoundary = false;

 scene.on("rendering", function (e) {
     switch (e.pass) {
         case 0:
             viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
             break;

         case 1:
             viewport.boundary = [200, 0, 200, 200];
             break;
     }
 });
 ````

 @class Viewport
 @module xeokit
 @submodule rendering
 @constructor
 @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.
 @param {*} [cfg] Viewport configuration
 @param {String} [cfg.id] Optional ID, unique among all components in the parent
 {@link Scene}, generated automatically when omitted.
 @param {String:Object} [cfg.meta] Optional map of user-defined metadata to attach to this Viewport.
 @param [cfg.boundary] {Number[]} Canvas-space Viewport boundary, given as
 (min, max, width, height). Defaults to the size of the parent
 {@link Scene} {@link Canvas}.
 @param [cfg.autoBoundary=false] {Boolean} Indicates if this Viewport's {@link Viewport#boundary}
 automatically synchronizes with the size of the parent {@link Scene} {@link Canvas}.

 @extends Component
 */

var Viewport = /*@__PURE__*/(function (Component) {
    function Viewport(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._state = new RenderState({
            boundary: [0, 0, 100, 100]
        });

        this.boundary = cfg.boundary;
        this.autoBoundary = cfg.autoBoundary;
    }

    if ( Component ) Viewport.__proto__ = Component;
    Viewport.prototype = Object.create( Component && Component.prototype );
    Viewport.prototype.constructor = Viewport;

    var prototypeAccessors = { type: { configurable: true },boundary: { configurable: true },autoBoundary: { configurable: true } };


    /**
     * Sets the canvas-space boundary of this Viewport, indicated as ````[min, max, width, height]````.
     *
     * When {@link Viewport#autoBoundary} is ````true````, ignores calls to this method and automatically synchronizes with {@link Canvas#boundary}.
     *
     * Fires a "boundary"" event on change.
     *
     * Defaults to the {@link Canvas} extents.
     *
     * @param {Number[]} value New Viewport extents.
     */
    prototypeAccessors.type.get = function () {
        return "Viewport";
    };

    prototypeAccessors.boundary.set = function (value) {

        if (this._autoBoundary) {
            return;
        }

        if (!value) {

            var canvasBoundary = this.scene.canvas.boundary;

            var width = canvasBoundary[2];
            var height = canvasBoundary[3];

            value = [0, 0, width, height];
        }

        this._state.boundary = value;

        this.glRedraw();

        /**
         Fired whenever this Viewport's {@link Viewport#boundary} property changes.

         @event boundary
         @param value {Boolean} The property's new value
         */
        this.fire("boundary", this._state.boundary);
    };

    /**
     * Gets the canvas-space boundary of this Viewport, indicated as ````[min, max, width, height]````.
     *
     * @returns {Number[]} The Viewport extents.
     */
    prototypeAccessors.boundary.get = function () {
        return this._state.boundary;
    };

    /**
     * Sets if {@link Viewport#boundary} automatically synchronizes with {@link Canvas#boundary}.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set true to automatically sycnhronize.
     */
    prototypeAccessors.autoBoundary.set = function (value) {

        value = !!value;

        if (value === this._autoBoundary) {
            return;
        }

        this._autoBoundary = value;

        if (this._autoBoundary) {
            this._onCanvasSize = this.scene.canvas.on("boundary",
                function (boundary) {

                    var width = boundary[2];
                    var height = boundary[3];

                    this._state.boundary = [0, 0, width, height];

                    this.glRedraw();

                    /**
                     Fired whenever this Viewport's {@link Viewport#boundary} property changes.

                     @event boundary
                     @param value {Boolean} The property's new value
                     */
                    this.fire("boundary", this._state.boundary);

                }, this);

        } else if (this._onCanvasSize) {
            this.scene.canvas.off(this._onCanvasSize);
            this._onCanvasSize = null;
        }

        /**
         Fired whenever this Viewport's {@link autoBoundary/autoBoundary} property changes.

         @event autoBoundary
         @param value The property's new value
         */
        this.fire("autoBoundary", this._autoBoundary);
    };

    /**
     * Gets if {@link Viewport#boundary} automatically synchronizes with {@link Canvas#boundary}.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when automatically sycnhronizing.
     */
    prototypeAccessors.autoBoundary.get = function () {
        return this._autoBoundary;
    };

    Viewport.prototype._getState = function _getState () {
        return this._state;
    };

    /**
     * @private
     */
    Viewport.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( Viewport.prototype, prototypeAccessors );

    return Viewport;
}(Component));

/**
 * @desc Defines its {@link Camera}'s perspective projection using a field-of-view angle.
 *
 * * Located at {@link Camera#perspective}.
 * * Implicitly sets the left, right, top, bottom frustum planes using {@link Perspective#fov}.
 * * {@link Perspective#near} and {@link Perspective#far} specify the distances to the WebGL clipping planes.
 */
var Perspective = /*@__PURE__*/(function (Component) {
    function Perspective(camera, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, camera, cfg);

        /**
         * The Camera this Perspective belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */
        this.camera = camera;

        this._state = new RenderState({
            matrix: math.mat4(),
            inverseMatrix: math.mat4(),
            transposedMatrix: math.mat4(),
            near: 0.1,
            far: 2000.0
        });

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        this._fov = 60.0;

        // Recompute aspect from change in canvas size
        this._canvasResized = this.scene.canvas.on("boundary", this._needUpdate, this);

        this.fov = cfg.fov;
        this.fovAxis = cfg.fovAxis;
        this.near = cfg.near;
        this.far = cfg.far;
    }

    if ( Component ) Perspective.__proto__ = Component;
    Perspective.prototype = Object.create( Component && Component.prototype );
    Perspective.prototype.constructor = Perspective;

    var prototypeAccessors = { type: { configurable: true },fov: { configurable: true },fovAxis: { configurable: true },near: { configurable: true },far: { configurable: true },matrix: { configurable: true },inverseMatrix: { configurable: true },transposedMatrix: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Perspective";
    };

    Perspective.prototype._update = function _update () {

        var WIDTH_INDEX = 2;
        var HEIGHT_INDEX = 3;
        var boundary = this.scene.viewport.boundary;
        var aspect = boundary[WIDTH_INDEX] / boundary[HEIGHT_INDEX];
        var fovAxis = this._fovAxis;

        var fov = this._fov;
        if (fovAxis === "x" || (fovAxis === "min" && aspect < 1) || (fovAxis === "max" && aspect > 1)) {
            fov = fov / aspect;
        }
        fov = Math.min(fov, 120);

        math.perspectiveMat4(fov * (Math.PI / 180.0), aspect, this._state.near, this._state.far, this._state.matrix);

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        this.glRedraw();

        this.fire("matrix", this._state.matrix);
    };

    /**
     * Sets the Perspective's field-of-view angle (FOV).
     *
     * Fires an "fov" event on change.

     * Default value is ````60.0````.
     *
     * @param {Number} value New field-of-view.
     */
    prototypeAccessors.fov.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 60.0;
        if (value === this._fov) {
            return;
        }
        this._fov = value;
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("fov", this._fov);
    };

    /**
     * Gets the Perspective's field-of-view angle (FOV).
     *
     * Default value is ````60.0````.
     *
     * @returns {Number} Current field-of-view.
     */
    prototypeAccessors.fov.get = function () {
        return this._fov;
    };

    /**
     * Sets the Perspective's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Fires an "fovAxis" event on change.

     * Default value ````"min"````.
     *
     * @param {String} value New FOV axis value.
     */
    prototypeAccessors.fovAxis.set = function (value) {
        value = value || "min";
        if (this._fovAxis === value) {
            return;
        }
        if (value !== "x" && value !== "y" && value !== "min") {
            this.error("Unsupported value for 'fovAxis': " + value + " - defaulting to 'min'");
            value = "min";
        }
        this._fovAxis = value;
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("fovAxis", this._fovAxis);
    };

    /**
     * Gets the Perspective's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Fires an "fovAxis" event on change.

     * Default value is ````"min"````.
     *
     * @returns {String} The current FOV axis value.
     */
    prototypeAccessors.fovAxis.get = function () {
        return this._fovAxis;
    };

    /**
     * Sets the position of the Perspective's near plane on the positive View-space Z-axis.
     *
     * Fires a "near" event on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Perspective near plane position.
     */
    prototypeAccessors.near.set = function (value) {
        var near = (value !== undefined && value !== null) ? value : 0.1;
        if (this._state.near === near) {
            return;
        }
        this._state.near = near;
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("near", this._state.near);
    };

    /**
     * Gets the position of the Perspective's near plane on the positive View-space Z-axis.
     *
     * Fires an "emits" emits on change.
     *
     * Default value is ````0.1````.
     *
     * @returns The Perspective's near plane position.
     */
    prototypeAccessors.near.get = function () {
        return this._state.near;
    };

    /**
     * Sets the position of this Perspective's far plane on the positive View-space Z-axis.
     *
     * Fires a "far" event on change.
     *
     * @param {Number} value New Perspective far plane position.
     */
    prototypeAccessors.far.set = function (value) {
        var far = (value !== undefined && value !== null) ? value : 2000.0;
        if (this._state.far === far) {
            return;
        }
        this._state.far = far;
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("far", this._state.far);
    };

    /**
     * Gets the position of this Perspective's far plane on the positive View-space Z-axis.
     *
     * @return {Number} The Perspective's far plane position.
     */
    prototypeAccessors.far.get = function () {
        return this._state.far;
    };

    /**
     * Gets the Perspective's projection transform matrix.
     *
     * Fires a "matrix" event on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Perspective's projection matrix.
     */
    prototypeAccessors.matrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.matrix;
    };

    /**
     * Gets the inverse of {@link Perspective#matrix}.
     *
     * @returns {Number[]} The inverse of {@link Perspective#matrix}.
     */
    prototypeAccessors.inverseMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._inverseMatrixDirty) {
            math.inverseMat4(this._state.matrix, this._state.inverseMatrix);
            this._inverseMatrixDirty = false;
        }
        return this._state.inverseMatrix;
    };

    /**
     * Gets the transpose of {@link Perspective#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Perspective#matrix}.
     */
    prototypeAccessors.transposedMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._transposedMatrixDirty) {
            math.transposeMat4(this._state.matrix, this._state.transposedMatrix);
            this._transposedMatrixDirty = false;
        }
        return this._state.transposedMatrix;
    };

    /**
     * Un-projects the given Canvas-space coordinates and Screen-space depth, using this Perspective projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */
    Perspective.prototype.unproject = function unproject (canvasPos, screenZ, screenPos, viewPos, worldPos) {

        var canvas = this.scene.canvas.canvas;

        var halfCanvasWidth = canvas.offsetWidth / 2.0;
        var halfCanvasHeight = canvas.offsetHeight / 2.0;

        screenPos[0] = (canvasPos[0] - halfCanvasWidth) / halfCanvasWidth;
        screenPos[1] = (canvasPos[1] - halfCanvasHeight) / halfCanvasHeight;
        screenPos[2] = screenZ;
        screenPos[3] = 1.0;

        math.mulMat4v4(this.inverseMatrix, screenPos, viewPos);
        math.mulVec3Scalar(viewPos, 1.0 / viewPos[3]);

        viewPos[3] = 1.0;
        viewPos[1] *= -1;

        math.mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);

        return worldPos;
    };

    /** @private
     *
     */
    Perspective.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
        this.scene.canvas.off(this._canvasResized);
    };

    Object.defineProperties( Perspective.prototype, prototypeAccessors );

    return Perspective;
}(Component));

/**
 * @desc Defines its {@link Camera}'s orthographic projection as a box-shaped view volume.
 *
 * * Located at {@link Camera#ortho}.
 * * Works like Blender's orthographic projection, where the positions of the left, right, top and bottom planes are implicitly
 * indicated with a single {@link Ortho#scale} property, which causes the frustum to be symmetrical on X and Y axis, large enough to
 * contain the number of units given by {@link Ortho#scale}.
 * * {@link Ortho#near} and {@link Ortho#far} indicated the distances to the WebGL clipping planes.
 */
var Ortho = /*@__PURE__*/(function (Component) {
    function Ortho(camera, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, camera, cfg);

        /**
         * The Camera this Ortho belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */
        this.camera = camera;

        this._state = new RenderState({
            matrix: math.mat4(),
            inverseMatrix: math.mat4(),
            transposedMatrix: math.mat4(),
            near: 0.1,
            far: 2000.0
        });

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        this.scale = cfg.scale;
        this.near = cfg.near;
        this.far = cfg.far;

        this._onCanvasBoundary = this.scene.canvas.on("boundary", this._needUpdate, this);
    }

    if ( Component ) Ortho.__proto__ = Component;
    Ortho.prototype = Object.create( Component && Component.prototype );
    Ortho.prototype.constructor = Ortho;

    var prototypeAccessors = { type: { configurable: true },scale: { configurable: true },near: { configurable: true },far: { configurable: true },matrix: { configurable: true },inverseMatrix: { configurable: true },transposedMatrix: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Ortho";
    };

    Ortho.prototype._update = function _update () {

        var WIDTH_INDEX = 2;
        var HEIGHT_INDEX = 3;

        var scene = this.scene;
        var scale = this._scale;
        var halfSize = 0.5 * scale;

        var boundary = scene.viewport.boundary;
        var boundaryWidth = boundary[WIDTH_INDEX];
        var boundaryHeight = boundary[HEIGHT_INDEX];
        var aspect = boundaryWidth / boundaryHeight;

        var left;
        var right;
        var top;
        var bottom;

        if (boundaryWidth > boundaryHeight) {
            left = -halfSize;
            right = halfSize;
            top = halfSize / aspect;
            bottom = -halfSize / aspect;

        } else {
            left = -halfSize * aspect;
            right = halfSize * aspect;
            top = halfSize;
            bottom = -halfSize;
        }

        math.orthoMat4c(left, right, bottom, top, this._state.near, this._state.far, this._state.matrix);

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        this.glRedraw();

        this.fire("matrix", this._state.matrix);
    };


    /**
     * Sets scale factor for this Ortho's extents on X and Y axis.
     *
     * Clamps to minimum value of ````0.01```.
     *
     * Fires a "scale" event on change.
     *
     * Default value is ````1.0````
     * @param {Number} value New scale value.
     */
    prototypeAccessors.scale.set = function (value) {
        if (value === undefined || value === null) {
            value = 1.0;
        }
        if (value <= 0) {
            value = 0.01;
        }
        this._scale = value;
        this._needUpdate(0);
        this.fire("scale", this._scale);
    };

    /**
     * Gets scale factor for this Ortho's extents on X and Y axis.
     *
     * Clamps to minimum value of ````0.01```.
     *
     * Default value is ````1.0````
     *
     * @returns {Number} New Ortho scale value.
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the position of the Ortho's near plane on the positive View-space Z-axis.
     *
     * Fires a "near" emits on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Ortho near plane position.
     */
    prototypeAccessors.near.set = function (value) {
        var near = (value !== undefined && value !== null) ? value : 0.1;
        if (this._state.near === near) {
            return;
        }
        this._state.near = near;
        this._needUpdate(0);
        this.fire("near", this._state.near);
    };

    /**
     * Gets the position of the Ortho's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @returns {Number} New Ortho near plane position.
     */
    prototypeAccessors.near.get = function () {
        return this._state.near;
    };

    /**
     * Sets the position of the Ortho's far plane on the positive View-space Z-axis.
     *
     * Fires a "far" event on change.
     *
     * Default value is ````2000.0````.
     *
     * @param {Number} value New far ortho plane position.
     */
    prototypeAccessors.far.set = function (value) {
        var far = (value !== undefined && value !== null) ? value : 2000.0;
        if (this._state.far === far) {
            return;
        }
        this._state.far = far;
        this._needUpdate(0);
        this.fire("far", this._state.far);
    };

    /**
     * Gets the position of the Ortho's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @returns {Number} New far ortho plane position.
     */
    prototypeAccessors.far.get = function () {
        return this._state.far;
    };

    /**
     * Gets the Ortho's projection transform matrix.
     *
     * Fires a "matrix" event on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Ortho's projection matrix.
     */
    prototypeAccessors.matrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.matrix;
    };

    /**
     * Gets the inverse of {@link Ortho#matrix}.
     *
     * @returns {Number[]} The inverse of {@link Ortho#matrix}.
     */
    prototypeAccessors.inverseMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._inverseMatrixDirty) {
            math.inverseMat4(this._state.matrix, this._state.inverseMatrix);
            this._inverseMatrixDirty = false;
        }
        return this._state.inverseMatrix;
    };

    /**
     * Gets the transpose of {@link Ortho#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Ortho#matrix}.
     */
    prototypeAccessors.transposedMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._transposedMatrixDirty) {
            math.transposeMat4(this._state.matrix, this._state.transposedMatrix);
            this._transposedMatrixDirty = false;
        }
        return this._state.transposedMatrix;
    };

    /**
     * Un-projects the given Canvas-space coordinates, using this Ortho projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */
    Ortho.prototype.unproject = function unproject (canvasPos, screenZ, screenPos, viewPos, worldPos) {

        var canvas = this.scene.canvas.canvas;

        var halfCanvasWidth = canvas.offsetWidth / 2.0;
        var halfCanvasHeight = canvas.offsetHeight / 2.0;

        screenPos[0] = (canvasPos[0] - halfCanvasWidth) / halfCanvasWidth;
        screenPos[1] = (canvasPos[1] - halfCanvasHeight) / halfCanvasHeight;
        screenPos[2] = screenZ;
        screenPos[3] = 1.0;

        math.mulMat4v4(this.inverseMatrix, screenPos, viewPos);
        math.mulVec3Scalar(viewPos, 1.0 / viewPos[3]);

        viewPos[3] = 1.0;
        viewPos[1] *= -1;

        math.mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);

        return worldPos;
    };

    /** @private
     *
     */
    Ortho.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
        this.scene.canvas.off(this._onCanvasBoundary);
    };

    Object.defineProperties( Ortho.prototype, prototypeAccessors );

    return Ortho;
}(Component));

/**
 * @desc Defines its {@link Camera}'s perspective projection as a frustum-shaped view volume.
 *
 * * Located at {@link Camera#frustum}.
 * * Allows to explicitly set the positions of the left, right, top, bottom, near and far planes, which is useful for asymmetrical view volumes, such as for stereo viewing.
 * * {@link Frustum#near} and {@link Frustum#far} specify the distances to the WebGL clipping planes.
 */
var Frustum$1 = /*@__PURE__*/(function (Component) {
    function Frustum(camera, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, camera, cfg);

        /**
         * The Camera this Frustum belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */
        this.camera = camera;

        this._state = new RenderState({
            matrix: math.mat4(),
            inverseMatrix: math.mat4(),
            transposedMatrix: math.mat4(),
            near: 0.1,
            far: 10000.0
        });

        this._left = -1.0;
        this._right = 1.0;
        this._bottom = -1.0;
        this._top = 1.0;

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        // Set component properties

        this.left = cfg.left;
        this.right = cfg.right;
        this.bottom = cfg.bottom;
        this.top = cfg.top;
        this.near = cfg.near;
        this.far = cfg.far;
    }

    if ( Component ) Frustum.__proto__ = Component;
    Frustum.prototype = Object.create( Component && Component.prototype );
    Frustum.prototype.constructor = Frustum;

    var prototypeAccessors = { type: { configurable: true },left: { configurable: true },right: { configurable: true },top: { configurable: true },bottom: { configurable: true },near: { configurable: true },far: { configurable: true },matrix: { configurable: true },inverseMatrix: { configurable: true },transposedMatrix: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Frustum";
    };

    Frustum.prototype._update = function _update () {

        math.frustumMat4(this._left, this._right, this._bottom, this._top, this._state.near, this._state.far, this._state.matrix);

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;

        this.glRedraw();

        this.fire("matrix", this._state.matrix);
    };

    /**
     * Sets the position of the Frustum's left plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#left:emits} emits on change.
     *
     * @param {Number} value New left frustum plane position.
     */
    prototypeAccessors.left.set = function (value) {
        this._left = (value !== undefined && value !== null) ? value : -1.0;
        this._needUpdate(0);
        this.fire("left", this._left);
    };

    /**
     * Gets the position of the Frustum's left plane on the View-space X-axis.
     *
     * @return {Number} Left frustum plane position.
     */
    prototypeAccessors.left.get = function () {
        return this._left;
    };

    /**
     * Sets the position of the Frustum's right plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#right:emits} emits on change.
     *
     * @param {Number} value New right frustum plane position.
     */
    prototypeAccessors.right.set = function (value) {
        this._right = (value !== undefined && value !== null) ? value : 1.0;
        this._needUpdate(0);
        this.fire("right", this._right);
    };

    /**
     * Gets the position of the Frustum's right plane on the View-space X-axis.
     *
     * Fires a {@link Frustum#right:emits} emits on change.
     *
     * @return {Number} Right frustum plane position.
     */
    prototypeAccessors.right.get = function () {
        return this._right;
    };

    /**
     * Sets the position of the Frustum's top plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#top:emits} emits on change.
     *
     * @param {Number} value New top frustum plane position.
     */
    prototypeAccessors.top.set = function (value) {
        this._top = (value !== undefined && value !== null) ? value : 1.0;
        this._needUpdate(0);
        this.fire("top", this._top);
    };

    /**
     * Gets the position of the Frustum's top plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#top:emits} emits on change.
     *
     * @return {Number} Top frustum plane position.
     */
    prototypeAccessors.top.get = function () {
        return this._top;
    };

    /**
     * Sets the position of the Frustum's bottom plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#bottom:emits} emits on change.
     *
     * @emits {"bottom"} event with the value of this property whenever it changes.
     *
     * @param {Number} value New bottom frustum plane position.
     */
    prototypeAccessors.bottom.set = function (value) {
        this._bottom = (value !== undefined && value !== null) ? value : -1.0;
        this._needUpdate(0);
        this.fire("bottom", this._bottom);
    };

    /**
     * Gets the position of the Frustum's bottom plane on the View-space Y-axis.
     *
     * Fires a {@link Frustum#bottom:emits} emits on change.
     *
     * @return {Number} Bottom frustum plane position.
     */
    prototypeAccessors.bottom.get = function () {
        return this._bottom;
    };

    /**
     * Sets the position of the Frustum's near plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#near:emits} emits on change.
     *
     * Default value is ````0.1````.
     *
     * @param {Number} value New Frustum near plane position.
     */
    prototypeAccessors.near.set = function (value) {
        this._state.near = (value !== undefined && value !== null) ? value : 0.1;
        this._needUpdate(0);
        this.fire("near", this._state.near);
    };

    /**
     * Gets the position of the Frustum's near plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#near:emits} emits on change.
     *
     * Default value is ````0.1````.
     *
     * @return {Number} Near frustum plane position.
     */
    prototypeAccessors.near.get = function () {
        return this._state.near;
    };

    /**
     * Sets the position of the Frustum's far plane on the positive View-space Z-axis.
     *
     * Fires a {@link Frustum#far:emits} emits on change.
     *
     * Default value is ````10000.0````.
     *
     * @param {Number} value New far frustum plane position.
     */
    prototypeAccessors.far.set = function (value) {
        this._state.far = (value !== undefined && value !== null) ? value : 10000.0;
        this._needUpdate(0);
        this.fire("far", this._state.far);
    };

    /**
     * Gets the position of the Frustum's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @return {Number} Far frustum plane position.
     */
    prototypeAccessors.far.get = function () {
        return this._state.far;
    };

    /**
     * Gets the Frustum's projection transform matrix.
     *
     * Fires a {@link Frustum#matrix:emits} emits on change.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns {Number[]} The Frustum's projection matrix matrix.
     */
    prototypeAccessors.matrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.matrix;
    };

    /**
     * Gets the inverse of {@link Frustum#matrix}.
     *
     * @returns {Number[]} The inverse orthographic projection matrix.
     */
    prototypeAccessors.inverseMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._inverseMatrixDirty) {
            math.inverseMat4(this._state.matrix, this._state.inverseMatrix);
            this._inverseMatrixDirty = false;
        }
        return this._state.inverseMatrix;
    };

    /**
     * Gets the transpose of {@link Frustum#matrix}.
     *
     * @returns {Number[]} The transpose of {@link Frustum#matrix}.
     */
    prototypeAccessors.transposedMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._transposedMatrixDirty) {
            math.transposeMat4(this._state.matrix, this._state.transposedMatrix);
            this._transposedMatrixDirty = false;
        }
        return this._state.transposedMatrix;
    };

    /**
     * Un-projects the given Canvas-space coordinates, using this Frustum projection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */
    Frustum.prototype.unproject = function unproject (canvasPos, screenZ, screenPos, viewPos, worldPos) {

        var canvas = this.scene.canvas.canvas;

        var halfCanvasWidth = canvas.offsetWidth / 2.0;
        var halfCanvasHeight = canvas.offsetHeight / 2.0;

        screenPos[0] = (canvasPos[0] - halfCanvasWidth) / halfCanvasWidth;
        screenPos[1] = (canvasPos[1] - halfCanvasHeight) / halfCanvasHeight;
        screenPos[2] = screenZ;
        screenPos[3] = 1.0;

        math.mulMat4v4(this.inverseMatrix, screenPos, viewPos);
        math.mulVec3Scalar(viewPos, 1.0 / viewPos[3]);

        viewPos[3] = 1.0;
        viewPos[1] *= -1;

        math.mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);

        return worldPos;
    };

    /** @private
     *
     */
    Frustum.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( Frustum.prototype, prototypeAccessors );

    return Frustum;
}(Component));

/**
 * @desc Defines a custom projection for a {@link Camera} as a custom 4x4 matrix..
 *
 * Located at {@link Camera#customProjection}.
 */
var CustomProjection = /*@__PURE__*/(function (Component) {
    function CustomProjection(camera, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, camera, cfg);

        /**
         * The Camera this CustomProjection belongs to.
         *
         * @property camera
         * @type {Camera}
         * @final
         */
        this.camera = camera;

        this._state = new RenderState({
            matrix: math.mat4(),
            inverseMatrix: math.mat4(),
            transposedMatrix: math.mat4()
        });

        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = false;

        this.matrix = cfg.matrix;
    }

    if ( Component ) CustomProjection.__proto__ = Component;
    CustomProjection.prototype = Object.create( Component && Component.prototype );
    CustomProjection.prototype.constructor = CustomProjection;

    var prototypeAccessors = { type: { configurable: true },matrix: { configurable: true },inverseMatrix: { configurable: true },transposedMatrix: { configurable: true } };

    /**
     * Sets the CustomProjection's projection transform matrix.
     *
     * Fires a "matrix" event on change.

     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @param {Number[]} matrix New value for the CustomProjection's matrix.
     */
    prototypeAccessors.type.get = function () {
        return "CustomProjection";
    };

    prototypeAccessors.matrix.set = function (matrix) {
        this._state.matrix.set(matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this._inverseMatrixDirty = true;
        this._transposedMatrixDirty = true;
        this.glRedraw();
        this.fire("far", this._state.matrix);
    };

    /**
     * Gets the CustomProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @return {Number[]} New value for the CustomProjection's matrix.
     */
    prototypeAccessors.matrix.get = function () {
        return this._state.matrix;
    };

    /**
     * Gets the inverse of {@link CustomProjection#matrix}.
     *
     * @returns {Number[]} The inverse of {@link CustomProjection#matrix}.
     */
    prototypeAccessors.inverseMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._inverseMatrixDirty) {
            math.inverseMat4(this._state.matrix, this._state.inverseMatrix);
            this._inverseMatrixDirty = false;
        }
        return this._state.inverseMatrix;
    };

    /**
     * Gets the transpose of {@link CustomProjection#matrix}.
     *
     * @returns {Number[]} The transpose of {@link CustomProjection#matrix}.
     */
    prototypeAccessors.transposedMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        if (this._transposedMatrixDirty) {
            math.transposeMat4(this._state.matrix, this._state.transposedMatrix);
            this._transposedMatrixDirty = false;
        }
        return this._state.transposedMatrix;
    };

    /**
     * Un-projects the given Canvas-space coordinates, using this CustomProjection.
     *
     * @param {Number[]} canvasPos Inputs 2D Canvas-space coordinates.
     * @param {Number} screenZ Inputs Screen-space Z coordinate.
     * @param {Number[]} screenPos Outputs 3D Screen/Clip-space coordinates.
     * @param {Number[]} viewPos Outputs un-projected 3D View-space coordinates.
     * @param {Number[]} worldPos Outputs un-projected 3D World-space coordinates.
     */
    CustomProjection.prototype.unproject = function unproject (canvasPos, screenZ, screenPos, viewPos, worldPos) {

        var canvas = this.scene.canvas.canvas;

        var halfCanvasWidth = canvas.offsetWidth / 2.0;
        var halfCanvasHeight = canvas.offsetHeight / 2.0;

        screenPos[0] = (canvasPos[0] - halfCanvasWidth) / halfCanvasWidth;
        screenPos[1] = (canvasPos[1] - halfCanvasHeight) / halfCanvasHeight;
        screenPos[2] = screenZ;
        screenPos[3] = 1.0;

        math.mulMat4v4(this.inverseMatrix, screenPos, viewPos);
        math.mulVec3Scalar(viewPos, 1.0 / viewPos[3]);

        viewPos[3] = 1.0;
        viewPos[1] *= -1;

        math.mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);

        return worldPos;
    };

    /** @private
     *
     */
    CustomProjection.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( CustomProjection.prototype, prototypeAccessors );

    return CustomProjection;
}(Component));

var tempVec3$5 = math.vec3();
var tempVec3b$8 = math.vec3();
var tempVec3c$5 = math.vec3();
var tempVec3d$3 = math.vec3();
var tempVec3e$2 = math.vec3();
var tempVec3f$2 = math.vec3();
var tempMat = math.mat4();
var tempMatb = math.mat4();
var eyeLookVec = math.vec3();
var eyeLookVecNorm = math.vec3();
var eyeLookOffset = math.vec3();
var offsetEye = math.vec3();

/**
 * @desc Manages viewing and projection transforms for its {@link Scene}.
 *
 * * One Camera per {@link Scene}
 * * Scene is located at {@link Viewer#scene} and Camera is located at {@link Scene#camera}
 * * Controls viewing and projection transforms
 * * Has methods to pan, zoom and orbit (or first-person rotation)
 * * Dynamically configurable World-space axis
 * * Has {@link Perspective}, {@link Ortho} and {@link Frustum} and {@link CustomProjection}, which you can dynamically switch it between
 * * Switchable gimbal lock
 * * Can be "flown" to look at targets using a {@link CameraFlightAnimation}
 * * Can be animated along a path using a {@link CameraPathAnimation}
 *
 * ## Getting the Camera
 *
 * There is exactly one Camera per {@link Scene}:
 *
 * ````javascript
 * import {Viewer} from "xeokit-sdk.es.js";
 *
 * var camera = viewer.scene.camera;
 *
 * ````
 *
 * ## Setting the Camera Position
 *
 * Get and set the Camera's absolute position via {@link Camera#eye}, {@link Camera#look} and {@link Camera#up}:
 *
 * ````javascript
 * camera.eye = [-10,0,0];
 * camera.look = [-10,0,0];
 * camera.up = [0,1,0];
 * ````
 *
 * ## Camera View and Projection Matrices
 *
 * The Camera's view matrix transforms coordinates from World-space to View-space.
 *
 * Getting the view matrix:
 *
 * ````javascript
 * var viewMatrix = camera.viewMatrix;
 * var viewNormalMatrix = camera.normalMatrix;
 * ````
 *
 * The Camera's view normal matrix transforms normal vectors from World-space to View-space.
 *
 * Getting the view normal matrix:
 *
 * ````javascript
 * var viewNormalMatrix = camera.normalMatrix;
 * ````
 *
 * The Camera fires a ````"viewMatrix"```` event whenever the {@link Camera#viewMatrix} and {@link Camera#viewNormalMatrix} updates.
 *
 * Listen for view matrix updates:
 *
 * ````javascript
 * camera.on("viewMatrix", function(matrix) { ... });
 * ````
 *
 * ## Rotating the Camera
 *
 * Orbiting the {@link Camera#look} position:
 *
 * ````javascript
 * camera.orbitYaw(20.0);
 * camera.orbitPitch(10.0);
 * ````
 *
 * First-person rotation, rotates {@link Camera#look} and {@link Camera#up} about {@link Camera#eye}:
 *
 * ````javascript
 * camera.yaw(5.0);
 * camera.pitch(-10.0);
 * ````
 *
 * ## Panning the Camera
 *
 * Panning along the Camera's local axis (ie. left/right, up/down, forward/backward):
 *
 * ````javascript
 * camera.pan([-20, 0, 10]);
 * ````
 *
 * ## Zooming the Camera
 *
 * Zoom to vary distance between {@link Camera#eye} and {@link Camera#look}:
 *
 * ````javascript
 * camera.zoom(-5); // Move five units closer
 * ````
 *
 * Get the current distance between {@link Camera#eye} and {@link Camera#look}:
 *
 * ````javascript
 * var distance = camera.eyeLookDist;
 * ````
 *
 * ## Projection
 *
 * The Camera has a Component to manage each projection type, which are: {@link Perspective}, {@link Ortho}
 * and {@link Frustum} and {@link CustomProjection}.
 *
 * You can configure those components at any time, regardless of which is currently active:
 *
 * The Camera has a {@link Perspective} to manage perspective
 * ````javascript
 *
 * // Set some properties on Perspective
 * camera.perspective.near = 0.4;
 * camera.perspective.fov = 45;
 *
 * // Set some properties on Ortho
 * camera.ortho.near = 0.8;
 * camera.ortho.far = 1000;
 *
 * // Set some properties on Frustum
 * camera.frustum.left = -1.0;
 * camera.frustum.right = 1.0;
 * camera.frustum.far = 1000.0;
 *
 * // Set the matrix property on CustomProjection
 * camera.customProjection.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 *
 * // Switch between the projection types
 * camera.projection = "perspective"; // Switch to perspective
 * camera.projection = "frustum"; // Switch to frustum
 * camera.projection = "ortho"; // Switch to ortho
 * camera.projection = "customProjection"; // Switch to custom
 * ````
 *
 * Camera provides the projection matrix for the currently active projection in {@link Camera#projMatrix}.
 *
 * Get the projection matrix:
 *
 * ````javascript
 * var projMatrix = camera.projMatrix;
 * ````
 *
 * Listen for projection matrix updates:
 *
 * ````javascript
 * camera.on("projMatrix", function(matrix) { ... });
 * ````
 *
 * ## Configuring World up direction
 *
 * We can dynamically configure the directions of the World-space coordinate system.
 *
 * Setting the +Y axis as World "up", +X as right and -Z as forwards (convention in some modeling software):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0,    // Right
 *     0, 1, 0,    // Up
 *     0, 0,-1     // Forward
 * ];
 * ````
 *
 * Setting the +Z axis as World "up", +X as right and -Y as "up" (convention in most CAD and BIM viewers):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0, // Right
 *     0, 0, 1, // Up
 *     0,-1, 0  // Forward
 * ];
 * ````
 *
 * The Camera has read-only convenience properties that provide each axis individually:
 *
 * ````javascript
 * var worldRight = camera.worldRight;
 * var worldForward = camera.worldForward;
 * var worldUp = camera.worldUp;
 * ````
 *
 * ### Gimbal locking
 *
 * By default, the Camera locks yaw rotation to pivot about the World-space "up" axis. We can dynamically lock and unlock that at any time:
 *
 * ````javascript
 * camera.gimbalLock = false; // Yaw rotation now happens about Camera's local Y-axis
 * camera.gimbalLock = true; // Yaw rotation now happens about World's "up" axis
 * ````
 *
 * See: <a href="https://en.wikipedia.org/wiki/Gimbal_lock">https://en.wikipedia.org/wiki/Gimbal_lock</a>
 */
var Camera = /*@__PURE__*/(function (Component) {
    function Camera(owner, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._state = new RenderState({
            deviceMatrix: math.mat4(),
            hasDeviceMatrix: false, // True when deviceMatrix set to other than identity
            matrix: math.mat4(),
            normalMatrix: math.mat4(),
            inverseMatrix: math.mat4()
        });

        this._perspective = new Perspective(this);
        this._ortho = new Ortho(this);
        this._frustum = new Frustum$1(this);
        this._customProjection = new CustomProjection(this);
        this._project = this._perspective;

        this._eye = math.vec3([0, 0, 10.0]);
        this._look = math.vec3([0, 0, 0]);
        this._up = math.vec3([0, 1, 0]);

        this._worldUp = math.vec3([0, 1, 0]);
        this._worldRight = math.vec3([1, 0, 0]);
        this._worldForward = math.vec3([0, 0, -1]);

        this.deviceMatrix = cfg.deviceMatrix;
        this.eye = cfg.eye;
        this.look = cfg.look;
        this.up = cfg.up;
        this.worldAxis = cfg.worldAxis;
        this.gimbalLock = cfg.gimbalLock;
        this.constrainPitch = cfg.constrainPitch;

        this.projection = cfg.projection;

        this._perspective.on("matrix", function () {
            if (this$1._projectionType === "perspective") {
                this$1.fire("projMatrix", this$1._perspective.matrix);
            }
        });
        this._ortho.on("matrix", function () {
            if (this$1._projectionType === "ortho") {
                this$1.fire("projMatrix", this$1._ortho.matrix);
            }
        });
        this._frustum.on("matrix", function () {
            if (this$1._projectionType === "frustum") {
                this$1.fire("projMatrix", this$1._frustum.matrix);
            }
        });
        this._customProjection.on("matrix", function () {
            if (this$1._projectionType === "customProjection") {
                this$1.fire("projMatrix", this$1._customProjection.matrix);
            }
        });
    }

    if ( Component ) Camera.__proto__ = Component;
    Camera.prototype = Object.create( Component && Component.prototype );
    Camera.prototype.constructor = Camera;

    var prototypeAccessors = { type: { configurable: true },eye: { configurable: true },look: { configurable: true },up: { configurable: true },deviceMatrix: { configurable: true },worldAxis: { configurable: true },worldUp: { configurable: true },xUp: { configurable: true },yUp: { configurable: true },zUp: { configurable: true },worldRight: { configurable: true },worldForward: { configurable: true },gimbalLock: { configurable: true },constrainPitch: { configurable: true },eyeLookDist: { configurable: true },matrix: { configurable: true },viewMatrix: { configurable: true },normalMatrix: { configurable: true },viewNormalMatrix: { configurable: true },inverseViewMatrix: { configurable: true },projMatrix: { configurable: true },perspective: { configurable: true },ortho: { configurable: true },frustum: { configurable: true },customProjection: { configurable: true },projection: { configurable: true },project: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Camera";
    };

    Camera.prototype._update = function _update () {
        var state = this._state;
        // In ortho mode, build the view matrix with an eye position that's translated
        // well back from look, so that the front sectionPlane plane doesn't unexpectedly cut
        // the front off the view (not a problem with perspective, since objects close enough
        // to be clipped by the front plane are usually too big to see anything of their cross-sections).
        var eye;
        if (this.projection === "ortho") {
            math.subVec3(this._eye, this._look, eyeLookVec);
            math.normalizeVec3(eyeLookVec, eyeLookVecNorm);
            math.mulVec3Scalar(eyeLookVecNorm, 1000.0, eyeLookOffset);
            math.addVec3(this._look, eyeLookOffset, offsetEye);
            eye = offsetEye;
        } else {
            eye = this._eye;
        }
        if (state.hasDeviceMatrix) {
            math.lookAtMat4v(eye, this._look, this._up, tempMatb);
            math.mulMat4(state.deviceMatrix, tempMatb, state.matrix);
            //state.matrix.set(state.deviceMatrix);
        } else {
            math.lookAtMat4v(eye, this._look, this._up, state.matrix);
        }
        math.inverseMat4(this._state.matrix, this._state.inverseMatrix);
        math.transposeMat4(this._state.inverseMatrix, this._state.normalMatrix);
        this.glRedraw();
        this.fire("matrix", this._state.matrix);
        this.fire("viewMatrix", this._state.matrix);
    };

    /**
     * Rotates {@link Camera#eye} about {@link Camera#look}, around the {@link Camera#up} vector
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */
    Camera.prototype.orbitYaw = function orbitYaw (angleInc) {
        var lookEyeVec = math.subVec3(this._eye, this._look, tempVec3$5);
        math.rotationMat4v(angleInc * 0.0174532925, this._gimbalLock ? this._worldUp : this._up, tempMat);
        lookEyeVec = math.transformPoint3(tempMat, lookEyeVec, tempVec3b$8);
        this.eye = math.addVec3(this._look, lookEyeVec, tempVec3c$5); // Set eye position as 'look' plus 'eye' vector
        this.up = math.transformPoint3(tempMat, this._up, tempVec3d$3); // Rotate 'up' vector
    };

    /**
     * Rotates {@link Camera#eye} about {@link Camera#look} around the right axis (orthogonal to {@link Camera#up} and "look").
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */
    Camera.prototype.orbitPitch = function orbitPitch (angleInc) {
        if (this._constrainPitch) {
            angleInc = math.dotVec3(this._up, this._worldUp) / math.DEGTORAD;
            if (angleInc < 1) {
                return;
            }
        }
        var eye2 = math.subVec3(this._eye, this._look, tempVec3$5);
        var left = math.cross3Vec3(math.normalizeVec3(eye2, tempVec3b$8), math.normalizeVec3(this._up, tempVec3c$5));
        math.rotationMat4v(angleInc * 0.0174532925, left, tempMat);
        eye2 = math.transformPoint3(tempMat, eye2, tempVec3d$3);
        this.up = math.transformPoint3(tempMat, this._up, tempVec3e$2);
        this.eye = math.addVec3(eye2, this._look, tempVec3f$2);
    };

    /**
     * Rotates {@link Camera#look} about {@link Camera#eye}, around the {@link Camera#up} vector.
     *
     * @param {Number} angleInc Angle of rotation in degrees
     */
    Camera.prototype.yaw = function yaw (angleInc) {
        var look2 = math.subVec3(this._look, this._eye, tempVec3$5);
        math.rotationMat4v(angleInc * 0.0174532925, this._gimbalLock ? this._worldUp : this._up, tempMat);
        look2 = math.transformPoint3(tempMat, look2, tempVec3b$8);
        this.look = math.addVec3(look2, this._eye, tempVec3c$5);
        if (this._gimbalLock) {
            this.up = math.transformPoint3(tempMat, this._up, tempVec3d$3);
        }
    };

    /**
     * Rotates {@link Camera#look} about {@link Camera#eye}, around the right axis (orthogonal to {@link Camera#up} and "look").

     * @param {Number} angleInc Angle of rotation in degrees
     */
    Camera.prototype.pitch = function pitch (angleInc) {
        if (this._constrainPitch) {
            angleInc = math.dotVec3(this._up, this._worldUp) / math.DEGTORAD;
            if (angleInc < 1) {
                return;
            }
        }
        var look2 = math.subVec3(this._look, this._eye, tempVec3$5);
        var left = math.cross3Vec3(math.normalizeVec3(look2, tempVec3b$8), math.normalizeVec3(this._up, tempVec3c$5));
        math.rotationMat4v(angleInc * 0.0174532925, left, tempMat);
        this.up = math.transformPoint3(tempMat, this._up, tempVec3f$2);
        look2 = math.transformPoint3(tempMat, look2, tempVec3d$3);
        this.look = math.addVec3(look2, this._eye, tempVec3e$2);
    };

    /**
     * Pans the Camera along its local X, Y and Z axis.
     *
     * @param pan The pan vector
     */
    Camera.prototype.pan = function pan (pan$1) {
        var eye2 = math.subVec3(this._eye, this._look, tempVec3$5);
        var vec = [0, 0, 0];
        var v;
        if (pan$1[0] !== 0) {
            var left = math.cross3Vec3(math.normalizeVec3(eye2, []), math.normalizeVec3(this._up, tempVec3b$8));
            v = math.mulVec3Scalar(left, pan$1[0]);
            vec[0] += v[0];
            vec[1] += v[1];
            vec[2] += v[2];
        }
        if (pan$1[1] !== 0) {
            v = math.mulVec3Scalar(math.normalizeVec3(this._up, tempVec3c$5), pan$1[1]);
            vec[0] += v[0];
            vec[1] += v[1];
            vec[2] += v[2];
        }
        if (pan$1[2] !== 0) {
            v = math.mulVec3Scalar(math.normalizeVec3(eye2, tempVec3d$3), pan$1[2]);
            vec[0] += v[0];
            vec[1] += v[1];
            vec[2] += v[2];
        }
        this.eye = math.addVec3(this._eye, vec, tempVec3e$2);
        this.look = math.addVec3(this._look, vec, tempVec3f$2);
    };

    /**
     * Increments/decrements the Camera's zoom factor, which is the distance between {@link Camera#eye} and {@link Camera#look}.
     *
     * @param {Number} delta Zoom factor increment.
     */
    Camera.prototype.zoom = function zoom (delta) {
        var vec = math.subVec3(this._eye, this._look, tempVec3$5);
        var lenLook = Math.abs(math.lenVec3(vec, tempVec3b$8));
        var newLenLook = Math.abs(lenLook + delta);
        if (newLenLook < 0.5) {
            return;
        }
        var dir = math.normalizeVec3(vec, tempVec3c$5);
        this.eye = math.addVec3(this._look, math.mulVec3Scalar(dir, newLenLook), tempVec3d$3);
    };

    /**
     * Sets the position of the Camera's eye.
     *
     * Default value is ````[0,0,10]````.
     *
     * @emits "eye" event on change, with the value of this property.
     * @type {Number[]} New eye position.
     */
    prototypeAccessors.eye.set = function (eye) {
        this._eye.set(eye || [0, 0, 10]);
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("eye", this._eye);
    };

    /**
     * Gets the position of the Camera's eye.
     *
     * Default vale is ````[0,0,10]````.
     *
     * @type {Number[]} New eye position.
     */
    prototypeAccessors.eye.get = function () {
        return this._eye;
    };

    /**
     * Sets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @emits "look" event on change, with the value of this property.
     *
     * @param {Number[]} look Camera look position.
     */
    prototypeAccessors.look.set = function (look) {
        this._look.set(look || [0, 0, 0]);
        this._needUpdate(0); // Ensure matrix built on next "tick"
        this.fire("look", this._look);
    };

    /**
     * Gets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @returns {Number[]} Camera look position.
     */
    prototypeAccessors.look.get = function () {
        return this._look;
    };

    /**
     * Sets the direction of this Camera's {@link Camera#up} vector.
     *
     * @emits "up" event on change, with the value of this property.
     *
     * @param {Number[]} up Direction of "up".
     */
    prototypeAccessors.up.set = function (up) {
        this._up.set(up || [0, 1, 0]);
        this._needUpdate(0);
        this.fire("up", this._up);
    };

    /**
     * Gets the direction of this Camera's {@link Camera#up} vector.
     *
     * @returns {Number[]} Direction of "up".
     */
    prototypeAccessors.up.get = function () {
        return this._up;
    };

    /**
     * Sets an optional matrix to premultiply into {@link Camera#matrix} matrix.
     *
     * This is intended to be used for stereo rendering with WebVR etc.
     *
     * @param {Number[]} matrix The matrix.
     */
    prototypeAccessors.deviceMatrix.set = function (matrix) {
        this._state.deviceMatrix.set(matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this._state.hasDeviceMatrix = !!matrix;
        this._needUpdate(0);
        this.fire("deviceMatrix", this._state.deviceMatrix);
    };

    /**
     * Gets an optional matrix to premultiply into {@link Camera#matrix} matrix.
     *
     * @returns {Number[]} The matrix.
     */
    prototypeAccessors.deviceMatrix.get = function () {
        return this._state.deviceMatrix;
    };

    /**
     * Sets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @param {Number[]} axis The new Wworld coordinate axis.
     */
    prototypeAccessors.worldAxis.set = function (axis) {
        axis = axis || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!this._worldAxis) {
            this._worldAxis = math.vec3(axis);
        } else {
            this._worldAxis.set(axis);
        }
        this._worldRight[0] = this._worldAxis[0];
        this._worldRight[1] = this._worldAxis[1];
        this._worldRight[2] = this._worldAxis[2];
        this._worldUp[0] = this._worldAxis[3];
        this._worldUp[1] = this._worldAxis[4];
        this._worldUp[2] = this._worldAxis[5];
        this._worldForward[0] = this._worldAxis[6];
        this._worldForward[1] = this._worldAxis[7];
        this._worldForward[2] = this._worldAxis[8];
        this.fire("worldAxis", this._worldAxis);
    };

    /**
     * Gets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @returns {Number[]} The current World coordinate axis.
     */
    prototypeAccessors.worldAxis.get = function () {
        return this._worldAxis;
    };

    /**
     * Gets the direction of World-space "up".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[0,1,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */
    prototypeAccessors.worldUp.get = function () {
        return this._worldUp;
    };

    /**
     * Gets if the World-space X-axis is "up".
     * @returns {boolean}
     */
    prototypeAccessors.xUp.get = function () {
        return this._worldUp[0] > this._worldUp[1] && this._worldUp[0] > this._worldUp[2];
    };

    /**
     * Gets if the World-space Y-axis is "up".
     * @returns {boolean}
     */
    prototypeAccessors.yUp.get = function () {
        return this._worldUp[1] > this._worldUp[0] && this._worldUp[1] > this._worldUp[2];
    };

    /**
     * Gets if the World-space Z-axis is "up".
     * @returns {boolean}
     */
    prototypeAccessors.zUp.get = function () {
        return this._worldUp[2] > this._worldUp[0] && this._worldUp[2] > this._worldUp[1];
    };

    /**
     * Gets the direction of World-space "right".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[1,0,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */
    prototypeAccessors.worldRight.get = function () {
        return this._worldRight;
    };

    /**
     * Gets the direction of World-space "forwards".
     *
     * This is set by {@link Camera#worldAxis}.
     *
     * Default value is ````[0,0,1]````.
     *
     * @returns {Number[]} The "up" vector.
     */
    prototypeAccessors.worldForward.get = function () {
        return this._worldForward;
    };

    /**
     * Sets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * Fires a {@link Camera#gimbalLock:event} event on change.
     *
     * @params {Boolean} gimbalLock Set true to lock gimbal.
     */
    prototypeAccessors.gimbalLock.set = function (value) {
        this._gimbalLock = value !== false;
        this.fire("gimbalLock", this._gimbalLock);
    };

    /**
     * Gets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * @returns {Boolean} Returns ````true```` if gimbal is locked.
     */
    prototypeAccessors.gimbalLock.get = function () {
        return this._gimbalLock;
    };

    /**
     * Sets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link Camera#up} and {@link Camera#worldUp} is less than one degree.
     *
     * Fires a {@link Camera#constrainPitch:event} event on change.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} value Set ````true```` to contrain pitch rotation.
     */
    prototypeAccessors.constrainPitch.set = function (value) {
        this._constrainPitch = !!value;
        this.fire("constrainPitch", this._constrainPitch);
    };

    /**
     * Gets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link Camera#up} and {@link Camera#worldUp} is less than one degree.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if pitch rotation is currently constrained.
     get constrainPitch() {
        return this._constrainPitch;
    }

     /**
     * Gets distance from {@link Camera#look} to {@link Camera#eye}.
     *
     * @returns {Number} The distance.
     */
    prototypeAccessors.eyeLookDist.get = function () {
        return math.lenVec3(math.subVec3(this._look, this._eye, tempVec3$5));
    };

    /**
     * Gets the Camera's viewing transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing transform matrix.
     */
    prototypeAccessors.matrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.matrix;
    };

    /**
     * Gets the Camera's viewing transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing transform matrix.
     */
    prototypeAccessors.viewMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.matrix;
    };

    /**
     * The Camera's viewing normal transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing normal transform matrix.
     */
    prototypeAccessors.normalMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.normalMatrix;
    };

    /**
     * The Camera's viewing normal transformation matrix.
     *
     * Fires a {@link Camera#matrix:event} event on change.
     *
     * @returns {Number[]} The viewing normal transform matrix.
     */
    prototypeAccessors.viewNormalMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.normalMatrix;
    };

    /**
     * Gets the inverse of the Camera's viewing transform matrix.
     *
     * This has the same value as {@link Camera#normalMatrix}.
     *
     * @returns {Number[]} The inverse viewing transform matrix.
     */
    prototypeAccessors.inverseViewMatrix.get = function () {
        if (this._updateScheduled) {
            this._doUpdate();
        }
        return this._state.inverseMatrix;
    };

    /**
     * Gets the Camera's projection transformation projMatrix.
     *
     * Fires a {@link Camera#projMatrix:event} event on change.
     *
     * @returns {Number[]} The projection matrix.
     */
    prototypeAccessors.projMatrix.get = function () {
        return this[this.projection].matrix;
    };

    /**
     * Gets the Camera's perspective projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````perspective````.
     *
     * @returns {Perspective} The Perspective component.
     */
    prototypeAccessors.perspective.get = function () {
        return this._perspective;
    };

    /**
     * Gets the Camera's orthographic projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````ortho````.
     *
     * @returns {Ortho} The Ortho component.
     */
    prototypeAccessors.ortho.get = function () {
        return this._ortho;
    };

    /**
     * Gets the Camera's frustum projection.
     *
     * The Camera uses this while {@link Camera#projection} equals ````frustum````.
     *
     * @returns {Frustum} The Ortho component.
     */
    prototypeAccessors.frustum.get = function () {
        return this._frustum;
    };

    /**
     * Gets the Camera's custom projection.
     *
     * This is used while {@link Camera#projection} equals "customProjection".
     *
     * @returns {CustomProjection} The custom projection.
     */
    prototypeAccessors.customProjection.get = function () {
        return this._customProjection;
    };

    /**
     * Sets the active projection type.
     *
     * Accepted values are ````"perspective"````, ````"ortho"````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````"perspective"````.
     *
     * @param {String} value Identifies the active projection type.
     */
    prototypeAccessors.projection.set = function (value) {
        value = value || "perspective";
        if (this._projectionType === value) {
            return;
        }
        if (value === "perspective") {
            this._project = this._perspective;
        } else if (value === "ortho") {
            this._project = this._ortho;
        } else if (value === "frustum") {
            this._project = this._frustum;
        } else if (value === "customProjection") {
            this._project = this._customProjection;
        } else {
            this.error("Unsupported value for 'projection': " + value + " defaulting to 'perspective'");
            this._project = this._perspective;
            value = "perspective";
        }
        this._project._update();
        this._projectionType = value;
        this.glRedraw();
        this._update(); // Need to rebuild lookat matrix with full eye, look & up
        this.fire("dirty");
        this.fire("projection", this._projectionType);
        this.fire("projMatrix", this._project.matrix);
    };

    /**
     * Gets the active projection type.
     *
     * Possible values are ````"perspective"````, ````"ortho"````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````"perspective"````.
     *
     * @returns {String} Identifies the active projection type.
     */
    prototypeAccessors.projection.get = function () {
        return this._projectionType;
    };

    /**
     * Gets the currently active projection for this Camera.
     *
     * The currently active project is selected with {@link Camera#projection}.
     *
     * @returns {Perspective|Ortho|Frustum|CustomProjection} The currently active projection is active.
     */
    prototypeAccessors.project.get = function () {
        return this._project;
    };

    /**
     * Destroys this Camera.
     */
    Camera.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( Camera.prototype, prototypeAccessors );

    return Camera;
}(Component));

/**
 * @desc A dynamic light source within a {@link Scene}.
 *
 * These are registered by {@link Light#id} in {@link Scene#lights}.
 */
var Light = /*@__PURE__*/(function (Component) {
    function Light(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Component.call(this, owner, cfg);
    }

    if ( Component ) Light.__proto__ = Component;
    Light.prototype = Object.create( Component && Component.prototype );
    Light.prototype.constructor = Light;

    var prototypeAccessors = { type: { configurable: true },isLight: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Light";
    };

    /**
     * @private
     */
    prototypeAccessors.isLight.get = function () {
        return true;
    };

    Object.defineProperties( Light.prototype, prototypeAccessors );

    return Light;
}(Component));

/**
 * @desc A directional light source that illuminates all {@link Mesh}es equally from a given direction.
 *
 * * Has an emission direction vector in {@link DirLight#dir}, but no position.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link DirLight#dir} is relative to the
 * World coordinate system, and will appear to move as the {@link Camera} moves. When in View-space, {@link DirLight#dir} is
 * relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll replace the {@link Scene}'s default light sources with three View-space DirLights.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#lights_DirLight_view)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      buildPlaneGeometry, ReadableGeometry,
 *      PhongMaterial, Texture, DirLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with three custom view-space DirLights
 *
 * viewer.scene.clearLights();
 *
 * new DirLight(viewer.scene, {
 *      id: "keyLight",
 *      dir: [0.8, -0.6, -0.8],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "fillLight",
 *      dir: [-0.8, -0.4, -0.4],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "rimLight",
 *      dir: [0.2, -0.8, 0.8],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.7, 0.7, 0.7],
 *          specular: [1.0, 1.0, 1.0],
 *          emissive: [0, 0, 0],
 *          alpha: 1.0,
 *          ambient: [1, 1, 0],
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 *  });
 *
 * new Mesh(viewer.scene, {
 *      geometry: buildPlaneGeometry(ReadableGeometry, viewer.scene, {
 *          xSize: 30,
 *          zSize: 30
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          backfaces: true
 *      }),
 *      position: [0, -2.1, 0]
 * });
 * ````
 */
var DirLight = /*@__PURE__*/(function (Light) {
    function DirLight(owner, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Light.call(this, owner, cfg);

        this._shadowRenderBuf = null;
        this._shadowViewMatrix = null;
        this._shadowProjMatrix = null;
        this._shadowViewMatrixDirty = true;
        this._shadowProjMatrixDirty = true;

        var camera = this.scene.camera;
        var canvas = this.scene.canvas;

        this._onCameraViewMatrix = camera.on("viewMatrix", function () {
            this$1._shadowViewMatrixDirty = true;
        });

        this._onCameraProjMatrix = camera.on("projMatrix", function () {
            this$1._shadowProjMatrixDirty = true;
        });

        this._onCanvasBoundary = canvas.on("boundary", function () {
            this$1._shadowProjMatrixDirty = true;
        });

        this._state = new RenderState({

            type: "dir",
            dir: math.vec3([1.0, 1.0, 1.0]),
            color: math.vec3([0.7, 0.7, 0.8]),
            intensity: 1.0,
            space: cfg.space || "view",
            castsShadow: false,

            getShadowViewMatrix: function () {
                if (this$1._shadowViewMatrixDirty) {
                    if (!this$1._shadowViewMatrix) {
                        this$1._shadowViewMatrix = math.identityMat4();
                    }
                    var camera = this$1.scene.camera;
                    var dir = this$1._state.dir;
                    var look = camera.look;
                    var eye = [look[0] - dir[0], look[1] - dir[1], look[2] - dir[2]];
                    var up = [0, 1, 0];
                    math.lookAtMat4v(eye, look, up, this$1._shadowViewMatrix);
                    this$1._shadowViewMatrixDirty = false;
                }
                return this$1._shadowViewMatrix;
            },

            getShadowProjMatrix: function () {
                if (this$1._shadowProjMatrixDirty) { // TODO: Set when canvas resizes
                    if (!this$1._shadowProjMatrix) {
                        this$1._shadowProjMatrix = math.identityMat4();
                    }
                    math.orthoMat4c(-40, 40, -40, 40, -40.0, 80, this$1._shadowProjMatrix);  // left, right, bottom, top, near, far, dest
                    this$1._shadowProjMatrixDirty = false;
                }
                return this$1._shadowProjMatrix;
            },

            getShadowRenderBuf: function () {
                if (!this$1._shadowRenderBuf) {
                    this$1._shadowRenderBuf = new RenderBuffer(this$1.scene.canvas.canvas, this$1.scene.canvas.gl, {size: [1024, 1024]}); // Super old mobile devices have a limit of 1024x1024 textures
                }
                return this$1._shadowRenderBuf;
            }
        });

        this.dir = cfg.dir;
        this.color = cfg.color;
        this.intensity = cfg.intensity;
        this.castsShadow = cfg.castsShadow;

        this.scene._lightCreated(this);
    }

    if ( Light ) DirLight.__proto__ = Light;
    DirLight.prototype = Object.create( Light && Light.prototype );
    DirLight.prototype.constructor = DirLight;

    var prototypeAccessors = { type: { configurable: true },dir: { configurable: true },color: { configurable: true },intensity: { configurable: true },castsShadow: { configurable: true } };

    /**
     * Sets the direction in which the DirLight is shining.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param {Number[]} value The direction vector.
     */
    prototypeAccessors.type.get = function () {
        return "DirLight";
    };

    prototypeAccessors.dir.set = function (value) {
        this._state.dir.set(value || [1.0, 1.0, 1.0]);
        this._shadowViewMatrixDirty = true;
        this.glRedraw();
    };

    /**
     * Gets the direction in which the DirLight is shining.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @returns {Number[]} The direction vector.
     */
    prototypeAccessors.dir.get = function () {
        return this._state.dir;
    };

    /**
     * Sets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The DirLight's RGB color.
     */
    prototypeAccessors.color.set = function (color) {
        this._state.color.set(color || [0.7, 0.7, 0.8]);
        this.glRedraw();
    };

    /**
     * Gets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The DirLight's RGB color.
     */
    prototypeAccessors.color.get = function () {
        return this._state.color;
    };

    /**
     * Sets the intensity of this DirLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The DirLight's intensity
     */
    prototypeAccessors.intensity.set = function (intensity) {
        intensity = intensity !== undefined ? intensity : 1.0;
        this._state.intensity = intensity;
        this.glRedraw();
    };

    /**
     * Gets the intensity of this DirLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The DirLight's intensity.
     */
    prototypeAccessors.intensity.get = function () {
        return this._state.intensity;
    };

    /**
     * Sets if this DirLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} castsShadow Set ````true```` to cast shadows.
     */
    prototypeAccessors.castsShadow.set = function (castsShadow) {
        castsShadow = !!castsShadow;
        if (this._state.castsShadow === castsShadow) {
            return;
        }
        this._state.castsShadow = castsShadow;
        this._shadowViewMatrixDirty = true;
        this.glRedraw();
    };

    /**
     * Gets if this DirLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if this DirLight casts shadows.
     */
    prototypeAccessors.castsShadow.get = function () {
        return this._state.castsShadow;
    };

    /**
     * Destroys this DirLight.
     */
    DirLight.prototype.destroy = function destroy () {

        var camera = this.scene.camera;
        var canvas = this.scene.canvas;
        camera.off(this._onCameraViewMatrix);
        camera.off(this._onCameraProjMatrix);
        canvas.off(this._onCanvasBoundary);

        Light.prototype.destroy.call(this);
        this._state.destroy();
        if (this._shadowRenderBuf) {
            this._shadowRenderBuf.destroy();
        }
        this.scene._lightDestroyed(this);
        this.glRedraw();
    };

    Object.defineProperties( DirLight.prototype, prototypeAccessors );

    return DirLight;
}(Light));

/**
 * @desc An ambient light source of fixed color and intensity that illuminates all {@link Mesh}es equally.
 *
 * * {@link AmbientLight#color} multiplies by {@link PhongMaterial#ambient} at each position of each {@link ReadableGeometry} surface.
 * * {@link AmbientLight#color} multiplies by {@link LambertMaterial#color} uniformly across each triangle of each {@link ReadableGeometry} (ie. flat shaded).
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll destroy the {@link Scene}'s default light sources then create an AmbientLight and a couple of {@link @DirLight}s:
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#lights_AmbientLight)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 * ReadableGeometry, PhongMaterial, Texture, AmbientLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with a single custom AmbientLight
 *
 * viewer.scene.clearLights();
 *
 * new AmbientLight(viewer.scene, {
 *      color: [0.0, 0.3, 0.7],
 *      intensity: 1.0
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "keyLight",
 *      dir: [0.8, -0.6, -0.8],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "fillLight",
 *      dir: [-0.8, -0.4, -0.4],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * new DirLight(viewer.scene, {
 *      id: "rimLight",
 *      dir: [0.2, -0.8, 0.8],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "view"
 * });
 *
 * // Create a mesh with torus shape and PhongMaterial
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [1.0, 1.0, 1.0],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *
 * // Adjust the color of our AmbientLight
 *
 * var ambientLight = viewer.scene.lights["myAmbientLight"];
 * ambientLight.color = [1.0, 0.8, 0.8];
 *````
 */
var AmbientLight = /*@__PURE__*/(function (Light) {
    function AmbientLight(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Light.call(this, owner, cfg);
        this._state = {
            type: "ambient",
            color: math.vec3([0.7, 0.7, 0.7]),
            intensity: 1.0
        };
        this.color = cfg.color;
        this.intensity = cfg.intensity;
        this.scene._lightCreated(this);
    }

    if ( Light ) AmbientLight.__proto__ = Light;
    AmbientLight.prototype = Object.create( Light && Light.prototype );
    AmbientLight.prototype.constructor = AmbientLight;

    var prototypeAccessors = { type: { configurable: true },color: { configurable: true },intensity: { configurable: true } };

    /**
     * Sets the RGB color of this AmbientLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The AmbientLight's RGB color.
     */
    prototypeAccessors.type.get = function () {
        return "AmbientLight";
    };

    prototypeAccessors.color.set = function (color) {
        this._state.color.set(color || [0.7, 0.7, 0.8]);
        this.glRedraw();
    };

    /**
     * Gets the RGB color of this AmbientLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The AmbientLight's RGB color.
     */
    prototypeAccessors.color.get = function () {
        return this._state.color;
    };

    /**
     * Sets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The AmbientLight's intensity.
     */
    prototypeAccessors.intensity.set = function (intensity) {
        this._state.intensity = intensity !== undefined ? intensity : 1.0;
        this.glRedraw();
    };

    /**
     * Gets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The AmbientLight's intensity.
     */
    prototypeAccessors.intensity.get = function () {
        return this._state.intensity;
    };

    /**
     * Destroys this AmbientLight.
     */
    AmbientLight.prototype.destroy = function destroy () {

        Light.prototype.destroy.call(this);

        this.scene._lightDestroyed(this);
    };

    Object.defineProperties( AmbientLight.prototype, prototypeAccessors );

    return AmbientLight;
}(Light));

/**
 * @desc Defines a shape for one or more {@link Mesh}es.
 *
 * * {@link ReadableGeometry} is a subclass that stores its data in both browser and GPU memory. Use ReadableGeometry when you need to keep the geometry arrays in browser memory.
 * * {@link VBOGeometry} is a subclass that stores its data solely in GPU memory. Use VBOGeometry when you need a lower memory footprint and don't need to keep the geometry data in browser memory.
 */
var Geometry = /*@__PURE__*/(function (Component) {
    function Geometry(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Component.call(this, owner, cfg);
        stats.memory.meshes++;
    }

    if ( Component ) Geometry.__proto__ = Component;
    Geometry.prototype = Object.create( Component && Component.prototype );
    Geometry.prototype.constructor = Geometry;

    var prototypeAccessors = { type: { configurable: true },isGeometry: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Geometry";
    };

    /** @private */
    prototypeAccessors.isGeometry.get = function () {
        return true;
    };

    Geometry.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        stats.memory.meshes--;
    };

    Object.defineProperties( Geometry.prototype, prototypeAccessors );

    return Geometry;
}(Component));

/**
 * @private
 */
var buildEdgeIndices = (function () {

    var uniquePositions = [];
    var indicesLookup = [];
    var indicesReverseLookup = [];
    var weldedIndices = [];

// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions

    var faces = [];
    var numFaces = 0;
    var compa = new Uint16Array(3);
    var compb = new Uint16Array(3);
    var compc = new Uint16Array(3);
    var a = math.vec3();
    var b = math.vec3();
    var c = math.vec3();
    var cb = math.vec3();
    var ab = math.vec3();
    var cross = math.vec3();
    var normal = math.vec3();

    function weldVertices(positions, indices) {
        var positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i;
        var len;
        var lenUniquePositions = 0;
        for (i = 0, len = positions.length; i < len; i += 3) {
            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];
            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);
            if (positionsMap[key] === undefined) {
                positionsMap[key] = lenUniquePositions / 3;
                uniquePositions[lenUniquePositions++] = vx;
                uniquePositions[lenUniquePositions++] = vy;
                uniquePositions[lenUniquePositions++] = vz;
            }
            indicesLookup[i / 3] = positionsMap[key];
        }
        for (i = 0, len = indices.length; i < len; i++) {
            weldedIndices[i] = indicesLookup[indices[i]];
            indicesReverseLookup[weldedIndices[i]] = indices[i];
        }
    }

    function buildFaces(numIndices, positionsDecodeMatrix) {
        numFaces = 0;
        for (var i = 0, len = numIndices; i < len; i += 3) {
            var ia = ((weldedIndices[i]) * 3);
            var ib = ((weldedIndices[i + 1]) * 3);
            var ic = ((weldedIndices[i + 2]) * 3);
            if (positionsDecodeMatrix) {
                compa[0] = uniquePositions[ia];
                compa[1] = uniquePositions[ia + 1];
                compa[2] = uniquePositions[ia + 2];
                compb[0] = uniquePositions[ib];
                compb[1] = uniquePositions[ib + 1];
                compb[2] = uniquePositions[ib + 2];
                compc[0] = uniquePositions[ic];
                compc[1] = uniquePositions[ic + 1];
                compc[2] = uniquePositions[ic + 2];
                // Decode
                math.decompressPosition(compa, positionsDecodeMatrix, a);
                math.decompressPosition(compb, positionsDecodeMatrix, b);
                math.decompressPosition(compc, positionsDecodeMatrix, c);
            } else {
                a[0] = uniquePositions[ia];
                a[1] = uniquePositions[ia + 1];
                a[2] = uniquePositions[ia + 2];
                b[0] = uniquePositions[ib];
                b[1] = uniquePositions[ib + 1];
                b[2] = uniquePositions[ib + 2];
                c[0] = uniquePositions[ic];
                c[1] = uniquePositions[ic + 1];
                c[2] = uniquePositions[ic + 2];
            }
            math.subVec3(c, b, cb);
            math.subVec3(a, b, ab);
            math.cross3Vec3(cb, ab, cross);
            math.normalizeVec3(cross, normal);
            var face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});
            face.normal[0] = normal[0];
            face.normal[1] = normal[1];
            face.normal[2] = normal[2];
            numFaces++;
        }
    }

    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {
        weldVertices(positions, indices);
        buildFaces(indices.length, positionsDecodeMatrix);
        var edgeIndices = [];
        var thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);
        var edges = {};
        var edge1;
        var edge2;
        var index1;
        var index2;
        var key;
        var largeIndex = false;
        var edge;
        var normal1;
        var normal2;
        var dot;
        var ia;
        var ib;
        for (var i = 0, len = indices.length; i < len; i += 3) {
            var faceIndex = i / 3;
            for (var j = 0; j < 3; j++) {
                edge1 = weldedIndices[i + j];
                edge2 = weldedIndices[i + ((j + 1) % 3)];
                index1 = Math.min(edge1, edge2);
                index2 = Math.max(edge1, edge2);
                key = index1 + "," + index2;
                if (edges[key] === undefined) {
                    edges[key] = {
                        index1: index1,
                        index2: index2,
                        face1: faceIndex,
                        face2: undefined
                    };
                } else {
                    edges[key].face2 = faceIndex;
                }
            }
        }
        for (key in edges) {
            edge = edges[key];
            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
            if (edge.face2 !== undefined) {
                normal1 = faces[edge.face1].normal;
                normal2 = faces[edge.face2].normal;
                dot = math.dotVec3(normal1, normal2);
                if (dot > thresholdDot) {
                    continue;
                }
            }
            ia = indicesReverseLookup[edge.index1];
            ib = indicesReverseLookup[edge.index2];
            if (!largeIndex && ia > 65535 || ib > 65535) {
                largeIndex = true;
            }
            edgeIndices.push(ia);
            edgeIndices.push(ib);
        }
        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);
    };
})();

/**
 * Private geometry compression and decompression utilities.
 */

/**
 * @private
 * @param array
 * @returns {{min: Float32Array, max: Float32Array}}
 */
function getPositionsBounds(array) {
    var min = new Float32Array(3);
    var max = new Float32Array(3);
    var i, j;
    for (i = 0; i < 3; i++) {
        min[i] = Number.MAX_VALUE;
        max[i] = -Number.MAX_VALUE;
    }
    for (i = 0; i < array.length; i += 3) {
        for (j = 0; j < 3; j++) {
            min[j] = Math.min(min[j], array[i + j]);
            max[j] = Math.max(max[j], array[i + j]);
        }
    }
    return {
        min: min,
        max: max
    };
}

var createPositionsDecodeMatrix = (function () {
    var translate = math.mat4();
    var scale = math.mat4();
    return function (aabb, positionsDecodeMatrix) {
        positionsDecodeMatrix = positionsDecodeMatrix || math.mat4();
        var xmin = aabb[0];
        var ymin = aabb[1];
        var zmin = aabb[2];
        var xwid = aabb[3] - xmin;
        var ywid = aabb[4] - ymin;
        var zwid = aabb[5] - zmin;
        var maxInt = 65535;
        math.identityMat4(translate);
        math.translationMat4v(aabb, translate);
        math.identityMat4(scale);
        math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);
        math.mulMat4(translate, scale, positionsDecodeMatrix);
        return positionsDecodeMatrix;
    };
})();

/**
 * @private
 */
var compressPositions = (function () { // http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf
    var translate = math.mat4();
    var scale = math.mat4();
    return function (array, min, max) {
        var quantized = new Uint16Array(array.length);
        var multiplier = new Float32Array([
            max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,
            max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,
            max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0
        ]);
        var i;
        for (i = 0; i < array.length; i += 3) {
            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
            quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
        }
        math.identityMat4(translate);
        math.translationMat4v(min, translate);
        math.identityMat4(scale);
        math.scalingMat4v([
            (max[0] - min[0]) / 65535,
            (max[1] - min[1]) / 65535,
            (max[2] - min[2]) / 65535
        ], scale);
        var decodeMat = math.mulMat4(translate, scale, math.identityMat4());
        return {
            quantized: quantized,
            decodeMatrix: decodeMat
        };
    };
})();

function decompressPosition(position, decodeMatrix, dest) {
    dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];
    dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];
    dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
    return dest;
}

function decompressAABB(aabb, decodeMatrix, dest) {
    if ( dest === void 0 ) dest=aabb;

    dest[0] = aabb[0] * decodeMatrix[0] + decodeMatrix[12];
    dest[1] = aabb[1] * decodeMatrix[5] + decodeMatrix[13];
    dest[2] = aabb[2] * decodeMatrix[10] + decodeMatrix[14];
    dest[3] = aabb[3] * decodeMatrix[0] + decodeMatrix[12];
    dest[4] = aabb[4] * decodeMatrix[5] + decodeMatrix[13];
    dest[5] = aabb[5] * decodeMatrix[10] + decodeMatrix[14];
    return dest;
}

/**
 * @private
 */
function decompressPositions(positions, decodeMatrix, dest) {
    if ( dest === void 0 ) dest = new Float32Array(positions.length);

    for (var i = 0, len = positions.length; i < len; i += 3) {
        dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];
        dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];
        dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];
    }
    return dest;
}

//--------------- UVs --------------------------------------------------------------------------------------------------

/**
 * @private
 * @param array
 * @returns {{min: Float32Array, max: Float32Array}}
 */
function getUVBounds(array) {
    var min = new Float32Array(2);
    var max = new Float32Array(2);
    var i, j;
    for (i = 0; i < 2; i++) {
        min[i] = Number.MAX_VALUE;
        max[i] = -Number.MAX_VALUE;
    }
    for (i = 0; i < array.length; i += 2) {
        for (j = 0; j < 2; j++) {
            min[j] = Math.min(min[j], array[i + j]);
            max[j] = Math.max(max[j], array[i + j]);
        }
    }
    return {
        min: min,
        max: max
    };
}

/**
 * @private
 */
var compressUVs = (function () {
    var translate = math.mat3();
    var scale = math.mat3();
    return function (array, min, max) {
        var quantized = new Uint16Array(array.length);
        var multiplier = new Float32Array([
            65535 / (max[0] - min[0]),
            65535 / (max[1] - min[1])
        ]);
        var i;
        for (i = 0; i < array.length; i += 2) {
            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
        }
        math.identityMat3(translate);
        math.translationMat3v(min, translate);
        math.identityMat3(scale);
        math.scalingMat3v([
            (max[0] - min[0]) / 65535,
            (max[1] - min[1]) / 65535
        ], scale);
        var decodeMat = math.mulMat3(translate, scale, math.identityMat3());
        return {
            quantized: quantized,
            decodeMatrix: decodeMat
        };
    };
})();


//--------------- Normals ----------------------------------------------------------------------------------------------

/**
 * @private
 */
function compressNormals(array) { // http://jcgt.org/published/0003/02/01/

    // Note: three elements for each encoded normal, in which the last element in each triplet is redundant.
    // This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/

    var encoded = new Int8Array(array.length);
    var oct, dec, best, currentCos, bestCos;
    for (var i = 0; i < array.length; i += 3) {
        // Test various combinations of ceil and floor
        // to minimize rounding errors
        best = oct = octEncodeVec3$1(array, i, "floor", "floor");
        dec = octDecodeVec2$1(oct);
        currentCos = bestCos = dot$1(array, i, dec);
        oct = octEncodeVec3$1(array, i, "ceil", "floor");
        dec = octDecodeVec2$1(oct);
        currentCos = dot$1(array, i, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeVec3$1(array, i, "floor", "ceil");
        dec = octDecodeVec2$1(oct);
        currentCos = dot$1(array, i, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeVec3$1(array, i, "ceil", "ceil");
        dec = octDecodeVec2$1(oct);
        currentCos = dot$1(array, i, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        encoded[i] = best[0];
        encoded[i + 1] = best[1];
    }
    return encoded;
}

/**
 * @private
 */
function octEncodeVec3$1(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes
    var x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    var y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    if (array[i + 2] < 0) {
        var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        x = tempx;
        y = tempy;
    }
    return new Int8Array([
        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),
        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))
    ]);
}

/**
 * Decode an oct-encoded normal
 */
function octDecodeVec2$1(oct) {
    var x = oct[0];
    var y = oct[1];
    x /= x < 0 ? 127 : 128;
    y /= y < 0 ? 127 : 128;
    var z = 1 - Math.abs(x) - Math.abs(y);
    if (z < 0) {
        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    }
    var length = Math.sqrt(x * x + y * y + z * z);
    return [
        x / length,
        y / length,
        z / length
    ];
}

/**
 * Dot product of a normal in an array against a candidate decoding
 * @private
 */
function dot$1(array, i, vec3) {
    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];
}

/**
 * @private
 */
function decompressUV(uv, decodeMatrix, dest) {
    dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];
    dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];
}

/**
 * @private
 */
function decompressUVs(uvs, decodeMatrix, dest) {
    if ( dest === void 0 ) dest = new Float32Array(uvs.length);

    for (var i = 0, len = uvs.length; i < len; i += 3) {
        dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];
        dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];
    }
    return dest;
}

/**
 * @private
 */
function decompressNormal(oct, result) {
    var x = oct[0];
    var y = oct[1];
    x = (2 * x + 1) / 255;
    y = (2 * y + 1) / 255;
    var z = 1 - Math.abs(x) - Math.abs(y);
    if (z < 0) {
        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    }
    var length = Math.sqrt(x * x + y * y + z * z);
    result[0] = x / length;
    result[1] = y / length;
    result[2] = z / length;
    return result;
}

/**
 * @private
 */
function decompressNormals(octs, result) {
    for (var i = 0, j = 0, len = octs.length; i < len; i += 2) {
        var x = octs[i + 0];
        var y = octs[i + 1];
        x = (2 * x + 1) / 255;
        y = (2 * y + 1) / 255;
        var z = 1 - Math.abs(x) - Math.abs(y);
        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }
        var length = Math.sqrt(x * x + y * y + z * z);
        result[j + 0] = x / length;
        result[j + 1] = y / length;
        result[j + 2] = z / length;
        j += 3;
    }
    return result;
}

/**
 * @private
 */
var geometryCompressionUtils = {

    getPositionsBounds: getPositionsBounds,
    createPositionsDecodeMatrix: createPositionsDecodeMatrix,
    compressPositions: compressPositions,
    decompressPositions: decompressPositions,
    decompressPosition: decompressPosition,
    decompressAABB: decompressAABB,

    getUVBounds: getUVBounds,
    compressUVs: compressUVs,
    decompressUVs: decompressUVs,
    decompressUV: decompressUV,

    compressNormals: compressNormals,
    decompressNormals: decompressNormals,
    decompressNormal: decompressNormal
};

var memoryStats$1 = stats.memory;
var bigIndicesSupported$6 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];
var IndexArrayType$1 = bigIndicesSupported$6 ? Uint32Array : Uint16Array;
var tempAABB$2 = math.AABB3();

/**
 * @desc A {@link Geometry} that keeps its geometry data in both browser and GPU memory.
 *
 * ReadableGeometry uses more memory than {@link VBOGeometry}, which only stores its geometry data in GPU memory.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a ReadableGeometry that defines a single triangle, plus a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_ReadableGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 *     });
 *
 * const myMesh = new Mesh(viewer.scene, {
 *         geometry: new ReadableGeometry(viewer.scene, {
 *             primitive: "triangles",
 *             positions: [0.0, 3, 0.0, -3, -3, 0.0, 3, -3, 0.0],
 *             normals: [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0],
 *             uv: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
 *             indices: [0, 1, 2]
 *         }),
 *         material: new PhongMaterial(viewer.scene, {
 *             diffuseMap: new Texture(viewer.scene, {
 *                 src: "textures/diffuse/uvGrid2.jpg"
 *             }),
 *             backfaces: true
 *         })
 *     });
 *
 * // Get geometry data from browser memory:
 *
 * const positions = myMesh.geometry.positions; // Flat arrays
 * const normals = myMesh.geometry.normals;
 * const uv = myMesh.geometry.uv;
 * const indices = myMesh.geometry.indices;
 *
 * ````
 */
var ReadableGeometry = /*@__PURE__*/(function (Geometry) {
    function ReadableGeometry(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Geometry.call(this, owner, cfg);

        this._state = new RenderState({ // Arrays for emphasis effects are got from xeokit.Geometry friend methods
            compressGeometry: !!cfg.compressGeometry,
            primitive: null, // WebGL enum
            primitiveName: null, // String
            positions: null,    // Uint16Array when compressGeometry == true, else Float32Array
            normals: null,      // Uint8Array when compressGeometry == true, else Float32Array
            colors: null,
            uv: null,           // Uint8Array when compressGeometry == true, else Float32Array
            indices: null,
            positionsDecodeMatrix: null, // Set when compressGeometry == true
            uvDecodeMatrix: null, // Set when compressGeometry == true
            positionsBuf: null,
            normalsBuf: null,
            colorsbuf: null,
            uvBuf: null,
            indicesBuf: null,
            hash: ""
        });

        this._numTriangles = 0;

        this._edgeThreshold = cfg.edgeThreshold || 10.0;

        // Lazy-generated VBOs

        this._edgeIndicesBuf = null;
        this._pickTrianglePositionsBuf = null;
        this._pickTriangleColorsBuf = null;

        // Local-space Boundary3D

        this._aabbDirty = true;

        this._boundingSphere = true;
        this._aabb = null;
        this._aabbDirty = true;

        this._obb = null;
        this._obbDirty = true;

        var state = this._state;
        var gl = this.scene.canvas.gl;

        // Primitive type

        cfg.primitive = cfg.primitive || "triangles";
        switch (cfg.primitive) {
            case "points":
                state.primitive = gl.POINTS;
                state.primitiveName = cfg.primitive;
                break;
            case "lines":
                state.primitive = gl.LINES;
                state.primitiveName = cfg.primitive;
                break;
            case "line-loop":
                state.primitive = gl.LINE_LOOP;
                state.primitiveName = cfg.primitive;
                break;
            case "line-strip":
                state.primitive = gl.LINE_STRIP;
                state.primitiveName = cfg.primitive;
                break;
            case "triangles":
                state.primitive = gl.TRIANGLES;
                state.primitiveName = cfg.primitive;
                break;
            case "triangle-strip":
                state.primitive = gl.TRIANGLE_STRIP;
                state.primitiveName = cfg.primitive;
                break;
            case "triangle-fan":
                state.primitive = gl.TRIANGLE_FAN;
                state.primitiveName = cfg.primitive;
                break;
            default:
                this.error("Unsupported value for 'primitive': '" + cfg.primitive +
                    "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', " +
                    "'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");
                state.primitive = gl.TRIANGLES;
                state.primitiveName = cfg.primitive;
        }

        if (cfg.positions) {
            if (this._state.compressGeometry) {
                var bounds = geometryCompressionUtils.getPositionsBounds(cfg.positions);
                var result = geometryCompressionUtils.compressPositions(cfg.positions, bounds.min, bounds.max);
                state.positions = result.quantized;
                state.positionsDecodeMatrix = result.decodeMatrix;
            } else {
                state.positions = cfg.positions.constructor === Float32Array ? cfg.positions : new Float32Array(cfg.positions);
            }
        }
        if (cfg.colors) {
            state.colors = cfg.colors.constructor === Float32Array ? cfg.colors : new Float32Array(cfg.colors);
        }
        if (cfg.uv) {
            if (this._state.compressGeometry) {
                var bounds$1 = geometryCompressionUtils.getUVBounds(cfg.uv);
                var result$1 = geometryCompressionUtils.compressUVs(cfg.uv, bounds$1.min, bounds$1.max);
                state.uv = result$1.quantized;
                state.uvDecodeMatrix = result$1.decodeMatrix;
            } else {
                state.uv = cfg.uv.constructor === Float32Array ? cfg.uv : new Float32Array(cfg.uv);
            }
        }
        if (cfg.normals) {
            if (this._state.compressGeometry) {
                state.normals = geometryCompressionUtils.compressNormals(cfg.normals);
            } else {
                state.normals = cfg.normals.constructor === Float32Array ? cfg.normals : new Float32Array(cfg.normals);
            }
        }
        if (cfg.indices) {
            if (!bigIndicesSupported$6 && cfg.indices.constructor === Uint32Array) {
                this.error("This WebGL implementation does not support Uint32Array");
                return;
            }
            state.indices = (cfg.indices.constructor === Uint32Array || cfg.indices.constructor === Uint16Array) ? cfg.indices : new IndexArrayType$1(cfg.indices);
            if (this._state.primitiveName === "triangles") {
                this._numTriangles = (cfg.indices.length / 3);
            }
        }

        this._buildHash();

        memoryStats$1.meshes++;

        this._buildVBOs();
    }

    if ( Geometry ) ReadableGeometry.__proto__ = Geometry;
    ReadableGeometry.prototype = Object.create( Geometry && Geometry.prototype );
    ReadableGeometry.prototype.constructor = ReadableGeometry;

    var prototypeAccessors = { type: { configurable: true },isReadableGeometry: { configurable: true },primitive: { configurable: true },compressGeometry: { configurable: true },positions: { configurable: true },normals: { configurable: true },uv: { configurable: true },colors: { configurable: true },indices: { configurable: true },aabb: { configurable: true },obb: { configurable: true },numTriangles: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "ReadableGeometry";
    };

    /**
     * @private
     * @returns {boolean}
     */
    prototypeAccessors.isReadableGeometry.get = function () {
        return true;
    };

    ReadableGeometry.prototype._buildVBOs = function _buildVBOs () {
        var state = this._state;
        var gl = this.scene.canvas.gl;
        if (state.indices) {
            state.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, state.indices, state.indices.length, 1, gl.STATIC_DRAW);
            memoryStats$1.indices += state.indicesBuf.numItems;
        }
        if (state.positions) {
            state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, state.positions, state.positions.length, 3, gl.STATIC_DRAW);
            memoryStats$1.positions += state.positionsBuf.numItems;
        }
        if (state.normals) {
            var normalized = state.compressGeometry;
            state.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, state.normals, state.normals.length, 3, gl.STATIC_DRAW, normalized);
            memoryStats$1.normals += state.normalsBuf.numItems;
        }
        if (state.colors) {
            state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, state.colors, state.colors.length, 4, gl.STATIC_DRAW);
            memoryStats$1.colors += state.colorsBuf.numItems;
        }
        if (state.uv) {
            state.uvBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, state.uv, state.uv.length, 2, gl.STATIC_DRAW);
            memoryStats$1.uvs += state.uvBuf.numItems;
        }
    };

    ReadableGeometry.prototype._buildHash = function _buildHash () {
        var state = this._state;
        var hash = ["/g"];
        hash.push("/" + state.primitive + ";");
        if (state.positions) {
            hash.push("p");
        }
        if (state.colors) {
            hash.push("c");
        }
        if (state.normals || state.autoVertexNormals) {
            hash.push("n");
        }
        if (state.uv) {
            hash.push("u");
        }
        if (state.compressGeometry) {
            hash.push("cp");
        }
        hash.push(";");
        state.hash = hash.join("");
    };

    ReadableGeometry.prototype._getEdgeIndices = function _getEdgeIndices () {
        if (!this._edgeIndicesBuf) {
            this._buildEdgeIndices();
        }
        return this._edgeIndicesBuf;
    };

    ReadableGeometry.prototype._getPickTrianglePositions = function _getPickTrianglePositions () {
        if (!this._pickTrianglePositionsBuf) {
            this._buildPickTriangleVBOs();
        }
        return this._pickTrianglePositionsBuf;
    };

    ReadableGeometry.prototype._getPickTriangleColors = function _getPickTriangleColors () {
        if (!this._pickTriangleColorsBuf) {
            this._buildPickTriangleVBOs();
        }
        return this._pickTriangleColorsBuf;
    };

    ReadableGeometry.prototype._buildEdgeIndices = function _buildEdgeIndices () { // FIXME: Does not adjust indices after other objects are deleted from vertex buffer!!
        var state = this._state;
        if (!state.positions || !state.indices) {
            return;
        }
        var gl = this.scene.canvas.gl;
        var edgeIndices = buildEdgeIndices(state.positions, state.indices, state.positionsDecodeMatrix, this._edgeThreshold);
        this._edgeIndicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, edgeIndices, edgeIndices.length, 1, gl.STATIC_DRAW);
        memoryStats$1.indices += this._edgeIndicesBuf.numItems;
    };

    ReadableGeometry.prototype._buildPickTriangleVBOs = function _buildPickTriangleVBOs () { // Builds positions and indices arrays that allow each triangle to have a unique color
        var state = this._state;
        if (!state.positions || !state.indices) {
            return;
        }
        var gl = this.scene.canvas.gl;
        var arrays = math.buildPickTriangles(state.positions, state.indices, state.compressGeometry);
        var positions = arrays.positions;
        var colors = arrays.colors;
        this._pickTrianglePositionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
        this._pickTriangleColorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colors, colors.length, 4, gl.STATIC_DRAW, true);
        memoryStats$1.positions += this._pickTrianglePositionsBuf.numItems;
        memoryStats$1.colors += this._pickTriangleColorsBuf.numItems;
    };

    ReadableGeometry.prototype._buildPickVertexVBOs = function _buildPickVertexVBOs () {
        // var state = this._state;
        // if (!state.positions || !state.indices) {
        //     return;
        // }
        // var gl = this.scene.canvas.gl;
        // var arrays = math.buildPickVertices(state.positions, state.indices, state.compressGeometry);
        // var pickVertexPositions = arrays.positions;
        // var pickColors = arrays.colors;
        // this._pickVertexPositionsBuf = new xeokit.renderer.ArrayBuf(gl, gl.ARRAY_BUFFER, pickVertexPositions, pickVertexPositions.length, 3, gl.STATIC_DRAW);
        // this._pickVertexColorsBuf = new xeokit.renderer.ArrayBuf(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
        // memoryStats.positions += this._pickVertexPositionsBuf.numItems;
        // memoryStats.colors += this._pickVertexColorsBuf.numItems;
    };

    ReadableGeometry.prototype._webglContextLost = function _webglContextLost () {
        if (this._sceneVertexBufs) {
            this._sceneVertexBufs.webglContextLost();
        }
    };

    ReadableGeometry.prototype._webglContextRestored = function _webglContextRestored () {
        if (this._sceneVertexBufs) {
            this._sceneVertexBufs.webglContextRestored();
        }
        this._buildVBOs();
        this._edgeIndicesBuf = null;
        this._pickVertexPositionsBuf = null;
        this._pickTrianglePositionsBuf = null;
        this._pickTriangleColorsBuf = null;
        this._pickVertexPositionsBuf = null;
        this._pickVertexColorsBuf = null;
    };

    /**
     * Gets the Geometry's primitive type.

     Valid types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.

     @property primitive
     @default "triangles"
     @type {String}
     */
    prototypeAccessors.primitive.get = function () {
        return this._state.primitiveName;
    };

    /**
     Indicates if this Geometry is quantized.

     Compression is an internally-performed optimization which stores positions, colors, normals and UVs
     in quantized and oct-encoded formats for reduced memory footprint and GPU bus usage.

     Quantized geometry may not be updated.

     @property compressGeometry
     @default false
     @type {Boolean}
     @final
     */
    prototypeAccessors.compressGeometry.get = function () {
        return this._state.compressGeometry;
    };

    /**
     The Geometry's vertex positions.

     @property positions
     @default null
     @type {Number[]}
     */
    prototypeAccessors.positions.get = function () {
        if (!this._state.positions) {
            return null;
        }
        if (!this._state.compressGeometry) {
            return this._state.positions;
        }
        if (!this._decompressedPositions) {
            this._decompressedPositions = new Float32Array(this._state.positions.length);
            geometryCompressionUtils.decompressPositions(this._state.positions, this._state.positionsDecodeMatrix, this._decompressedPositions);
        }
        return this._decompressedPositions;
    };

    prototypeAccessors.positions.set = function (newPositions) {
        var state = this._state;
        var positions = state.positions;
        if (!positions) {
            this.error("can't update geometry positions - geometry has no positions");
            return;
        }
        if (positions.length !== newPositions.length) {
            this.error("can't update geometry positions - new positions are wrong length");
            return;
        }
        if (this._state.compressGeometry) {
            var bounds = geometryCompressionUtils.getPositionsBounds(newPositions);
            var result = geometryCompressionUtils.compressPositions(newPositions, bounds.min, bounds.max);
            newPositions = result.quantized; // TODO: Copy in-place
            state.positionsDecodeMatrix = result.decodeMatrix;
        }
        positions.set(newPositions);
        if (state.positionsBuf) {
            state.positionsBuf.setData(positions);
        }
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     The Geometry's vertex normals.

     @property normals
     @default null
     @type {Number[]}
     */
    prototypeAccessors.normals.get = function () {
        if (!this._state.normals) {
            return;
        }
        if (!this._state.compressGeometry) {
            return this._state.normals;
        }
        if (!this._decompressedNormals) {
            var lenCompressed = this._state.normals.length;
            var lenDecompressed = lenCompressed + (lenCompressed / 2); // 2 -> 3
            this._decompressedNormals = new Float32Array(lenDecompressed);
            geometryCompressionUtils.decompressNormals(this._state.normals, this._decompressedNormals);
        }
        return this._decompressedNormals;
    };

    prototypeAccessors.normals.set = function (newNormals) {
        if (this._state.compressGeometry) {
            this.error("can't update geometry normals - quantized geometry is immutable"); // But will be eventually
            return;
        }
        var state = this._state;
        var normals = state.normals;
        if (!normals) {
            this.error("can't update geometry normals - geometry has no normals");
            return;
        }
        if (normals.length !== newNormals.length) {
            this.error("can't update geometry normals - new normals are wrong length");
            return;
        }
        normals.set(newNormals);
        if (state.normalsBuf) {
            state.normalsBuf.setData(normals);
        }
        this.glRedraw();
    };


    /**
     The Geometry's UV coordinates.

     @property uv
     @default null
     @type {Number[]}
     */
    prototypeAccessors.uv.get = function () {
        if (!this._state.uv) {
            return null;
        }
        if (!this._state.compressGeometry) {
            return this._state.uv;
        }
        if (!this._decompressedUV) {
            this._decompressedUV = new Float32Array(this._state.uv.length);
            geometryCompressionUtils.decompressUVs(this._state.uv, this._state.uvDecodeMatrix, this._decompressedUV);
        }
        return this._decompressedUV;
    };

    prototypeAccessors.uv.set = function (newUV) {
        if (this._state.compressGeometry) {
            this.error("can't update geometry UVs - quantized geometry is immutable"); // But will be eventually
            return;
        }
        var state = this._state;
        var uv = state.uv;
        if (!uv) {
            this.error("can't update geometry UVs - geometry has no UVs");
            return;
        }
        if (uv.length !== newUV.length) {
            this.error("can't update geometry UVs - new UVs are wrong length");
            return;
        }
        uv.set(newUV);
        if (state.uvBuf) {
            state.uvBuf.setData(uv);
        }
        this.glRedraw();
    };

    /**
     The Geometry's vertex colors.

     @property colors
     @default null
     @type {Number[]}
     */
    prototypeAccessors.colors.get = function () {
        return this._state.colors;
    };

    prototypeAccessors.colors.set = function (newColors) {
        if (this._state.compressGeometry) {
            this.error("can't update geometry colors - quantized geometry is immutable"); // But will be eventually
            return;
        }
        var state = this._state;
        var colors = state.colors;
        if (!colors) {
            this.error("can't update geometry colors - geometry has no colors");
            return;
        }
        if (colors.length !== newColors.length) {
            this.error("can't update geometry colors - new colors are wrong length");
            return;
        }
        colors.set(newColors);
        if (state.colorsBuf) {
            state.colorsBuf.setData(colors);
        }
        this.glRedraw();
    };

    /**
     The Geometry's indices.

     If ````xeokit.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]```` is true, then this can be
     a ````Uint32Array````, otherwise it needs to be a ````Uint16Array````.

     @property indices
     @default null
     @type Uint16Array | Uint32Array
     @final
     */
    prototypeAccessors.indices.get = function () {
        return this._state.indices;
    };

    /**
     * Local-space axis-aligned 3D boundary (AABB) of this geometry.
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @property aabb
     * @final
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        if (this._aabbDirty) {
            if (!this._aabb) {
                this._aabb = math.AABB3();
            }
            math.positions3ToAABB3(this._state.positions, this._aabb, this._state.positionsDecodeMatrix);
            this._aabbDirty = false;
        }
        return this._aabb;
    };

    /**
     * Local-space oriented 3D boundary (OBB) of this geometry.
     *
     * The OBB is represented by a 32-element Float64Array containing the eight vertices of the box,
     * where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
     *
     * @property obb
     * @final
     * @type {Number[]}
     */
    prototypeAccessors.obb.get = function () {
        if (this._obbDirty) {
            if (!this._obb) {
                this._obb = math.OBB3();
            }
            math.positions3ToAABB3(this._state.positions, tempAABB$2, this._state.positionsDecodeMatrix);
            math.AABB3ToOBB3(tempAABB$2, this._obb);
            this._obbDirty = false;
        }
        return this._obb;
    };

    /**
     * Approximate number of triangles in this ReadableGeometry.
     *
     * Will be zero if {@link ReadableGeometry#primitive} is not 'triangles', 'triangle-strip' or 'triangle-fan'.
     *
     * @type {Number}
     */
    prototypeAccessors.numTriangles.get = function () {
        return this._numTriangles;
    };

    ReadableGeometry.prototype._setAABBDirty = function _setAABBDirty () {
        if (this._aabbDirty) {
            return;
        }
        this._aabbDirty = true;
        this._aabbDirty = true;
        this._obbDirty = true;
    };

    ReadableGeometry.prototype._getState = function _getState () {
        return this._state;
    };

    /**
     * Destroys this ReadableGeometry
     */
    ReadableGeometry.prototype.destroy = function destroy () {
        Geometry.prototype.destroy.call(this);
        var state = this._state;
        if (state.indicesBuf) {
            state.indicesBuf.destroy();
        }
        if (state.positionsBuf) {
            state.positionsBuf.destroy();
        }
        if (state.normalsBuf) {
            state.normalsBuf.destroy();
        }
        if (state.uvBuf) {
            state.uvBuf.destroy();
        }
        if (state.colorsBuf) {
            state.colorsBuf.destroy();
        }
        if (this._edgeIndicesBuf) {
            this._edgeIndicesBuf.destroy();
        }
        if (this._pickTrianglePositionsBuf) {
            this._pickTrianglePositionsBuf.destroy();
        }
        if (this._pickTriangleColorsBuf) {
            this._pickTriangleColorsBuf.destroy();
        }
        if (this._pickVertexPositionsBuf) {
            this._pickVertexPositionsBuf.destroy();
        }
        if (this._pickVertexColorsBuf) {
            this._pickVertexColorsBuf.destroy();
        }
        state.destroy();
        memoryStats$1.meshes--;
    };

    Object.defineProperties( ReadableGeometry.prototype, prototypeAccessors );

    return ReadableGeometry;
}(Geometry));

/**
 * @desc Creates box-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a box-shaped {@link ReadableGeometry}.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildBoxGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildBoxGeometry({
 *         center: [0,0,0],
 *         xSize: 1,  // Half-size on each axis
 *         ySize: 1,
 *         zSize: 1
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildBoxGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.
 * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.
 * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildBoxGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var xSize = cfg.xSize || 1;
    if (xSize < 0) {
        console.error("negative xSize not allowed - will invert");
        xSize *= -1;
    }

    var ySize = cfg.ySize || 1;
    if (ySize < 0) {
        console.error("negative ySize not allowed - will invert");
        ySize *= -1;
    }

    var zSize = cfg.zSize || 1;
    if (zSize < 0) {
        console.error("negative zSize not allowed - will invert");
        zSize *= -1;
    }

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;

    var xmin = -xSize + centerX;
    var ymin = -ySize + centerY;
    var zmin = -zSize + centerZ;
    var xmax = xSize + centerX;
    var ymax = ySize + centerY;
    var zmax = zSize + centerZ;

    return utils.apply(cfg, {

        // The vertices - eight for our cube, each
        // one spanning three array elements for X,Y and Z
        positions: [

            // v0-v1-v2-v3 front
            xmax, ymax, zmax,
            xmin, ymax, zmax,
            xmin, ymin, zmax,
            xmax, ymin, zmax,

            // v0-v3-v4-v1 right
            xmax, ymax, zmax,
            xmax, ymin, zmax,
            xmax, ymin, zmin,
            xmax, ymax, zmin,

            // v0-v1-v6-v1 top
            xmax, ymax, zmax,
            xmax, ymax, zmin,
            xmin, ymax, zmin,
            xmin, ymax, zmax,

            // v1-v6-v7-v2 left
            xmin, ymax, zmax,
            xmin, ymax, zmin,
            xmin, ymin, zmin,
            xmin, ymin, zmax,

            // v7-v4-v3-v2 bottom
            xmin, ymin, zmin,
            xmax, ymin, zmin,
            xmax, ymin, zmax,
            xmin, ymin, zmax,

            // v4-v7-v6-v1 back
            xmax, ymin, zmin,
            xmin, ymin, zmin,
            xmin, ymax, zmin,
            xmax, ymax, zmin
        ],

        // Normal vectors, one for each vertex
        normals: [

            // v0-v1-v2-v3 front
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,

            // v0-v3-v4-v5 right
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,

            // v0-v5-v6-v1 top
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,

            // v1-v6-v7-v2 left
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,

            // v7-v4-v3-v2 bottom
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,

            // v4-v7-v6-v5 back
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1
        ],

        // UV coords
        uv: [

            // v0-v1-v2-v3 front
            1, 0,
            0, 0,
            0, 1,
            1, 1,

            // v0-v3-v4-v1 right
            0, 0,
            0, 1,
            1, 1,
            1, 0,

            // v0-v1-v6-v1 top
            1, 1,
            1, 0,
            0, 0,
            0, 1,

            // v1-v6-v7-v2 left
            1, 0,
            0, 0,
            0, 1,
            1, 1,

            // v7-v4-v3-v2 bottom
            0, 1,
            1, 1,
            1, 0,
            0, 0,

            // v4-v7-v6-v1 back
            0, 1,
            1, 1,
            1, 0,
            0, 0
        ],

        // Indices - these organise the
        // positions and uv texture coordinates
        // into geometric primitives in accordance
        // with the "primitive" parameter,
        // in this case a set of three indices
        // for each triangle.
        //
        // Note that each triangle is specified
        // in counter-clockwise winding order.
        //
        // You can specify them in clockwise
        // order if you configure the Modes
        // node's frontFace flag as "cw", instead of
        // the default "ccw".
        indices: [
            0, 1, 2,
            0, 2, 3,
            // front
            4, 5, 6,
            4, 6, 7,
            // right
            8, 9, 10,
            8, 10, 11,
            // top
            12, 13, 14,
            12, 14, 15,
            // left
            16, 17, 18,
            16, 18, 19,
            // bottom
            20, 21, 22,
            20, 22, 23
        ]
    });
}

/**
 * @desc A **Material** defines the surface appearance of attached {@link Mesh}es.
 *
 * Material is the base class for:
 *
 * * {@link MetallicMaterial} - physically-based material for metallic surfaces. Use this one for things made of metal.
 * * {@link SpecularMaterial} - physically-based material for non-metallic (dielectric) surfaces. Use this one for insulators, such as ceramics, plastics, wood etc.
 * * {@link PhongMaterial} - material for classic Blinn-Phong shading. This is less demanding of graphics hardware than the physically-based materials.
 * * {@link LambertMaterial} - material for fast, flat-shaded CAD rendering without textures. Use this for navigating huge CAD or BIM models interactively. This material gives the best rendering performance and uses the least memory.
 * * {@link EmphasisMaterial} - defines the appearance of Meshes when "xrayed" or "highlighted".
 * * {@link EdgeMaterial} - defines the appearance of Meshes when edges are emphasized.
 *
 * A {@link Scene} is allowed to contain a mixture of these material types.
 *
 */

var Material = /*@__PURE__*/(function (Component) {
    function Material(owner, cfg) {
        if ( cfg === void 0 ) cfg={};

        Component.call(this, owner, cfg);
        stats.memory.materials++;
    }

    if ( Component ) Material.__proto__ = Component;
    Material.prototype = Object.create( Component && Component.prototype );
    Material.prototype.constructor = Material;

    var prototypeAccessors = { type: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Material";
    };

    Material.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        stats.memory.materials--;
    };

    Object.defineProperties( Material.prototype, prototypeAccessors );

    return Material;
}(Component));

var alphaModes$1 = {"opaque": 0, "mask": 1, "blend": 2};
var alphaModeNames$1 = ["opaque", "mask", "blend"];

/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the non-physically-correct Blinn-Phong shading model.
 *
 * * Useful for non-realistic objects like gizmos.
 * * {@link SpecularMaterial} is best for insulators, such as wood, ceramics and plastic.
 * * {@link MetallicMaterial} is best for conductive materials, such as metal.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with a PhongMaterial with a diffuse {@link Texture} and a specular {@link Fresnel}, using a {@link buildTorusGeometry} to create the {@link Geometry}.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_PhongMaterial)]
 *
 *  ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *     ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas"
 *    });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          specularFresnel: new Fresnel(viewer.scene, {
 *              leftColor: [1.0, 1.0, 1.0],
 *              rightColor: [0.0, 0.0, 0.0],
 *              power: 4
 *          })
 *     })
 * });
 * ````
 *
 * ## PhongMaterial Properties
 *
 *  The following table summarizes PhongMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link PhongMaterial#ambient} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 * | {@link PhongMaterial#diffuse} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 * | {@link PhongMaterial#specular} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular light reflected by the material. |
 * | {@link PhongMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 * | {@link PhongMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link PhongMaterial#shininess} | Number | [0, 128] | 80 | linear | Determines the size and sharpness of specular highlights. |
 * | {@link PhongMaterial#reflectivity} | Number | [0, 1] | 1 | linear | Determines the amount of reflectivity. |
 * | {@link PhongMaterial#diffuseMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#diffuse}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#specularMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#specular}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link PhongMaterial#emissive}. |
 * | {@link PhongMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by {@link PhongMaterial#ambient}, {@link PhongMaterial#diffuse} and {@link PhongMaterial#specular}. |
 * | {@link PhongMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link PhongMaterial#diffuseFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#diffuse}. |
 * | {@link PhongMaterial#specularFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#specular}. |
 * | {@link PhongMaterial#emissiveFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#emissive}. |
 * | {@link PhongMaterial#reflectivityFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#reflectivity}. |
 * | {@link PhongMaterial#alphaFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#alpha}. |
 * | {@link PhongMaterial#lineWidth} | Number | [0..100] | 1 |  | Line width in pixels. |
 * | {@link PhongMaterial#pointSize} | Number | [0..100] | 1 |  | Point size in pixels. |
 * | {@link PhongMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link PhongMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link PhongMaterial#backfaces} | Boolean |  | false |  | Whether to render geometry backfaces. |
 * | {@link PhongMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for geometry frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 */
var PhongMaterial = /*@__PURE__*/(function (Material) {
    function PhongMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "PhongMaterial",
            ambient: math.vec3([1.0, 1.0, 1.0]),
            diffuse: math.vec3([1.0, 1.0, 1.0]),
            specular: math.vec3([1.0, 1.0, 1.0]),
            emissive: math.vec3([0.0, 0.0, 0.0]),
            alpha: null,
            shininess: null,
            reflectivity: null,
            alphaMode: null,
            alphaCutoff: null,
            lineWidth: null,
            pointSize: null,
            backfaces: null,
            frontface: null, // Boolean for speed; true == "ccw", false == "cw"
            hash: null
        });

        this.ambient = cfg.ambient;
        this.diffuse = cfg.diffuse;
        this.specular = cfg.specular;
        this.emissive = cfg.emissive;
        this.alpha = cfg.alpha;
        this.shininess = cfg.shininess;
        this.reflectivity = cfg.reflectivity;
        this.lineWidth = cfg.lineWidth;
        this.pointSize = cfg.pointSize;

        if (cfg.ambientMap) {
            this._ambientMap = this._checkComponent("Texture", cfg.ambientMap);
        }
        if (cfg.diffuseMap) {
            this._diffuseMap = this._checkComponent("Texture", cfg.diffuseMap);
        }
        if (cfg.specularMap) {
            this._specularMap = this._checkComponent("Texture", cfg.specularMap);
        }
        if (cfg.emissiveMap) {
            this._emissiveMap = this._checkComponent("Texture", cfg.emissiveMap);
        }
        if (cfg.alphaMap) {
            this._alphaMap = this._checkComponent("Texture", cfg.alphaMap);
        }
        if (cfg.reflectivityMap) {
            this._reflectivityMap = this._checkComponent("Texture", cfg.reflectivityMap);
        }
        if (cfg.normalMap) {
            this._normalMap = this._checkComponent("Texture", cfg.normalMap);
        }
        if (cfg.occlusionMap) {
            this._occlusionMap = this._checkComponent("Texture", cfg.occlusionMap);
        }
        if (cfg.diffuseFresnel) {
            this._diffuseFresnel = this._checkComponent("Fresnel", cfg.diffuseFresnel);
        }
        if (cfg.specularFresnel) {
            this._specularFresnel = this._checkComponent("Fresnel", cfg.specularFresnel);
        }
        if (cfg.emissiveFresnel) {
            this._emissiveFresnel = this._checkComponent("Fresnel", cfg.emissiveFresnel);
        }
        if (cfg.alphaFresnel) {
            this._alphaFresnel = this._checkComponent("Fresnel", cfg.alphaFresnel);
        }
        if (cfg.reflectivityFresnel) {
            this._reflectivityFresnel = this._checkComponent("Fresnel", cfg.reflectivityFresnel);
        }

        this.alphaMode = cfg.alphaMode;
        this.alphaCutoff = cfg.alphaCutoff;
        this.backfaces = cfg.backfaces;
        this.frontface = cfg.frontface;

        this._makeHash();
    }

    if ( Material ) PhongMaterial.__proto__ = Material;
    PhongMaterial.prototype = Object.create( Material && Material.prototype );
    PhongMaterial.prototype.constructor = PhongMaterial;

    var prototypeAccessors = { type: { configurable: true },ambient: { configurable: true },diffuse: { configurable: true },specular: { configurable: true },emissive: { configurable: true },alpha: { configurable: true },shininess: { configurable: true },lineWidth: { configurable: true },pointSize: { configurable: true },reflectivity: { configurable: true },normalMap: { configurable: true },ambientMap: { configurable: true },diffuseMap: { configurable: true },specularMap: { configurable: true },emissiveMap: { configurable: true },alphaMap: { configurable: true },reflectivityMap: { configurable: true },occlusionMap: { configurable: true },diffuseFresnel: { configurable: true },specularFresnel: { configurable: true },emissiveFresnel: { configurable: true },alphaFresnel: { configurable: true },reflectivityFresnel: { configurable: true },alphaMode: { configurable: true },alphaCutoff: { configurable: true },backfaces: { configurable: true },frontface: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "PhongMaterial";
    };

    PhongMaterial.prototype._makeHash = function _makeHash () {
        var state = this._state;
        var hash = ["/p"]; // 'P' for Phong
        if (this._normalMap) {
            hash.push("/nm");
            if (this._normalMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._ambientMap) {
            hash.push("/am");
            if (this._ambientMap.hasMatrix) {
                hash.push("/mat");
            }
            hash.push("/" + this._ambientMap.encoding);
        }
        if (this._diffuseMap) {
            hash.push("/dm");
            if (this._diffuseMap.hasMatrix) {
                hash.push("/mat");
            }
            hash.push("/" + this._diffuseMap.encoding);
        }
        if (this._specularMap) {
            hash.push("/sm");
            if (this._specularMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._emissiveMap) {
            hash.push("/em");
            if (this._emissiveMap.hasMatrix) {
                hash.push("/mat");
            }
            hash.push("/" + this._emissiveMap.encoding);
        }
        if (this._alphaMap) {
            hash.push("/opm");
            if (this._alphaMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._reflectivityMap) {
            hash.push("/rm");
            if (this._reflectivityMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._occlusionMap) {
            hash.push("/ocm");
            if (this._occlusionMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._diffuseFresnel) {
            hash.push("/df");
        }
        if (this._specularFresnel) {
            hash.push("/sf");
        }
        if (this._emissiveFresnel) {
            hash.push("/ef");
        }
        if (this._alphaFresnel) {
            hash.push("/of");
        }
        if (this._reflectivityFresnel) {
            hash.push("/rf");
        }
        hash.push(";");
        state.hash = hash.join("");
    };

    /**
     * Sets the PhongMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.ambient.set = function (value) {
        var ambient = this._state.ambient;
        if (!ambient) {
            ambient = this._state.ambient = new Float32Array(3);
        } else if (value && ambient[0] === value[0] && ambient[1] === value[1] && ambient[2] === value[2]) {
            return;
        }
        if (value) {
            ambient[0] = value[0];
            ambient[1] = value[1];
            ambient[2] = value[2];
        } else {
            ambient[0] = .2;
            ambient[1] = .2;
            ambient[2] = .2;
        }
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.ambient.get = function () {
        return this._state.ambient;
    };

    /**
     * Sets the PhongMaterial's diffuse color.
     *
     * Multiplies by {@link PhongMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.diffuse.set = function (value) {
        var diffuse = this._state.diffuse;
        if (!diffuse) {
            diffuse = this._state.diffuse = new Float32Array(3);
        } else if (value && diffuse[0] === value[0] && diffuse[1] === value[1] && diffuse[2] === value[2]) {
            return;
        }
        if (value) {
            diffuse[0] = value[0];
            diffuse[1] = value[1];
            diffuse[2] = value[2];
        } else {
            diffuse[0] = 1;
            diffuse[1] = 1;
            diffuse[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Sets the PhongMaterial's diffuse color.
     *
     * Multiplies by {@link PhongMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.diffuse.get = function () {
        return this._state.diffuse;
    };

    /**
     * Sets the PhongMaterial's specular color.
     *
     * Multiplies by {@link PhongMaterial#specularMap}.
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.specular.set = function (value) {
        var specular = this._state.specular;
        if (!specular) {
            specular = this._state.specular = new Float32Array(3);
        } else if (value && specular[0] === value[0] && specular[1] === value[1] && specular[2] === value[2]) {
            return;
        }
        if (value) {
            specular[0] = value[0];
            specular[1] = value[1];
            specular[2] = value[2];
        } else {
            specular[0] = 1;
            specular[1] = 1;
            specular[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's specular color.
     *
     * Multiplies by {@link PhongMaterial#specularMap}.
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.specular.get = function () {
        return this._state.specular;
    };

    /**
     * Sets the PhongMaterial's emissive color.
     *
     * Multiplies by {@link PhongMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.emissive.set = function (value) {
        var emissive = this._state.emissive;
        if (!emissive) {
            emissive = this._state.emissive = new Float32Array(3);
        } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
            return;
        }
        if (value) {
            emissive[0] = value[0];
            emissive[1] = value[1];
            emissive[2] = value[2];
        } else {
            emissive[0] = 0;
            emissive[1] = 0;
            emissive[2] = 0;
        }
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's emissive color.
     *
     * Multiplies by {@link PhongMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.emissive.get = function () {
        return this._state.emissive;
    };

    /**
     * Sets the PhongMaterial alpha.
     *
     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.
     *
     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
     *
     * Multiplies by {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.alpha === value) {
            return;
        }
        this._state.alpha = value;
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial alpha.
     *
     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.
     *
     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
     *
     * Multiplies by {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.get = function () {
        return this._state.alpha;
    };

    /**
     * Sets the PhongMaterial shininess.
     *
     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.
     *
     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
     * highlight.
     *
     * Default value is ```` 80.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.shininess.set = function (value) {
        this._state.shininess = value !== undefined ? value : 80;
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial shininess.
     *
     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.
     *
     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
     * highlight.
     *
     * Default value is ```` 80.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.shininess.get = function () {
        return this._state.shininess;
    };

    /**
     * Sets the PhongMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.set = function (value) {
        this._state.lineWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.get = function () {
        return this._state.lineWidth;
    };

    /**
     * Sets the PhongMaterial's point size.
     *
     * Default value is 1.0.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.set = function (value) {
        this._state.pointSize = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's point size.
     *
     * Default value is 1.0.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.get = function () {
        return this._state.pointSize;
    };

    /**
     * Sets how much {@link ReflectionMap} is reflected by this PhongMaterial.
     *
     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.
     *
     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.
     *
     * Multiplies by {@link PhongMaterial#reflectivityMap}.
     *
     * @type {Number}
     */
    prototypeAccessors.reflectivity.set = function (value) {
        this._state.reflectivity = value !== undefined ? value : 1.0;
        this.glRedraw();
    };

    /**
     * Gets how much {@link ReflectionMap} is reflected by this PhongMaterial.
     *
     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.
     *
     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.
     *
     * Multiplies by {@link PhongMaterial#reflectivityMap}.
     *
     * @type {Number}
     */
    prototypeAccessors.reflectivity.get = function () {
        return this._state.reflectivity;
    };

    /**
     * Gets the PhongMaterials's normal map {@link Texture}.
     *
     * @type {Texture}
     */
    prototypeAccessors.normalMap.get = function () {
        return this._normalMap;
    };

    /**
     * Gets the PhongMaterials's ambient {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#ambient}.
     *
     * @type {Texture}
     */
    prototypeAccessors.ambientMap.get = function () {
        return this._ambientMap;
    };

    /**
     * Gets the PhongMaterials's diffuse {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#diffuse}.
     *
     * @type {Texture}
     */
    prototypeAccessors.diffuseMap.get = function () {
        return this._diffuseMap;
    };

    /**
     * Gets the PhongMaterials's specular {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#specular}.
     *
     * @type {Texture}
     */
    prototypeAccessors.specularMap.get = function () {
        return this._specularMap;
    };

    /**
     * Gets the PhongMaterials's emissive {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#emissive}.
     *
     * @type {Texture}
     */
    prototypeAccessors.emissiveMap.get = function () {
        return this._emissiveMap;
    };

    /**
     * Gets the PhongMaterials's alpha {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#alpha}.
     *
     * @type {Texture}
     */
    prototypeAccessors.alphaMap.get = function () {
        return this._alphaMap;
    };

    /**
     * Gets the PhongMaterials's reflectivity {@link Texture}.
     *
     * Multiplies by {@link PhongMaterial#reflectivity}.
     *
     * @type {Texture}
     */
    prototypeAccessors.reflectivityMap.get = function () {
        return this._reflectivityMap;
    };

    /**
     * Gets the PhongMaterials's ambient occlusion {@link Texture}.
     *
     * @type {Texture}
     */
    prototypeAccessors.occlusionMap.get = function () {
        return this._occlusionMap;
    };

    /**
     * Gets the PhongMaterials's diffuse {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#diffuse}.
     *
     * @type {Fresnel}
     */
    prototypeAccessors.diffuseFresnel.get = function () {
        return this._diffuseFresnel;
    };

    /**
     * Gets the PhongMaterials's specular {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#specular}.
     *
     * @type {Fresnel}
     */
    prototypeAccessors.specularFresnel.get = function () {
        return this._specularFresnel;
    };

    /**
     * Gets the PhongMaterials's emissive {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#emissive}.
     *
     * @type {Fresnel}
     */
    prototypeAccessors.emissiveFresnel.get = function () {
        return this._emissiveFresnel;
    };

    /**
     * Gets the PhongMaterials's alpha {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#alpha}.
     *
     * @type {Fresnel}
     */
    prototypeAccessors.alphaFresnel.get = function () {
        return this._alphaFresnel;
    };

    /**
     * Gets the PhongMaterials's reflectivity {@link Fresnel}.
     *
     * Applies to {@link PhongMaterial#reflectivity}.
     *
     * @type {Fresnel}
     */
    prototypeAccessors.reflectivityFresnel.get = function () {
        return this._reflectivityFresnel;
    };

    /**
     * Sets the PhongMaterial's alpha rendering mode.
     *
     * This governs how alpha is treated. Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.
     *
     * Supported values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).
     *
     *@type {String}
     */
    prototypeAccessors.alphaMode.set = function (alphaMode) {
        alphaMode = alphaMode || "opaque";
        var value = alphaModes$1[alphaMode];
        if (value === undefined) {
            this.error("Unsupported value for 'alphaMode': " + alphaMode + " - defaulting to 'opaque'");
            value = "opaque";
        }
        if (this._state.alphaMode === value) {
            return;
        }
        this._state.alphaMode = value;
        this.glRedraw();
    };

    /**
     * Gets the PhongMaterial's alpha rendering mode.
     *
     *@type {String}
     */
    prototypeAccessors.alphaMode.get = function () {
        return alphaModeNames$1[this._state.alphaMode];
    };

    /**
     * Sets the PhongMaterial's alpha cutoff value.
     *
     * This specifies the cutoff threshold when {@link PhongMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully
     * opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.set = function (alphaCutoff) {
        if (alphaCutoff === null || alphaCutoff === undefined) {
            alphaCutoff = 0.5;
        }
        if (this._state.alphaCutoff === alphaCutoff) {
            return;
        }
        this._state.alphaCutoff = alphaCutoff;
    };

    /**
     * Gets the PhongMaterial's alpha cutoff value.
     *
     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.get = function () {
        return this._state.alphaCutoff;
    };

    /**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link Geometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (value) {
        value = !!value;
        if (this._state.backfaces === value) {
            return;
        }
        this._state.backfaces = value;
        this.glRedraw();
    };

    /**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._state.backfaces;
    };

    /**
     * Sets the winding direction of geometry front faces.
     *
     * Default is ````"ccw"````.
     * @type {String}
     */
    prototypeAccessors.frontface.set = function (value) {
        value = value !== "cw";
        if (this._state.frontface === value) {
            return;
        }
        this._state.frontface = value;
        this.glRedraw();
    };

    /**
     * Gets the winding direction of front faces on attached {@link Mesh}es.
     *
     * Default is ````"ccw"````.
     * @type {String}
     */
    prototypeAccessors.frontface.get = function () {
        return this._state.frontface ? "ccw" : "cw";
    };

    /**
     * Destroys this PhongMaterial.
     */
    PhongMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( PhongMaterial.prototype, prototypeAccessors );

    return PhongMaterial;
}(Material));

var PRESETS$3 = {
    "default": {
        fill: true,
        fillColor: [0.4, 0.4, 0.4],
        fillAlpha: 0.2,
        edges: true,
        edgeColor: [0.2, 0.2, 0.2],
        edgeAlpha: 0.5,
        edgeWidth: 1
    },
    "defaultWhiteBG": {
        fill: true,
        fillColor: [1, 1, 1],
        fillAlpha: 0.6,
        edgeColor: [0.2, 0.2, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "defaultLightBG": {
        fill: true,
        fillColor: [0.4, 0.4, 0.4],
        fillAlpha: 0.2,
        edges: true,
        edgeColor: [0.2, 0.2, 0.2],
        edgeAlpha: 0.5,
        edgeWidth: 1
    },
    "defaultDarkBG": {
        fill: true,
        fillColor: [0.4, 0.4, 0.4],
        fillAlpha: 0.2,
        edges: true,
        edgeColor: [0.5, 0.5, 0.5],
        edgeAlpha: 0.5,
        edgeWidth: 1
    },
    "phosphorous": {
        fill: true,
        fillColor: [0.0, 0.0, 0.0],
        fillAlpha: 0.4,
        edges: true,
        edgeColor: [0.9, 0.9, 0.9],
        edgeAlpha: 0.5,
        edgeWidth: 2
    },
    "sunset": {
        fill: true,
        fillColor: [0.9, 0.9, 0.6],
        fillAlpha: 0.2,
        edges: true,
        edgeColor: [0.9, 0.9, 0.9],
        edgeAlpha: 0.5,
        edgeWidth: 1
    },
    "vectorscope": {
        fill: true,
        fillColor: [0.0, 0.0, 0.0],
        fillAlpha: 0.7,
        edges: true,
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1,
        edgeWidth: 2
    },
    "battlezone": {
        fill: true,
        fillColor: [0.0, 0.0, 0.0],
        fillAlpha: 1.0,
        edges: true,
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1,
        edgeWidth: 3
    },
    "sepia": {
        fill: true,
        fillColor: [0.970588207244873, 0.7965892553329468, 0.6660899519920349],
        fillAlpha: 0.4,
        edges: true,
        edgeColor: [0.529411792755127, 0.4577854573726654, 0.4100345969200134],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "yellowHighlight": {
        fill: true,
        fillColor: [1.0, 1.0, 0.0],
        fillAlpha: 0.5,
        edges: true,
        edgeColor: [0.529411792755127, 0.4577854573726654, 0.4100345969200134],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "greenSelected": {
        fill: true,
        fillColor: [0.0, 1.0, 0.0],
        fillAlpha: 0.5,
        edges: true,
        edgeColor: [0.4577854573726654, 0.529411792755127, 0.4100345969200134],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "gamegrid": {
        fill: true,
        fillColor: [0.2, 0.2, 0.7],
        fillAlpha: 0.9,
        edges: true,
        edgeColor: [0.4, 0.4, 1.6],
        edgeAlpha: 0.8,
        edgeWidth: 3
    }
};

/**
 * Configures the appearance of {@link Entity}s when they are xrayed, highlighted or selected.
 *
 * * XRay an {@link Entity} by setting {@link Entity#xrayed} ````true````.
 * * Highlight an {@link Entity} by setting {@link Entity#highlighted} ````true````.
 * * Select an {@link Entity} by setting {@link Entity#selected} ````true````.
 * * When {@link Entity}s are within the subtree of a root {@link Entity}, then setting {@link Entity#xrayed}, {@link Entity#highlighted} or {@link Entity#selected}
 * on the root will collectively set those properties on all sub-{@link Entity}s.
 * * EmphasisMaterial provides several presets. Select a preset by setting {@link EmphasisMaterial#preset} to the ID of a preset in {@link EmphasisMaterial#presets}.
 * * By default, a {@link Mesh} uses the default EmphasisMaterials in {@link Scene#xrayMaterial}, {@link Scene#highlightMaterial} and {@link Scene#selectedMaterial}
 * but you can assign each {@link Mesh#xrayMaterial}, {@link Mesh#highlightMaterial} or {@link Mesh#selectedMaterial} to a custom EmphasisMaterial, if required.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with its own XRayMaterial and set {@link Mesh#xrayed} ````true```` to xray it.
 *
 * Recall that {@link Mesh} is a concrete subtype of the abstract {@link Entity} base class.
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *     geometry: new BoxGeometry(viewer.scene, {
 *         edgeThreshold: 1
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     xrayMaterial: new EmphasisMaterial(viewer.scene, {
 *         fill: true,
 *         fillColor: [0, 0, 0],
 *         fillAlpha: 0.7,
 *         edges: true,
 *         edgeColor: [0.2, 1.0, 0.2],
 *         edgeAlpha: 1.0,
 *         edgeWidth: 2
 *     }),
 *     xrayed: true
 * });
 * ````
 *
 * Note the ````edgeThreshold```` configuration for the {@link ReadableGeometry} on our {@link Mesh}.  EmphasisMaterial configures
 * a wireframe representation of the {@link ReadableGeometry} for the selected emphasis mode, which will have inner edges (those edges between
 * adjacent co-planar triangles) removed for visual clarity. The ````edgeThreshold```` indicates that, for
 * this particular {@link ReadableGeometry}, an inner edge is one where the angle between the surface normals of adjacent triangles
 * is not greater than ````5```` degrees. That's set to ````2```` by default, but we can override it to tweak the effect
 * as needed for particular Geometries.
 *
 * Here's the example again, this time implicitly defaulting to the {@link Scene#edgeMaterial}. We'll also modify that EdgeMaterial
 * to customize the effect.
 *
 * ````javascript
 * new Mesh({
 *     geometry: new TeapotGeometry(viewer.scene, {
 *         edgeThreshold: 5
 *     }),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     xrayed: true
 * });
 *
 * var xrayMaterial = viewer.scene.xrayMaterial;
 *
 * xrayMaterial.fillColor = [0.2, 1.0, 0.2];
 * xrayMaterial.fillAlpha = 1.0;
 * ````
 *
 * ## Presets
 *
 * Let's switch the {@link Scene#xrayMaterial} to one of the presets in {@link EmphasisMaterial#presets}:
 *
 * ````javascript
 * viewer.xrayMaterial.preset = EmphasisMaterial.presets["sepia"];
 * ````
 *
 * We can also create an EmphasisMaterial from a preset, while overriding properties of the preset as required:
 *
 * ````javascript
 * var myEmphasisMaterial = new EMphasisMaterial(viewer.scene, {
 *      preset: "sepia",
 *      fillColor = [1.0, 0.5, 0.5]
 * });
 * ````
 */
var EmphasisMaterial = /*@__PURE__*/(function (Material) {
    function EmphasisMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "EmphasisMaterial",
            fill: null,
            fillColor: null,
            fillAlpha: null,
            edges: null,
            edgeColor: null,
            edgeAlpha: null,
            edgeWidth: null,
            backfaces: true
        });

        this._preset = "default";

        if (cfg.preset) { // Apply preset then override with configs where provided
            this.preset = cfg.preset;
            if (cfg.fill !== undefined) {
                this.fill = cfg.fill;
            }
            if (cfg.fillColor) {
                this.fillColor = cfg.fillColor;
            }
            if (cfg.fillAlpha !== undefined) {
                this.fillAlpha = cfg.fillAlpha;
            }
            if (cfg.edges !== undefined) {
                this.edges = cfg.edges;
            }
            if (cfg.edgeColor) {
                this.edgeColor = cfg.edgeColor;
            }
            if (cfg.edgeAlpha !== undefined) {
                this.edgeAlpha = cfg.edgeAlpha;
            }
            if (cfg.edgeWidth !== undefined) {
                this.edgeWidth = cfg.edgeWidth;
            }
            if (cfg.backfaces !== undefined) {
                this.backfaces = cfg.backfaces;
            }
        } else {
            this.fill = cfg.fill;
            this.fillColor = cfg.fillColor;
            this.fillAlpha = cfg.fillAlpha;
            this.edges = cfg.edges;
            this.edgeColor = cfg.edgeColor;
            this.edgeAlpha = cfg.edgeAlpha;
            this.edgeWidth = cfg.edgeWidth;
            this.backfaces = cfg.backfaces;
        }
    }

    if ( Material ) EmphasisMaterial.__proto__ = Material;
    EmphasisMaterial.prototype = Object.create( Material && Material.prototype );
    EmphasisMaterial.prototype.constructor = EmphasisMaterial;

    var prototypeAccessors = { type: { configurable: true },presets: { configurable: true },fill: { configurable: true },fillColor: { configurable: true },fillAlpha: { configurable: true },edges: { configurable: true },edgeColor: { configurable: true },edgeAlpha: { configurable: true },edgeWidth: { configurable: true },backfaces: { configurable: true },preset: { configurable: true } };

    /**
     * Sets if surfaces are filled with color.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.type.get = function () {
        return "EmphasisMaterial";
    };

    /**
     * Gets available EmphasisMaterial presets.
     *
     * @type {Object}
     */
    prototypeAccessors.presets.get = function () {
        return PRESETS$3;
    };

    prototypeAccessors.fill.set = function (value) {
        value = value !== false;
        if (this._state.fill === value) {
            return;
        }
        this._state.fill = value;
        this.glRedraw();
    };

    /**
     * Gets if surfaces are filled with color.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.fill.get = function () {
        return this._state.fill;
    };

    /**
     * Sets the RGB color of filled faces.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.fillColor.set = function (value) {
        var fillColor = this._state.fillColor;
        if (!fillColor) {
            fillColor = this._state.fillColor = new Float32Array(3);
        } else if (value && fillColor[0] === value[0] && fillColor[1] === value[1] && fillColor[2] === value[2]) {
            return;
        }
        if (value) {
            fillColor[0] = value[0];
            fillColor[1] = value[1];
            fillColor[2] = value[2];
        } else {
            fillColor[0] = 0.4;
            fillColor[1] = 0.4;
            fillColor[2] = 0.4;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB color of filled faces.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.fillColor.get = function () {
        return this._state.fillColor;
    };

    /**
     * Sets the transparency of filled faces.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.fillAlpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 0.2;
        if (this._state.fillAlpha === value) {
            return;
        }
        this._state.fillAlpha = value;
        this.glRedraw();
    };

    /**
     * Gets the transparency of filled faces.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.fillAlpha.get = function () {
        return this._state.fillAlpha;
    };

    /**
     * Sets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.set = function (value) {
        value = value !== false;
        if (this._state.edges === value) {
            return;
        }
        this._state.edges = value;
        this.glRedraw();
    };

    /**
     * Gets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.get = function () {
        return this._state.edges;
    };

    /**
     * Sets the RGB color of edges.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.edgeColor.set = function (value) {
        var edgeColor = this._state.edgeColor;
        if (!edgeColor) {
            edgeColor = this._state.edgeColor = new Float32Array(3);
        } else if (value && edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
            return;
        }
        if (value) {
            edgeColor[0] = value[0];
            edgeColor[1] = value[1];
            edgeColor[2] = value[2];
        } else {
            edgeColor[0] = 0.2;
            edgeColor[1] = 0.2;
            edgeColor[2] = 0.2;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB color of edges.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.edgeColor.get = function () {
        return this._state.edgeColor;
    };

    /**
     * Sets the transparency of edges.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeAlpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 0.5;
        if (this._state.edgeAlpha === value) {
            return;
        }
        this._state.edgeAlpha = value;
        this.glRedraw();
    };

    /**
     * Gets the transparency of edges.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeAlpha.get = function () {
        return this._state.edgeAlpha;
    };

    /**
     * Sets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeWidth.set = function (value) {
        this._state.edgeWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeWidth.get = function () {
        return this._state.edgeWidth;
    };

    /**
     * Sets whether to render backfaces when {@link EmphasisMaterial#fill} is ````true````..
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (value) {
        value = !!value;
        if (this._state.backfaces === value) {
            return;
        }
        this._state.backfaces = value;
        this.glRedraw();
    };

    /**
     * Gets whether to render backfaces when {@link EmphasisMaterial#fill} is ````true````..
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._state.backfaces;
    };

    /**
     * Selects a preset EmphasisMaterial configuration.
     *
     * Default value is "default".
     *
     * @type {String}
     */
    prototypeAccessors.preset.set = function (value) {
        value = value || "default";
        if (this._preset === value) {
            return;
        }
        var preset = PRESETS$3[value];
        if (!preset) {
            this.error("unsupported preset: '" + value + "' - supported values are " + Object.keys(PRESETS$3).join(", "));
            return;
        }
        this.fill = preset.fill;
        this.fillColor = preset.fillColor;
        this.fillAlpha = preset.fillAlpha;
        this.edges = preset.edges;
        this.edgeColor = preset.edgeColor;
        this.edgeAlpha = preset.edgeAlpha;
        this.edgeWidth = preset.edgeWidth;
        this._preset = value;
    };

    /**
     * Gets the current preset EmphasisMaterial configuration.
     *
     * Default value is "default".
     *
     * @type {String}
     */
    prototypeAccessors.preset.get = function () {
        return this._preset;
    };

    /**
     * Destroys this EmphasisMaterial.
     */
    EmphasisMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( EmphasisMaterial.prototype, prototypeAccessors );

    return EmphasisMaterial;
}(Material));

var PRESETS$2 = {
    "default": {
        edgeColor: [0.0, 0.0, 0.0],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "defaultWhiteBG": {
        edgeColor: [0.2, 0.2, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "defaultLightBG": {
        edgeColor: [0.2, 0.2, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 1
    },
    "defaultDarkBG": {
        edgeColor: [0.5, 0.5, 0.5],
        edgeAlpha: 1.0,
        edgeWidth: 1
    }
};

/**
 * @desc Configures the appearance of {@link Entity}s when their edges are emphasised.
 *
 * * Emphasise edges of an {@link Entity} by setting {@link Entity#edges} ````true````.
 * * When {@link Entity}s are within the subtree of a root {@link Entity}, then setting {@link Entity#edges} on the root
 * will collectively set that property on all sub-{@link Entity}s.
 * * EdgeMaterial provides several presets. Select a preset by setting {@link EdgeMaterial#preset} to the ID of a preset in {@link EdgeMaterial#presets}.
 * * By default, a {@link Mesh} uses the default EdgeMaterial in {@link Scene#edgeMaterial}, but you can assign each {@link Mesh#edgeMaterial} to a custom EdgeMaterial if required.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Mesh} with its own EdgeMaterial and set {@link Mesh#edges} ````true```` to emphasise its edges.
 *
 * Recall that {@link Mesh} is a concrete subtype of the abstract {@link Entity} base class.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_EdgeMaterial)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, PhongMaterial, EdgeMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.5,
 *          heightSegments: 24,
 *          widthSegments: 16,
 *          edgeThreshold: 2 // Default is 10
 *      })),
 *
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.4, 0.4, 1.0],
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          alpha: 0.5,
 *          alphaMode: "blend"
 *      }),
 *
 *      edgeMaterial: new EdgeMaterial(viewer.scene, {
 *          edgeColor: [0.0, 0.0, 1.0]
 *          edgeAlpha: 1.0,
 *          edgeWidth: 2
 *      }),
 *
 *      edges: true
 * });
 * ````
 *
 * Note the ````edgeThreshold```` configuration for the {@link ReadableGeometry} on our {@link Mesh}.  EdgeMaterial configures
 * a wireframe representation of the {@link ReadableGeometry}, which will have inner edges (those edges between
 * adjacent co-planar triangles) removed for visual clarity. The ````edgeThreshold```` indicates that, for
 * this particular {@link ReadableGeometry}, an inner edge is one where the angle between the surface normals of adjacent triangles
 * is not greater than ````5```` degrees. That's set to ````2```` by default, but we can override it to tweak the effect
 * as needed for particular Geometries.
 *
 * Here's the example again, this time implicitly defaulting to the {@link Scene#edgeMaterial}. We'll also modify that EdgeMaterial
 * to customize the effect.
 *
 * ````javascript
 * new Mesh({
 *     geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.5,
 *          heightSegments: 24,
 *          widthSegments: 16,
 *          edgeThreshold: 2 // Default is 10
 *      })),
 *     material: new PhongMaterial(viewer.scene, {
 *         diffuse: [0.2, 0.2, 1.0]
 *     }),
 *     edges: true
 * });
 *
 * var edgeMaterial = viewer.scene.edgeMaterial;
 *
 * edgeMaterial.edgeColor = [0.2, 1.0, 0.2];
 * edgeMaterial.edgeAlpha = 1.0;
 * edgeMaterial.edgeWidth = 2;
 * ````
 *
 *  ## Presets
 *
 * Let's switch the {@link Scene#edgeMaterial} to one of the presets in {@link EdgeMaterial#presets}:
 *
 * ````javascript
 * viewer.edgeMaterial.preset = EdgeMaterial.presets["sepia"];
 * ````
 *
 * We can also create an EdgeMaterial from a preset, while overriding properties of the preset as required:
 *
 * ````javascript
 * var myEdgeMaterial = new EdgeMaterial(viewer.scene, {
 *      preset: "sepia",
 *      edgeColor = [1.0, 0.5, 0.5]
 * });
 * ````
 */
var EdgeMaterial = /*@__PURE__*/(function (Material) {
    function EdgeMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "EdgeMaterial",
            edges: null,
            edgeColor: null,
            edgeAlpha: null,
            edgeWidth: null
        });

        this._preset = "default";

        if (cfg.preset) { // Apply preset then override with configs where provided
            this.preset = cfg.preset;
            if (cfg.edgeColor) {
                this.edgeColor = cfg.edgeColor;
            }
            if (cfg.edgeAlpha !== undefined) {
                this.edgeAlpha = cfg.edgeAlpha;
            }
            if (cfg.edgeWidth !== undefined) {
                this.edgeWidth = cfg.edgeWidth;
            }
        } else {
            this.edgeColor = cfg.edgeColor;
            this.edgeAlpha = cfg.edgeAlpha;
            this.edgeWidth = cfg.edgeWidth;
        }
        this.edges = (cfg.edges !== false);
    }

    if ( Material ) EdgeMaterial.__proto__ = Material;
    EdgeMaterial.prototype = Object.create( Material && Material.prototype );
    EdgeMaterial.prototype.constructor = EdgeMaterial;

    var prototypeAccessors = { type: { configurable: true },presets: { configurable: true },edges: { configurable: true },edgeColor: { configurable: true },edgeAlpha: { configurable: true },edgeWidth: { configurable: true },preset: { configurable: true } };


    /**
     * Sets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.type.get = function () {
        return "EdgeMaterial";
    };

    /**
     * Gets available EdgeMaterial presets.
     *
     * @type {Object}
     */
    prototypeAccessors.presets.get = function () {
        return PRESETS$2;
    };

    prototypeAccessors.edges.set = function (value) {
        value = value !== false;
        if (this._state.edges === value) {
            return;
        }
        this._state.edges = value;
        this.glRedraw();
    };

    /**
     * Gets if edges are visible.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.get = function () {
        return this._state.edges;
    };

    /**
     * Sets RGB edge color.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.edgeColor.set = function (value) {
        var edgeColor = this._state.edgeColor;
        if (!edgeColor) {
            edgeColor = this._state.edgeColor = new Float32Array(3);
        } else if (value && edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
            return;
        }
        if (value) {
            edgeColor[0] = value[0];
            edgeColor[1] = value[1];
            edgeColor[2] = value[2];
        } else {
            edgeColor[0] = 0.2;
            edgeColor[1] = 0.2;
            edgeColor[2] = 0.2;
        }
        this.glRedraw();
    };

    /**
     * Gets RGB edge color.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.edgeColor.get = function () {
        return this._state.edgeColor;
    };

    /**
     * Sets edge transparency.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeAlpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.edgeAlpha === value) {
            return;
        }
        this._state.edgeAlpha = value;
        this.glRedraw();
    };

    /**
     * Gets edge transparency.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeAlpha.get = function () {
        return this._state.edgeAlpha;
    };

    /**
     * Sets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeWidth.set = function (value) {
        this._state.edgeWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets edge width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeWidth.get = function () {
        return this._state.edgeWidth;
    };

    /**
     * Selects a preset EdgeMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.set = function (value) {
        value = value || "default";
        if (this._preset === value) {
            return;
        }
        var preset = PRESETS$2[value];
        if (!preset) {
            this.error("unsupported preset: '" + value + "' - supported values are " + Object.keys(PRESETS$2).join(", "));
            return;
        }
        this.edgeColor = preset.edgeColor;
        this.edgeAlpha = preset.edgeAlpha;
        this.edgeWidth = preset.edgeWidth;
        this._preset = value;
    };

    /**
     * The current preset EdgeMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.get = function () {
        return this._preset;
    };

    /**
     * Destroys this EdgeMaterial.
     */
    EdgeMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( EdgeMaterial.prototype, prototypeAccessors );

    return EdgeMaterial;
}(Material));

//----------------------------------------------------------------------------------------------------------------------

var unitsInfo = {
    meters: {
        abbrev: "m"
    },
    metres: {
        abbrev: "m"
    },
    centimeters: {
        abbrev: "cm"
    },
    centimetres: {
        abbrev: "cm"
    },
    millimeters: {
        abbrev: "mm"
    },
    millimetres: {
        abbrev: "mm"
    },
    yards: {
        abbrev: "yd"
    },
    feet: {
        abbrev: "ft"
    },
    inches: {
        abbrev: "in"
    }
};

/**
 * @desc Configures its {@link Scene}'s measurement unit and mapping between the Real-space and World-space 3D Cartesian coordinate systems.
 *
 *
 * ## Overview
 *
 * * Located at {@link Scene#metrics}.
 * * {@link Metrics#units} configures the Real-space unit type, which is ````"meters"```` by default.
 * * {@link Metrics#scale} configures the number of Real-space units represented by each unit within the World-space 3D coordinate system. This is ````1.0```` by default.
 * * {@link Metrics#origin} configures the 3D Real-space origin, in current Real-space units, at which this {@link Scene}'s World-space coordinate origin sits, This is ````[0,0,0]```` by default.
 *
 * ## Usage
 *
 * Let's load a model using an {@link XKTLoaderPlugin}, then configure the Real-space unit type and the coordinate
 * mapping between the Real-space and World-space 3D coordinate systems.
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * const metrics = viewer.scene.metrics;
 *
 * metrics.units = "meters";
 * metrics.scale = 10.0;
 * metrics.origin = [100.0, 0.0, 200.0];
 * ````
 */
var Metrics = /*@__PURE__*/(function (Component) {
    function Metrics(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._units = "meters";
        this._scale = 1.0;
        this._origin = math.vec3([0, 0, 0]);

        this.units = cfg.units;
        this.scale = cfg.scale;
        this.origin = cfg.origin;
    }

    if ( Component ) Metrics.__proto__ = Component;
    Metrics.prototype = Object.create( Component && Component.prototype );
    Metrics.prototype.constructor = Metrics;

    var prototypeAccessors = { unitsInfo: { configurable: true },units: { configurable: true },scale: { configurable: true },origin: { configurable: true } };

    /**
     * Gets info about the supported Real-space unit types.
     *
     * This will be:
     *
     * ````javascript
     * {
     *      {
     *          meters: {
     *              abbrev: "m"
     *          },
     *          metres: {
     *              abbrev: "m"
     *          },
     *          centimeters: {
     *              abbrev: "cm"
     *          },
     *          centimetres: {
     *              abbrev: "cm"
     *          },
     *          millimeters: {
     *              abbrev: "mm"
     *          },
     *          millimetres: {
     *              abbrev: "mm"
     *          },
     *          yards: {
     *              abbrev: "yd"
     *          },
     *          feet: {
     *              abbrev: "ft"
     *          },
     *          inches: {
     *              abbrev: "in"
     *          }
     *      }
     * }
     * ````
     *
     * @type {*}
     */
    prototypeAccessors.unitsInfo.get = function () {
        return unitsInfo;
    };

    /**
     * Sets the {@link Scene}'s Real-space unit type.
     *
     * Accepted values are ````"meters"````, ````"centimeters"````, ````"millimeters"````, ````"metres"````, ````"centimetres"````, ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
     *
     * @emits ````"units"```` event on change, with the value of this property.
     * @type {String}
     */
    prototypeAccessors.units.set = function (value) {
        if (!value) {
            value = "meters";
        }
        var info = unitsInfo[value];
        if (!info) {
            this.error("Unsupported value for 'units': " + value + " defaulting to 'meters'");
            value = "meters";
        }
        this._units = value;
        this.fire("units", this._units);
    };

    /**
     * Gets the {@link Scene}'s Real-space unit type.
     *
     * @type {String}
     */
    prototypeAccessors.units.get = function () {
        return this._units;
    };

    /**
     * Sets the number of Real-space units represented by each unit of the {@link Scene}'s World-space coordinate system.
     *
     * For example, if {@link Metrics#units} is ````"meters"````, and there are ten meters per World-space coordinate system unit, then ````scale```` would have a value of ````10.0````.
     *
     * @emits ````"scale"```` event on change, with the value of this property.
     * @type {Number}
     */
    prototypeAccessors.scale.set = function (value) {
        value = value || 1;
        if (value <= 0) {
            this.error("scale value should be larger than zero");
            return;
        }
        this._scale = value;
        this.fire("scale", this._scale);
    };

    /**
     * Gets the number of Real-space units represented by each unit of the {@link Scene}'s World-space coordinate system.
     *
     * @type {Number}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the Real-space 3D origin, in Real-space units, at which this {@link Scene}'s World-space coordinate origin ````[0,0,0]```` sits.
     *
     * @emits "origin" event on change, with the value of this property.
     * @type {Number[]}
     */
    prototypeAccessors.origin.set = function (value) {
        if (!value) {
            this._origin[0] = 0;
            this._origin[1] = 0;
            this._origin[2] = 0;
            return;
        }
        this._origin[0] = value[0];
        this._origin[1] = value[1];
        this._origin[2] = value[2];
        this.fire("origin", this._origin);
    };

    /**
     * Gets the 3D Real-space origin, in Real-space units, at which this {@link Scene}'s World-space coordinate origin ````[0,0,0]```` sits.
     *
     * @type {Number[]}
     */
    prototypeAccessors.origin.get = function () {
        return this._origin;
    };

    /**
     * Converts a 3D position from World-space to Real-space.
     *
     * This is equivalent to ````realPos = #origin + (worldPos * #scale)````.
     *
     * @param {Number[]} worldPos World-space 3D position, in World coordinate system units.
     * @param {Number[]} [realPos] Destination for Real-space 3D position.
     * @returns {Number[]} Real-space 3D position, in units indicated by {@link Metrics#units}.
     */
    Metrics.prototype.worldToRealPos = function worldToRealPos (worldPos, realPos) {
        if ( realPos === void 0 ) realPos = math.vec3(3);

        realPos[0] = this._origin[0] + (this._scale * worldPos[0]);
        realPos[1] = this._origin[1] + (this._scale * worldPos[1]);
        realPos[2] = this._origin[2] + (this._scale * worldPos[2]);
    };

    /**
     * Converts a 3D position from Real-space to World-space.
     *
     * This is equivalent to ````worldPos = (worldPos - #origin) / #scale````.
     *
     * @param {Number[]} realPos Real-space 3D position.
     * @param {Number[]} [worldPos] Destination for World-space 3D position.
     * @returns {Number[]} World-space 3D position.
     */
    Metrics.prototype.realToWorldPos = function realToWorldPos (realPos, worldPos) {
        if ( worldPos === void 0 ) worldPos = math.vec3(3);

        worldPos[0] = (realPos[0] - this._origin[0]) / this._scale;
        worldPos[1] = (realPos[1] - this._origin[1]) / this._scale;
        worldPos[2] = (realPos[2] - this._origin[2]) / this._scale;
        return worldPos;
    };

    Object.defineProperties( Metrics.prototype, prototypeAccessors );

    return Metrics;
}(Component));

/**
 * @desc Configures Scalable Ambient Obscurance (SAO) for a {@link Scene}.
 *
 *  <a href="https://xeokit.github.io/xeokit-sdk/examples/#postEffects_SAO_OTCConferenceCenter"><img src="http://xeokit.io/img/docs/SAO/saoEnabledDisabled.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter)]
 *
 * ## Overview
 *
 * SAO approximates [Ambient Occlusion](https://en.wikipedia.org/wiki/Ambient_occlusion) in realtime. It darkens creases, cavities and surfaces
 * that are close to each other, which tend to be occluded from ambient light and appear darker.
 *
 * The animated GIF above shows the effect as we repeatedly enable and disable SAO. When SAO is enabled, we can see darkening
 * in regions such as the corners, and the crevices between stairs. This increases the amount of detail we can see when ambient
 * light is high, or when objects have uniform colors across their surfaces. Run the example to experiment with the various
 * SAO configurations.
 *
 * xeokit's implementation of SAO is based on the paper [Scalable Ambient Obscurance](https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf).
 *
 * ## Caveats
 *
 * Currently, SAO only works with perspective and orthographic projections. Therefore, to use SAO, make sure {@link Camera#projection} is
 * either "perspective" or "ortho".
 *
 * {@link SAO#scale} and {@link SAO#intensity} must be tuned to the distance
 * between {@link Perspective#near} and {@link Perspective#far}, or the distance
 * between {@link Ortho#near} and {@link Ortho#far}, depending on which of those two projections the {@link Camera} is currently
 * using. Use the [live example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter) to get a
 * feel for that.
 *
 * ## Usage
 *
 * In the example below, we'll start by logging a warning message to the console if SAO is not supported by the
 * system.
 *
 *Then we'll enable and configure SAO, position the camera, and configure the near and far perspective and orthographic
 * clipping planes. Finally, we'll use {@link XKTLoaderPlugin} to load the OTC Conference Center model.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * const sao = viewer.scene.sao;
 *
 * if (!sao.supported) {
 *     sao.warn("SAO is not supported on this system - ignoring SAO configs")
 * }
 *
 * sao.enabled = true; // Enable SAO - only works if supported (see above)
 * sao.intensity = 0.15;
 * sao.bias = 0.5;
 * sao.scale = 1.0;
 * sao.minResolution = 0.0;
 * sao.numSamples = 10;
 * sao.kernelRadius = 100;
 * sao.blendCutoff = 0.1;
 *
 * const camera = viewer.scene.camera;
 *
 * camera.eye = [3.69, 5.83, -23.98];
 * camera.look = [84.31, -29.88, -116.21];
 * camera.up = [0.18, 0.96, -0.21];
 *
 * camera.perspective.near = 0.1;
 * camera.perspective.far = 2000.0;
 *
 * camera.ortho.near = 0.1;
 * camera.ortho.far = 2000.0;
 * camera.projection = "perspective";
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/OTCConferenceCenter.xkt"
 *     edges: true
 * });
 * ````
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#postEeffects_SAO_OTCConferenceCenter)]
 *
 * ## Efficiency
 *
 * SAO can incur some rendering overhead, especially on objects that are viewed close to the camera. For this reason,
 * it's recommended to use a low value for {@link SAO#kernelRadius}.  A low radius will sample pixels that are close
 * to the source pixel, which will allow the GPU to efficiently cache those pixels. When {@link Camera#projection} is "perspective",
 * objects near to the viewpoint will use larger radii than farther pixels. Therefore, computing  SAO for close objects
 * is more expensive than for objects far away, that occupy fewer pixels on the canvas.
 *
 * ## Selectively enabling SAO for models
 *
 * When loading multiple models into a Scene, we sometimes only want SAO on the models that are actually going to
 * show it, such as the architecture or structure, and not show SAO on models that won't show it well, such as the
 * electrical wiring, or plumbing.
 *
 * To illustrate, lets load some of the models for the West Riverside Hospital. We'll enable SAO on the structure model,
 * but disable it on the electrical and plumbing.
 *
 * This will only apply SAO to those models if {@link SAO#supported} and {@link SAO#enabled} are both true.
 *
 * Note, by the way, how we load the models in sequence. Since XKTLoaderPlugin uses scratch memory as part of its loading
 * process, this allows the plugin to reuse that same memory across multiple loads, instead of having to create multiple
 * pools of scratch memory.
 *
 * ````javascript
 * const structure = xktLoader.load({
 *      id: "structure",
 *      src: "./models/xkt/WestRiverSideHospital/structure.xkt"
 *      edges: true,
 *      saoEnabled: true
 *  });
 *
 *  structure.on("loaded", () => {
 *
 *      const electrical = xktLoader.load({
 *          id: "electrical",
 *          src: "./models/xkt/WestRiverSideHospital/electrical.xkt",
 *          edges: true
 *      });
 *
 *      electrical.on("loaded", () => {
 *
 *          const plumbing = xktLoader.load({
 *              id: "plumbing",
 *              src: "./models/xkt/WestRiverSideHospital/plumbing.xkt",
 *              edges: true
 *          });
 *      });
 * });
 * ````
 *
 * ## Disabling SAO while camera is moving
 *
 * For smoother interaction with large models on low-power hardware, we can disable SAO while the {@link Camera} is moving:
 *
 * ````javascript
 * const timeoutDuration = 150; // Milliseconds
 * var timer = timeoutDuration;
 * var saoDisabled = false;
 *
 * const onCameraMatrix = scene.camera.on("matrix", () => {
 *     timer = timeoutDuration;
 *     if (!saoDisabled) {
 *         scene.sao.enabled = false;
 *         saoDisabled = true;
 *     }
 * });
 *
 * const onSceneTick = scene.on("tick", (tickEvent) => {
 *     if (!saoDisabled) {
 *         return;
 *     }
 *     timer -= tickEvent.deltaTime; // Milliseconds
 *     if (timer <= 0) {
 *         if (saoDisabled) {
 *             scene.sao.enabled = true;
 *             saoDisabled = false;
 *         }
 *     }
 * });
 * ````
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#techniques_nonInteractiveQuality)]
 */
var SAO = /*@__PURE__*/(function (Component) {
    function SAO(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        var ua = navigator.userAgent.match(/(opera|chrome|safari|firefox|msie|mobile)\/?\s*(\.?\d+(\.\d+)*)/i);
        var isSafari = (ua && ua[1].toLowerCase() === "safari");

        this._supported = (!isSafari) &&
            WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_standard_derivatives"]; // For computing normals in SAO fragment shader

        this.enabled = cfg.enabled;
        this.kernelRadius = cfg.kernelRadius;
        this.intensity = cfg.intensity;
        this.bias = cfg.bias;
        this.scale = cfg.scale;
        this.minResolution = cfg.minResolution;
        this.numSamples = cfg.numSamples;
        this.blur = cfg.blur;
        this.blendCutoff = cfg.blendCutoff;
        this.blendFactor = cfg.blendFactor;
    }

    if ( Component ) SAO.__proto__ = Component;
    SAO.prototype = Object.create( Component && Component.prototype );
    SAO.prototype.constructor = SAO;

    var prototypeAccessors = { supported: { configurable: true },enabled: { configurable: true },possible: { configurable: true },active: { configurable: true },kernelRadius: { configurable: true },intensity: { configurable: true },bias: { configurable: true },scale: { configurable: true },minResolution: { configurable: true },numSamples: { configurable: true },blur: { configurable: true },blendCutoff: { configurable: true },blendFactor: { configurable: true } };

    /**
     * Gets whether or not SAO is supported by this browser and GPU.
     *
     * Even when enabled, SAO will only work if supported.
     *
     * @type {Boolean}
     */
    prototypeAccessors.supported.get = function () {
        return this._supported;
    };

    /**
     * Sets whether SAO is enabled for the {@link Scene}.
     *
     * Even when enabled, SAO will only work if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.enabled.set = function (value) {
        value = !!value;
        if (this._enabled === value) {
            return;
        }
        this._enabled = value;
        this.glRedraw();
    };

    /**
     * Gets whether SAO is enabled for the {@link Scene}.
     *
     * Even when enabled, SAO will only apply if supported.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.enabled.get = function () {
        return this._enabled;
    };

    /**
     * Returns true if SAO is currently possible, where it is supported, enabled, and the current scene state is compatible.
     * Called internally by renderer logic.
     * @private
     * @returns {boolean}
     */
    prototypeAccessors.possible.get = function () {
        if (!this._supported) {
            return false;
        }
        if (!this._enabled) {
            return false;
        }
        var projection = this.scene.camera.projection;
        if (projection === "customProjection") {
            return false;
        }
        if (projection === "frustum") {
            return false;
        }
        return true;
    };

    /**
     * @private
     * @returns {boolean|*}
     */
    prototypeAccessors.active.get = function () {
        return this._active;
    };

    /**
     * Sets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.kernelRadius.set = function (value) {
        if (value === undefined || value === null) {
            value = 100.0;
        }
        if (this._kernelRadius === value) {
            return;
        }
        this._kernelRadius = value;
        this.glRedraw();
    };

    /**
     * Gets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.kernelRadius.get = function () {
        return this._kernelRadius;
    };

    /**
     * Sets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     *
     * @type {Number}
     */
    prototypeAccessors.intensity.set = function (value) {
        if (value === undefined || value === null) {
            value = 0.15;
        }
        if (this._intensity === value) {
            return;
        }
        this._intensity = value;
        this.glRedraw();
    };

    /**
     * Gets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     *
     * @type {Number}
     */
    prototypeAccessors.intensity.get = function () {
        return this._intensity;
    };

    /**
     * Sets the SAO bias.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */
    prototypeAccessors.bias.set = function (value) {
        if (value === undefined || value === null) {
            value = 0.5;
        }
        if (this._bias === value) {
            return;
        }
        this._bias = value;
        this.glRedraw();
    };

    /**
     * Gets the SAO bias.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */
    prototypeAccessors.bias.get = function () {
        return this._bias;
    };

    /**
     * Sets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.scale.set = function (value) {
        if (value === undefined || value === null) {
            value = 1.0;
        }
        if (this._scale === value) {
            return;
        }
        this._scale = value;
        this.glRedraw();
    };

    /**
     * Gets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.minResolution.set = function (value) {
        if (value === undefined || value === null) {
            value = 0.0;
        }
        if (this._minResolution === value) {
            return;
        }
        this._minResolution = value;
        this.glRedraw();
    };

    /**
     * Gets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.minResolution.get = function () {
        return this._minResolution;
    };

    /**
     * Sets the number of SAO samples.
     *
     * Default value is ````10````.
     *
     * Update this sparingly, since it causes a shader recompile.
     *
     * @type {Number}
     */
    prototypeAccessors.numSamples.set = function (value) {
        if (value === undefined || value === null) {
            value = 10;
        }
        if (this._numSamples === value) {
            return;
        }
        this._numSamples = value;
        this.glRedraw();
    };

    /**
     * Gets the number of SAO samples.
     *
     * Default value is ````10````.
     *
     * @type {Number}
     */
    prototypeAccessors.numSamples.get = function () {
        return this._numSamples;
    };

    /**
     * Sets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.blur.set = function (value) {
        value = (value !== false);
        if (this._blur === value) {
            return;
        }
        this._blur = value;
        this.glRedraw();
    };

    /**
     * Gets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.blur.get = function () {
        return this._blur;
    };

    /**
     * Sets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */
    prototypeAccessors.blendCutoff.set = function (value) {
        if (value === undefined || value === null) {
            value = 0.3;
        }
        if (this._blendCutoff === value) {
            return;
        }
        this._blendCutoff = value;
        this.glRedraw();
    };

    /**
     * Gets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */
    prototypeAccessors.blendCutoff.get = function () {
        return this._blendCutoff;
    };

    /**
     * Sets the SAO blend factor.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */
    prototypeAccessors.blendFactor.set = function (value) {
        if (value === undefined || value === null) {
            value = 1.0;
        }
        if (this._blendFactor === value) {
            return;
        }
        this._blendFactor = value;
        this.glRedraw();
    };

    /**
     * Gets the SAO blend scale.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     *
     * @type {Number}
     */
    prototypeAccessors.blendFactor.get = function () {
        return this._blendFactor;
    };

    /**
     * Destroys this component.
     */
    SAO.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( SAO.prototype, prototypeAccessors );

    return SAO;
}(Component));

var PRESETS$1 = {
    "default": {
        pointSize: 4,
        roundPoints: true,
        perspectivePoints: true
    },
    "square": {
        pointSize: 4,
        roundPoints: false,
        perspectivePoints: true
    },
    "round": {
        pointSize: 4,
        roundPoints: true,
        perspectivePoints: true
    }
};

/**
 * @desc Configures the size and shape of "points" geometry primitives.
 *
 * * Located at {@link Scene#pointsMaterial}.
 * * Supports round and square points.
 * * Optional perspective point scaling.
 * * Globally configures "points" primitives for all {@link PerformanceModel}s.
 *
 * ## Usage
 *
 * In the example below, we'll customize the {@link Scene}'s global ````PointsMaterial````, then use
 * an {@link XKTLoaderPlugin} to load a model containing a point cloud.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_PointsMaterial)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * viewer.scene.pointsMaterial.pointSize = 2;
 * viewer.scene.pointsMaterial.roundPoints = true;
 * viewer.scene.pointsMaterial.perspectivePoints = true;
 * viewer.scene.pointsMaterial.minPerspectivePointSize = 1;
 * viewer.scene.pointsMaterial.maxPerspectivePointSize = 6;
 * viewer.scene.pointsMaterial.filterIntensity = true;
 * viewer.scene.pointsMaterial.minIntensity = 0.0;
 * viewer.scene.pointsMaterial.maxIntensity = 1.0;
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "../assets/models/xkt/MAP-PointCloud.xkt"
 * });
 * ````
 */
var PointsMaterial = /*@__PURE__*/(function (Material) {
    function PointsMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "PointsMaterial",
            pointSize: null,
            roundPoints: null,
            perspectivePoints: null,
            minPerspectivePointSize: null,
            maxPerspectivePointSize: null,
            filterIntensity: null,
            minIntensity: null,
            maxIntensity: null
        });

        if (cfg.preset) { // Apply preset then override with configs where provided
            this.preset = cfg.preset;
            if (cfg.pointSize !== undefined) {
                this.pointSize = cfg.pointSize;
            }
            if (cfg.roundPoints !== undefined) {
                this.roundPoints = cfg.roundPoints;
            }
            if (cfg.perspectivePoints !== undefined) {
                this.perspectivePoints = cfg.perspectivePoints;
            }
            if (cfg.minPerspectivePointSize !== undefined) {
                this.minPerspectivePointSize = cfg.minPerspectivePointSize;
            }
            if (cfg.maxPerspectivePointSize !== undefined) {
                this.maxPerspectivePointSize = cfg.minPerspectivePointSize;
            }
        } else {
            this._preset = "default";
            this.pointSize = cfg.pointSize;
            this.roundPoints = cfg.roundPoints;

            this.perspectivePoints = cfg.perspectivePoints;
            this.minPerspectivePointSize = cfg.minPerspectivePointSize;
            this.maxPerspectivePointSize = cfg.maxPerspectivePointSize;
        }

        this.filterIntensity = cfg.filterIntensity;
        this.minIntensity = cfg.minIntensity;
        this.maxIntensity = cfg.maxIntensity;
    }

    if ( Material ) PointsMaterial.__proto__ = Material;
    PointsMaterial.prototype = Object.create( Material && Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;

    var prototypeAccessors = { type: { configurable: true },presets: { configurable: true },pointSize: { configurable: true },roundPoints: { configurable: true },perspectivePoints: { configurable: true },minPerspectivePointSize: { configurable: true },maxPerspectivePointSize: { configurable: true },filterIntensity: { configurable: true },minIntensity: { configurable: true },maxIntensity: { configurable: true },preset: { configurable: true },hash: { configurable: true } };

    /**
     * Sets point size.
     *
     * Default value is ````2.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.type.get = function () {
        return "PointsMaterial";
    };

    /**
     * Gets available PointsMaterial presets.
     *
     * @type {Object}
     */
    prototypeAccessors.presets.get = function () {
        return PRESETS$1;
    };

    prototypeAccessors.pointSize.set = function (value) {
        this._state.pointSize = value || 2.0;
        this.glRedraw();
    };

    /**
     * Gets point size.
     *
     * Default value is ````2.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.get = function () {
        return this._state.pointSize;
    };


    /**
     * Sets if points are round or square.
     *
     * Default is ````true```` to set points round.
     *
     * @type {Boolean}
     */
    prototypeAccessors.roundPoints.set = function (value) {
        value = (value !== false);
        if (this._state.roundPoints === value) {
            return;
        }
        this._state.roundPoints = value;
        this.scene._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets if points are round or square.
     *
     * Default is ````true```` to set points round.
     *
     * @type {Boolean}
     */
    prototypeAccessors.roundPoints.get = function () {
        return this._state.roundPoints;
    };

    /**
     * Sets if rendered point size reduces with distance when {@link Camera#projection} is set to ````"perspective"````.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.perspectivePoints.set = function (value) {
        value = (value !== false);
        if (this._state.perspectivePoints === value) {
            return;
        }
        this._state.perspectivePoints = value;
        this.scene._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets if rendered point size reduces with distance when {@link Camera#projection} is set to "perspective".
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.perspectivePoints.get = function () {
        return this._state.perspectivePoints;
    };

    /**
     * Sets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.minPerspectivePointSize.set = function (value) {
        this._state.minPerspectivePointSize = value || 1.0;
        this.scene._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.minPerspectivePointSize.get = function () {
        return this._state.minPerspectivePointSize;
    };

    /**
     * Sets the maximum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.maxPerspectivePointSize.set = function (value) {
        this._state.maxPerspectivePointSize = value || 6;
        this.scene._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets the maximum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.maxPerspectivePointSize.get = function () {
        return this._state.maxPerspectivePointSize;
    };

    /**
     * Sets if rendered point size reduces with distance when {@link Camera#projection} is set to ````"perspective"````.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.filterIntensity.set = function (value) {
        value = (value !== false);
        if (this._state.filterIntensity === value) {
            return;
        }
        this._state.filterIntensity = value;
        this.scene._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets if rendered point size reduces with distance when {@link Camera#projection} is set to "perspective".
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.filterIntensity.get = function () {
        return this._state.filterIntensity;
    };

    /**
     * Sets the minimum rendered size of points when {@link PointsMaterial#perspectivePoints} is ````true````.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.minIntensity.set = function (value) {
        this._state.minIntensity = (value !== undefined && value !== null) ? value: 0.0;
        this.glRedraw();
    };

    /**
     * Gets the minimum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.minIntensity.get = function () {
        return this._state.minIntensity;
    };

    /**
     * Sets the maximum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.maxIntensity.set = function (value) {
        this._state.maxIntensity = (value !== undefined && value !== null) ? value: 1.0;
        this.glRedraw();
    };

    /**
     * Gets the maximum rendered size of points when {@link PointsMaterial#filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.maxIntensity.get = function () {
        return this._state.maxIntensity;
    };

    /**
     * Selects a preset ````PointsMaterial```` configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.set = function (value) {
        value = value || "default";
        if (this._preset === value) {
            return;
        }
        var preset = PRESETS$1[value];
        if (!preset) {
            this.error("unsupported preset: '" + value + "' - supported values are " + Object.keys(PRESETS$1).join(", "));
            return;
        }
        this.pointSize = preset.pointSize;
        this.roundPoints = preset.roundPoints;
        this.perspectivePoints = preset.perspectivePoints;
        this.minPerspectivePointSize = preset.minPerspectivePointSize;
        this.maxPerspectivePointSize = preset.maxPerspectivePointSize;
        this._preset = value;
    };

    /**
     * The current preset ````PointsMaterial```` configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.get = function () {
        return this._preset;
    };

    /**
     * @private
     * @return {string}
     */
    prototypeAccessors.hash.get = function () {
        return [
            this.pointSize,
            this.roundPoints,
            this.perspectivePoints,
            this.minPerspectivePointSize,
            this.maxPerspectivePointSize,
            this.filterIntensity
        ].join((";"));
    };

    /**
     * Destroys this ````PointsMaterial````.
     */
    PointsMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( PointsMaterial.prototype, prototypeAccessors );

    return PointsMaterial;
}(Material));

var PRESETS = {
    "default": {
        lineWidth: 1
    },
    "thick": {
        lineWidth: 2
    },
    "thicker": {
        lineWidth: 4
    }
};

/**
 * @desc Configures the shape of "lines" geometry primitives.
 *
 * * Located at {@link Scene#linesMaterial}.
 * * Globally configures "lines" primitives for all {@link PerformanceModel}s.
 *
 * ## Usage
 *
 * In the example below, we'll customize the {@link Scene}'s global ````LinesMaterial````, then use
 * an {@link XKTLoaderPlugin} to load a model containing line segments.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_LinesMaterial)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * viewer.scene.linesMaterial.lineWidth = 3;
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Duplex.ifc.xkt"
 * });
 * ````
 */
var LinesMaterial = /*@__PURE__*/(function (Material) {
    function LinesMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "LinesMaterial",
            lineWidth: null
        });

        if (cfg.preset) { // Apply preset then override with configs where provided
            this.preset = cfg.preset;
            if (cfg.lineWidth !== undefined) {
                this.lineWidth = cfg.lineWidth;
            }
        } else {
            this._preset = "default";
            this.lineWidth = cfg.lineWidth;
        }
    }

    if ( Material ) LinesMaterial.__proto__ = Material;
    LinesMaterial.prototype = Object.create( Material && Material.prototype );
    LinesMaterial.prototype.constructor = LinesMaterial;

    var prototypeAccessors = { type: { configurable: true },presets: { configurable: true },lineWidth: { configurable: true },preset: { configurable: true },hash: { configurable: true } };

    /**
     * Sets line width.
     *
     * Default value is ````1```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.type.get = function () {
        return "LinesMaterial";
    };

    /**
     * Gets available LinesMaterial presets.
     *
     * @type {Object}
     */
    prototypeAccessors.presets.get = function () {
        return PRESETS;
    };

    prototypeAccessors.lineWidth.set = function (value) {
        this._state.lineWidth = value || 1;
        this.glRedraw();
    };

    /**
     * Gets the line width.
     *
     * Default value is ````1```` pixels.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.get = function () {
        return this._state.lineWidth;
    };

    /**
     * Selects a preset LinesMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.set = function (value) {
        value = value || "default";
        if (this._preset === value) {
            return;
        }
        var preset = PRESETS[value];
        if (!preset) {
            this.error("unsupported preset: '" + value + "' - supported values are " + Object.keys(PRESETS).join(", "));
            return;
        }
        this.lineWidth = preset.lineWidth;
        this._preset = value;
    };

    /**
     * The current preset LinesMaterial configuration.
     *
     * Default value is ````"default"````.
     *
     * @type {String}
     */
    prototypeAccessors.preset.get = function () {
        return this._preset;
    };

    /**
     * @private
     * @return {string}
     */
    prototypeAccessors.hash.get = function () {
        return ["" + this.lineWidth].join((";"));
    };

    /**
     * Destroys this LinesMaterial.
     */
    LinesMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( LinesMaterial.prototype, prototypeAccessors );

    return LinesMaterial;
}(Material));

// Cached vars to avoid garbage collection

function getEntityIDMap(scene, entityIds) {
    var map = {};
    var entityId;
    var entity;
    for (var i = 0, len = entityIds.length; i < len; i++) {
        entityId = entityIds[i];
        entity = scene.component[entityId];
        if (!entity) {
            scene.warn("pick(): Component not found: " + entityId);
            continue;
        }
        if (!entity.isEntity) {
            scene.warn("pick(): Component is not an Entity: " + entityId);
            continue;
        }
        map[entityId] = true;
    }
    return map;
}

/**
 * Fired whenever a debug message is logged on a component within this Scene.
 * @event log
 * @param {String} value The debug message
 */

/**
 * Fired whenever an error is logged on a component within this Scene.
 * @event error
 * @param {String} value The error message
 */

/**
 * Fired whenever a warning is logged on a component within this Scene.
 * @event warn
 * @param {String} value The warning message
 */

/**
 * @desc Contains the components that comprise a 3D scene.
 *
 * * A {@link Viewer} has a single Scene, which it provides in {@link Viewer#scene}.
 * * Plugins like {@link AxisGizmoPlugin} also have their own private Scenes.
 * * Each Scene has a corresponding {@link MetaScene}, which the Viewer provides in {@link Viewer#metaScene}.
 *
 * ## Getting a Viewer's Scene
 *
 * ````javascript
 * var scene = viewer.scene;
 * ````
 *
 * ## Creating and accessing Scene components
 *
 * As a brief introduction to creating Scene components, we'll create a {@link Mesh} that has a
 * {@link buildTorusGeometry} and a {@link PhongMaterial}:
 *
 * ````javascript
 * var teapotMesh = new Mesh(scene, {
 *     id: "myMesh",                               // <<---------- ID automatically generated if not provided
 *     geometry: new TorusGeometry(scene),
 *     material: new PhongMaterial(scene, {
 *         id: "myMaterial",
 *         diffuse: [0.2, 0.2, 1.0]
 *     })
 * });
 *
 * teapotMesh.scene.camera.eye = [45, 45, 45];
 * ````
 *
 * Find components by ID in their Scene's {@link Scene#components} map:
 *
 * ````javascript
 * var teapotMesh = scene.components["myMesh"];
 * teapotMesh.visible = false;
 *
 * var teapotMaterial = scene.components["myMaterial"];
 * teapotMaterial.diffuse = [1,0,0]; // Change to red
 * ````
 *
 * A Scene also has a map of component instances for each {@link Component} subtype:
 *
 * ````javascript
 * var meshes = scene.types["Mesh"];
 * var teapotMesh = meshes["myMesh"];
 * teapotMesh.xrayed = true;
 *
 * var phongMaterials = scene.types["PhongMaterial"];
 * var teapotMaterial = phongMaterials["myMaterial"];
 * teapotMaterial.diffuse = [0,1,0]; // Change to green
 * ````
 *
 * See {@link Node}, {@link Node} and {@link Model} for how to create and access more sophisticated content.
 *
 * ## Controlling the camera
 *
 * Use the Scene's {@link Camera} to control the current viewpoint and projection:
 *
 * ````javascript
 * var camera = myScene.camera;
 *
 * camera.eye = [-10,0,0];
 * camera.look = [-10,0,0];
 * camera.up = [0,1,0];
 *
 * camera.projection = "perspective";
 * camera.perspective.fov = 45;
 * //...
 * ````
 *
 * ## Managing the canvas
 *
 * The Scene's {@link Canvas} component provides various conveniences relevant to the WebGL canvas, such
 * as firing resize events etc:
 *
 * ````javascript
 * var canvas = scene.canvas;
 *
 * canvas.on("boundary", function(boundary) {
 *     //...
 * });
 * ````
 *
 * ## Picking
 *
 * Use {@link Scene#pick} to pick and raycast entites.
 *
 * For example, to pick a point on the surface of the closest entity at the given canvas coordinates:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      pickSurface: true,
 *      canvasPos: [23, 131]
 * });
 *
 * if (pickResult) { // Picked an entity
 *
 *     var entity = pickResult.entity;
 *
 *     var primitive = pickResult.primitive; // Type of primitive that was picked, usually "triangles"
 *     var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Mesh's Geometry's indices array
 *     var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
 *     var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
 *     var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
 *     var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
 *     var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
 *     var normal = pickResult.normal; // Float64Array containing the interpolated normal vector at the picked position on the triangle
 *     var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
 * }
 * ````
 *
 * ## Pick masking
 *
 * We can use {@link Scene#pick}'s ````includeEntities```` and ````excludeEntities````  options to mask which {@link Mesh}es we attempt to pick.
 *
 * This is useful for picking through things, to pick only the Entities of interest.
 *
 * To pick only Entities ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through any other Entities that are
 * in the way, as if they weren't there:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      canvasPos: [23, 131],
 *      includeEntities: ["gearbox#77.0", "gearbox#79.0"]
 * });
 *
 * if (pickResult) {
 *       // Entity will always be either "gearbox#77.0" or "gearbox#79.0"
 *       var entity = pickResult.entity;
 * }
 * ````
 *
 * To pick any pickable Entity, except for ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through those
 * Entities if they happen to be in the way:
 *
 * ````javascript
 * var pickResult = scene.pick({
 *      canvasPos: [23, 131],
 *      excludeEntities: ["gearbox#77.0", "gearbox#79.0"]
 * });
 *
 * if (pickResult) {
 *       // Entity will never be "gearbox#77.0" or "gearbox#79.0"
 *       var entity = pickResult.entity;
 * }
 * ````
 *
 * See {@link Scene#pick} for more info on picking.
 *
 * ## Querying and tracking boundaries
 *
 * Getting a Scene's World-space axis-aligned boundary (AABB):
 *
 * ````javascript
 * var aabb = scene.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 * ````
 *
 * Subscribing to updates to the AABB, which occur whenever {@link Entity}s are transformed, their
 * {@link ReadableGeometry}s have been updated, or the {@link Camera} has moved:
 *
 * ````javascript
 * scene.on("boundary", function() {
 *      var aabb = scene.aabb;
 * });
 * ````
 *
 * Getting the AABB of the {@link Entity}s with the given IDs:
 *
 * ````JavaScript
 * scene.getAABB(); // Gets collective boundary of all Entities in the scene
 * scene.getAABB("saw"); // Gets boundary of an Object
 * scene.getAABB(["saw", "gearbox"]); // Gets collective boundary of two Objects
 * ````
 *
 * See {@link Scene#getAABB} and {@link Entity} for more info on querying and tracking boundaries.
 *
 * ## Managing the viewport
 *
 * The Scene's {@link Viewport} component manages the WebGL viewport:
 *
 * ````javascript
 * var viewport = scene.viewport
 * viewport.boundary = [0, 0, 500, 400];;
 * ````
 *
 * ## Controlling rendering
 *
 * You can configure a Scene to perform multiple "passes" (renders) per frame. This is useful when we want to render the
 * scene to multiple viewports, such as for stereo effects.
 *
 * In the example, below, we'll configure the Scene to render twice on each frame, each time to different viewport. We'll do this
 * with a callback that intercepts the Scene before each render and sets its {@link Viewport} to a
 * different portion of the canvas. By default, the Scene will clear the canvas only before the first render, allowing the
 * two views to be shown on the canvas at the same time.
 *
 * ````Javascript
 * var viewport = scene.viewport;
 *
 * // Configure Scene to render twice for each frame
 * scene.passes = 2; // Default is 1
 * scene.clearEachPass = false; // Default is false
 *
 * // Render to a separate viewport on each render
 *
 * var viewport = scene.viewport;
 * viewport.autoBoundary = false;
 *
 * scene.on("rendering", function (e) {
 *      switch (e.pass) {
 *          case 0:
 *              viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
 *              break;
 *
 *          case 1:
 *              viewport.boundary = [200, 0, 200, 200];
 *              break;
 *      }
 * });
 *
 * // We can also intercept the Scene after each render,
 * // (though we're not using this for anything here)
 * scene.on("rendered", function (e) {
 *      switch (e.pass) {
 *          case 0:
 *              break;
 *
 *          case 1:
 *              break;
 *      }
 * });
 * ````
 *
 * ## Gamma correction
 *
 * Within its shaders, xeokit performs shading calculations in linear space.
 *
 * By default, the Scene expects color textures (eg. {@link PhongMaterial#diffuseMap},
 * {@link MetallicMaterial#baseColorMap} and {@link SpecularMaterial#diffuseMap}) to
 * be in pre-multipled gamma space, so will convert those to linear space before they are used in shaders. Other textures are
 * always expected to be in linear space.
 *
 * By default, the Scene will also gamma-correct its rendered output.
 *
 * You can configure the Scene to expect all those color textures to be linear space, so that it does not gamma-correct them:
 *
 * ````javascript
 * scene.gammaInput = false;
 * ````
 *
 * You would still need to gamma-correct the output, though, if it's going straight to the canvas, so normally we would
 * leave that enabled:
 *
 * ````javascript
 * scene.gammaOutput = true;
 * ````
 *
 * See {@link Texture} for more information on texture encoding and gamma.
 *
 * @class Scene
 */
var Scene = /*@__PURE__*/(function (Component) {
    function Scene(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, null, cfg);

        var canvas = cfg.canvasElement || document.getElementById(cfg.canvasId);

        if (!(canvas instanceof HTMLCanvasElement)) {
            throw "Mandatory config expected: valid canvasId or canvasElement";
        }

        var transparent = (!!cfg.transparent);
        var alphaDepthMask = (!!cfg.alphaDepthMask);

        this._aabbDirty = true;

        /**
         * The {@link Viewer} this Scene belongs to.
         * @type {Viewer}
         */
        this.viewer = viewer;

        /** Decremented each frame, triggers occlusion test for occludable {@link Marker}s when zero.
         * @private
         * @type {number}
         */
        this.occlusionTestCountdown = 0;

        /**
         The number of models currently loading.

         @property loading
         @final
         @type {Number}
         */
        this.loading = 0;

        /**
         The epoch time (in milliseconds since 1970) when this Scene was instantiated.

         @property timeCreated
         @final
         @type {Number}
         */
        this.startTime = (new Date()).getTime();

        /**
         * Map of {@link Entity}s that represent models.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id} when {@link Entity#isModel} is ````true````.
         *
         * @property models
         * @final
         * @type {{String:Entity}}
         */
        this.models = {};

        /**
         * Map of {@link Entity}s that represents objects.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id} when {@link Entity#isObject} is ````true````.
         *
         * @property objects
         * @final
         * @type {{String:Entity}}
         */
        this.objects = {};
        this._numObjects = 0;

        /**
         * Map of currently visible {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````, and is visible when {@link Entity#visible} is true.
         *
         * @property visibleObjects
         * @final
         * @type {{String:Object}}
         */
        this.visibleObjects = {};
        this._numVisibleObjects = 0;

        /**
         * Map of currently xrayed {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````, and is xrayed when {@link Entity#xrayed} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property xrayedObjects
         * @final
         * @type {{String:Object}}
         */
        this.xrayedObjects = {};
        this._numXRayedObjects = 0;

        /**
         * Map of currently highlighted {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true```` is true, and is highlighted when {@link Entity#highlighted} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property highlightedObjects
         * @final
         * @type {{String:Object}}
         */
        this.highlightedObjects = {};
        this._numHighlightedObjects = 0;

        /**
         * Map of currently selected {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is true, and is selected while {@link Entity#selected} is true.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property selectedObjects
         * @final
         * @type {{String:Object}}
         */
        this.selectedObjects = {};
        this._numSelectedObjects = 0;

        /**
         * Map of currently colorized {@link Entity}s that represent objects.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property colorizedObjects
         * @final
         * @type {{String:Object}}
         */
        this.colorizedObjects = {};
        this._numColorizedObjects = 0;

        /**
         * Map of {@link Entity}s that represent objects whose opacity was updated.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property opacityObjects
         * @final
         * @type {{String:Object}}
         */
        this.opacityObjects = {};
        this._numOpacityObjects = 0;

        /**
         * Map of {@link Entity}s that represent objects whose {@link Entity#offset}s were updated.
         *
         * An Entity represents an object if {@link Entity#isObject} is ````true````.
         *
         * Each {@link Entity} is mapped here by {@link Entity#id}.
         *
         * @property offsetObjects
         * @final
         * @type {{String:Object}}
         */
        this.offsetObjects = {};
        this._numOffsetObjects = 0;

        // Cached ID arrays, lazy-rebuilt as needed when stale after map updates

        /**
         Lazy-regenerated ID lists.
         */
        this._modelIds = null;
        this._objectIds = null;
        this._visibleObjectIds = null;
        this._xrayedObjectIds = null;
        this._highlightedObjectIds = null;
        this._selectedObjectIds = null;
        this._colorizedObjectIds = null;
        this._opacityObjectIds = null;
        this._offsetObjectIds = null;

        this._collidables = {}; // Components that contribute to the Scene AABB
        this._compilables = {}; // Components that require shader compilation

        this._needRecompile = false;

        /**
         * For each {@link Component} type, a map of IDs to {@link Component} instances of that type.
         *
         * @type {{String:{String:Component}}}
         */
        this.types = {};

        /**
         * The {@link Component}s within this Scene, each mapped to its {@link Component#id}.
         *
         * *@type {{String:Component}}
         */
        this.components = {};

        /**
         * The {@link SectionPlane}s in this Scene, each mapped to its {@link SectionPlane#id}.
         *
         * @type {{String:SectionPlane}}
         */
        this.sectionPlanes = {};

        /**
         * The {@link Light}s in this Scene, each mapped to its {@link Light#id}.
         *
         * @type {{String:Light}}
         */
        this.lights = {};

        /**
         * The {@link LightMap}s in this Scene, each mapped to its {@link LightMap#id}.
         *
         * @type {{String:LightMap}}
         */
        this.lightMaps = {};

        /**
         * The {@link ReflectionMap}s in this Scene, each mapped to its {@link ReflectionMap#id}.
         *
         * @type {{String:ReflectionMap}}
         */
        this.reflectionMaps = {};

        /**
         * The real world offset for this Scene
         *
         * @type {Number[]}
         */
        this.realWorldOffset = cfg.realWorldOffset || new Float64Array([0, 0, 0]);

        /**
         * Manages the HTML5 canvas for this Scene.
         *
         * @type {Canvas}
         */
        this.canvas = new Canvas(this, {
            dontClear: true, // Never destroy this component with Scene#clear();
            canvas: canvas,
            spinnerElementId: cfg.spinnerElementId,
            transparent: transparent,
            webgl2: cfg.webgl2 !== false,
            contextAttr: cfg.contextAttr || {},
            backgroundColor: cfg.backgroundColor,
            backgroundColorFromAmbientLight: cfg.backgroundColorFromAmbientLight,
            premultipliedAlpha: cfg.premultipliedAlpha
        });

        this.canvas.on("boundary", function () {
            this$1.glRedraw();
        });

        this.canvas.on("webglContextFailed", function () {
            alert("xeokit failed to find WebGL!");
        });

        this._renderer = new Renderer(this, {
            transparent: transparent,
            alphaDepthMask: alphaDepthMask
        });

        this._sectionPlanesState = new (function () {

            this.sectionPlanes = [];

            this.clippingCaps = false;

            var hash = null;

            this.getHash = function () {
                if (hash) {
                    return hash;
                }
                var sectionPlanes = this.sectionPlanes;
                if (sectionPlanes.length === 0) {
                    return this.hash = ";";
                }

                var hashParts = [];
                for (var i = 0, len = sectionPlanes.length; i < len; i++) {
                    sectionPlanes[i];
                    hashParts.push("cp");
                }
                hashParts.push(";");
                hash = hashParts.join("");
                return hash;
            };

            this.addSectionPlane = function (sectionPlane) {
                this.sectionPlanes.push(sectionPlane);
                hash = null;
            };

            this.removeSectionPlane = function (sectionPlane) {
                for (var i = 0, len = this.sectionPlanes.length; i < len; i++) {
                    if (this.sectionPlanes[i].id === sectionPlane.id) {
                        this.sectionPlanes.splice(i, 1);
                        hash = null;
                        return;
                    }
                }
            };
        })();

        this._lightsState = new (function () {

            var DEFAULT_AMBIENT = math.vec4([0, 0, 0, 0]);
            var ambientColorIntensity = math.vec4();

            this.lights = [];
            this.reflectionMaps = [];
            this.lightMaps = [];

            var hash = null;
            var ambientLight = null;

            this.getHash = function () {
                if (hash) {
                    return hash;
                }
                var hashParts = [];
                var lights = this.lights;
                var light;
                for (var i = 0, len = lights.length; i < len; i++) {
                    light = lights[i];
                    hashParts.push("/");
                    hashParts.push(light.type);
                    hashParts.push((light.space === "world") ? "w" : "v");
                    if (light.castsShadow) {
                        hashParts.push("sh");
                    }
                }
                if (this.lightMaps.length > 0) {
                    hashParts.push("/lm");
                }
                if (this.reflectionMaps.length > 0) {
                    hashParts.push("/rm");
                }
                hashParts.push(";");
                hash = hashParts.join("");
                return hash;
            };

            this.addLight = function (state) {
                this.lights.push(state);
                ambientLight = null;
                hash = null;
            };

            this.removeLight = function (state) {
                for (var i = 0, len = this.lights.length; i < len; i++) {
                    var light = this.lights[i];
                    if (light.id === state.id) {
                        this.lights.splice(i, 1);
                        if (ambientLight && ambientLight.id === state.id) {
                            ambientLight = null;
                        }
                        hash = null;
                        return;
                    }
                }
            };

            this.addReflectionMap = function (state) {
                this.reflectionMaps.push(state);
                hash = null;
            };

            this.removeReflectionMap = function (state) {
                for (var i = 0, len = this.reflectionMaps.length; i < len; i++) {
                    if (this.reflectionMaps[i].id === state.id) {
                        this.reflectionMaps.splice(i, 1);
                        hash = null;
                        return;
                    }
                }
            };

            this.addLightMap = function (state) {
                this.lightMaps.push(state);
                hash = null;
            };

            this.removeLightMap = function (state) {
                for (var i = 0, len = this.lightMaps.length; i < len; i++) {
                    if (this.lightMaps[i].id === state.id) {
                        this.lightMaps.splice(i, 1);
                        hash = null;
                        return;
                    }
                }
            };

            this.getAmbientColorAndIntensity = function () {
                if (!ambientLight) {
                    for (var i = 0, len = this.lights.length; i < len; i++) {
                        var light = this.lights[i];
                        if (light.type === "ambient") {
                            ambientLight = light;
                            break;
                        }
                    }
                }
                if (ambientLight) {
                    var color = ambientLight.color;
                    var intensity = ambientLight.intensity;
                    ambientColorIntensity[0] = color[0];
                    ambientColorIntensity[1] = color[1];
                    ambientColorIntensity[2] = color[2];
                    ambientColorIntensity[3] = intensity;
                    return ambientColorIntensity;
                } else {
                    return DEFAULT_AMBIENT;
                }
            };

        })();

        /**
         * Publishes input events that occur on this Scene's canvas.
         *
         * @property input
         * @type {Input}
         * @final
         */
        this.input = new Input(this, {
            dontClear: true, // Never destroy this component with Scene#clear();
            element: this.canvas.canvas
        });

        /**
         * Configures this Scene's units of measurement and coordinate mapping between Real-space and World-space 3D coordinate systems.
         *
         * @property metrics
         * @type {Metrics}
         * @final
         */
        this.metrics = new Metrics(this, {
            units: cfg.units,
            scale: cfg.scale,
            origin: cfg.origin
        });

        /** Configures Scalable Ambient Obscurance (SAO) for this Scene.
         * @type {SAO}
         * @final
         */
        this.sao = new SAO(this, {
            enabled: cfg.saoEnabled
        });

        this.ticksPerRender = cfg.ticksPerRender;
        this.ticksPerOcclusionTest = cfg.ticksPerOcclusionTest;
        this.passes = cfg.passes;
        this.clearEachPass = cfg.clearEachPass;
        this.gammaInput = cfg.gammaInput;
        this.gammaOutput = cfg.gammaOutput;
        this.gammaFactor = cfg.gammaFactor;

        this._entityOffsetsEnabled = !!cfg.entityOffsetsEnabled;
        this._pickSurfacePrecisionEnabled = !!cfg.pickSurfacePrecisionEnabled;
        this._logarithmicDepthBufferEnabled = !!cfg.logarithmicDepthBufferEnabled;

        this._pbrEnabled = !!cfg.pbrEnabled;

        // Register Scene on xeokit
        // Do this BEFORE we add components below
        core._addScene(this);

        this._initDefaults();

        // Global components

        this._viewport = new Viewport(this, {
            id: "default.viewport",
            autoBoundary: true,
            dontClear: true // Never destroy this component with Scene#clear();
        });

        this._camera = new Camera(this, {
            id: "default.camera",
            dontClear: true // Never destroy this component with Scene#clear();
        });

        // Default lights

        new AmbientLight(this, {
            color: [1.0, 1.0, 1.0],
            intensity: 0.7
        });

        new DirLight(this, {
            dir: [0.8, -.5, -0.5],
            color: [0.67, 0.67, 1.0],
            intensity: 0.7,
            space: "world"
        });

        new DirLight(this, {
            dir: [-0.8, -1.0, 0.5],
            color: [1, 1, .9],
            intensity: 0.9,
            space: "world"
        });

        this._camera.on("dirty", function () {
            this$1._renderer.imageDirty();
        });
    }

    if ( Component ) Scene.__proto__ = Component;
    Scene.prototype = Object.create( Component && Component.prototype );
    Scene.prototype.constructor = Scene;

    var prototypeAccessors = { type: { configurable: true },entityOffsetsEnabled: { configurable: true },pickSurfacePrecisionEnabled: { configurable: true },logarithmicDepthBufferEnabled: { configurable: true },pbrEnabled: { configurable: true },modelIds: { configurable: true },numObjects: { configurable: true },objectIds: { configurable: true },numVisibleObjects: { configurable: true },visibleObjectIds: { configurable: true },numXRayedObjects: { configurable: true },xrayedObjectIds: { configurable: true },numHighlightedObjects: { configurable: true },highlightedObjectIds: { configurable: true },numSelectedObjects: { configurable: true },selectedObjectIds: { configurable: true },numColorizedObjects: { configurable: true },colorizedObjectIds: { configurable: true },opacityObjectIds: { configurable: true },offsetObjectIds: { configurable: true },ticksPerRender: { configurable: true },ticksPerOcclusionTest: { configurable: true },passes: { configurable: true },clearEachPass: { configurable: true },gammaInput: { configurable: true },gammaOutput: { configurable: true },gammaFactor: { configurable: true },geometry: { configurable: true },material: { configurable: true },xrayMaterial: { configurable: true },highlightMaterial: { configurable: true },selectedMaterial: { configurable: true },edgeMaterial: { configurable: true },pointsMaterial: { configurable: true },linesMaterial: { configurable: true },viewport: { configurable: true },camera: { configurable: true },center: { configurable: true },aabb: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Scene";
    };

    Scene.prototype._initDefaults = function _initDefaults () {

        this.geometry;
        this.material;
        this.xrayMaterial;
        this.edgeMaterial;
        this.selectedMaterial;
        this.highlightMaterial;
    };

    Scene.prototype._addComponent = function _addComponent (component) {
        if (component.id) { // Manual ID
            if (this.components[component.id]) {
                this.error("Component " + utils.inQuotes(component.id) + " already exists in Scene - ignoring ID, will randomly-generate instead");
                component.id = null;
            }
        }
        if (!component.id) { // Auto ID
            if (window.nextID === undefined) {
                window.nextID = 0;
            }
            //component.id = math.createUUID();
            component.id = "__" + window.nextID++;
            while (this.components[component.id]) {
                component.id = math.createUUID();
            }
        }
        this.components[component.id] = component;

        // Register for class type
        var type = component.type;
        var types = this.types[component.type];
        if (!types) {
            types = this.types[type] = {};
        }
        types[component.id] = component;

        if (component.compile) {
            this._compilables[component.id] = component;
        }
        if (component.isDrawable) {
            this._renderer.addDrawable(component.id, component);
            this._collidables[component.id] = component;
        }
    };

    Scene.prototype._removeComponent = function _removeComponent (component) {
        var id = component.id;
        var type = component.type;
        delete this.components[id];
        // Unregister for types
        var types = this.types[type];
        if (types) {
            delete types[id];
            if (utils.isEmptyObject(types)) {
                delete this.types[type];
            }
        }
        if (component.compile) {
            delete this._compilables[component.id];
        }
        if (component.isDrawable) {
            this._renderer.removeDrawable(component.id);
            delete this._collidables[component.id];
        }
    };

    // Methods below are called by various component types to register themselves on their
    // Scene. Violates Hollywood Principle, where we could just filter on type in _addComponent,
    // but this is faster than checking the type of each component in such a filter.

    Scene.prototype._sectionPlaneCreated = function _sectionPlaneCreated (sectionPlane) {
        this.sectionPlanes[sectionPlane.id] = sectionPlane;
        this.scene._sectionPlanesState.addSectionPlane(sectionPlane._state);
        this.scene.fire("sectionPlaneCreated", sectionPlane, true /* Don't retain event */);
        this._needRecompile = true;
    };

    Scene.prototype._lightCreated = function _lightCreated (light) {
        this.lights[light.id] = light;
        this.scene._lightsState.addLight(light._state);
        this._needRecompile = true;
    };

    Scene.prototype._lightMapCreated = function _lightMapCreated (lightMap) {
        this.lightMaps[lightMap.id] = lightMap;
        this.scene._lightsState.addLightMap(lightMap._state);
        this._needRecompile = true;
    };

    Scene.prototype._reflectionMapCreated = function _reflectionMapCreated (reflectionMap) {
        this.reflectionMaps[reflectionMap.id] = reflectionMap;
        this.scene._lightsState.addReflectionMap(reflectionMap._state);
        this._needRecompile = true;
    };

    Scene.prototype._sectionPlaneDestroyed = function _sectionPlaneDestroyed (sectionPlane) {
        delete this.sectionPlanes[sectionPlane.id];
        this.scene._sectionPlanesState.removeSectionPlane(sectionPlane._state);
        this.scene.fire("sectionPlaneDestroyed", sectionPlane, true /* Don't retain event */);
        this._needRecompile = true;
    };

    Scene.prototype._lightDestroyed = function _lightDestroyed (light) {
        delete this.lights[light.id];
        this.scene._lightsState.removeLight(light._state);
        this._needRecompile = true;
    };

    Scene.prototype._lightMapDestroyed = function _lightMapDestroyed (lightMap) {
        delete this.lightMaps[lightMap.id];
        this.scene._lightsState.removeLightMap(lightMap._state);
        this._needRecompile = true;
    };

    Scene.prototype._reflectionMapDestroyed = function _reflectionMapDestroyed (reflectionMap) {
        delete this.reflectionMaps[reflectionMap.id];
        this.scene._lightsState.removeReflectionMap(reflectionMap._state);
        this._needRecompile = true;
    };

    Scene.prototype._registerModel = function _registerModel (entity) {
        this.models[entity.id] = entity;
        this._modelIds = null; // Lazy regenerate
    };

    Scene.prototype._deregisterModel = function _deregisterModel (entity) {
        delete this.models[entity.id];
        this._modelIds = null; // Lazy regenerate
    };

    Scene.prototype._registerObject = function _registerObject (entity) {
        this.objects[entity.id] = entity;
        this._numObjects++;
        this._objectIds = null; // Lazy regenerate
    };

    Scene.prototype._deregisterObject = function _deregisterObject (entity) {
        delete this.objects[entity.id];
        this._numObjects--;
        this._objectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectVisibilityUpdated = function _objectVisibilityUpdated (entity, notify) {
        if ( notify === void 0 ) notify = true;

        if (entity.visible) {
            this.visibleObjects[entity.id] = entity;
            this._numVisibleObjects++;
        } else {
            delete this.visibleObjects[entity.id];
            this._numVisibleObjects--;
        }
        this._visibleObjectIds = null; // Lazy regenerate
        if (notify) {
            this.fire("objectVisibility", entity, true);
        }
    };

    Scene.prototype._objectXRayedUpdated = function _objectXRayedUpdated (entity) {
        if (entity.xrayed) {
            this.xrayedObjects[entity.id] = entity;
            this._numXRayedObjects++;
        } else {
            delete this.xrayedObjects[entity.id];
            this._numXRayedObjects--;
        }
        this._xrayedObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectHighlightedUpdated = function _objectHighlightedUpdated (entity) {
        if (entity.highlighted) {
            this.highlightedObjects[entity.id] = entity;
            this._numHighlightedObjects++;
        } else {
            delete this.highlightedObjects[entity.id];
            this._numHighlightedObjects--;
        }
        this._highlightedObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectSelectedUpdated = function _objectSelectedUpdated (entity) {
        if (entity.selected) {
            this.selectedObjects[entity.id] = entity;
            this._numSelectedObjects++;
        } else {
            delete this.selectedObjects[entity.id];
            this._numSelectedObjects--;
        }
        this._selectedObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectColorizeUpdated = function _objectColorizeUpdated (entity, colorized) {
        if (colorized) {
            this.colorizedObjects[entity.id] = entity;
            this._numColorizedObjects++;
        } else {
            delete this.colorizedObjects[entity.id];
            this._numColorizedObjects--;
        }
        this._colorizedObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectOpacityUpdated = function _objectOpacityUpdated (entity, opacityUpdated) {
        if (opacityUpdated) {
            this.opacityObjects[entity.id] = entity;
            this._numOpacityObjects++;
        } else {
            delete this.opacityObjects[entity.id];
            this._numOpacityObjects--;
        }
        this._opacityObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._objectOffsetUpdated = function _objectOffsetUpdated (entity, offset) {
        if (!offset || offset[0] === 0 && offset[1] === 0 && offset[2] === 0) {
            this.offsetObjects[entity.id] = entity;
            this._numOffsetObjects++;
        } else {
            delete this.offsetObjects[entity.id];
            this._numOffsetObjects--;
        }
        this._offsetObjectIds = null; // Lazy regenerate
    };

    Scene.prototype._webglContextLost = function _webglContextLost () {
        //  this.loading++;
        this.canvas.spinner.processes++;
        for (var id in this.components) {
            if (this.components.hasOwnProperty(id)) {
                var component = this.components[id];
                if (component._webglContextLost) {
                    component._webglContextLost();
                }
            }
        }
        this._renderer.webglContextLost();
    };

    Scene.prototype._webglContextRestored = function _webglContextRestored () {
        var gl = this.canvas.gl;
        for (var id in this.components) {
            if (this.components.hasOwnProperty(id)) {
                var component = this.components[id];
                if (component._webglContextRestored) {
                    component._webglContextRestored(gl);
                }
            }
        }
        this._renderer.webglContextRestored(gl);
        //this.loading--;
        this.canvas.spinner.processes--;
    };

    /**
     * Whether {@link Entity#offset} is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * @returns {Boolean} True if {@link Entity#offset} is enabled.
     */
    prototypeAccessors.entityOffsetsEnabled.get = function () {
        return this._entityOffsetsEnabled;
    };

    /**
     * Whether precision surface picking is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * The ````pickSurfacePrecision```` option for ````Scene#pick```` only works if this is set ````true````.
     *
     * Note that when ````true````, this configuration will increase the amount of browser memory used by the Viewer.
     *
     * @returns {Boolean} True if precision picking is enabled.
     */
    prototypeAccessors.pickSurfacePrecisionEnabled.get = function () {
        return this._pickSurfacePrecisionEnabled;
    };

    /**
     * Whether logarithmic depth buffer is enabled.
     *
     * This is set via the {@link Viewer} constructor and is ````false```` by default.
     *
     * @returns {Boolean} True if logarithmic depth buffer is enabled.
     */
    prototypeAccessors.logarithmicDepthBufferEnabled.get = function () {
        return this._logarithmicDepthBufferEnabled;
    };

    /**
     * Sets whether physically-based rendering is enabled.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} True if quality rendering is enabled.
     */
    prototypeAccessors.pbrEnabled.set = function (pbrEnabled) {
        this._pbrEnabled = !!pbrEnabled;
        this.glRedraw();
    };

    /**
     * Sets whether quality rendering is enabled.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} True if quality rendering is enabled.
     */
    prototypeAccessors.pbrEnabled.get = function () {
        return this._pbrEnabled;
    };

    /**
     * Performs an occlusion test on all {@link Marker}s in this {@link Scene}.
     *
     * Sets each {@link Marker#visible} ````true```` if the Marker is currently not occluded by any opaque {@link Entity}s
     * in the Scene, or ````false```` if an Entity is occluding it.
     */
    Scene.prototype.doOcclusionTest = function doOcclusionTest () {
        if (this._needRecompile) {
            this._recompile();
            this._needRecompile = false;
        }
        this._renderer.doOcclusionTest();
    };

    /**
     * Renders a single frame of this Scene.
     *
     * The Scene will periodically render itself after any updates, but you can call this method to force a render
     * if required.
     *
     * @param {Boolean} [forceRender=false] Forces a render when true, otherwise only renders if something has changed in this Scene
     * since the last render.
     */
    Scene.prototype.render = function render (forceRender) {

        if (forceRender) {
            core.runTasks();
        }

        var renderEvent = {
            sceneId: null,
            pass: 0
        };

        if (this._needRecompile) {
            this._recompile();
            this._renderer.imageDirty();
            this._needRecompile = false;
        }

        renderEvent.sceneId = this.id;

        var passes = this._passes;
        var clearEachPass = this._clearEachPass;
        var pass;
        var clear;

        for (pass = 0; pass < passes; pass++) {

            renderEvent.pass = pass;

            /**
             * Fired when about to render a frame for a Scene.
             *
             * @event rendering
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} pass Index of the pass we are about to render (see {@link Scene#passes}).
             */
            this.fire("rendering", renderEvent, true);

            clear = clearEachPass || (pass === 0);

            this._renderer.render({pass: pass, clear: clear, force: forceRender});

            /**
             * Fired when we have just rendered a frame for a Scene.
             *
             * @event rendering
             * @param {String} sceneID The ID of this Scene.
             * @param {Number} pass Index of the pass we rendered (see {@link Scene#passes}).
             */
            this.fire("rendered", renderEvent, true);
        }

        this._saveAmbientColor();
    };

    Scene.prototype._recompile = function _recompile () {
        for (var id in this._compilables) {
            if (this._compilables.hasOwnProperty(id)) {
                this._compilables[id].compile();
            }
        }
        this._renderer.shadowsDirty();
        this.fire("compile", this, true);
    };

    Scene.prototype._saveAmbientColor = function _saveAmbientColor () {
        var canvas = this.canvas;
        if (!canvas.transparent && !canvas.backgroundImage && !canvas.backgroundColor) {
            var ambientColorIntensity = this._lightsState.getAmbientColorAndIntensity();
            if (!this._lastAmbientColor ||
                this._lastAmbientColor[0] !== ambientColorIntensity[0] ||
                this._lastAmbientColor[1] !== ambientColorIntensity[1] ||
                this._lastAmbientColor[2] !== ambientColorIntensity[2] ||
                this._lastAmbientColor[3] !== ambientColorIntensity[3]) {
                canvas.backgroundColor = ambientColorIntensity;
                if (!this._lastAmbientColor) {
                    this._lastAmbientColor = math.vec4([0, 0, 0, 1]);
                }
                this._lastAmbientColor.set(ambientColorIntensity);
            }
        } else {
            this._lastAmbientColor = null;
        }
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#models}.
     *
     * @type {String[]}
     */
    prototypeAccessors.modelIds.get = function () {
        if (!this._modelIds) {
            this._modelIds = Object.keys(this.models);
        }
        return this._modelIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#objects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numObjects.get = function () {
        return this._numObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#objects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.objectIds.get = function () {
        if (!this._objectIds) {
            this._objectIds = Object.keys(this.objects);
        }
        return this._objectIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#visibleObjects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numVisibleObjects.get = function () {
        return this._numVisibleObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#visibleObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.visibleObjectIds.get = function () {
        if (!this._visibleObjectIds) {
            this._visibleObjectIds = Object.keys(this.visibleObjects);
        }
        return this._visibleObjectIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#xrayedObjects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numXRayedObjects.get = function () {
        return this._numXRayedObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#xrayedObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.xrayedObjectIds.get = function () {
        if (!this._xrayedObjectIds) {
            this._xrayedObjectIds = Object.keys(this.xrayedObjects);
        }
        return this._xrayedObjectIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#highlightedObjects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numHighlightedObjects.get = function () {
        return this._numHighlightedObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#highlightedObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.highlightedObjectIds.get = function () {
        if (!this._highlightedObjectIds) {
            this._highlightedObjectIds = Object.keys(this.highlightedObjects);
        }
        return this._highlightedObjectIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#selectedObjects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numSelectedObjects.get = function () {
        return this._numSelectedObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#selectedObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.selectedObjectIds.get = function () {
        if (!this._selectedObjectIds) {
            this._selectedObjectIds = Object.keys(this.selectedObjects);
        }
        return this._selectedObjectIds;
    };

    /**
     * Gets the number of {@link Entity}s in {@link Scene#colorizedObjects}.
     *
     * @type {Number}
     */
    prototypeAccessors.numColorizedObjects.get = function () {
        return this._numColorizedObjects;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#colorizedObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.colorizedObjectIds.get = function () {
        if (!this._colorizedObjectIds) {
            this._colorizedObjectIds = Object.keys(this.colorizedObjects);
        }
        return this._colorizedObjectIds;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#opacityObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.opacityObjectIds.get = function () {
        if (!this._opacityObjectIds) {
            this._opacityObjectIds = Object.keys(this.opacityObjects);
        }
        return this._opacityObjectIds;
    };

    /**
     * Gets the IDs of the {@link Entity}s in {@link Scene#offsetObjects}.
     *
     * @type {String[]}
     */
    prototypeAccessors.offsetObjectIds.get = function () {
        if (!this._offsetObjectIds) {
            this._offsetObjectIds = Object.keys(this.offsetObjects);
        }
        return this._offsetObjectIds;
    };

    /**
     * Sets the number of "ticks" that happen between each render or this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.ticksPerRender.set = function (value) {
        if (value === undefined || value === null) {
            value = 1;
        } else if (!utils.isNumeric(value) || value <= 0) {
            this.error("Unsupported value for 'ticksPerRender': '" + value +
                "' - should be an integer greater than zero.");
            value = 1;
        }
        if (value === this._ticksPerRender) {
            return;
        }
        this._ticksPerRender = value;
    };

    /**
     * Gets the number of "ticks" that happen between each render or this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.ticksPerRender.get = function () {
        return this._ticksPerRender;
    };

    /**
     * Sets the number of "ticks" that happen between occlusion testing for {@link Marker}s.
     *
     * Default value is ````20````.
     *
     * @type {Number}
     */
    prototypeAccessors.ticksPerOcclusionTest.set = function (value) {
        if (value === undefined || value === null) {
            value = 20;
        } else if (!utils.isNumeric(value) || value <= 0) {
            this.error("Unsupported value for 'ticksPerOcclusionTest': '" + value +
                "' - should be an integer greater than zero.");
            value = 20;
        }
        if (value === this._ticksPerOcclusionTest) {
            return;
        }
        this._ticksPerOcclusionTest = value;
    };

    /**
     * Gets the number of "ticks" that happen between each render of this Scene.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.ticksPerOcclusionTest.get = function () {
        return this._ticksPerOcclusionTest;
    };

    /**
     * Sets the number of times this Scene renders per frame.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.passes.set = function (value) {
        if (value === undefined || value === null) {
            value = 1;
        } else if (!utils.isNumeric(value) || value <= 0) {
            this.error("Unsupported value for 'passes': '" + value +
                "' - should be an integer greater than zero.");
            value = 1;
        }
        if (value === this._passes) {
            return;
        }
        this._passes = value;
        this.glRedraw();
    };

    /**
     * Gets the number of times this Scene renders per frame.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.passes.get = function () {
        return this._passes;
    };

    /**
     * When {@link Scene#passes} is greater than ````1````, indicates whether or not to clear the canvas before each pass (````true````) or just before the first pass (````false````).
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clearEachPass.set = function (value) {
        value = !!value;
        if (value === this._clearEachPass) {
            return;
        }
        this._clearEachPass = value;
        this.glRedraw();
    };

    /**
     * When {@link Scene#passes} is greater than ````1````, indicates whether or not to clear the canvas before each pass (````true````) or just before the first pass (````false````).
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clearEachPass.get = function () {
        return this._clearEachPass;
    };

    /**
     * Sets whether or not {@link Scene} should expect all {@link Texture}s and colors to have pre-multiplied gamma.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.gammaInput.set = function (value) {
        value = value !== false;
        if (value === this._renderer.gammaInput) {
            return;
        }
        this._renderer.gammaInput = value;
        this._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets whether or not {@link Scene} should expect all {@link Texture}s and colors to have pre-multiplied gamma.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.gammaInput.get = function () {
        return this._renderer.gammaInput;
    };

    /**
     * Sets whether or not to render pixels with pre-multiplied gama.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.gammaOutput.set = function (value) {
        value = !!value;
        if (value === this._renderer.gammaOutput) {
            return;
        }
        this._renderer.gammaOutput = value;
        this._needRecompile = true;
        this.glRedraw();
    };

    /**
     * Gets whether or not to render pixels with pre-multiplied gama.
     *
     * Default value is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.gammaOutput.get = function () {
        return this._renderer.gammaOutput;
    };

    /**
     * Sets the gamma factor to use when {@link Scene#gammaOutput} is set true.
     *
     * Default value is ````2.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.gammaFactor.set = function (value) {
        value = (value === undefined || value === null) ? 2.2 : value;
        if (value === this._renderer.gammaFactor) {
            return;
        }
        this._renderer.gammaFactor = value;
        this.glRedraw();
    };

    /**
     * Gets the gamma factor to use when {@link Scene#gammaOutput} is set true.
     *
     * Default value is ````2.2````.
     *
     * @type {Number}
     */
    prototypeAccessors.gammaFactor.get = function () {
        return this._renderer.gammaFactor;
    };

    /**
     * Gets the default {@link Geometry} for this Scene, which is a {@link ReadableGeometry} with a unit-sized box shape.
     *
     * Has {@link ReadableGeometry#id} set to "default.geometry".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#geometry} set to this {@link ReadableGeometry} by default.
     *
     * @type {ReadableGeometry}
     */
    prototypeAccessors.geometry.get = function () {
        return this.components["default.geometry"] || buildBoxGeometry(ReadableGeometry);
    };

    /**
     * Gets the default {@link Material} for this Scene, which is a {@link PhongMaterial}.
     *
     * Has {@link PhongMaterial#id} set to "default.material".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#material} set to this {@link PhongMaterial} by default.
     *
     * @type {PhongMaterial}
     */
    prototypeAccessors.material.get = function () {
        return this.components["default.material"] || new PhongMaterial(this, {
            id: "default.material",
            emissive: [0.4, 0.4, 0.4], // Visible by default on geometry without normals
            dontClear: true
        });
    };

    /**
     * Gets the default xraying {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.xrayMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#xrayMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are xrayed while {@link Mesh#xrayed} is ````true````.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.xrayMaterial.get = function () {
        return this.components["default.xrayMaterial"] || new EmphasisMaterial(this, {
            id: "default.xrayMaterial",
            preset: "sepia",
            dontClear: true
        });
    };

    /**
     * Gets the default highlight {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.highlightMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#highlightMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are highlighted while {@link Mesh#highlighted} is ````true````.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.highlightMaterial.get = function () {
        return this.components["default.highlightMaterial"] || new EmphasisMaterial(this, {
            id: "default.highlightMaterial",
            preset: "yellowHighlight",
            dontClear: true
        });
    };

    /**
     * Gets the default selection {@link EmphasisMaterial} for this Scene.
     *
     * Has {@link EmphasisMaterial#id} set to "default.selectedMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#highlightMaterial} set to this {@link EmphasisMaterial} by default.
     *
     * {@link Mesh}s are highlighted while {@link Mesh#highlighted} is ````true````.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.selectedMaterial.get = function () {
        return this.components["default.selectedMaterial"] || new EmphasisMaterial(this, {
            id: "default.selectedMaterial",
            preset: "greenSelected",
            dontClear: true
        });
    };

    /**
     * Gets the default {@link EdgeMaterial} for this Scene.
     *
     * Has {@link EdgeMaterial#id} set to "default.edgeMaterial".
     *
     * {@link Mesh}s in this Scene have {@link Mesh#edgeMaterial} set to this {@link EdgeMaterial} by default.
     *
     * {@link Mesh}s have their edges emphasized while {@link Mesh#edges} is ````true````.
     *
     * @type {EdgeMaterial}
     */
    prototypeAccessors.edgeMaterial.get = function () {
        return this.components["default.edgeMaterial"] || new EdgeMaterial(this, {
            id: "default.edgeMaterial",
            preset: "default",
            edgeColor: [0.0, 0.0, 0.0],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            dontClear: true
        });
    };

    /**
     * Gets the {@link PointsMaterial} for this Scene.
     *
     * @type {PointsMaterial}
     */
    prototypeAccessors.pointsMaterial.get = function () {
        return this.components["default.pointsMaterial"] || new PointsMaterial(this, {
            id: "default.pointsMaterial",
            preset: "default",
            dontClear: true
        });
    };

    /**
     * Gets the {@link LinesMaterial} for this Scene.
     *
     * @type {LinesMaterial}
     */
    prototypeAccessors.linesMaterial.get = function () {
        return this.components["default.linesMaterial"] || new LinesMaterial(this, {
            id: "default.linesMaterial",
            preset: "default",
            dontClear: true
        });
    };

    /**
     * Gets the {@link Viewport} for this Scene.
     *
     * @type Viewport
     */
    prototypeAccessors.viewport.get = function () {
        return this._viewport;
    };

    /**
     * Gets the {@link Camera} for this Scene.
     *
     * @type {Camera}
     */
    prototypeAccessors.camera.get = function () {
        return this._camera;
    };

    /**
     * Gets the World-space 3D center of this Scene.
     *
     *@type {Number[]}
     */
    prototypeAccessors.center.get = function () {
        if (this._aabbDirty || !this._center) {
            if (!this._center || !this._center) {
                this._center = math.vec3();
            }
            var aabb = this.aabb;
            this._center[0] = (aabb[0] + aabb[3]) / 2;
            this._center[1] = (aabb[1] + aabb[4]) / 2;
            this._center[2] = (aabb[2] + aabb[5]) / 2;
        }
        return this._center;
    };

    /**
     * Gets the World-space axis-aligned 3D boundary (AABB) of this Scene.
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * When the Scene has no content, will be ````[-100,-100,-100,100,100,100]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        if (this._aabbDirty) {
            if (!this._aabb) {
                this._aabb = math.AABB3();
            }
            var xmin = math.MAX_DOUBLE;
            var ymin = math.MAX_DOUBLE;
            var zmin = math.MAX_DOUBLE;
            var xmax = math.MIN_DOUBLE;
            var ymax = math.MIN_DOUBLE;
            var zmax = math.MIN_DOUBLE;
            var aabb;
            var collidables = this._collidables;
            var collidable;
            var valid = false;
            for (var collidableId in collidables) {
                if (collidables.hasOwnProperty(collidableId)) {
                    collidable = collidables[collidableId];
                    if (collidable.collidable === false) {
                        continue;
                    }
                    aabb = collidable.aabb;
                    if (aabb[0] < xmin) {
                        xmin = aabb[0];
                    }
                    if (aabb[1] < ymin) {
                        ymin = aabb[1];
                    }
                    if (aabb[2] < zmin) {
                        zmin = aabb[2];
                    }
                    if (aabb[3] > xmax) {
                        xmax = aabb[3];
                    }
                    if (aabb[4] > ymax) {
                        ymax = aabb[4];
                    }
                    if (aabb[5] > zmax) {
                        zmax = aabb[5];
                    }
                    valid = true;
                }
            }
            if (!valid) {
                xmin = -100;
                ymin = -100;
                zmin = -100;
                xmax = 100;
                ymax = 100;
                zmax = 100;
            }
            this._aabb[0] = xmin;
            this._aabb[1] = ymin;
            this._aabb[2] = zmin;
            this._aabb[3] = xmax;
            this._aabb[4] = ymax;
            this._aabb[5] = zmax;
            this._aabbDirty = false;
        }
        return this._aabb;
    };

    Scene.prototype._setAABBDirty = function _setAABBDirty () {
        //if (!this._aabbDirty) {
        this._aabbDirty = true;
        this.fire("boundary");
        // }
    };

    /**
     * Attempts to pick an {@link Entity} in this Scene.
     *
     * Ignores {@link Entity}s with {@link Entity#pickable} set ````false````.
     *
     * When an {@link Entity} is picked, fires a "pick" event on the {@link Entity} with the pick result as parameters.
     *
     * Picking the {@link Entity} at the given canvas coordinates:

     * ````javascript
     * var pickResult = scene.pick({
     *          canvasPos: [23, 131]
     *       });
     *
     * if (pickResult) { // Picked an Entity
     *         var entity = pickResult.entity;
     *     }
     * ````
     *
     * Picking, with a ray cast through the canvas, hits an {@link Entity}:
     *
     * ````javascript
     * var pickResult = scene.pick({
     *         pickSurface: true,
     *         canvasPos: [23, 131]
     *      });
     *
     * if (pickResult) { // Picked an Entity
     *
     *     var entity = pickResult.entity;
     *
     *     if (pickResult.primitive === "triangle") {
     *
     *         // Picked a triangle on the entity surface
     *
     *         var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
     *         var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
     *         var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
     *         var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
     *         var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the interpolated World-space normal vector at the picked position on the triangle
     *         var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
     *
     *     } else if (pickResult.worldPos && pickResult.worldNormal) {
     *
     *         // Picked a point and normal on the entity surface
     *
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the Entity surface
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the picked World-space normal vector on the Entity Surface
     *     }
     * }
     * ````
     *
     * Picking the {@link Entity} that intersects an arbitrarily-aligned World-space ray:
     *
     * ````javascript
     * var pickResult = scene.pick({
     *       pickSurface: true,   // Picking with arbitrarily-positioned ray
     *       origin: [0,0,-5],    // Ray origin
     *       direction: [0,0,1]   // Ray direction
     * });
     *
     * if (pickResult) { // Picked an Entity with the ray
     *
     *       var entity = pickResult.entity;
     *
     *       if (pickResult.primitive == "triangle") {
     *
     *          // Picked a triangle on the entity surface
     *
     *           var primitive = pickResult.primitive; // Type of primitive that was picked, usually "triangles"
     *           var primIndex = pickResult.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
     *           var indices = pickResult.indices; // UInt32Array containing the triangle's vertex indices
     *           var localPos = pickResult.localPos; // Float64Array containing the picked Local-space position on the triangle
     *           var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the triangle
     *           var viewPos = pickResult.viewPos; // Float64Array containing the picked View-space position on the triangle
     *           var bary = pickResult.bary; // Float64Array containing the picked barycentric position within the triangle
     *           var worldNormal = pickResult.worldNormal; // Float64Array containing the interpolated World-space normal vector at the picked position on the triangle
     *           var uv = pickResult.uv; // Float64Array containing the interpolated UV coordinates at the picked position on the triangle
     *           var origin = pickResult.origin; // Float64Array containing the World-space ray origin
     *           var direction = pickResult.direction; // Float64Array containing the World-space ray direction
     *
     *     } else if (pickResult.worldPos && pickResult.worldNormal) {
     *
     *         // Picked a point and normal on the entity surface
     *
     *         var worldPos = pickResult.worldPos; // Float64Array containing the picked World-space position on the Entity surface
     *         var worldNormal = pickResult.worldNormal; // Float64Array containing the picked World-space normal vector on the Entity Surface
     *     }
     * }
     *  ````
     *
     * @param {*} params Picking parameters.
     * @param {Boolean} [params.pickSurface=false] Whether to find the picked position on the surface of the Entity.
     * @param {Boolean} [params.pickSurfacePrecision=false] When picking an Entity surface position, indicates whether or not we want full-precision {@link PickResult#worldPos}. Only works when {@link Scene#pickSurfacePrecisionEnabled} is ````true````. If pick succeeds, the returned {@link PickResult} will have {@link PickResult#precision} set ````true````, to indicate that it contains full-precision surface pick results.
     * @param {Boolean} [params.pickSurfaceNormal=false] Whether to find the picked normal on the surface of the Entity. Only works if ````pickSurface```` is given.
     * @param {Number[]} [params.canvasPos] Canvas-space coordinates. When ray-picking, this will override the **origin** and ** direction** parameters and will cause the ray to be fired through the canvas at this position, directly along the negative View-space Z-axis.
     * @param {Number[]} [params.origin] World-space ray origin when ray-picking. Ignored when canvasPos given.
     * @param {Number[]} [params.direction] World-space ray direction when ray-picking. Also indicates the length of the ray. Ignored when canvasPos given.
     * @param {Number[]} [params.matrix] 4x4 transformation matrix to define the World-space ray origin and direction, as an alternative to ````origin```` and ````direction````.
     * @param {String[]} [params.includeEntities] IDs of {@link Entity}s to restrict picking to. When given, ignores {@link Entity}s whose IDs are not in this list.
     * @param {String[]} [params.excludeEntities] IDs of {@link Entity}s to ignore. When given, will pick *through* these {@link Entity}s, as if they were not there.
     * @param {PickResult} [pickResult] Holds the results of the pick attempt. Will use the Scene's singleton PickResult if you don't supply your own.
     * @returns {PickResult} Holds results of the pick attempt, returned when an {@link Entity} is picked, else null. See method comments for description.
     */
    Scene.prototype.pick = function pick (params, pickResult) {

        if (this.canvas.boundary[2] === 0 || this.canvas.boundary[3] === 0) {
            this.error("Picking not allowed while canvas has zero width or height");
            return null;
        }

        params = params || {};

        params.pickSurface = params.pickSurface || params.rayPick; // Backwards compatibility

        if (!params.canvasPos && !params.matrix && (!params.origin || !params.direction)) {
            this.warn("picking without canvasPos, matrix, or ray origin and direction");
        }

        var includeEntities = params.includeEntities || params.include; // Backwards compat
        if (includeEntities) {
            params.includeEntityIds = getEntityIDMap(this, includeEntities);
        }

        var excludeEntities = params.excludeEntities || params.exclude; // Backwards compat
        if (excludeEntities) {
            params.excludeEntityIds = getEntityIDMap(this, excludeEntities);
        }

        if (this._needRecompile) {
            this._recompile();
            this._renderer.imageDirty();
            this._needRecompile = false;
        }

        pickResult = this._renderer.pick(params, pickResult);

        if (pickResult) {
            if (pickResult.entity && pickResult.entity.fire) {
                pickResult.entity.fire("picked", pickResult); // TODO: PerformanceModelNode doesn't fire events
            }
            return pickResult;
        }
    };

    /**
     * Destroys all non-default {@link Component}s in this Scene.
     */
    Scene.prototype.clear = function clear () {
        var component;
        for (var id in this.components) {
            if (this.components.hasOwnProperty(id)) {
                component = this.components[id];
                if (!component._dontClear) { // Don't destroy components like Camera, Input, Viewport etc.
                    component.destroy();
                }
            }
        }
    };

    /**
     * Destroys all {@link Light}s in this Scene..
     */
    Scene.prototype.clearLights = function clearLights () {
        var ids = Object.keys(this.lights);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.lights[ids[i]].destroy();
        }
    };

    /**
     * Destroys all {@link SectionPlane}s in this Scene.
     */
    Scene.prototype.clearSectionPlanes = function clearSectionPlanes () {
        var ids = Object.keys(this.sectionPlanes);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.sectionPlanes[ids[i]].destroy();
        }
    };

    /**
     * Gets the collective axis-aligned boundary (AABB) of a batch of {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which {@link Entity#isObject} is registered by {@link Entity#id} in {@link Scene#visibleObjects}.
     *
     * Each {@link Entity} is only included in the AABB when {@link Entity#collidable} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @returns {[Number, Number, Number, Number, Number, Number]} An axis-aligned World-space bounding box, given as elements ````[xmin, ymin, zmin, xmax, ymax, zmax]````.
     */
    Scene.prototype.getAABB = function getAABB (ids) {
        if (ids === undefined) {
            return this.aabb;
        }
        if (utils.isString(ids)) {
            var entity = this.objects[ids];
            if (entity && entity.aabb) { // A Component subclass with an AABB
                return entity.aabb;
            }
            ids = [ids]; // Must be an entity type
        }
        if (ids.length === 0) {
            return this.aabb;
        }
        var xmin = math.MAX_DOUBLE;
        var ymin = math.MAX_DOUBLE;
        var zmin = math.MAX_DOUBLE;
        var xmax = math.MIN_DOUBLE;
        var ymax = math.MIN_DOUBLE;
        var zmax = math.MIN_DOUBLE;
        var valid;
        this.withObjects(ids, function (entity) {
                if (entity.collidable) {
                    var aabb = entity.aabb;
                    if (aabb[0] < xmin) {
                        xmin = aabb[0];
                    }
                    if (aabb[1] < ymin) {
                        ymin = aabb[1];
                    }
                    if (aabb[2] < zmin) {
                        zmin = aabb[2];
                    }
                    if (aabb[3] > xmax) {
                        xmax = aabb[3];
                    }
                    if (aabb[4] > ymax) {
                        ymax = aabb[4];
                    }
                    if (aabb[5] > zmax) {
                        zmax = aabb[5];
                    }
                    valid = true;
                }
            }
        );
        if (valid) {
            var aabb2 = math.AABB3();
            aabb2[0] = xmin;
            aabb2[1] = ymin;
            aabb2[2] = zmin;
            aabb2[3] = xmax;
            aabb2[4] = ymax;
            aabb2[5] = zmax;
            return aabb2;
        } else {
            return this.aabb; // Scene AABB
        }
    };

    /**
     * Batch-updates {@link Entity#visible} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#visible} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#visibleObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} visible Whether or not to cull.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsVisible = function setObjectsVisible (ids, visible) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.visible !== visible);
            entity.visible = visible;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#collidable} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} collidable Whether or not to cull.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsCollidable = function setObjectsCollidable (ids, collidable) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.collidable !== collidable);
            entity.collidable = collidable;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#culled} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} culled Whether or not to cull.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsCulled = function setObjectsCulled (ids, culled) {
        return this.withObjects(ids, this.objects, function (entity) {
            var changed = (entity.culled !== culled);
            entity.culled = culled;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#selected} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#selected} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#selectedObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} selected Whether or not to highlight.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsSelected = function setObjectsSelected (ids, selected) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.selected !== selected);
            entity.selected = selected;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#highlighted} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#highlighted} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#highlightedObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} highlighted Whether or not to highlight.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsHighlighted = function setObjectsHighlighted (ids, highlighted) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.highlighted !== highlighted);
            entity.highlighted = highlighted;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#xrayed} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#xrayed} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#xrayedObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} xrayed Whether or not to xray.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsXRayed = function setObjectsXRayed (ids, xrayed) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.xrayed !== xrayed);
            entity.xrayed = xrayed;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#edges} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} edges Whether or not to show edges.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsEdges = function setObjectsEdges (ids, edges) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.edges !== edges);
            entity.edges = edges;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#colorize} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number[]} [colorize=(1,1,1)] RGB colorize factors, multiplied by the rendered pixel colors.
     * @returns {Boolean} True if any {@link Entity}s changed opacity, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsColorized = function setObjectsColorized (ids, colorize) {
        return this.withObjects(ids, function (entity) {
            entity.colorize = colorize;
        });
    };

    /**
     * Batch-updates {@link Entity#opacity} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number} [opacity=1.0] Opacity factor, multiplied by the rendered pixel alphas.
     * @returns {Boolean} True if any {@link Entity}s changed opacity, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsOpacity = function setObjectsOpacity (ids, opacity) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.opacity !== opacity);
            entity.opacity = opacity;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#pickable} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Boolean} pickable Whether or not to enable picking.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.setObjectsPickable = function setObjectsPickable (ids, pickable) {
        return this.withObjects(ids, function (entity) {
            var changed = (entity.pickable !== pickable);
            entity.pickable = pickable;
            return changed;
        });
    };

    /**
     * Batch-updates {@link Entity#offset} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Number[]} [offset] 3D offset vector.
     */
    Scene.prototype.setObjectsOffset = function setObjectsOffset (ids, offset) {
        this.withObjects(ids, function (entity) {
            entity.offset = offset;
        });
    };

    /**
     * Iterates with a callback over {@link Entity#visible} on {@link Entity}s that represent objects.
     *
     * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````.
     *
     * Each {@link Entity} on which both {@link Entity#isObject} and {@link Entity#visible} are ````true```` is
     * registered by {@link Entity#id} in {@link Scene#visibleObjects}.
     *
     * @param {String[]} ids Array of {@link Entity#id} values.
     * @param {Function} callback Callback to execute on eacn {@link Entity}.
     * @returns {Boolean} True if any {@link Entity}s were updated, else false if all updates were redundant and not applied.
     */
    Scene.prototype.withObjects = function withObjects (ids, callback) {
        if (utils.isString(ids)) {
            ids = [ids];
        }
        var changed = false;
        for (var i = 0, len = ids.length; i < len; i++) {
            var id = ids[i];
            var entity = this.objects[id];
            if (entity) {
                changed = callback(entity) || changed;
            } else {
                var modelIds = this.modelIds;
                for (var i$1 = 0, len$1 = modelIds.length; i$1 < len$1; i$1++) {
                    var modelId = modelIds[i$1];
                    var globalObjectId = math.globalizeObjectId(modelId, id);
                    entity = this.objects[globalObjectId];
                    if (entity) {
                        changed = callback(entity) || changed;
                    }
                }
            }
        }
        return changed;
    };

    /**
     * Destroys this Scene.
     */
    Scene.prototype.destroy = function destroy () {

        Component.prototype.destroy.call(this);

        for (var id in this.components) {
            if (this.components.hasOwnProperty(id)) {
                this.components[id].destroy();
            }
        }

        this.canvas.gl = null;

        // Memory leak prevention
        this.components = null;
        this.models = null;
        this.objects = null;
        this.visibleObjects = null;
        this.xrayedObjects = null;
        this.highlightedObjects = null;
        this.selectedObjects = null;
        this.colorizedObjects = null;
        this.opacityObjects = null;
        this.sectionPlanes = null;
        this.lights = null;
        this.lightMaps = null;
        this.reflectionMaps = null;
        this._objectIds = null;
        this._visibleObjectIds = null;
        this._xrayedObjectIds = null;
        this._highlightedObjectIds = null;
        this._selectedObjectIds = null;
        this._colorizedObjectIds = null;
        this.types = null;
        this.components = null;
        this.canvas = null;
        this._renderer = null;
        this.input = null;
        this._viewport = null;
        this._camera = null;
    };

    Object.defineProperties( Scene.prototype, prototypeAccessors );

    return Scene;
}(Component));

/**
 * @private
 */
var DrawShaderSource = function (mesh) {
    if (mesh._material._state.type === "LambertMaterial") {
        this.vertex = buildVertexLambert(mesh);
        this.fragment = buildFragmentLambert(mesh);
    } else {
        this.vertex = buildVertexDraw(mesh);
        this.fragment = buildFragmentDraw(mesh);
    }
};

var TEXTURE_DECODE_FUNCS$2 = {
    "linear": "linearToLinear",
    "sRGB": "sRGBToLinear",
    "gamma": "gammaToLinear"
};

function getReceivesShadow(mesh) {
    if (!mesh.receivesShadow) {
        return false;
    }
    var lights = mesh.scene._lightsState.lights;
    if (!lights || lights.length === 0) {
        return false;
    }
    for (var i = 0, len = lights.length; i < len; i++) {
        if (lights[i].castsShadow) {
            return true;
        }
    }
    return false;
}

function hasTextures(mesh) {
    if (!mesh._geometry._state.uvBuf) {
        return false;
    }
    var material = mesh._material;
    return !!(material._ambientMap ||
        material._occlusionMap ||
        material._baseColorMap ||
        material._diffuseMap ||
        material._alphaMap ||
        material._specularMap ||
        material._glossinessMap ||
        material._specularGlossinessMap ||
        material._emissiveMap ||
        material._metallicMap ||
        material._roughnessMap ||
        material._metallicRoughnessMap ||
        material._reflectivityMap ||
        material._normalMap);
}

function hasNormals$1(mesh) {
    var primitive = mesh._geometry._state.primitiveName;
    if ((mesh._geometry._state.autoVertexNormals || mesh._geometry._state.normalsBuf) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
        return true;
    }
    return false;
}

function buildVertexLambert(mesh) {

    var scene = mesh.scene;
    var sectionPlanesState = mesh.scene._sectionPlanesState;
    var lightsState = mesh.scene._lightsState;
    var geometryState = mesh._geometry._state;
    var billboard = mesh._state.billboard;
    var stationary = mesh._state.stationary;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!geometryState.compressGeometry;

    var src = [];
    src.push("// Lambertian drawing vertex shader");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform vec4 colorize;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    src.push("uniform vec4 lightAmbient;");
    src.push("uniform vec4 materialColor;");
    src.push("uniform vec3 materialEmissive;");
    if (geometryState.normalsBuf) {
        src.push("attribute vec3 normal;");
        src.push("uniform mat4 modelNormalMatrix;");
        src.push("uniform mat4 viewNormalMatrix;");
        for (var i = 0, len = lightsState.lights.length; i < len; i++) {
            var light = lightsState.lights[i];
            if (light.type === "ambient") {
                continue;
            }
            src.push("uniform vec4 lightColor" + i + ";");
            if (light.type === "dir") {
                src.push("uniform vec3 lightDir" + i + ";");
            }
            if (light.type === "point") {
                src.push("uniform vec3 lightPos" + i + ";");
            }
            if (light.type === "spot") {
                src.push("uniform vec3 lightPos" + i + ";");
                src.push("uniform vec3 lightDir" + i + ";");
            }
        }
        if (quantizedGeometry) {
            src.push("vec3 octDecode(vec2 oct) {");
            src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
            src.push("    if (v.z < 0.0) {");
            src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
            src.push("    }");
            src.push("    return normalize(v);");
            src.push("}");
        }
    }
    src.push("varying vec4 vColor;");
    if (geometryState.primitiveName === "points") {
        src.push("uniform float pointSize;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    src.push("vec4 worldPosition;");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    if (geometryState.normalsBuf) {
        if (quantizedGeometry) {
            src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
        } else {
            src.push("vec4 localNormal = vec4(normal, 0.0); ");
        }
        src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");
        src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");
    }
    src.push("mat4 viewMatrix2 = viewMatrix;");
    src.push("mat4 modelMatrix2 = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
        src.push("billboard(modelViewMatrix);");
        if (geometryState.normalsBuf) {
            src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
            src.push("billboard(modelNormalMatrix2);");
            src.push("billboard(viewNormalMatrix2);");
            src.push("billboard(modelViewNormalMatrix);");
        }
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition = modelViewMatrix * localPosition;");
    } else {
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
    }
    if (geometryState.normalsBuf) {
        src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");
    }
    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");
    src.push("float lambertian = 1.0;");
    if (geometryState.normalsBuf) {
        for (var i$1 = 0, len$1 = lightsState.lights.length; i$1 < len$1; i$1++) {
            var light$1 = lightsState.lights[i$1];
            if (light$1.type === "ambient") {
                continue;
            }
            if (light$1.type === "dir") {
                if (light$1.space === "view") {
                    src.push("viewLightDir = normalize(lightDir" + i$1 + ");");
                } else {
                    src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i$1 + ", 0.0)).xyz);");
                }
            } else if (light$1.type === "point") {
                if (light$1.space === "view") {
                    src.push("viewLightDir = -normalize(lightPos" + i$1 + " - viewPosition.xyz);");
                } else {
                    src.push("viewLightDir = -normalize((viewMatrix2 * vec4(lightPos" + i$1 + ", 0.0)).xyz);");
                }
            } else if (light$1.type === "spot") {
                if (light$1.space === "view") {
                    src.push("viewLightDir = normalize(lightDir" + i$1 + ");");
                } else {
                    src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i$1 + ", 0.0)).xyz);");
                }
            } else {
                continue;
            }
            src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
            src.push("reflectedColor += lambertian * (lightColor" + i$1 + ".rgb * lightColor" + i$1 + ".a);");
        }
    }
    //src.push("vColor = vec4((reflectedColor * materialColor) + (lightAmbient.rgb * lightAmbient.a), 1.0) * colorize;");
    src.push("vColor = vec4((lightAmbient.rgb * lightAmbient.a * materialColor.rgb) + materialEmissive.rgb + (reflectedColor * materialColor.rgb), materialColor.a) * colorize;"); // TODO: How to have ambient bright enough for canvas BG but not too bright for scene?
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
    }
    if (geometryState.primitiveName === "points") {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("vFragDepth = 1.0 + clipPos.w;");
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function buildFragmentLambert(mesh) {
    var scene = mesh.scene;
    var sectionPlanesState = scene._sectionPlanesState;
    mesh._material._state;
    var geometryState = mesh._geometry._state;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
    var src = [];
    src.push("// Lambertian drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("uniform bool clippable;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    if (gammaOutput) {
        src.push("uniform float gammaFactor;");
        src.push("    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (geometryState.primitiveName === "points") {
        src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("float r = dot(cxy, cxy);");
        src.push("if (r > 1.0) {");
        src.push("   discard;");
        src.push("}");

    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    if (gammaOutput) {
        src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
    } else {
        src.push("gl_FragColor = vColor;");
    }
    src.push("}");
    return src;
}

function buildVertexDraw(mesh) {
    var scene = mesh.scene;
    var material = mesh._material;
    var meshState = mesh._state;
    var sectionPlanesState = scene._sectionPlanesState;
    var geometryState = mesh._geometry._state;
    var lightsState = scene._lightsState;
    var light;
    var billboard = meshState.billboard;
    var stationary = meshState.stationary;
    var texturing = hasTextures(mesh);
    var normals = hasNormals$1(mesh);
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var receivesShadow = getReceivesShadow(mesh);
    var quantizedGeometry = !!geometryState.compressGeometry;
    var src = [];
    src.push("// Drawing vertex shader");
    if (normals && material._normalMap) {
        src.push("#extension GL_OES_standard_derivatives : enable");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute  vec3 position;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    src.push("uniform  mat4 modelMatrix;");
    src.push("uniform  mat4 viewMatrix;");
    src.push("uniform  mat4 projMatrix;");
    src.push("varying  vec3 vViewPosition;");
    src.push("uniform  vec3 offset;");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (lightsState.lightMaps.length > 0) {
        src.push("varying    vec3 vWorldNormal;");
    }
    if (normals) {
        src.push("attribute  vec3 normal;");
        src.push("uniform    mat4 modelNormalMatrix;");
        src.push("uniform    mat4 viewNormalMatrix;");
        src.push("varying    vec3 vViewNormal;");
        for (var i$1 = 0, len$1 = lightsState.lights.length; i$1 < len$1; i$1++) {
            light = lightsState.lights[i$1];
            if (light.type === "ambient") {
                continue;
            }
            if (light.type === "dir") {
                src.push("uniform vec3 lightDir" + i$1 + ";");
            }
            if (light.type === "point") {
                src.push("uniform vec3 lightPos" + i$1 + ";");
            }
            if (light.type === "spot") {
                src.push("uniform vec3 lightPos" + i$1 + ";");
                src.push("uniform vec3 lightDir" + i$1 + ";");
            }
            if (!(light.type === "dir" && light.space === "view")) {
                src.push("varying vec4 vViewLightReverseDirAndDist" + i$1 + ";");
            }
        }
        if (quantizedGeometry) {
            src.push("vec3 octDecode(vec2 oct) {");
            src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
            src.push("    if (v.z < 0.0) {");
            src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
            src.push("    }");
            src.push("    return normalize(v);");
            src.push("}");
        }
    }
    if (texturing) {
        src.push("attribute vec2 uv;");
        src.push("varying vec2 vUV;");
        if (quantizedGeometry) {
            src.push("uniform mat3 uvDecodeMatrix;");
        }
    }
    if (geometryState.colors) {
        src.push("attribute vec4 color;");
        src.push("varying vec4 vColor;");
    }
    if (geometryState.primitiveName === "points") {
        src.push("uniform float pointSize;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    if (receivesShadow) {
        src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");
        for (var i$2 = 0, len$2 = lightsState.lights.length; i$2 < len$2; i$2++) { // Light sources
            if (lightsState.lights[i$2].castsShadow) {
                src.push("uniform mat4 shadowViewMatrix" + i$2 + ";");
                src.push("uniform mat4 shadowProjMatrix" + i$2 + ";");
                src.push("varying vec4 vShadowPosFromLight" + i$2 + ";");
            }
        }
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    src.push("vec4 worldPosition;");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    if (normals) {
        if (quantizedGeometry) {
            src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
        } else {
            src.push("vec4 localNormal = vec4(normal, 0.0); ");
        }
        src.push("mat4 modelNormalMatrix2    = modelNormalMatrix;");
        src.push("mat4 viewNormalMatrix2     = viewNormalMatrix;");
    }
    src.push("mat4 viewMatrix2           = viewMatrix;");
    src.push("mat4 modelMatrix2          = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
        src.push("billboard(modelViewMatrix);");
        if (normals) {
            src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
            src.push("billboard(modelNormalMatrix2);");
            src.push("billboard(viewNormalMatrix2);");
            src.push("billboard(modelViewNormalMatrix);");
        }
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition = modelViewMatrix * localPosition;");
    } else {
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
    }
    if (normals) {
        src.push("vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; ");
        if (lightsState.lightMaps.length > 0) {
            src.push("vWorldNormal = worldNormal;");
        }
        src.push("vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);");
        src.push("vec3 tmpVec3;");
        src.push("float lightDist;");
        for (var i$3 = 0, len$3 = lightsState.lights.length; i$3 < len$3; i$3++) { // Lights
            light = lightsState.lights[i$3];
            if (light.type === "ambient") {
                continue;
            }
            if (light.type === "dir") {
                if (light.space === "world") {
                    src.push("tmpVec3 = vec3(viewMatrix2 * vec4(lightDir" + i$3 + ", 0.0) ).xyz;");
                    src.push("vViewLightReverseDirAndDist" + i$3 + " = vec4(-tmpVec3, 0.0);");
                }
            }
            if (light.type === "point") {
                if (light.space === "world") {
                    src.push("tmpVec3 = (viewMatrix2 * vec4(lightPos" + i$3 + ", 1.0)).xyz - viewPosition.xyz;");
                    src.push("lightDist = abs(length(tmpVec3));");
                } else {
                    src.push("tmpVec3 = lightPos" + i$3 + ".xyz - viewPosition.xyz;");
                    src.push("lightDist = abs(length(tmpVec3));");
                }
                src.push("vViewLightReverseDirAndDist" + i$3 + " = vec4(tmpVec3, lightDist);");
            }
        }
    }
    if (texturing) {
        if (quantizedGeometry) {
            src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");
        } else {
            src.push("vUV = uv;");
        }
    }
    if (geometryState.colors) {
        src.push("vColor = color;");
    }
    if (geometryState.primitiveName === "points") {
        src.push("gl_PointSize = pointSize;");
    }
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
    }
    src.push("   vViewPosition = viewPosition.xyz;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("vFragDepth = 1.0 + clipPos.w;");
    }
    src.push("gl_Position = clipPos;");
    if (receivesShadow) {
        src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");
        src.push("vec4 tempx; ");
        for (var i$4 = 0, len$4 = lightsState.lights.length; i$4 < len$4; i$4++) { // Light sources
            if (lightsState.lights[i$4].castsShadow) {
                src.push("vShadowPosFromLight" + i$4 + " = texUnitConverter * shadowProjMatrix" + i$4 + " * (shadowViewMatrix" + i$4 + " * worldPosition); ");
            }
        }
    }
    src.push("}");
    return src;
}

function buildFragmentDraw(mesh) {

    var scene = mesh.scene;
    scene.canvas.gl;
    var material = mesh._material;
    var geometryState = mesh._geometry._state;
    var sectionPlanesState = mesh.scene._sectionPlanesState;
    var lightsState = mesh.scene._lightsState;
    var materialState = mesh._material._state;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var normals = hasNormals$1(mesh);
    var uvs = geometryState.uvBuf;
    var phongMaterial = (materialState.type === "PhongMaterial");
    var metallicMaterial = (materialState.type === "MetallicMaterial");
    var specularMaterial = (materialState.type === "SpecularMaterial");
    var receivesShadow = getReceivesShadow(mesh);
    scene.gammaInput; // If set, then it expects that all textures and colors are premultiplied gamma. Default is false.
    var gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
    var src = [];

    src.push("// Drawing fragment shader");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    if (normals && material._normalMap) {
        src.push("#extension GL_OES_standard_derivatives : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (receivesShadow) {
        src.push("float unpackDepth (vec4 color) {");
        src.push("  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));");
        src.push("  return dot(color, bitShift);");
        src.push("}");
    }

    //--------------------------------------------------------------------------------
    // GAMMA CORRECTION
    //--------------------------------------------------------------------------------

    src.push("uniform float gammaFactor;");
    src.push("vec4 linearToLinear( in vec4 value ) {");
    src.push("  return value;");
    src.push("}");
    src.push("vec4 sRGBToLinear( in vec4 value ) {");
    src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");
    src.push("}");
    src.push("vec4 gammaToLinear( in vec4 value) {");
    src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");
    src.push("}");
    if (gammaOutput) {
        src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }

    //--------------------------------------------------------------------------------
    // USER CLIP PLANES
    //--------------------------------------------------------------------------------

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("uniform bool clippable;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }

    if (normals) {

        //--------------------------------------------------------------------------------
        // LIGHT AND REFLECTION MAP INPUTS
        // Define here so available globally to shader functions
        //--------------------------------------------------------------------------------

        if (lightsState.lightMaps.length > 0) {
            src.push("uniform samplerCube lightMap;");
            src.push("uniform mat4 viewNormalMatrix;");
        }
        if (lightsState.reflectionMaps.length > 0) {
            src.push("uniform samplerCube reflectionMap;");
        }
        if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {
            src.push("uniform mat4 viewMatrix;");
        }

        //--------------------------------------------------------------------------------
        // SHADING FUNCTIONS
        //--------------------------------------------------------------------------------

        // CONSTANT DEFINITIONS

        src.push("#define PI 3.14159265359");
        src.push("#define RECIPROCAL_PI 0.31830988618");
        src.push("#define RECIPROCAL_PI2 0.15915494");
        src.push("#define EPSILON 1e-6");

        src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");

        // UTILITY DEFINITIONS

        src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");
        src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");
        src.push("}");

        // STRUCTURES

        src.push("struct IncidentLight {");
        src.push("   vec3 color;");
        src.push("   vec3 direction;");
        src.push("};");

        src.push("struct ReflectedLight {");
        src.push("   vec3 diffuse;");
        src.push("   vec3 specular;");
        src.push("};");

        src.push("struct Geometry {");
        src.push("   vec3 position;");
        src.push("   vec3 viewNormal;");
        src.push("   vec3 worldNormal;");
        src.push("   vec3 viewEyeDir;");
        src.push("};");

        src.push("struct Material {");
        src.push("   vec3    diffuseColor;");
        src.push("   float   specularRoughness;");
        src.push("   vec3    specularColor;");
        src.push("   float   shine;"); // Only used for Phong
        src.push("};");

        // COMMON UTILS

        if (phongMaterial) {

            if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {

                src.push("void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");

                if (lightsState.lightMaps.length > 0) {
                    src.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS$2[lightsState.lightMaps[0].encoding] + "(textureCube(lightMap, geometry.worldNormal)).rgb;");
                    src.push("   irradiance *= PI;");
                    src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
                    src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");
                }
                if (lightsState.reflectionMaps.length > 0) {
                    src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");
                    src.push("   vec3 radiance               = textureCube(reflectionMap, reflectVec).rgb * 0.2;");
                    src.push("   radiance *= PI;");
                    src.push("   reflectedLight.specular     += radiance;");
                }
                src.push("}");
            }

            src.push("void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
            src.push("   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));");
            src.push("   vec3 irradiance = dotNL * directLight.color * PI;");
            src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
            src.push("   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);");
            src.push("}");
        }

        if (metallicMaterial || specularMaterial) {

            // IRRADIANCE EVALUATION

            src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");
            src.push("   float r = ggxRoughness + 0.0001;");
            src.push("   return (2.0 / (r * r) - 2.0);");
            src.push("}");

            src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");
            src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");
            src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");
            src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");
            src.push("}");

            if (lightsState.reflectionMaps.length > 0) {
                src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");
                src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"); //TODO: a random factor - fix this
                src.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS$2[lightsState.reflectionMaps[0].encoding] + "(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;");
                src.push("  return envMapColor;");
                src.push("}");
            }

            // SPECULAR BRDF EVALUATION

            src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");
            src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");
            src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");
            src.push("}");

            src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");
            src.push("   float a2 = ( alpha * alpha );");
            src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
            src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
            src.push("   return 1.0 / ( gl * gv );");
            src.push("}");

            src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");
            src.push("   float a2 = ( alpha * alpha );");
            src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
            src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
            src.push("   return 0.5 / max( gv + gl, EPSILON );");
            src.push("}");

            src.push("float D_GGX(const in float alpha, const in float dotNH) {");
            src.push("   float a2 = ( alpha * alpha );");
            src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");
            src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");
            src.push("}");

            src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
            src.push("   float alpha = ( roughness * roughness );");
            src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");
            src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");
            src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");
            src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");
            src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");
            src.push("   vec3  F = F_Schlick( specularColor, dotLH );");
            src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");
            src.push("   float D = D_GGX( alpha, dotNH );");
            src.push("   return F * (G * D);");
            src.push("}");

            src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
            src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");
            src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");
            src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");
            src.push("   vec4 r = roughness * c0 + c1;");
            src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");
            src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");
            src.push("   return specularColor * AB.x + AB.y;");
            src.push("}");

            if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {

                src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
                if (lightsState.lightMaps.length > 0) {
                    src.push("   vec3 irradiance = sRGBToLinear(textureCube(lightMap, geometry.worldNormal)).rgb;");
                    src.push("   irradiance *= PI;");
                    src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
                    src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");
                    //   src.push("   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);");
                }
                if (lightsState.reflectionMaps.length > 0) {
                    src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");
                    src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
                    src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");
                    src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");
                    src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");
                    src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");
                }
                src.push("}");
            }

            // MAIN LIGHTING COMPUTATION FUNCTION

            src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
            src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");
            src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");
            src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
            src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");
            src.push("}");

        } // (metallicMaterial || specularMaterial)

    } // geometry.normals

    //--------------------------------------------------------------------------------
    // GEOMETRY INPUTS
    //--------------------------------------------------------------------------------

    src.push("varying vec3 vViewPosition;");

    if (geometryState.colors) {
        src.push("varying vec4 vColor;");
    }

    if (uvs &&
        ((normals && material._normalMap)
            || material._ambientMap
            || material._baseColorMap
            || material._diffuseMap
            || material._emissiveMap
            || material._metallicMap
            || material._roughnessMap
            || material._metallicRoughnessMap
            || material._specularMap
            || material._glossinessMap
            || material._specularGlossinessMap
            || material._occlusionMap
            || material._alphaMap)) {
        src.push("varying vec2 vUV;");
    }

    if (normals) {
        if (lightsState.lightMaps.length > 0) {
            src.push("varying vec3 vWorldNormal;");
        }
        src.push("varying vec3 vViewNormal;");
    }

    //--------------------------------------------------------------------------------
    // MATERIAL CHANNEL INPUTS
    //--------------------------------------------------------------------------------

    if (materialState.ambient) {
        src.push("uniform vec3 materialAmbient;");
    }
    if (materialState.baseColor) {
        src.push("uniform vec3 materialBaseColor;");
    }
    if (materialState.alpha !== undefined && materialState.alpha !== null) {
        src.push("uniform vec4 materialAlphaModeCutoff;"); // [alpha, alphaMode, alphaCutoff]
    }
    if (materialState.emissive) {
        src.push("uniform vec3 materialEmissive;");
    }
    if (materialState.diffuse) {
        src.push("uniform vec3 materialDiffuse;");
    }
    if (materialState.glossiness !== undefined && materialState.glossiness !== null) {
        src.push("uniform float materialGlossiness;");
    }
    if (materialState.shininess !== undefined && materialState.shininess !== null) {
        src.push("uniform float materialShininess;");  // Phong channel
    }
    if (materialState.specular) {
        src.push("uniform vec3 materialSpecular;");
    }
    if (materialState.metallic !== undefined && materialState.metallic !== null) {
        src.push("uniform float materialMetallic;");
    }
    if (materialState.roughness !== undefined && materialState.roughness !== null) {
        src.push("uniform float materialRoughness;");
    }
    if (materialState.specularF0 !== undefined && materialState.specularF0 !== null) {
        src.push("uniform float materialSpecularF0;");
    }

    //--------------------------------------------------------------------------------
    // MATERIAL TEXTURE INPUTS
    //--------------------------------------------------------------------------------

    if (uvs && material._ambientMap) {
        src.push("uniform sampler2D ambientMap;");
        if (material._ambientMap._state.matrix) {
            src.push("uniform mat4 ambientMapMatrix;");
        }
    }
    if (uvs && material._baseColorMap) {
        src.push("uniform sampler2D baseColorMap;");
        if (material._baseColorMap._state.matrix) {
            src.push("uniform mat4 baseColorMapMatrix;");
        }
    }
    if (uvs && material._diffuseMap) {
        src.push("uniform sampler2D diffuseMap;");
        if (material._diffuseMap._state.matrix) {
            src.push("uniform mat4 diffuseMapMatrix;");
        }
    }
    if (uvs && material._emissiveMap) {
        src.push("uniform sampler2D emissiveMap;");
        if (material._emissiveMap._state.matrix) {
            src.push("uniform mat4 emissiveMapMatrix;");
        }
    }
    if (normals && uvs && material._metallicMap) {
        src.push("uniform sampler2D metallicMap;");
        if (material._metallicMap._state.matrix) {
            src.push("uniform mat4 metallicMapMatrix;");
        }
    }
    if (normals && uvs && material._roughnessMap) {
        src.push("uniform sampler2D roughnessMap;");
        if (material._roughnessMap._state.matrix) {
            src.push("uniform mat4 roughnessMapMatrix;");
        }
    }
    if (normals && uvs && material._metallicRoughnessMap) {
        src.push("uniform sampler2D metallicRoughnessMap;");
        if (material._metallicRoughnessMap._state.matrix) {
            src.push("uniform mat4 metallicRoughnessMapMatrix;");
        }
    }
    if (normals && material._normalMap) {
        src.push("uniform sampler2D normalMap;");
        if (material._normalMap._state.matrix) {
            src.push("uniform mat4 normalMapMatrix;");
        }
        src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");
        src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");
        src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");
        src.push("      vec2 st0 = dFdx( uv.st );");
        src.push("      vec2 st1 = dFdy( uv.st );");
        src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");
        src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");
        src.push("      vec3 N = normalize( surf_norm );");
        src.push("      vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;");
        src.push("      mat3 tsn = mat3( S, T, N );");
        //     src.push("      mapN *= 3.0;");
        src.push("      return normalize( tsn * mapN );");
        src.push("}");
    }
    if (uvs && material._occlusionMap) {
        src.push("uniform sampler2D occlusionMap;");
        if (material._occlusionMap._state.matrix) {
            src.push("uniform mat4 occlusionMapMatrix;");
        }
    }
    if (uvs && material._alphaMap) {
        src.push("uniform sampler2D alphaMap;");
        if (material._alphaMap._state.matrix) {
            src.push("uniform mat4 alphaMapMatrix;");
        }
    }
    if (normals && uvs && material._specularMap) {
        src.push("uniform sampler2D specularMap;");
        if (material._specularMap._state.matrix) {
            src.push("uniform mat4 specularMapMatrix;");
        }
    }
    if (normals && uvs && material._glossinessMap) {
        src.push("uniform sampler2D glossinessMap;");
        if (material._glossinessMap._state.matrix) {
            src.push("uniform mat4 glossinessMapMatrix;");
        }
    }
    if (normals && uvs && material._specularGlossinessMap) {
        src.push("uniform sampler2D materialSpecularGlossinessMap;");
        if (material._specularGlossinessMap._state.matrix) {
            src.push("uniform mat4 materialSpecularGlossinessMapMatrix;");
        }
    }

    //--------------------------------------------------------------------------------
    // MATERIAL FRESNEL INPUTS
    //--------------------------------------------------------------------------------

    if (normals && (material._diffuseFresnel ||
        material._specularFresnel ||
        material._alphaFresnel ||
        material._emissiveFresnel ||
        material._reflectivityFresnel)) {
        src.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");
        src.push("    float fr = abs(dot(eyeDir, normal));");
        src.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
        src.push("    return pow(finalFr, power);");
        src.push("}");
        if (material._diffuseFresnel) {
            src.push("uniform float  diffuseFresnelCenterBias;");
            src.push("uniform float  diffuseFresnelEdgeBias;");
            src.push("uniform float  diffuseFresnelPower;");
            src.push("uniform vec3   diffuseFresnelCenterColor;");
            src.push("uniform vec3   diffuseFresnelEdgeColor;");
        }
        if (material._specularFresnel) {
            src.push("uniform float  specularFresnelCenterBias;");
            src.push("uniform float  specularFresnelEdgeBias;");
            src.push("uniform float  specularFresnelPower;");
            src.push("uniform vec3   specularFresnelCenterColor;");
            src.push("uniform vec3   specularFresnelEdgeColor;");
        }
        if (material._alphaFresnel) {
            src.push("uniform float  alphaFresnelCenterBias;");
            src.push("uniform float  alphaFresnelEdgeBias;");
            src.push("uniform float  alphaFresnelPower;");
            src.push("uniform vec3   alphaFresnelCenterColor;");
            src.push("uniform vec3   alphaFresnelEdgeColor;");
        }
        if (material._reflectivityFresnel) {
            src.push("uniform float  materialSpecularF0FresnelCenterBias;");
            src.push("uniform float  materialSpecularF0FresnelEdgeBias;");
            src.push("uniform float  materialSpecularF0FresnelPower;");
            src.push("uniform vec3   materialSpecularF0FresnelCenterColor;");
            src.push("uniform vec3   materialSpecularF0FresnelEdgeColor;");
        }
        if (material._emissiveFresnel) {
            src.push("uniform float  emissiveFresnelCenterBias;");
            src.push("uniform float  emissiveFresnelEdgeBias;");
            src.push("uniform float  emissiveFresnelPower;");
            src.push("uniform vec3   emissiveFresnelCenterColor;");
            src.push("uniform vec3   emissiveFresnelEdgeColor;");
        }
    }

    //--------------------------------------------------------------------------------
    // LIGHT SOURCES
    //--------------------------------------------------------------------------------

    src.push("uniform vec4   lightAmbient;");

    if (normals) {
        for (var i$1 = 0, len = lightsState.lights.length; i$1 < len; i$1++) { // Light sources
            var light$1 = lightsState.lights[i$1];
            if (light$1.type === "ambient") {
                continue;
            }
            src.push("uniform vec4 lightColor" + i$1 + ";");
            if (light$1.type === "point") {
                src.push("uniform vec3 lightAttenuation" + i$1 + ";");
            }
            if (light$1.type === "dir" && light$1.space === "view") {
                src.push("uniform vec3 lightDir" + i$1 + ";");
            }
            if (light$1.type === "point" && light$1.space === "view") {
                src.push("uniform vec3 lightPos" + i$1 + ";");
            } else {
                src.push("varying vec4 vViewLightReverseDirAndDist" + i$1 + ";");
            }
        }
    }

    if (receivesShadow) {

        // Variance castsShadow mapping filter

        // src.push("float linstep(float low, float high, float v){");
        // src.push("      return clamp((v-low)/(high-low), 0.0, 1.0);");
        // src.push("}");
        //
        // src.push("float VSM(sampler2D depths, vec2 uv, float compare){");
        // src.push("      vec2 moments = texture2D(depths, uv).xy;");
        // src.push("      float p = smoothstep(compare-0.02, compare, moments.x);");
        // src.push("      float variance = max(moments.y - moments.x*moments.x, -0.001);");
        // src.push("      float d = compare - moments.x;");
        // src.push("      float p_max = linstep(0.2, 1.0, variance / (variance + d*d));");
        // src.push("      return clamp(max(p, p_max), 0.0, 1.0);");
        // src.push("}");

        for (var i$2 = 0, len$1 = lightsState.lights.length; i$2 < len$1; i$2++) { // Light sources
            if (lightsState.lights[i$2].castsShadow) {
                src.push("varying vec4 vShadowPosFromLight" + i$2 + ";");
                src.push("uniform sampler2D shadowMap" + i$2 + ";");
            }
        }
    }

    src.push("uniform vec4 colorize;");

    //================================================================================
    // MAIN
    //================================================================================

    src.push("void main(void) {");

    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }

    if (geometryState.primitiveName === "points") {
        src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("float r = dot(cxy, cxy);");
        src.push("if (r > 1.0) {");
        src.push("   discard;");
        src.push("}");
    }

    src.push("float occlusion = 1.0;");

    if (materialState.ambient) {
        src.push("vec3 ambientColor = materialAmbient;");
    } else {
        src.push("vec3 ambientColor = vec3(1.0, 1.0, 1.0);");
    }

    if (materialState.diffuse) {
        src.push("vec3 diffuseColor = materialDiffuse;");
    } else if (materialState.baseColor) {
        src.push("vec3 diffuseColor = materialBaseColor;");
    } else {
        src.push("vec3 diffuseColor = vec3(1.0, 1.0, 1.0);");
    }

    if (geometryState.colors) {
        src.push("diffuseColor *= vColor.rgb;");
    }

    if (materialState.emissive) {
        src.push("vec3 emissiveColor = materialEmissive;"); // Emissive default is (0,0,0), so initializing here
    } else {
        src.push("vec3  emissiveColor = vec3(0.0, 0.0, 0.0);");
    }

    if (materialState.specular) {
        src.push("vec3 specular = materialSpecular;");
    } else {
        src.push("vec3 specular = vec3(1.0, 1.0, 1.0);");
    }

    if (materialState.alpha !== undefined) {
        src.push("float alpha = materialAlphaModeCutoff[0];");
    } else {
        src.push("float alpha = 1.0;");
    }

    if (geometryState.colors) {
        src.push("alpha *= vColor.a;");
    }

    if (materialState.glossiness !== undefined) {
        src.push("float glossiness = materialGlossiness;");
    } else {
        src.push("float glossiness = 1.0;");
    }

    if (materialState.metallic !== undefined) {
        src.push("float metallic = materialMetallic;");
    } else {
        src.push("float metallic = 1.0;");
    }

    if (materialState.roughness !== undefined) {
        src.push("float roughness = materialRoughness;");
    } else {
        src.push("float roughness = 1.0;");
    }

    if (materialState.specularF0 !== undefined) {
        src.push("float specularF0 = materialSpecularF0;");
    } else {
        src.push("float specularF0 = 1.0;");
    }

    //--------------------------------------------------------------------------------
    // TEXTURING
    //--------------------------------------------------------------------------------

    if (uvs && ((normals && material._normalMap)
        || material._ambientMap
        || material._baseColorMap
        || material._diffuseMap
        || material._occlusionMap
        || material._emissiveMap
        || material._metallicMap
        || material._roughnessMap
        || material._metallicRoughnessMap
        || material._specularMap
        || material._glossinessMap
        || material._specularGlossinessMap
        || material._alphaMap)) {
        src.push("vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);");
        src.push("vec2 textureCoord;");
    }

    if (uvs && material._ambientMap) {
        if (material._ambientMap._state.matrix) {
            src.push("textureCoord = (ambientMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("vec4 ambientTexel = texture2D(ambientMap, textureCoord).rgb;");
        src.push("ambientTexel = " + TEXTURE_DECODE_FUNCS$2[material._ambientMap._state.encoding] + "(ambientTexel);");
        src.push("ambientColor *= ambientTexel.rgb;");
    }

    if (uvs && material._diffuseMap) {
        if (material._diffuseMap._state.matrix) {
            src.push("textureCoord = (diffuseMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("vec4 diffuseTexel = texture2D(diffuseMap, textureCoord);");
        src.push("diffuseTexel = " + TEXTURE_DECODE_FUNCS$2[material._diffuseMap._state.encoding] + "(diffuseTexel);");
        src.push("diffuseColor *= diffuseTexel.rgb;");
        src.push("alpha *= diffuseTexel.a;");
    }

    if (uvs && material._baseColorMap) {
        if (material._baseColorMap._state.matrix) {
            src.push("textureCoord = (baseColorMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("vec4 baseColorTexel = texture2D(baseColorMap, textureCoord);");
        src.push("baseColorTexel = " + TEXTURE_DECODE_FUNCS$2[material._baseColorMap._state.encoding] + "(baseColorTexel);");
        src.push("diffuseColor *= baseColorTexel.rgb;");
        src.push("alpha *= baseColorTexel.a;");
    }

    if (uvs && material._emissiveMap) {
        if (material._emissiveMap._state.matrix) {
            src.push("textureCoord = (emissiveMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("vec4 emissiveTexel = texture2D(emissiveMap, textureCoord);");
        src.push("emissiveTexel = " + TEXTURE_DECODE_FUNCS$2[material._emissiveMap._state.encoding] + "(emissiveTexel);");
        src.push("emissiveColor = emissiveTexel.rgb;");
    }

    if (uvs && material._alphaMap) {
        if (material._alphaMap._state.matrix) {
            src.push("textureCoord = (alphaMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("alpha *= texture2D(alphaMap, textureCoord).r;");
    }

    if (uvs && material._occlusionMap) {
        if (material._occlusionMap._state.matrix) {
            src.push("textureCoord = (occlusionMapMatrix * texturePos).xy;");
        } else {
            src.push("textureCoord = texturePos.xy;");
        }
        src.push("occlusion *= texture2D(occlusionMap, textureCoord).r;");
    }

    if (normals && ((lightsState.lights.length > 0) || lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {

        //--------------------------------------------------------------------------------
        // SHADING
        //--------------------------------------------------------------------------------

        if (uvs && material._normalMap) {
            if (material._normalMap._state.matrix) {
                src.push("textureCoord = (normalMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );");
        } else {
            src.push("vec3 viewNormal = normalize(vViewNormal);");
        }

        if (uvs && material._specularMap) {
            if (material._specularMap._state.matrix) {
                src.push("textureCoord = (specularMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("specular *= texture2D(specularMap, textureCoord).rgb;");
        }

        if (uvs && material._glossinessMap) {
            if (material._glossinessMap._state.matrix) {
                src.push("textureCoord = (glossinessMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("glossiness *= texture2D(glossinessMap, textureCoord).r;");
        }

        if (uvs && material._specularGlossinessMap) {
            if (material._specularGlossinessMap._state.matrix) {
                src.push("textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec4 specGlossRGB = texture2D(materialSpecularGlossinessMap, textureCoord).rgba;"); // TODO: what if only RGB texture?
            src.push("specular *= specGlossRGB.rgb;");
            src.push("glossiness *= specGlossRGB.a;");
        }

        if (uvs && material._metallicMap) {
            if (material._metallicMap._state.matrix) {
                src.push("textureCoord = (metallicMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("metallic *= texture2D(metallicMap, textureCoord).r;");
        }

        if (uvs && material._roughnessMap) {
            if (material._roughnessMap._state.matrix) {
                src.push("textureCoord = (roughnessMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("roughness *= texture2D(roughnessMap, textureCoord).r;");
        }

        if (uvs && material._metallicRoughnessMap) {
            if (material._metallicRoughnessMap._state.matrix) {
                src.push("textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec3 metalRoughRGB = texture2D(metallicRoughnessMap, textureCoord).rgb;");
            src.push("metallic *= metalRoughRGB.b;");
            src.push("roughness *= metalRoughRGB.g;");
        }

        src.push("vec3 viewEyeDir = normalize(-vViewPosition);");

        if (material._diffuseFresnel) {
            src.push("float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);");
            src.push("diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);");
        }
        if (material._specularFresnel) {
            src.push("float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);");
            src.push("specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);");
        }
        if (material._alphaFresnel) {
            src.push("float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);");
            src.push("alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);");
        }
        if (material._emissiveFresnel) {
            src.push("float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);");
            src.push("emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);");
        }

        src.push("if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {"); // ie. (alphaMode == "mask" && alpha < alphaCutoff)
        src.push("   discard;"); // TODO: Discard earlier within this shader?
        src.push("}");

        // PREPARE INPUTS FOR SHADER FUNCTIONS

        src.push("IncidentLight  light;");
        src.push("Material       material;");
        src.push("Geometry       geometry;");
        src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");
        src.push("vec3           viewLightDir;");

        if (phongMaterial) {
            src.push("material.diffuseColor      = diffuseColor;");
            src.push("material.specularColor     = specular;");
            src.push("material.shine             = materialShininess;");
        }

        if (specularMaterial) {
            src.push("float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);"); // Energy conservation
            src.push("material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;");
            src.push("material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );");
            src.push("material.specularColor     = specular;");
        }

        if (metallicMaterial) {
            src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");
            src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");
            src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");
            src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);");
        }

        src.push("geometry.position      = vViewPosition;");
        if (lightsState.lightMaps.length > 0) {
            src.push("geometry.worldNormal   = normalize(vWorldNormal);");
        }
        src.push("geometry.viewNormal    = viewNormal;");
        src.push("geometry.viewEyeDir    = viewEyeDir;");

        // ENVIRONMENT AND REFLECTION MAP SHADING

        if ((phongMaterial) && (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {
            src.push("computePhongLightMapping(geometry, material, reflectedLight);");
        }

        if ((specularMaterial || metallicMaterial) && (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {
            src.push("computePBRLightMapping(geometry, material, reflectedLight);");
        }

        // LIGHT SOURCE SHADING

        src.push("float shadow = 1.0;");

        // if (receivesShadow) {
        //
        //     src.push("float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);");
        //     src.push("float illuminated = VSM(sLightDepth, lightUV, lightDepth2);");
        //
        src.push("float shadowAcneRemover = 0.007;");
        src.push("vec3 fragmentDepth;");
        src.push("float texelSize = 1.0 / 1024.0;");
        src.push("float amountInLight = 0.0;");
        src.push("vec3 shadowCoord;");
        src.push('vec4 rgbaDepth;');
        src.push("float depth;");
        for (var i$3 = 0, len$2 = lightsState.lights.length; i$3 < len$2; i$3++) {

            var light$2 = lightsState.lights[i$3];

            if (light$2.type === "ambient") {
                continue;
            }
            if (light$2.type === "dir" && light$2.space === "view") {
                src.push("viewLightDir = -normalize(lightDir" + i$3 + ");");
            } else if (light$2.type === "point" && light$2.space === "view") {
                src.push("viewLightDir = normalize(lightPos" + i$3 + " - vViewPosition);");
                //src.push("tmpVec3 = lightPos" + i + ".xyz - viewPosition.xyz;");
                //src.push("lightDist = abs(length(tmpVec3));");
            } else {
                src.push("viewLightDir = normalize(vViewLightReverseDirAndDist" + i$3 + ".xyz);"); // If normal mapping, the fragment->light vector will be in tangent space
            }

            if (receivesShadow && light$2.castsShadow) {

                // if (true) {
                //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
                //     src.push("lightDepth2 = clamp(length(vec3[0.0, 20.0, 20.0])/40.0, 0.0, 1.0);");
                //     src.push("castsShadow *= VSM(shadowMap' + i + ', shadowCoord, lightDepth2);");
                // }
                //
                // if (false) {
                //
                // PCF

                src.push("shadow = 0.0;");

                src.push("fragmentDepth = vShadowPosFromLight" + i$3 + ".xyz;");
                src.push("fragmentDepth.z -= shadowAcneRemover;");
                src.push("for (int x = -3; x <= 3; x++) {");
                src.push("  for (int y = -3; y <= 3; y++) {");
                src.push("      float texelDepth = unpackDepth(texture2D(shadowMap" + i$3 + ", fragmentDepth.xy + vec2(x, y) * texelSize));");
                src.push("      if (fragmentDepth.z < texelDepth) {");
                src.push("          shadow += 1.0;");
                src.push("      }");
                src.push("  }");
                src.push("}");

                src.push("shadow = shadow / 9.0;");

                src.push("light.color =  lightColor" + i$3 + ".rgb * (lightColor" + i$3 + ".a * shadow);"); // a is intensity
                //
                // }
                //
                // if (false){
                //
                //     src.push("shadow = 1.0;");
                //
                //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
                //
                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.94201624, -0.39906216 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.94558609, -0.76890725 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.094184101, -0.92938870 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.34495938, 0.29387760 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                //
                //     src.push("light.color =  lightColor" + i + ".rgb * (lightColor" + i + ".a * shadow);");
                // }
            } else {
                src.push("light.color =  lightColor" + i$3 + ".rgb * (lightColor" + i$3 + ".a );"); // a is intensity
            }

            src.push("light.direction = viewLightDir;");

            if (phongMaterial) {
                src.push("computePhongLighting(light, geometry, material, reflectedLight);");
            }

            if (specularMaterial || metallicMaterial) {
                src.push("computePBRLighting(light, geometry, material, reflectedLight);");
            }
        }

        //src.push("reflectedLight.diffuse *= shadow;");

        // COMBINE TERMS

        if (phongMaterial) {
            src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * diffuseColor) + ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;");

        } else {
            src.push("vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (occlusion * reflectedLight.specular) + emissiveColor;");
        }

    } else {

        //--------------------------------------------------------------------------------
        // NO SHADING - EMISSIVE and AMBIENT ONLY
        //--------------------------------------------------------------------------------

        src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");

        src.push("vec3 outgoingLight = emissiveColor + ambientColor;");
    }

    src.push("gl_FragColor = vec4(outgoingLight, alpha) * colorize;");

    if (gammaOutput) {
        src.push("gl_FragColor = linearToGamma(gl_FragColor, gammaFactor);");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");

    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var tempVec3a$Y = math.vec3();

var ids$2 = new Map({});

/**
 * @private
 */
var DrawRenderer = function (hash, mesh) {
    this.id = ids$2.addItem({});
    this._hash = hash;
    this._scene = mesh.scene;
    this._useCount = 0;
    this._shaderSource = new DrawShaderSource(mesh);
    this._allocate(mesh);
};

var drawRenderers = {};

DrawRenderer.get = function (mesh) {
    var scene = mesh.scene;
    var hash = [
        scene.canvas.canvas.id,
        (scene.gammaInput ? "gi;" : ";") + (scene.gammaOutput ? "go" : ""),
        scene._lightsState.getHash(),
        scene._sectionPlanesState.getHash(),
        mesh._geometry._state.hash,
        mesh._material._state.hash,
        mesh._state.drawHash
    ].join(";");
    var renderer = drawRenderers[hash];
    if (!renderer) {
        renderer = new DrawRenderer(hash, mesh);
        if (renderer.errors) {
            console.log(renderer.errors.join("\n"));
            return null;
        }
        drawRenderers[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

DrawRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        ids$2.removeItem(this.id);
        if (this._program) {
            this._program.destroy();
        }
        delete drawRenderers[this._hash];
        stats.memory.programs--;
    }
};

DrawRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

DrawRenderer.prototype.drawMesh = function (frameCtx, mesh) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var maxTextureUnits = WEBGL_INFO$1.MAX_TEXTURE_UNITS;
    var scene = mesh.scene;
    var material = mesh._material;
    var gl = scene.canvas.gl;
    var program = this._program;
    var meshState = mesh._state;
    var materialState = mesh._material._state;
    var geometryState = mesh._geometry._state;
    var camera = scene.camera;
    var rtcCenter = mesh.rtcCenter;

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$Y) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    if (materialState.id !== this._lastMaterialId) {

        frameCtx.textureUnit = this._baseTextureUnit;

        var backfaces = materialState.backfaces;
        if (frameCtx.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }

        var frontface = materialState.frontface;
        if (frameCtx.frontface !== frontface) {
            if (frontface) {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frameCtx.frontface = frontface;
        }

        if (frameCtx.lineWidth !== materialState.lineWidth) {
            gl.lineWidth(materialState.lineWidth);
            frameCtx.lineWidth = materialState.lineWidth;
        }

        if (this._uPointSize) {
            gl.uniform1f(this._uPointSize, materialState.pointSize);
        }

        switch (materialState.type) {
            case "LambertMaterial":
                if (this._uMaterialAmbient) {
                    gl.uniform3fv(this._uMaterialAmbient, materialState.ambient);
                }
                if (this._uMaterialColor) {
                    gl.uniform4f(this._uMaterialColor, materialState.color[0], materialState.color[1], materialState.color[2], materialState.alpha);
                }
                if (this._uMaterialEmissive) {
                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);
                }
                break;

            case "PhongMaterial":
                if (this._uMaterialShininess) {
                    gl.uniform1f(this._uMaterialShininess, materialState.shininess);
                }
                if (this._uMaterialAmbient) {
                    gl.uniform3fv(this._uMaterialAmbient, materialState.ambient);
                }
                if (this._uMaterialDiffuse) {
                    gl.uniform3fv(this._uMaterialDiffuse, materialState.diffuse);
                }
                if (this._uMaterialSpecular) {
                    gl.uniform3fv(this._uMaterialSpecular, materialState.specular);
                }
                if (this._uMaterialEmissive) {
                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);
                }
                if (this._uAlphaModeCutoff) {
                    gl.uniform4f(
                        this._uAlphaModeCutoff,
                        1.0 * materialState.alpha,
                        materialState.alphaMode === 1 ? 1.0 : 0.0,
                        materialState.alphaCutoff,
                        0);
                }
                if (material._ambientMap && material._ambientMap._state.texture && this._uMaterialAmbientMap) {
                    program.bindTexture(this._uMaterialAmbientMap, material._ambientMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uMaterialAmbientMapMatrix) {
                        gl.uniformMatrix4fv(this._uMaterialAmbientMapMatrix, false, material._ambientMap._state.matrix);
                    }
                }
                if (material._diffuseMap && material._diffuseMap._state.texture && this._uDiffuseMap) {
                    program.bindTexture(this._uDiffuseMap, material._diffuseMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uDiffuseMapMatrix) {
                        gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, material._diffuseMap._state.matrix);
                    }
                }
                if (material._specularMap && material._specularMap._state.texture && this._uSpecularMap) {
                    program.bindTexture(this._uSpecularMap, material._specularMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uSpecularMapMatrix) {
                        gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, material._specularMap._state.matrix);
                    }
                }
                if (material._emissiveMap && material._emissiveMap._state.texture && this._uEmissiveMap) {
                    program.bindTexture(this._uEmissiveMap, material._emissiveMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uEmissiveMapMatrix) {
                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, material._emissiveMap._state.matrix);
                    }
                }
                if (material._alphaMap && material._alphaMap._state.texture && this._uAlphaMap) {
                    program.bindTexture(this._uAlphaMap, material._alphaMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uAlphaMapMatrix) {
                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, material._alphaMap._state.matrix);
                    }
                }
                if (material._reflectivityMap && material._reflectivityMap._state.texture && this._uReflectivityMap) {
                    program.bindTexture(this._uReflectivityMap, material._reflectivityMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    if (this._uReflectivityMapMatrix) {
                        gl.uniformMatrix4fv(this._uReflectivityMapMatrix, false, material._reflectivityMap._state.matrix);
                    }
                }
                if (material._normalMap && material._normalMap._state.texture && this._uNormalMap) {
                    program.bindTexture(this._uNormalMap, material._normalMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uNormalMapMatrix) {
                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, material._normalMap._state.matrix);
                    }
                }
                if (material._occlusionMap && material._occlusionMap._state.texture && this._uOcclusionMap) {
                    program.bindTexture(this._uOcclusionMap, material._occlusionMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uOcclusionMapMatrix) {
                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, material._occlusionMap._state.matrix);
                    }
                }
                if (material._diffuseFresnel) {
                    if (this._uDiffuseFresnelEdgeBias) {
                        gl.uniform1f(this._uDiffuseFresnelEdgeBias, material._diffuseFresnel.edgeBias);
                    }
                    if (this._uDiffuseFresnelCenterBias) {
                        gl.uniform1f(this._uDiffuseFresnelCenterBias, material._diffuseFresnel.centerBias);
                    }
                    if (this._uDiffuseFresnelEdgeColor) {
                        gl.uniform3fv(this._uDiffuseFresnelEdgeColor, material._diffuseFresnel.edgeColor);
                    }
                    if (this._uDiffuseFresnelCenterColor) {
                        gl.uniform3fv(this._uDiffuseFresnelCenterColor, material._diffuseFresnel.centerColor);
                    }
                    if (this._uDiffuseFresnelPower) {
                        gl.uniform1f(this._uDiffuseFresnelPower, material._diffuseFresnel.power);
                    }
                }
                if (material._specularFresnel) {
                    if (this._uSpecularFresnelEdgeBias) {
                        gl.uniform1f(this._uSpecularFresnelEdgeBias, material._specularFresnel.edgeBias);
                    }
                    if (this._uSpecularFresnelCenterBias) {
                        gl.uniform1f(this._uSpecularFresnelCenterBias, material._specularFresnel.centerBias);
                    }
                    if (this._uSpecularFresnelEdgeColor) {
                        gl.uniform3fv(this._uSpecularFresnelEdgeColor, material._specularFresnel.edgeColor);
                    }
                    if (this._uSpecularFresnelCenterColor) {
                        gl.uniform3fv(this._uSpecularFresnelCenterColor, material._specularFresnel.centerColor);
                    }
                    if (this._uSpecularFresnelPower) {
                        gl.uniform1f(this._uSpecularFresnelPower, material._specularFresnel.power);
                    }
                }
                if (material._alphaFresnel) {
                    if (this._uAlphaFresnelEdgeBias) {
                        gl.uniform1f(this._uAlphaFresnelEdgeBias, material._alphaFresnel.edgeBias);
                    }
                    if (this._uAlphaFresnelCenterBias) {
                        gl.uniform1f(this._uAlphaFresnelCenterBias, material._alphaFresnel.centerBias);
                    }
                    if (this._uAlphaFresnelEdgeColor) {
                        gl.uniform3fv(this._uAlphaFresnelEdgeColor, material._alphaFresnel.edgeColor);
                    }
                    if (this._uAlphaFresnelCenterColor) {
                        gl.uniform3fv(this._uAlphaFresnelCenterColor, material._alphaFresnel.centerColor);
                    }
                    if (this._uAlphaFresnelPower) {
                        gl.uniform1f(this._uAlphaFresnelPower, material._alphaFresnel.power);
                    }
                }
                if (material._reflectivityFresnel) {
                    if (this._uReflectivityFresnelEdgeBias) {
                        gl.uniform1f(this._uReflectivityFresnelEdgeBias, material._reflectivityFresnel.edgeBias);
                    }
                    if (this._uReflectivityFresnelCenterBias) {
                        gl.uniform1f(this._uReflectivityFresnelCenterBias, material._reflectivityFresnel.centerBias);
                    }
                    if (this._uReflectivityFresnelEdgeColor) {
                        gl.uniform3fv(this._uReflectivityFresnelEdgeColor, material._reflectivityFresnel.edgeColor);
                    }
                    if (this._uReflectivityFresnelCenterColor) {
                        gl.uniform3fv(this._uReflectivityFresnelCenterColor, material._reflectivityFresnel.centerColor);
                    }
                    if (this._uReflectivityFresnelPower) {
                        gl.uniform1f(this._uReflectivityFresnelPower, material._reflectivityFresnel.power);
                    }
                }
                if (material._emissiveFresnel) {
                    if (this._uEmissiveFresnelEdgeBias) {
                        gl.uniform1f(this._uEmissiveFresnelEdgeBias, material._emissiveFresnel.edgeBias);
                    }
                    if (this._uEmissiveFresnelCenterBias) {
                        gl.uniform1f(this._uEmissiveFresnelCenterBias, material._emissiveFresnel.centerBias);
                    }
                    if (this._uEmissiveFresnelEdgeColor) {
                        gl.uniform3fv(this._uEmissiveFresnelEdgeColor, material._emissiveFresnel.edgeColor);
                    }
                    if (this._uEmissiveFresnelCenterColor) {
                        gl.uniform3fv(this._uEmissiveFresnelCenterColor, material._emissiveFresnel.centerColor);
                    }
                    if (this._uEmissiveFresnelPower) {
                        gl.uniform1f(this._uEmissiveFresnelPower, material._emissiveFresnel.power);
                    }
                }
                break;

            case "MetallicMaterial":
                if (this._uBaseColor) {
                    gl.uniform3fv(this._uBaseColor, materialState.baseColor);
                }
                if (this._uMaterialMetallic) {
                    gl.uniform1f(this._uMaterialMetallic, materialState.metallic);
                }
                if (this._uMaterialRoughness) {
                    gl.uniform1f(this._uMaterialRoughness, materialState.roughness);
                }
                if (this._uMaterialSpecularF0) {
                    gl.uniform1f(this._uMaterialSpecularF0, materialState.specularF0);
                }
                if (this._uMaterialEmissive) {
                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);
                }
                if (this._uAlphaModeCutoff) {
                    gl.uniform4f(
                        this._uAlphaModeCutoff,
                        1.0 * materialState.alpha,
                        materialState.alphaMode === 1 ? 1.0 : 0.0,
                        materialState.alphaCutoff,
                        0.0);
                }
                var baseColorMap = material._baseColorMap;
                if (baseColorMap && baseColorMap._state.texture && this._uBaseColorMap) {
                    program.bindTexture(this._uBaseColorMap, baseColorMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uBaseColorMapMatrix) {
                        gl.uniformMatrix4fv(this._uBaseColorMapMatrix, false, baseColorMap._state.matrix);
                    }
                }
                var metallicMap = material._metallicMap;
                if (metallicMap && metallicMap._state.texture && this._uMetallicMap) {
                    program.bindTexture(this._uMetallicMap, metallicMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uMetallicMapMatrix) {
                        gl.uniformMatrix4fv(this._uMetallicMapMatrix, false, metallicMap._state.matrix);
                    }
                }
                var roughnessMap = material._roughnessMap;
                if (roughnessMap && roughnessMap._state.texture && this._uRoughnessMap) {
                    program.bindTexture(this._uRoughnessMap, roughnessMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uRoughnessMapMatrix) {
                        gl.uniformMatrix4fv(this._uRoughnessMapMatrix, false, roughnessMap._state.matrix);
                    }
                }
                var metallicRoughnessMap = material._metallicRoughnessMap;
                if (metallicRoughnessMap && metallicRoughnessMap._state.texture && this._uMetallicRoughnessMap) {
                    program.bindTexture(this._uMetallicRoughnessMap, metallicRoughnessMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uMetallicRoughnessMapMatrix) {
                        gl.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix, false, metallicRoughnessMap._state.matrix);
                    }
                }
                var emissiveMap = material._emissiveMap;
                if (emissiveMap && emissiveMap._state.texture && this._uEmissiveMap) {
                    program.bindTexture(this._uEmissiveMap, emissiveMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uEmissiveMapMatrix) {
                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, emissiveMap._state.matrix);
                    }
                }
                var occlusionMap = material._occlusionMap;
                if (occlusionMap && material._occlusionMap._state.texture && this._uOcclusionMap) {
                    program.bindTexture(this._uOcclusionMap, occlusionMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uOcclusionMapMatrix) {
                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, occlusionMap._state.matrix);
                    }
                }
                var alphaMap = material._alphaMap;
                if (alphaMap && alphaMap._state.texture && this._uAlphaMap) {
                    program.bindTexture(this._uAlphaMap, alphaMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uAlphaMapMatrix) {
                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, alphaMap._state.matrix);
                    }
                }
                var normalMap = material._normalMap;
                if (normalMap && normalMap._state.texture && this._uNormalMap) {
                    program.bindTexture(this._uNormalMap, normalMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uNormalMapMatrix) {
                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, normalMap._state.matrix);
                    }
                }
                break;

            case "SpecularMaterial":
                if (this._uMaterialDiffuse) {
                    gl.uniform3fv(this._uMaterialDiffuse, materialState.diffuse);
                }
                if (this._uMaterialSpecular) {
                    gl.uniform3fv(this._uMaterialSpecular, materialState.specular);
                }
                if (this._uMaterialGlossiness) {
                    gl.uniform1f(this._uMaterialGlossiness, materialState.glossiness);
                }
                if (this._uMaterialReflectivity) {
                    gl.uniform1f(this._uMaterialReflectivity, materialState.reflectivity);
                }
                if (this._uMaterialEmissive) {
                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);
                }
                if (this._uAlphaModeCutoff) {
                    gl.uniform4f(
                        this._uAlphaModeCutoff,
                        1.0 * materialState.alpha,
                        materialState.alphaMode === 1 ? 1.0 : 0.0,
                        materialState.alphaCutoff,
                        0.0);
                }
                var diffuseMap = material._diffuseMap;
                if (diffuseMap && diffuseMap._state.texture && this._uDiffuseMap) {
                    program.bindTexture(this._uDiffuseMap, diffuseMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uDiffuseMapMatrix) {
                        gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, diffuseMap._state.matrix);
                    }
                }
                var specularMap = material._specularMap;
                if (specularMap && specularMap._state.texture && this._uSpecularMap) {
                    program.bindTexture(this._uSpecularMap, specularMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uSpecularMapMatrix) {
                        gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, specularMap._state.matrix);
                    }
                }
                var glossinessMap = material._glossinessMap;
                if (glossinessMap && glossinessMap._state.texture && this._uGlossinessMap) {
                    program.bindTexture(this._uGlossinessMap, glossinessMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uGlossinessMapMatrix) {
                        gl.uniformMatrix4fv(this._uGlossinessMapMatrix, false, glossinessMap._state.matrix);
                    }
                }
                var specularGlossinessMap = material._specularGlossinessMap;
                if (specularGlossinessMap && specularGlossinessMap._state.texture && this._uSpecularGlossinessMap) {
                    program.bindTexture(this._uSpecularGlossinessMap, specularGlossinessMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uSpecularGlossinessMapMatrix) {
                        gl.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix, false, specularGlossinessMap._state.matrix);
                    }
                }
                var emissiveMap = material._emissiveMap;
                if (emissiveMap && emissiveMap._state.texture && this._uEmissiveMap) {
                    program.bindTexture(this._uEmissiveMap, emissiveMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uEmissiveMapMatrix) {
                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, emissiveMap._state.matrix);
                    }
                }
                var occlusionMap = material._occlusionMap;
                if (occlusionMap && occlusionMap._state.texture && this._uOcclusionMap) {
                    program.bindTexture(this._uOcclusionMap, occlusionMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uOcclusionMapMatrix) {
                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, occlusionMap._state.matrix);
                    }
                }
                var alphaMap = material._alphaMap;
                if (alphaMap && alphaMap._state.texture && this._uAlphaMap) {
                    program.bindTexture(this._uAlphaMap, alphaMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uAlphaMapMatrix) {
                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, alphaMap._state.matrix);
                    }
                }
                var normalMap = material._normalMap;
                if (normalMap && normalMap._state.texture && this._uNormalMap) {
                    program.bindTexture(this._uNormalMap, normalMap._state.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                    if (this._uNormalMapMatrix) {
                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, normalMap._state.matrix);
                    }
                }
                break;
        }
        this._lastMaterialId = materialState.id;
    }

    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);
    if (this._uModelNormalMatrix) {
        gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, mesh.worldNormalMatrix);
    }

    if (this._uClippable) {
        gl.uniform1i(this._uClippable, meshState.clippable);
    }

    if (this._uColorize) {
        var colorize = meshState.colorize;
        var lastColorize = this._lastColorize;
        if (lastColorize[0] !== colorize[0] ||
            lastColorize[1] !== colorize[1] ||
            lastColorize[2] !== colorize[2] ||
            lastColorize[3] !== colorize[3]) {
            gl.uniform4fv(this._uColorize, colorize);
            lastColorize[0] = colorize[0];
            lastColorize[1] = colorize[1];
            lastColorize[2] = colorize[2];
            lastColorize[3] = colorize[3];
        }
    }

    gl.uniform3fv(this._uOffset, meshState.offset);

    // Bind VBOs

    if (geometryState.id !== this._lastGeometryId) {
        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        }
        if (this._uUVDecodeMatrix) {
            gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometryState.uvDecodeMatrix);
        }
        if (this._aPosition) {
            this._aPosition.bindArrayBuffer(geometryState.positionsBuf);
            frameCtx.bindArray++;
        }
        if (this._aNormal) {
            this._aNormal.bindArrayBuffer(geometryState.normalsBuf);
            frameCtx.bindArray++;
        }
        if (this._aUV) {
            this._aUV.bindArrayBuffer(geometryState.uvBuf);
            frameCtx.bindArray++;
        }
        if (this._aColor) {
            this._aColor.bindArrayBuffer(geometryState.colorsBuf);
            frameCtx.bindArray++;
        }
        if (this._aFlags) {
            this._aFlags.bindArrayBuffer(geometryState.flagsBuf);
            frameCtx.bindArray++;
        }
        if (geometryState.indicesBuf) {
            geometryState.indicesBuf.bind();
            frameCtx.bindArray++;
        }
        this._lastGeometryId = geometryState.id;
    }

    // Draw (indices bound in prev step)

    if (geometryState.indicesBuf) {
        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
        frameCtx.drawElements++;
    } else if (geometryState.positions) {
        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);
        frameCtx.drawArrays++;
    }
};

DrawRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    var material = mesh._material;
    var lightsState = scene._lightsState;
    var sectionPlanesState = scene._sectionPlanesState;
    var materialState = mesh._material._state;

    this._program = new Program(gl, this._shaderSource);
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uUVDecodeMatrix = program.getLocation("uvDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uModelNormalMatrix = program.getLocation("modelNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uGammaFactor = program.getLocation("gammaFactor");
    this._uLightAmbient = [];
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];
    this._uShadowViewMatrix = [];
    this._uShadowProjMatrix = [];

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {

            case "ambient":
                this._uLightAmbient[i] = program.getLocation("lightAmbient");
                break;

            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;

            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;

            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }

        if (light.castsShadow) {
            this._uShadowViewMatrix[i] = program.getLocation("shadowViewMatrix" + i);
            this._uShadowProjMatrix[i] = program.getLocation("shadowProjMatrix" + i);
        }
    }

    if (lightsState.lightMaps.length > 0) {
        this._uLightMap = "lightMap";
    }

    if (lightsState.reflectionMaps.length > 0) {
        this._uReflectionMap = "reflectionMap";
    }

    this._uSectionPlanes = [];
    var sectionPlanes = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._uPointSize = program.getLocation("pointSize");

    switch (materialState.type) {
        case "LambertMaterial":
            this._uMaterialColor = program.getLocation("materialColor");
            this._uMaterialEmissive = program.getLocation("materialEmissive");
            this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
            break;

        case "PhongMaterial":
            this._uMaterialAmbient = program.getLocation("materialAmbient");
            this._uMaterialDiffuse = program.getLocation("materialDiffuse");
            this._uMaterialSpecular = program.getLocation("materialSpecular");
            this._uMaterialEmissive = program.getLocation("materialEmissive");
            this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
            this._uMaterialShininess = program.getLocation("materialShininess");
            if (material._ambientMap) {
                this._uMaterialAmbientMap = "ambientMap";
                this._uMaterialAmbientMapMatrix = program.getLocation("ambientMapMatrix");
            }
            if (material._diffuseMap) {
                this._uDiffuseMap = "diffuseMap";
                this._uDiffuseMapMatrix = program.getLocation("diffuseMapMatrix");
            }
            if (material._specularMap) {
                this._uSpecularMap = "specularMap";
                this._uSpecularMapMatrix = program.getLocation("specularMapMatrix");
            }
            if (material._emissiveMap) {
                this._uEmissiveMap = "emissiveMap";
                this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
            }
            if (material._alphaMap) {
                this._uAlphaMap = "alphaMap";
                this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
            }
            if (material._reflectivityMap) {
                this._uReflectivityMap = "reflectivityMap";
                this._uReflectivityMapMatrix = program.getLocation("reflectivityMapMatrix");
            }
            if (material._normalMap) {
                this._uNormalMap = "normalMap";
                this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
            }
            if (material._occlusionMap) {
                this._uOcclusionMap = "occlusionMap";
                this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
            }
            if (material._diffuseFresnel) {
                this._uDiffuseFresnelEdgeBias = program.getLocation("diffuseFresnelEdgeBias");
                this._uDiffuseFresnelCenterBias = program.getLocation("diffuseFresnelCenterBias");
                this._uDiffuseFresnelEdgeColor = program.getLocation("diffuseFresnelEdgeColor");
                this._uDiffuseFresnelCenterColor = program.getLocation("diffuseFresnelCenterColor");
                this._uDiffuseFresnelPower = program.getLocation("diffuseFresnelPower");
            }
            if (material._specularFresnel) {
                this._uSpecularFresnelEdgeBias = program.getLocation("specularFresnelEdgeBias");
                this._uSpecularFresnelCenterBias = program.getLocation("specularFresnelCenterBias");
                this._uSpecularFresnelEdgeColor = program.getLocation("specularFresnelEdgeColor");
                this._uSpecularFresnelCenterColor = program.getLocation("specularFresnelCenterColor");
                this._uSpecularFresnelPower = program.getLocation("specularFresnelPower");
            }
            if (material._alphaFresnel) {
                this._uAlphaFresnelEdgeBias = program.getLocation("alphaFresnelEdgeBias");
                this._uAlphaFresnelCenterBias = program.getLocation("alphaFresnelCenterBias");
                this._uAlphaFresnelEdgeColor = program.getLocation("alphaFresnelEdgeColor");
                this._uAlphaFresnelCenterColor = program.getLocation("alphaFresnelCenterColor");
                this._uAlphaFresnelPower = program.getLocation("alphaFresnelPower");
            }
            if (material._reflectivityFresnel) {
                this._uReflectivityFresnelEdgeBias = program.getLocation("reflectivityFresnelEdgeBias");
                this._uReflectivityFresnelCenterBias = program.getLocation("reflectivityFresnelCenterBias");
                this._uReflectivityFresnelEdgeColor = program.getLocation("reflectivityFresnelEdgeColor");
                this._uReflectivityFresnelCenterColor = program.getLocation("reflectivityFresnelCenterColor");
                this._uReflectivityFresnelPower = program.getLocation("reflectivityFresnelPower");
            }
            if (material._emissiveFresnel) {
                this._uEmissiveFresnelEdgeBias = program.getLocation("emissiveFresnelEdgeBias");
                this._uEmissiveFresnelCenterBias = program.getLocation("emissiveFresnelCenterBias");
                this._uEmissiveFresnelEdgeColor = program.getLocation("emissiveFresnelEdgeColor");
                this._uEmissiveFresnelCenterColor = program.getLocation("emissiveFresnelCenterColor");
                this._uEmissiveFresnelPower = program.getLocation("emissiveFresnelPower");
            }
            break;

        case "MetallicMaterial":
            this._uBaseColor = program.getLocation("materialBaseColor");
            this._uMaterialMetallic = program.getLocation("materialMetallic");
            this._uMaterialRoughness = program.getLocation("materialRoughness");
            this._uMaterialSpecularF0 = program.getLocation("materialSpecularF0");
            this._uMaterialEmissive = program.getLocation("materialEmissive");
            this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
            if (material._baseColorMap) {
                this._uBaseColorMap = "baseColorMap";
                this._uBaseColorMapMatrix = program.getLocation("baseColorMapMatrix");
            }
            if (material._metallicMap) {
                this._uMetallicMap = "metallicMap";
                this._uMetallicMapMatrix = program.getLocation("metallicMapMatrix");
            }
            if (material._roughnessMap) {
                this._uRoughnessMap = "roughnessMap";
                this._uRoughnessMapMatrix = program.getLocation("roughnessMapMatrix");
            }
            if (material._metallicRoughnessMap) {
                this._uMetallicRoughnessMap = "metallicRoughnessMap";
                this._uMetallicRoughnessMapMatrix = program.getLocation("metallicRoughnessMapMatrix");
            }
            if (material._emissiveMap) {
                this._uEmissiveMap = "emissiveMap";
                this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
            }
            if (material._occlusionMap) {
                this._uOcclusionMap = "occlusionMap";
                this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
            }
            if (material._alphaMap) {
                this._uAlphaMap = "alphaMap";
                this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
            }
            if (material._normalMap) {
                this._uNormalMap = "normalMap";
                this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
            }
            break;

        case "SpecularMaterial":
            this._uMaterialDiffuse = program.getLocation("materialDiffuse");
            this._uMaterialSpecular = program.getLocation("materialSpecular");
            this._uMaterialGlossiness = program.getLocation("materialGlossiness");
            this._uMaterialReflectivity = program.getLocation("reflectivityFresnel");
            this._uMaterialEmissive = program.getLocation("materialEmissive");
            this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
            if (material._diffuseMap) {
                this._uDiffuseMap = "diffuseMap";
                this._uDiffuseMapMatrix = program.getLocation("diffuseMapMatrix");
            }
            if (material._specularMap) {
                this._uSpecularMap = "specularMap";
                this._uSpecularMapMatrix = program.getLocation("specularMapMatrix");
            }
            if (material._glossinessMap) {
                this._uGlossinessMap = "glossinessMap";
                this._uGlossinessMapMatrix = program.getLocation("glossinessMapMatrix");
            }
            if (material._specularGlossinessMap) {
                this._uSpecularGlossinessMap = "materialSpecularGlossinessMap";
                this._uSpecularGlossinessMapMatrix = program.getLocation("materialSpecularGlossinessMapMatrix");
            }
            if (material._emissiveMap) {
                this._uEmissiveMap = "emissiveMap";
                this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
            }
            if (material._occlusionMap) {
                this._uOcclusionMap = "occlusionMap";
                this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
            }
            if (material._alphaMap) {
                this._uAlphaMap = "alphaMap";
                this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
            }
            if (material._normalMap) {
                this._uNormalMap = "normalMap";
                this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
            }
            break;
    }

    this._aPosition = program.getAttribute("position");
    this._aNormal = program.getAttribute("normal");
    this._aUV = program.getAttribute("uv");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");

    this._uClippable = program.getLocation("clippable");
    this._uColorize = program.getLocation("colorize");
    this._uOffset = program.getLocation("offset");

    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;

    this._lastColorize = new Float32Array(4);

    this._baseTextureUnit = 0;

};

DrawRenderer.prototype._bindProgram = function (frameCtx) {

    var maxTextureUnits = WEBGL_INFO$1.MAX_TEXTURE_UNITS;
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;
    var project = scene.camera.project;
    var light;

    var program = this._program;

    program.bind();

    frameCtx.useProgram++;
    frameCtx.textureUnit = 0;

    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;

    this._lastColorize[0] = -1;
    this._lastColorize[1] = -1;
    this._lastColorize[2] = -1;
    this._lastColorize[3] = -1;

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    for (var i = 0, len = lightsState.lights.length; i < len; i++) {

        light = lightsState.lights[i];

        if (this._uLightAmbient[i]) {
            gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);

        } else {

            if (this._uLightColor[i]) {
                gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
            }

            if (this._uLightPos[i]) {
                gl.uniform3fv(this._uLightPos[i], light.pos);
                if (this._uLightAttenuation[i]) {
                    gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
                }
            }

            if (this._uLightDir[i]) {
                gl.uniform3fv(this._uLightDir[i], light.dir);
            }

            if (light.castsShadow) {
                if (this._uShadowViewMatrix[i]) {
                    gl.uniformMatrix4fv(this._uShadowViewMatrix[i], false, light.getShadowViewMatrix());
                }
                if (this._uShadowProjMatrix[i]) {
                    gl.uniformMatrix4fv(this._uShadowProjMatrix[i], false, light.getShadowProjMatrix());
                }
                var shadowRenderBuf = light.getShadowRenderBuf();
                if (shadowRenderBuf) {
                    program.bindTexture("shadowMap" + i, shadowRenderBuf.getTexture(), frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
                    frameCtx.bindTexture++;
                }
            }
        }
    }

    if (lightsState.lightMaps.length > 0 && lightsState.lightMaps[0].texture && this._uLightMap) {
        program.bindTexture(this._uLightMap, lightsState.lightMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (lightsState.reflectionMaps.length > 0 && lightsState.reflectionMaps[0].texture && this._uReflectionMap) {
        program.bindTexture(this._uReflectionMap, lightsState.reflectionMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (this._uGammaFactor) {
        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
    }

    this._baseTextureUnit = frameCtx.textureUnit;
};

/**
 * @private
 */
var EmphasisFillShaderSource = function EmphasisFillShaderSource(mesh) {
    this.vertex = buildVertex$5(mesh);
    this.fragment = buildFragment$5(mesh);
};

function buildVertex$5(mesh) {

    var scene = mesh.scene;
    var lightsState = scene._lightsState;
    var normals = hasNormals(mesh);
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    var billboard = mesh._state.billboard;
    var stationary = mesh._state.stationary;
    var src = [];

    src.push("// EmphasisFillShaderSource vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform vec4 colorize;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    src.push("uniform vec4   lightAmbient;");
    src.push("uniform vec4   fillColor;");
    if (normals) {
        src.push("attribute vec3 normal;");
        src.push("uniform mat4 modelNormalMatrix;");
        src.push("uniform mat4 viewNormalMatrix;");
        for (var i = 0, len = lightsState.lights.length; i < len; i++) {
            var light = lightsState.lights[i];
            if (light.type === "ambient") {
                continue;
            }
            src.push("uniform vec4 lightColor" + i + ";");
            if (light.type === "dir") {
                src.push("uniform vec3 lightDir" + i + ";");
            }
            if (light.type === "point") {
                src.push("uniform vec3 lightPos" + i + ";");
            }
            if (light.type === "spot") {
                src.push("uniform vec3 lightPos" + i + ";");
            }
        }
        if (quantizedGeometry) {
            src.push("vec3 octDecode(vec2 oct) {");
            src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
            src.push("    if (v.z < 0.0) {");
            src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
            src.push("    }");
            src.push("    return normalize(v);");
            src.push("}");
        }
    }
    src.push("varying vec4 vColor;");
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    src.push("vec4 worldPosition;");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    if (normals) {
        if (quantizedGeometry) {
            src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
        } else {
            src.push("vec4 localNormal = vec4(normal, 0.0); ");
        }
        src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");
        src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");
    }
    src.push("mat4 viewMatrix2 = viewMatrix;");
    src.push("mat4 modelMatrix2 = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
        src.push("billboard(modelViewMatrix);");
        if (normals) {
            src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
            src.push("billboard(modelNormalMatrix2);");
            src.push("billboard(viewNormalMatrix2);");
            src.push("billboard(modelViewNormalMatrix);");
        }
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("vec4 viewPosition = modelViewMatrix * localPosition;");
    } else {
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
    }
    if (normals) {
        src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");
    }
    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");
    src.push("float lambertian = 1.0;");
    if (normals) {
        for (var i$1 = 0, len$1 = lightsState.lights.length; i$1 < len$1; i$1++) {
            var light$1 = lightsState.lights[i$1];
            if (light$1.type === "ambient") {
                continue;
            }
            if (light$1.type === "dir") {
                if (light$1.space === "view") {
                    src.push("viewLightDir = normalize(lightDir" + i$1 + ");");
                } else {
                    src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i$1 + ", 0.0)).xyz);");
                }
            } else if (light$1.type === "point") {
                if (light$1.space === "view") {
                    src.push("viewLightDir = normalize(lightPos" + i$1 + " - viewPosition.xyz);");
                } else {
                    src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos" + i$1 + ", 0.0)).xyz);");
                }
            } else {
                continue;
            }
            src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
            src.push("reflectedColor += lambertian * (lightColor" + i$1 + ".rgb * lightColor" + i$1 + ".a);");
        }
    }
    // TODO: A blending mode for emphasis materials, to select add/multiply/mix
    //src.push("vColor = vec4((mix(reflectedColor, fillColor.rgb, 0.7)), fillColor.a);");
    src.push("vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);");
    //src.push("vColor = vec4(reflectedColor + fillColor.rgb, fillColor.a);");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
    }
    if (mesh._geometry._state.primitiveName === "points") {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function hasNormals(mesh) {
    var primitive = mesh._geometry._state.primitiveName;
    if ((mesh._geometry._state.autoVertexNormals || mesh._geometry._state.normalsBuf) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
        return true;
    }
    return false;
}

function buildFragment$5(mesh) {

    var scene = mesh.scene;
    var sectionPlanesState = mesh.scene._sectionPlanesState;
    var gammaOutput = mesh.scene.gammaOutput;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Lambertian drawing fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (gammaOutput) {
        src.push("uniform float gammaFactor;");
        src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("uniform bool clippable;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (mesh._geometry._state.primitiveName === "points") {
        src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("float r = dot(cxy, cxy);");
        src.push("if (r > 1.0) {");
        src.push("   discard;");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    if (gammaOutput) {
        src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
    } else {
        src.push("gl_FragColor = vColor;");
    }
    src.push("}");
    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var ids$1 = new Map({});

var tempVec3a$X = math.vec3();

/**
 * @private
 */
var EmphasisFillRenderer = function (hash, mesh) {
    this.id = ids$1.addItem({});
    this._hash = hash;
    this._scene = mesh.scene;
    this._useCount = 0;
    this._shaderSource = new EmphasisFillShaderSource(mesh);
    this._allocate(mesh);
};

var xrayFillRenderers = {};

EmphasisFillRenderer.get = function (mesh) {
    var hash = [
        mesh.scene.id,
        mesh.scene.gammaOutput ? "go" : "", // Gamma input not needed
        mesh.scene._sectionPlanesState.getHash(),
        !!mesh._geometry._state.normalsBuf ? "n" : "",
        mesh._geometry._state.compressGeometry ? "cp" : "",
        mesh._state.hash
    ].join(";");
    var renderer = xrayFillRenderers[hash];
    if (!renderer) {
        renderer = new EmphasisFillRenderer(hash, mesh);
        xrayFillRenderers[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

EmphasisFillRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        ids$1.removeItem(this.id);
        if (this._program) {
            this._program.destroy();
        }
        delete xrayFillRenderers[this._hash];
        stats.memory.programs--;
    }
};

EmphasisFillRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

EmphasisFillRenderer.prototype.drawMesh = function (frameCtx, mesh, mode) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var scene = this._scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var materialState = mode === 0 ? mesh._xrayMaterial._state : (mode === 1 ? mesh._highlightMaterial._state : mesh._selectedMaterial._state);
    var meshState = mesh._state;
    var geometryState = mesh._geometry._state;
    var rtcCenter = mesh.rtcCenter;

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$X) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    if (materialState.id !== this._lastMaterialId) {
        var fillColor = materialState.fillColor;
        var backfaces = materialState.backfaces;
        if (frameCtx.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }
        gl.uniform4f(this._uFillColor, fillColor[0], fillColor[1], fillColor[2], materialState.fillAlpha);
        this._lastMaterialId = materialState.id;
    }

    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);
    if (this._uModelNormalMatrix) {
        gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, mesh.worldNormalMatrix);
    }

    if (this._uClippable) {
        gl.uniform1i(this._uClippable, meshState.clippable);
    }

    gl.uniform3fv(this._uOffset, meshState.offset);

    // Bind VBOs
    if (geometryState.id !== this._lastGeometryId) {
        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        }
        if (this._uUVDecodeMatrix) {
            gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometryState.uvDecodeMatrix);
        }
        if (this._aPosition) {
            this._aPosition.bindArrayBuffer(geometryState.positionsBuf);
            frameCtx.bindArray++;
        }
        if (this._aNormal) {
            this._aNormal.bindArrayBuffer(geometryState.normalsBuf);
            frameCtx.bindArray++;
        }
        if (geometryState.indicesBuf) {
            geometryState.indicesBuf.bind();
            frameCtx.bindArray++;
            // gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
            // frameCtx.drawElements++;
        } else if (geometryState.positionsBuf) ;
        this._lastGeometryId = geometryState.id;
    }

    if (geometryState.indicesBuf) {
        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
        frameCtx.drawElements++;
    } else if (geometryState.positionsBuf) {
        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positionsBuf.numItems);
        frameCtx.drawArrays++;
    }
};

EmphasisFillRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var lightsState = scene._lightsState;
    var sectionPlanesState = scene._sectionPlanesState;
    var gl = scene.canvas.gl;
    this._program = new Program(gl, this._shaderSource);
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uModelNormalMatrix = program.getLocation("modelNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uLightAmbient = [];
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];
    for (var i = 0, len = lightsState.lights.length; i < len; i++) {
        var light = lightsState.lights[i];
        switch (light.type) {
            case "ambient":
                this._uLightAmbient[i] = program.getLocation("lightAmbient");
                break;
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }
    this._uSectionPlanes = [];
    for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }
    this._uFillColor = program.getLocation("fillColor");
    this._aPosition = program.getAttribute("position");
    this._aNormal = program.getAttribute("normal");
    this._uClippable = program.getLocation("clippable");
    this._uGammaFactor = program.getLocation("gammaFactor");
    this._uOffset = program.getLocation("offset");
    if (scene.logarithmicDepthBufferEnabled ) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
};

EmphasisFillRenderer.prototype._bindProgram = function (frameCtx) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;
    var camera = scene.camera;
    var project = camera.project;
    var program = this._program;
    program.bind();
    frameCtx.useProgram++;
    frameCtx.textureUnit = 0;
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
    this._lastIndicesBufId = null;
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.normalMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);
    if (scene.logarithmicDepthBufferEnabled ) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
    for (var i = 0, len = lightsState.lights.length; i < len; i++) {
        var light = lightsState.lights[i];
        if (this._uLightAmbient[i]) {
            gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);
        } else {
            if (this._uLightColor[i]) {
                gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
            }
            if (this._uLightPos[i]) {
                gl.uniform3fv(this._uLightPos[i], light.pos);
                if (this._uLightAttenuation[i]) {
                    gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
                }
            }
            if (this._uLightDir[i]) {
                gl.uniform3fv(this._uLightDir[i], light.dir);
            }
        }
    }
    if (this._uGammaFactor) {
        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
    }
};

/**
 * @private
 */
var EmphasisEdgesShaderSource = function EmphasisEdgesShaderSource(mesh) {
    this.vertex = buildVertex$4(mesh);
    this.fragment = buildFragment$4(mesh);
};

function buildVertex$4(mesh) {
    var scene = mesh.scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    var billboard = mesh._state.billboard;
    var stationary = mesh._state.stationary;
    var src = [];
    src.push("// Edges drawing vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform vec4 edgeColor;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    src.push("varying vec4 vColor;");
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    src.push("vec4 worldPosition;");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    src.push("mat4 viewMatrix2 = viewMatrix;");
    src.push("mat4 modelMatrix2 = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
        src.push("billboard(modelViewMatrix);");
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition = modelViewMatrix * localPosition;");
    } else {
        src.push("worldPosition = modelMatrix2 * localPosition;");
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
        src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
    }
    src.push("vColor = edgeColor;");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function buildFragment$4(mesh) {

    var scene = mesh.scene;
    var sectionPlanesState = mesh.scene._sectionPlanesState;
    var gammaOutput = mesh.scene.gammaOutput;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Edges drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (gammaOutput) {
        src.push("uniform float gammaFactor;");
        src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("uniform bool clippable;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    if (gammaOutput) {
        src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
    } else {
        src.push("gl_FragColor = vColor;");
    }
    src.push("}");
    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var ids = new Map({});

var tempVec3a$W = math.vec3();

/**
 * @private
 */
var EmphasisEdgesRenderer = function (hash, mesh) {
    this.id = ids.addItem({});
    this._hash = hash;
    this._scene = mesh.scene;
    this._useCount = 0;
    this._shaderSource = new EmphasisEdgesShaderSource(mesh);
    this._allocate(mesh);
};

var renderers$4 = {};

EmphasisEdgesRenderer.get = function (mesh) {
    var hash = [
        mesh.scene.id,
        mesh.scene.gammaOutput ? "go" : "", // Gamma input not needed
        mesh.scene._sectionPlanesState.getHash(),
        mesh._geometry._state.compressGeometry ? "cp" : "",
        mesh._state.hash
    ].join(";");
    var renderer = renderers$4[hash];
    if (!renderer) {
        renderer = new EmphasisEdgesRenderer(hash, mesh);
        renderers$4[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

EmphasisEdgesRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        ids.removeItem(this.id);
        if (this._program) {
            this._program.destroy();
        }
        delete renderers$4[this._hash];
        stats.memory.programs--;
    }
};

EmphasisEdgesRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

EmphasisEdgesRenderer.prototype.drawMesh = function (frameCtx, mesh, mode) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var scene = this._scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var materialState;
    var meshState = mesh._state;
    var geometry = mesh._geometry;
    var geometryState = geometry._state;
    var rtcCenter = mesh.rtcCenter;

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$W) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    switch (mode) {
        case 0:
            materialState = mesh._xrayMaterial._state;
            break;
        case 1:
            materialState = mesh._highlightMaterial._state;
            break;
        case 2:
            materialState = mesh._selectedMaterial._state;
            break;
        case 3:
        default:
            materialState = mesh._edgeMaterial._state;
            break;
    }

    if (materialState.id !== this._lastMaterialId) {
        var backfaces = materialState.backfaces;
        if (frameCtx.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }
        if (frameCtx.lineWidth !== materialState.edgeWidth) {
            gl.lineWidth(materialState.edgeWidth);
            frameCtx.lineWidth = materialState.edgeWidth;
        }
        if (this._uEdgeColor) {
            var edgeColor = materialState.edgeColor;
            var edgeAlpha = materialState.edgeAlpha;
            gl.uniform4f(this._uEdgeColor, edgeColor[0], edgeColor[1], edgeColor[2], edgeAlpha);
        }
        this._lastMaterialId = materialState.id;
    }

    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);

    if (this._uClippable) {
        gl.uniform1i(this._uClippable, meshState.clippable);
    }

    gl.uniform3fv(this._uOffset, meshState.offset);

    // Bind VBOs
    var indicesBuf;
    if (geometryState.primitive === gl.TRIANGLES) {
        indicesBuf = geometry._getEdgeIndices();
    } else if (geometryState.primitive === gl.LINES) {
        indicesBuf = geometryState.indicesBuf;
    }

    if (indicesBuf) {
        if (geometryState.id !== this._lastGeometryId) {
            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
            }
            if (this._aPosition) {
                this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
                frameCtx.bindArray++;
            }
            indicesBuf.bind();
            frameCtx.bindArray++;
            this._lastGeometryId = geometryState.id;
        }

        gl.drawElements(gl.LINES, indicesBuf.numItems, indicesBuf.itemType, 0);

        frameCtx.drawElements++;
    }
};

EmphasisEdgesRenderer.prototype._allocate = function (mesh) {

    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._shaderSource);

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];
    for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._uEdgeColor = program.getLocation("edgeColor");
    this._aPosition = program.getAttribute("position");
    this._uClippable = program.getLocation("clippable");
    this._uGammaFactor = program.getLocation("gammaFactor");
    this._uOffset = program.getLocation("offset");

    if (scene.logarithmicDepthBufferEnabled ) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }

    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
};

EmphasisEdgesRenderer.prototype._bindProgram = function (frameCtx) {

    var program = this._program;
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var camera = scene.camera;
    var project = camera.project;

    program.bind();

    frameCtx.useProgram++;

    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled ) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    if (this._uGammaFactor) {
        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
    }
};

/**
 * @author xeolabs / https://github.com/xeolabs
 */

/**
 * @private
 */
var PickMeshShaderSource = function PickMeshShaderSource(mesh) {
    this.vertex = buildVertex$3(mesh);
    this.fragment = buildFragment$3(mesh);
};

function buildVertex$3(mesh) {
    var scene = mesh.scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    var billboard = mesh._state.billboard;
    var stationary = mesh._state.stationary;
    var src = [];
    src.push("// Mesh picking vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("varying vec4 vViewPosition;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    src.push("mat4 viewMatrix2 = viewMatrix;");
    src.push("mat4 modelMatrix2 = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
    }
    src.push("   vec4 worldPosition = modelMatrix2 * localPosition;");
    src.push("   worldPosition.xyz = worldPosition.xyz + offset;");
    src.push("   vec4 viewPosition = viewMatrix2 * worldPosition;");
    if (clipping) {
        src.push("   vWorldPosition = worldPosition;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function buildFragment$3(mesh) {
    var scene = mesh.scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Mesh picking fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    src.push("uniform vec4 pickColor;");
    if (clipping) {
        src.push("uniform bool clippable;");
        src.push("varying vec4 vWorldPosition;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = pickColor; ");
    src.push("}");
    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var tempVec3a$V = math.vec3();

// No ID, because there is exactly one PickMeshRenderer per scene

/**
 * @private
 */
var PickMeshRenderer = function (hash, mesh) {
    this._hash = hash;
    this._shaderSource = new PickMeshShaderSource(mesh);
    this._scene = mesh.scene;
    this._useCount = 0;
    this._allocate(mesh);
};

var renderers$3 = {};

PickMeshRenderer.get = function (mesh) {
    var hash = [
        mesh.scene.canvas.canvas.id,
        mesh.scene._sectionPlanesState.getHash(),
        mesh._geometry._state.hash,
        mesh._state.hash
    ].join(";");
    var renderer = renderers$3[hash];
    if (!renderer) {
        renderer = new PickMeshRenderer(hash, mesh);
        if (renderer.errors) {
            console.log(renderer.errors.join("\n"));
            return null;
        }
        renderers$3[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

PickMeshRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        if (this._program) {
            this._program.destroy();
        }
        delete renderers$3[this._hash];
        stats.memory.programs--;
    }
};

PickMeshRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

PickMeshRenderer.prototype.drawMesh = function (frameCtx, mesh) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var meshState = mesh._state;
    var materialState = mesh._material._state;
    var geometryState = mesh._geometry._state;
    var rtcCenter = mesh.rtcCenter;

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCPickViewMatrix(meshState.rtcCenterHash, rtcCenter) : frameCtx.pickViewMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$V) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    if (materialState.id !== this._lastMaterialId) {
        var backfaces = materialState.backfaces;
        if (frameCtx.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }
        var frontface = materialState.frontface;
        if (frameCtx.frontface !== frontface) {
            if (frontface) {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frameCtx.frontface = frontface;
        }
        this._lastMaterialId = materialState.id;
    }

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);
    gl.uniformMatrix4fv(this._uModelMatrix, false, mesh.worldMatrix);
    if (this._uClippable) {
        gl.uniform1i(this._uClippable, mesh._state.clippable);
    }
    gl.uniform3fv(this._uOffset, mesh._state.offset);

    if (geometryState.id !== this._lastGeometryId) {
        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        }
        if (this._aPosition) {
            this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
            frameCtx.bindArray++;
        }
        if (geometryState.indicesBuf) {
            geometryState.indicesBuf.bind();
            frameCtx.bindArray++;
        }
        this._lastGeometryId = geometryState.id;
    }

    // Mesh-indexed color
    var pickID = mesh._state.pickID;
    var a = pickID >> 24 & 0xFF;
    var b = pickID >> 16 & 0xFF;
    var g = pickID >> 8 & 0xFF;
    var r = pickID & 0xFF;
    gl.uniform4f(this._uPickColor, r / 255, g / 255, b / 255, a / 255);

    if (geometryState.indicesBuf) {
        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
        frameCtx.drawElements++;
    } else if (geometryState.positions) {
        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);
    }
};

PickMeshRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    this._program = new Program(gl, this._shaderSource);
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];
    var clips = scene._sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._uClippable = program.getLocation("clippable");
    this._uPickColor = program.getLocation("pickColor");
    this._uOffset = program.getLocation("offset");
    if (scene.logarithmicDepthBufferEnabled ) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
    this._lastMaterialId = null;
    this._lastGeometryId = null;
};

PickMeshRenderer.prototype._bindProgram = function (frameCtx) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;
    this._program.bind();
    frameCtx.useProgram++;
    if (scene.logarithmicDepthBufferEnabled ) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
    this._lastMaterialId = null;
    this._lastGeometryId = null;
};

/**
 * @private
 */

var PickTriangleShaderSource = function PickTriangleShaderSource(mesh) {
    this.vertex = buildVertex$2(mesh);
    this.fragment = buildFragment$2(mesh);
};

function buildVertex$2(mesh) {
    var scene = mesh.scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    mesh._state.billboard;
    mesh._state.stationary;
    var src = [];
    src.push("// Surface picking vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform vec3 offset;");
    if (clipping) {
        src.push("uniform bool clippable;");
        src.push("varying vec4 vWorldPosition;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("varying vec4 vColor;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    src.push("   vec4 worldPosition = modelMatrix * localPosition; ");
    src.push("   worldPosition.xyz = worldPosition.xyz + offset;");
    src.push("   vec4 viewPosition = viewMatrix * worldPosition;");
    if (clipping) {
        src.push("   vWorldPosition = worldPosition;");
    }
    src.push("   vColor = color;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function buildFragment$2(mesh) {
    var scene = mesh.scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Surface picking fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    src.push("varying vec4 vColor;");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("uniform bool clippable;");
        src.push("varying vec4 vWorldPosition;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vColor;");
    src.push("}");
    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var tempVec3a$U = math.vec3();

/**
 * @private
 */
var PickTriangleRenderer = function (hash, mesh) {
    this._hash = hash;
    this._scene = mesh.scene;
    this._useCount = 0;
    this._shaderSource = new PickTriangleShaderSource(mesh);
    this._allocate(mesh);
};

var renderers$2 = {};

PickTriangleRenderer.get = function (mesh) {
    var hash = [
        mesh.scene.canvas.canvas.id,
        mesh.scene._sectionPlanesState.getHash(),
        mesh._geometry._state.compressGeometry ? "cp" : "",
        mesh._state.hash
    ].join(";");
    var renderer = renderers$2[hash];
    if (!renderer) {
        renderer = new PickTriangleRenderer(hash, mesh);
        if (renderer.errors) {
            console.log(renderer.errors.join("\n"));
            return null;
        }
        renderers$2[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

PickTriangleRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        if (this._program) {
            this._program.destroy();
        }
        delete renderers$2[this._hash];
        stats.memory.programs--;
    }
};

PickTriangleRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

PickTriangleRenderer.prototype.drawMesh = function (frameCtx, mesh) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var meshState = mesh._state;
    var materialState = mesh._material._state;
    var geometry = mesh._geometry;
    var geometryState = mesh._geometry._state;
    var rtcCenter = mesh.rtcCenter;
    var backfaces = materialState.backfaces;
    var frontface = materialState.frontface;
    var project = scene.camera.project;
    var positionsBuf = geometry._getPickTrianglePositions();
    var pickColorsBuf = geometry._getPickTriangleColors();

    this._program.bind();

    frameCtx.useProgram++;

    if (scene.logarithmicDepthBufferEnabled ) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCPickViewMatrix(meshState.rtcCenterHash, rtcCenter) : frameCtx.pickViewMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$U) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        gl.uniform1f(this._uZFar, scene.camera.project.far);
    }

    if (frameCtx.backfaces !== backfaces) {
        if (backfaces) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }
        frameCtx.backfaces = backfaces;
    }
    if (frameCtx.frontface !== frontface) {
        if (frontface) {
            gl.frontFace(gl.CCW);
        } else {
            gl.frontFace(gl.CW);
        }
        frameCtx.frontface = frontface;
    }

    gl.uniformMatrix4fv(this._uModelMatrix, false, mesh.worldMatrix);
    if (this._uClippable) {
        gl.uniform1i(this._uClippable, mesh._state.clippable);
    }
    gl.uniform3fv(this._uOffset, mesh._state.offset);
    if (this._uPositionsDecodeMatrix) {
        gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        this._aPosition.bindArrayBuffer(positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
    } else {
        this._aPosition.bindArrayBuffer(positionsBuf);
    }
    pickColorsBuf.bind();
    gl.enableVertexAttribArray(this._aColor.location);
    gl.vertexAttribPointer(this._aColor.location, pickColorsBuf.itemSize, pickColorsBuf.itemType, true, 0, 0); // Normalize
    gl.drawArrays(geometryState.primitive, 0, positionsBuf.numItems / 3);
};

PickTriangleRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    this._program = new Program(gl, this._shaderSource);
    this._useCount = 0;
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];
    var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
    for (var i = 0, len = sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._uClippable = program.getLocation("clippable");
    this._uOffset = program.getLocation("offset");
    if (scene.logarithmicDepthBufferEnabled ) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

/**
 * @author xeolabs / https://github.com/xeolabs
 */

/**
 * @private
 */
var OcclusionShaderSource = function OcclusionShaderSource(mesh) {
    this.vertex = buildVertex$1(mesh);
    this.fragment = buildFragment$1(mesh);
};

function buildVertex$1(mesh) {
    var scene = mesh.scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    var billboard = mesh._state.billboard;
    var stationary = mesh._state.stationary;
    var src = [];
    src.push("// Mesh occlusion vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("void billboard(inout mat4 mat) {");
        src.push("   mat[0][0] = 1.0;");
        src.push("   mat[0][1] = 0.0;");
        src.push("   mat[0][2] = 0.0;");
        if (billboard === "spherical") {
            src.push("   mat[1][0] = 0.0;");
            src.push("   mat[1][1] = 1.0;");
            src.push("   mat[1][2] = 0.0;");
        }
        src.push("   mat[2][0] = 0.0;");
        src.push("   mat[2][1] = 0.0;");
        src.push("   mat[2][2] =1.0;");
        src.push("}");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    src.push("mat4 viewMatrix2 = viewMatrix;");
    src.push("mat4 modelMatrix2 = modelMatrix;");
    if (stationary) {
        src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;");
    }
    if (billboard === "spherical" || billboard === "cylindrical") {
        src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
        src.push("billboard(modelMatrix2);");
        src.push("billboard(viewMatrix2);");
    }
    src.push("   vec4 worldPosition = modelMatrix2 * localPosition;");
    src.push("   worldPosition.xyz = worldPosition.xyz + offset;");
    src.push("   vec4 viewPosition = viewMatrix2 * worldPosition;");
    if (clipping) {
        src.push("   vWorldPosition = worldPosition;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    return src;
}

function buildFragment$1(mesh) {

    var scene = mesh.scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Mesh occlusion fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (clipping) {
        src.push("uniform bool clippable;");
        src.push("varying vec4 vWorldPosition;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }

    src.push("void main(void) {");

    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }

    src.push("   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); ");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");

    return src;
}

/**
 * @author xeolabs / https://github.com/xeolabs
 */

var tempVec3a$T = math.vec3();

// No ID, because there is exactly one PickMeshRenderer per scene

/**
 * @private
 */
var OcclusionRenderer = function (hash, mesh) {
    this._hash = hash;
    this._shaderSource = new OcclusionShaderSource(mesh);
    this._scene = mesh.scene;
    this._useCount = 0;
    this._allocate(mesh);
};

var renderers$1 = {};

OcclusionRenderer.get = function (mesh) {
    var hash = [
        mesh.scene.canvas.canvas.id,
        mesh.scene._sectionPlanesState.getHash(),
        mesh._geometry._state.hash,
        mesh._state.hash
    ].join(";");
    var renderer = renderers$1[hash];
    if (!renderer) {
        renderer = new OcclusionRenderer(hash, mesh);
        if (renderer.errors) {
            console.log(renderer.errors.join("\n"));
            return null;
        }
        renderers$1[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

OcclusionRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        if (this._program) {
            this._program.destroy();
        }
        delete renderers$1[this._hash];
        stats.memory.programs--;
    }
};

OcclusionRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

OcclusionRenderer.prototype.drawMesh = function (frameCtx, mesh) {

    if (!this._program) {
        this._allocate(mesh);
    }

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var materialState = mesh._material._state;
    var meshState = mesh._state;
    var geometryState = mesh._geometry._state;
    var rtcCenter = mesh.rtcCenter;

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    if (materialState.id !== this._lastMaterialId) {
        var backfaces = materialState.backfaces;
        if (frameCtx.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }
        var frontface = materialState.frontface;
        if (frameCtx.frontface !== frontface) {
            if (frontface) {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frameCtx.frontface = frontface;
        }
        this._lastMaterialId = materialState.id;
    }

    var camera = scene.camera;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);

    if (meshState.clippable) {
        var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
        if (numSectionPlanes > 0) {
            var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
            var renderFlags = mesh.renderFlags;
            for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
                var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
                if (sectionPlaneUniforms) {
                    var active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];
                    gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                    if (active) {
                        var sectionPlane = sectionPlanes[sectionPlaneIndex];
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$T) : sectionPlane.pos);
                        gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                    }
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uProjMatrix, false, camera._project._state.matrix);
    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);

    if (this._uClippable) {
        gl.uniform1i(this._uClippable, mesh._state.clippable);
    }

    gl.uniform3fv(this._uOffset, mesh._state.offset);

    if (geometryState.id !== this._lastGeometryId) {
        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        }
        if (this._aPosition) {
            this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
            frameCtx.bindArray++;
        }
        if (geometryState.indicesBuf) {
            geometryState.indicesBuf.bind();
            frameCtx.bindArray++;
        }
        this._lastGeometryId = geometryState.id;
    }
    if (geometryState.indicesBuf) {
        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
        frameCtx.drawElements++;
    } else if (geometryState.positions) {
        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);
    }
};

OcclusionRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    this._program = new Program(gl, this._shaderSource);
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];
    var clips = scene._sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._uClippable = program.getLocation("clippable");
    this._uOffset = program.getLocation("offset");
    if (scene.logarithmicDepthBufferEnabled ) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
};

OcclusionRenderer.prototype._bindProgram = function (frameCtx) {
    var scene = this._scene;
    var project = scene.camera.project;
    var gl = scene.canvas.gl;
    this._program.bind();
    frameCtx.useProgram++;
    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);
    if (scene.logarithmicDepthBufferEnabled ) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
};

/**
 * @private
 */
var ShadowShaderSource = function ShadowShaderSource(mesh) {
    this.vertex = buildVertex(mesh);
    this.fragment = buildFragment(mesh);
};

function buildVertex(mesh) {
    var scene = mesh.scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var quantizedGeometry = !!mesh._geometry._state.compressGeometry;
    var src = [];
    src.push("// Mesh shadow vertex shader");
    src.push("attribute vec3 position;");
    src.push("uniform mat4 modelMatrix;");
    src.push("uniform mat4 shadowViewMatrix;");
    src.push("uniform mat4 shadowProjMatrix;");
    src.push("uniform vec3 offset;");
    if (quantizedGeometry) {
        src.push("uniform mat4 positionsDecodeMatrix;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
    }
    src.push("void main(void) {");
    src.push("vec4 localPosition = vec4(position, 1.0); ");
    src.push("vec4 worldPosition;");
    if (quantizedGeometry) {
        src.push("localPosition = positionsDecodeMatrix * localPosition;");
    }
    src.push("worldPosition = modelMatrix * localPosition;");
    src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    src.push("vec4 viewPosition  = shadowViewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
    }
    src.push("   gl_Position = shadowProjMatrix * viewPosition;");
    src.push("}");
    return src;
}

function buildFragment(mesh) {
    var scene = mesh.scene;
    scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Mesh shadow fragment shader");

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (clipping) {
        src.push("uniform bool clippable;");
        src.push("varying vec4 vWorldPosition;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }

    src.push("vec4 encodeFloat( const in float depth ) {");
    src.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);");
    src.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);");
    src.push("  vec4 comp = fract(depth * bitShift);");
    src.push("  comp -= comp.xxyz * bitMask;");
    src.push("  return comp;");
    src.push("}");

    src.push("void main(void) {");
    if (clipping) {
        src.push("if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("gl_FragColor = encodeFloat(gl_FragCoord.z);");
    src.push("}");
    return src;
}

/**
 * @private
 */
var ShadowRenderer = function (hash, mesh) {
    this._hash = hash;
    this._shaderSource = new ShadowShaderSource(mesh);
    this._scene = mesh.scene;
    this._useCount = 0;
    this._allocate(mesh);
};

var renderers = {};

ShadowRenderer.get = function (mesh) {
    var scene = mesh.scene;
    var hash = [scene.canvas.canvas.id, scene._sectionPlanesState.getHash(), mesh._geometry._state.hash, mesh._state.hash].join(";");
    var renderer = renderers[hash];
    if (!renderer) {
        renderer = new ShadowRenderer(hash, mesh);
        if (renderer.errors) {
            console.log(renderer.errors.join("\n"));
            return null;
        }
        renderers[hash] = renderer;
        stats.memory.programs++;
    }
    renderer._useCount++;
    return renderer;
};

ShadowRenderer.prototype.put = function () {
    if (--this._useCount === 0) {
        if (this._program) {
            this._program.destroy();
        }
        delete renderers[this._hash];
        stats.memory.programs--;
    }
};

ShadowRenderer.prototype.webglContextRestored = function () {
    this._program = null;
};

ShadowRenderer.prototype.drawMesh = function (frame, mesh) {
    if (!this._program) {
        this._allocate(mesh);
    }
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var materialState = mesh._material._state;
    var geometryState = mesh._geometry._state;
    if (frame.lastProgramId !== this._program.id) {
        frame.lastProgramId = this._program.id;
        this._bindProgram(frame);
    }
    if (materialState.id !== this._lastMaterialId) {
        var backfaces = materialState.backfaces;
        if (frame.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frame.backfaces = backfaces;
        }
        var frontface = materialState.frontface;
        if (frame.frontface !== frontface) {
            if (frontface) {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frame.frontface = frontface;
        }
        if (frame.lineWidth !== materialState.lineWidth) {
            gl.lineWidth(materialState.lineWidth);
            frame.lineWidth = materialState.lineWidth;
        }
        if (this._uPointSize) {
            gl.uniform1i(this._uPointSize, materialState.pointSize);
        }
        this._lastMaterialId = materialState.id;
    }
    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);
    if (geometryState.combineGeometry) {
        var vertexBufs = mesh.vertexBufs;
        if (vertexBufs.id !== this._lastVertexBufsId) {
            if (vertexBufs.positionsBuf && this._aPosition) {
                this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
                frame.bindArray++;
            }
            this._lastVertexBufsId = vertexBufs.id;
        }
    }
    if (this._uClippable) {
        gl.uniform1i(this._uClippable, mesh._state.clippable);
    }
    gl.uniform3fv(this._uOffset, mesh._state.offset);
    if (geometryState.id !== this._lastGeometryId) {
        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);
        }
        if (geometryState.combineGeometry) { // VBOs were bound by the preceding VertexBufs chunk
            if (geometryState.indicesBufCombined) {
                geometryState.indicesBufCombined.bind();
                frame.bindArray++;
            }
        } else {
            if (this._aPosition) {
                this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);
                frame.bindArray++;
            }
            if (geometryState.indicesBuf) {
                geometryState.indicesBuf.bind();
                frame.bindArray++;
            }
        }
        this._lastGeometryId = geometryState.id;
    }
    if (geometryState.combineGeometry) {
        if (geometryState.indicesBufCombined) {
            gl.drawElements(geometryState.primitive, geometryState.indicesBufCombined.numItems, geometryState.indicesBufCombined.itemType, 0);
            frame.drawElements++;
        }
    } else {
        if (geometryState.indicesBuf) {
            gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);
            frame.drawElements++;
        } else if (geometryState.positions) {
            gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);
            frame.drawArrays++;
        }
    }
};

ShadowRenderer.prototype._allocate = function (mesh) {
    var scene = mesh.scene;
    var gl = scene.canvas.gl;
    this._program = new Program(gl, this._shaderSource);
    this._scene = scene;
    this._useCount = 0;
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uModelMatrix = program.getLocation("modelMatrix");
    this._uShadowViewMatrix = program.getLocation("shadowViewMatrix");
    this._uShadowProjMatrix = program.getLocation("shadowProjMatrix");
    this._uSectionPlanes = {};
    var clips = scene._sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._uClippable = program.getLocation("clippable");
    this._uOffset = program.getLocation("offset");
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
};

ShadowRenderer.prototype._bindProgram = function (frame) {
    if (!this._program) {
        this._allocate(mesh);
    }
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    this._program.bind();
    frame.useProgram++;
    gl.uniformMatrix4fv(this._uShadowViewMatrix, false, frame.shadowViewMatrix);
    gl.uniformMatrix4fv(this._uShadowProjMatrix, false, frame.shadowProjMatrix);
    this._lastMaterialId = null;
    this._lastVertexBufsId = null;
    this._lastGeometryId = null;
    if (sectionPlanesState.sectionPlanes.length > 0) {
        var sectionPlaneUniforms;
        var uSectionPlaneActive;
        var sectionPlane;
        var uSectionPlanePos;
        var uSectionPlaneDir;
        for (var i = 0, len = this._uSectionPlanes.length; i < len; i++) {
            sectionPlaneUniforms = this._uSectionPlanes[i];
            uSectionPlaneActive = sectionPlaneUniforms.active;
            sectionPlane = sectionPlanesState.sectionPlanes[i];
            if (uSectionPlaneActive) {
                gl.uniform1i(uSectionPlaneActive, sectionPlane.active);
            }
            uSectionPlanePos = sectionPlaneUniforms.pos;
            if (uSectionPlanePos) {
                gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
            }
            uSectionPlaneDir = sectionPlaneUniforms.dir;
            if (uSectionPlaneDir) {
                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
            }
        }
    }
};

/**
 * Indicates what rendering needs to be done for the layers within a {@link Drawable}.
 *
 * Each Drawable has a RenderFlags in {@link Drawable#renderFlags}.
 *
 * Before rendering each frame, {@link Renderer} will call {@link Drawable#rebuildRenderFlags} on each {@link Drawable}.
 *
 * Then, when rendering a frame, Renderer will apply rendering passes to each Drawable according on what flags are set in {@link Drawable#renderFlags}.
 *
 * @private
 */
var RenderFlags = function RenderFlags() {

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate which layers are visible within the {@link Drawable}.
     *
     * This is a list of IDs of visible layers within the {@link Drawable}. The IDs will be whatever the
     * {@link Drawable} uses to identify its layers, usually integers.
     *
     * @property visibleLayers
     * @type {Number[]}
     */
    this.visibleLayers = [];


    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate which {@link SectionPlane}s are active within each layer of the {@link Drawable}.
     *
     * Layout is as follows:
     *
     * ````[
     *  false, false, true, // Layer 0, SectionPlanes 0, 1, 2
     *  false, true, true,  // Layer 1, SectionPlanes 0, 1, 2
     *  true, false, true   // Layer 2, SectionPlanes 0, 1, 2
     * ]````
     *
     * @property sectionPlanesActivePerLayer
     * @type {Boolean[]}
     */
    this.sectionPlanesActivePerLayer = [];

    this.reset();
};

/**
 * @private
 */
RenderFlags.prototype.reset = function reset () {

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is culled.
     * 
     * When this is ````false````, then all of the other properties on ````RenderFlags```` will remain at their default values.
     * 
     * @property culled
     * @type {Boolean}
     */
    this.culled = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is sliced by any {@link SectionPlane}s.
     *
     * @property sectioned
     * @type {Boolean}
     */
    this.sectioned  = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of layers within the {@link Drawable}.
     *
     * @property numLayers
     * @type {Number}
     */
    this.numLayers = 0;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of visible layers within the {@link Drawable}.
     *
     * @property numVisibleLayers
     * @type {Number}
     */
    this.numVisibleLayers = 0;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorOpaque}.
     * @property colorOpaque
     * @type {boolean}
     */
    this.colorOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorTransparent}.
     * @property colorTransparent
     * @type {boolean}
     */
    this.colorTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorOpaque}.
     * @property edgesOpaque
     * @type {boolean}
     */
    this.edgesOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorTransparent}.
     * @property edgesTransparent
     * @type {boolean}
     */
    this.edgesTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteXRayed}.
     * @property xrayedSilhouetteOpaque
     * @type {boolean}
     */
    this.xrayedSilhouetteOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesXRayed}.
     * @property xrayedEdgesOpaque
     * @type {boolean}
     */
    this.xrayedEdgesOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteXRayed}.
     * @property xrayedSilhouetteTransparent
     * @type {boolean}
     */
    this.xrayedSilhouetteTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesXRayed}.
     * @property xrayedEdgesTransparent
     * @type {boolean}
     */
    this.xrayedEdgesTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteHighlighted}.
     * @property highlightedSilhouetteOpaque
     * @type {boolean}
     */
    this.highlightedSilhouetteOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesHighlighted}.
     * @property highlightedEdgesOpaque
     * @type {boolean}
     */
    this.highlightedEdgesOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteHighlighted}.
     * @property highlightedSilhouetteTransparent
     * @type {boolean}
     */
    this.highlightedSilhouetteTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesHighlighted}.
     * @property highlightedEdgesTransparent
     * @type {boolean}
     */
    this.highlightedEdgesTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteSelected}.
     * @property selectedSilhouetteOpaque
     * @type {boolean}
     */
    this.selectedSilhouetteOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesSelected}.
     * @property selectedEdgesOpaque
     * @type {boolean}
     */
    this.selectedEdgesOpaque = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteSelected}.
     * @property selectedSilhouetteTransparent
     * @type {boolean}
     */
    this.selectedSilhouetteTransparent = false;

    /**
     * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesSelected}.
     * @property selectedEdgesTransparent
     * @type {boolean}
     */
    this.selectedEdgesTransparent = false;
};

/**
 Fired when this Mesh is picked via a call to {@link Scene/pick:method"}}Scene#pick(){{/crossLink}}.

 The event parameters will be the hit result returned by the {@link Scene/pick:method"}}Scene#pick(){{/crossLink}} method.
 @event picked
 */

var obb = math.OBB3();
var angleAxis$1 = math.vec4();
var q1$1 = math.vec4();
var q2$1 = math.vec4();
var xAxis$1 = math.vec3([1, 0, 0]);
var yAxis$1 = math.vec3([0, 1, 0]);
var zAxis$1 = math.vec3([0, 0, 1]);

var veca$1 = math.vec3(3);
var vecb$1 = math.vec3(3);

var identityMat$1 = math.identityMat4();

/**
 * @desc An {@link Entity} that is a drawable element, with a {@link Geometry} and a {@link Material}, that can be
 * connected into a scene graph using {@link Node}s.
 *
 * ## Usage
 *
 * The example below is the same as the one given for {@link Node}, since the two classes work together.  In this example,
 * we'll create a scene graph in which a root {@link Node} represents a group and the Meshes are leaves.
 *
 * Since {@link Node} implements {@link Entity}, we can designate the root {@link Node} as a model, causing it to be registered by its
 * ID in {@link Scene#models}.
 *
 * Since Mesh also implements {@link Entity}, we can designate the leaf Meshes as objects, causing them to
 * be registered by their IDs in {@link Scene#objects}.
 *
 * We can then find those {@link Entity} types in {@link Scene#models} and {@link Scene#objects}.
 *
 * We can also update properties of our object-Meshes via calls to {@link Scene#setObjectsHighlighted} etc.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneGraph)]
 *
 * ````javascript
 * import {Viewer, Mesh, Node, PhongMaterial, buildBoxGeometry, ReadableGeometry} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * const boxGeometry = new ReadableGeometry(viewer.scene, buildBoxGeometry({
 *      xSize: 1,
 *      ySize: 1,
 *      zSize: 1
 * }));
 *
 * new Node(viewer.scene, {
 *      id: "table",
 *      isModel: true, // <---------- Node represents a model, so is registered by ID in viewer.scene.models
 *      rotation: [0, 50, 0],
 *      position: [0, 0, 0],
 *      scale: [1, 1, 1],
 *
 *      children: [
 *
 *          new Mesh(viewer.scene, { // Red table leg
 *              id: "redLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1, 0.3, 0.3]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, { // Green table leg
 *              id: "greenLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 1.0, 0.3]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, {// Blue table leg
 *              id: "blueLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 0.3, 1.0]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, {  // Yellow table leg
 *              id: "yellowLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                   diffuse: [1.0, 1.0, 0.0]
 *              }),
 *              geometry: boxGeometry
 *          }),
 *
 *          new Mesh(viewer.scene, { // Purple table top
 *              id: "tableTop",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [0, -3, 0],
 *              scale: [6, 0.5, 6],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1.0, 0.3, 1.0]
 *              }),
 *              geometry: boxGeometry
 *          })
 *      ]
 *  });
 *
 * // Find Nodes and Meshes by their IDs
 *
 * var table = viewer.scene.models["table"];                // Since table Node has isModel == true
 *
 * var redLeg = viewer.scene.objects["redLeg"];             // Since the Meshes have isObject == true
 * var greenLeg = viewer.scene.objects["greenLeg"];
 * var blueLeg = viewer.scene.objects["blueLeg"];
 *
 * // Highlight one of the table leg Meshes
 *
 * viewer.scene.setObjectsHighlighted(["redLeg"], true);    // Since the Meshes have isObject == true
 *
 * // Periodically update transforms on our Nodes and Meshes
 *
 * viewer.scene.on("tick", function () {
 *
 *       // Rotate legs
 *       redLeg.rotateY(0.5);
 *       greenLeg.rotateY(0.5);
 *       blueLeg.rotateY(0.5);
 *
 *       // Rotate table
 *       table.rotateY(0.5);
 *       table.rotateX(0.3);
 *   });
 * ````
 *
 * ## Metadata
 *
 * As mentioned, we can also associate {@link MetaModel}s and {@link MetaObject}s with our {@link Node}s and Meshes,
 * within a {@link MetaScene}. See {@link MetaScene} for an example.
 *
 * @implements {Entity}
 * @implements {Drawable}
 */
var Mesh = /*@__PURE__*/(function (Component) {
    function Mesh(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        /**
         * ID of the corresponding object within the originating system, if any.
         *
         * @type {String}
         * @abstract
         */
        this.originalSystemId = (cfg.originalSystemId || this.id);

        /** @private **/
        this.renderFlags = new RenderFlags();

        this._state = new RenderState({ // NOTE: Renderer gets modeling and normal matrices from Mesh#matrix and Mesh.#normalWorldMatrix
            visible: true,
            culled: false,
            pickable: null,
            clippable: null,
            collidable: null,
            castsShadow: null,
            receivesShadow: null,
            xrayed: false,
            highlighted: false,
            selected: false,
            edges: false,
            stationary: !!cfg.stationary,
            billboard: this._checkBillboard(cfg.billboard),
            layer: null,
            colorize: null,
            pickID: this.scene._renderer.getPickID(this),
            drawHash: "",
            pickHash: "",
            offset: math.vec3(),
            rtcCenter: null,
            rtcCenterHash: null
        });

        this._drawRenderer = null;
        this._shadowRenderer = null;
        this._emphasisFillRenderer = null;
        this._emphasisEdgesRenderer = null;
        this._pickMeshRenderer = null;
        this._pickTriangleRenderer = null;
        this._occlusionRenderer = null;

        this._geometry = cfg.geometry ? this._checkComponent2(["ReadableGeometry", "VBOGeometry"], cfg.geometry) : this.scene.geometry;
        this._material = cfg.material ? this._checkComponent2(["PhongMaterial", "MetallicMaterial", "SpecularMaterial", "LambertMaterial"], cfg.material) : this.scene.material;
        this._xrayMaterial = cfg.xrayMaterial ? this._checkComponent("EmphasisMaterial", cfg.xrayMaterial) : this.scene.xrayMaterial;
        this._highlightMaterial = cfg.highlightMaterial ? this._checkComponent("EmphasisMaterial", cfg.highlightMaterial) : this.scene.highlightMaterial;
        this._selectedMaterial = cfg.selectedMaterial ? this._checkComponent("EmphasisMaterial", cfg.selectedMaterial) : this.scene.selectedMaterial;
        this._edgeMaterial = cfg.edgeMaterial ? this._checkComponent("EdgeMaterial", cfg.edgeMaterial) : this.scene.edgeMaterial;

        this._parentNode = null;

        this._aabb = null;
        this._aabbDirty = true;

        this._numTriangles = (this._geometry ? this._geometry.numTriangles : 0);

        this.scene._aabbDirty = true;

        this._scale = math.vec3();
        this._quaternion = math.identityQuaternion();
        this._rotation = math.vec3();
        this._position = math.vec3();

        this._worldMatrix = math.identityMat4();
        this._worldNormalMatrix = math.identityMat4();

        this._localMatrixDirty = true;
        this._worldMatrixDirty = true;
        this._worldNormalMatrixDirty = true;

        if (cfg.rtcCenter) {
            this._state.rtcCenter = math.vec3(cfg.rtcCenter);
            this._state.rtcCenterHash = cfg.rtcCenter.join();
        }

        if (cfg.matrix) {
            this.matrix = cfg.matrix;
        } else {
            this.scale = cfg.scale;
            this.position = cfg.position;
            if (cfg.quaternion) ; else {
                this.rotation = cfg.rotation;
            }
        }

        this._isObject = cfg.isObject;
        if (this._isObject) {
            this.scene._registerObject(this);
        }

        this._isModel = cfg.isModel;
        if (this._isModel) {
            this.scene._registerModel(this);
        }

        this.visible = cfg.visible;
        this.culled = cfg.culled;
        this.pickable = cfg.pickable;
        this.clippable = cfg.clippable;
        this.collidable = cfg.collidable;
        this.castsShadow = cfg.castsShadow;
        this.receivesShadow = cfg.receivesShadow;
        this.xrayed = cfg.xrayed;
        this.highlighted = cfg.highlighted;
        this.selected = cfg.selected;
        this.edges = cfg.edges;
        this.layer = cfg.layer;
        this.colorize = cfg.colorize;
        this.opacity = cfg.opacity;
        this.offset = cfg.offset;

        if (cfg.parentId) {
            var parentNode = this.scene.components[cfg.parentId];
            if (!parentNode) {
                this.error("Parent not found: '" + cfg.parentId + "'");
            } else if (!parentNode.isNode) {
                this.error("Parent is not a Node: '" + cfg.parentId + "'");
            } else {
                parentNode.addChild(this);
            }
            this._parentNode = parentNode;
        } else if (cfg.parent) {
            if (!cfg.parent.isNode) {
                this.error("Parent is not a Node");
            }
            cfg.parent.addChild(this);
            this._parentNode = cfg.parent;
        }

        this.compile();
    }

    if ( Component ) Mesh.__proto__ = Component;
    Mesh.prototype = Object.create( Component && Component.prototype );
    Mesh.prototype.constructor = Mesh;

    var prototypeAccessors = { type: { configurable: true },isMesh: { configurable: true },parent: { configurable: true },geometry: { configurable: true },material: { configurable: true },position: { configurable: true },rotation: { configurable: true },quaternion: { configurable: true },scale: { configurable: true },matrix: { configurable: true },worldMatrix: { configurable: true },worldNormalMatrix: { configurable: true },isEntity: { configurable: true },isModel: { configurable: true },isObject: { configurable: true },aabb: { configurable: true },rtcCenter: { configurable: true },numTriangles: { configurable: true },visible: { configurable: true },xrayed: { configurable: true },highlighted: { configurable: true },selected: { configurable: true },edges: { configurable: true },culled: { configurable: true },clippable: { configurable: true },collidable: { configurable: true },pickable: { configurable: true },castsShadow: { configurable: true },receivesShadow: { configurable: true },saoEnabled: { configurable: true },colorize: { configurable: true },opacity: { configurable: true },transparent: { configurable: true },layer: { configurable: true },stationary: { configurable: true },billboard: { configurable: true },offset: { configurable: true },isDrawable: { configurable: true },isStateSortable: { configurable: true },xrayMaterial: { configurable: true },highlightMaterial: { configurable: true },selectedMaterial: { configurable: true },edgeMaterial: { configurable: true } };

    //------------------------------------------------------------------------------------------------------------------
    // Mesh members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that this Component is a Mesh.
     * @final
     * @type {Boolean}
     */
    prototypeAccessors.type.get = function () {
        return "Mesh";
    };

    prototypeAccessors.isMesh.get = function () {
        return true;
    };

    /**
     * The parent Node.
     *
     * The parent Node may also be set by passing the Mesh to the parent's {@link Node#addChild} method.
     *
     * @type {Node}
     */
    prototypeAccessors.parent.get = function () {
        return this._parentNode;
    };

    Mesh.prototype._checkBillboard = function _checkBillboard (value) {
        value = value || "none";
        if (value !== "spherical" && value !== "cylindrical" && value !== "none") {
            this.error("Unsupported value for 'billboard': " + value + " - accepted values are " +
                "'spherical', 'cylindrical' and 'none' - defaulting to 'none'.");
            value = "none";
        }
        return value;
    };

    /**
     * Called by xeokit to compile shaders for this Mesh.
     * @private
     */
    Mesh.prototype.compile = function compile () {
        var drawHash = this._makeDrawHash();
        if (this._state.drawHash !== drawHash) {
            this._state.drawHash = drawHash;
            this._putDrawRenderers();
            this._drawRenderer = DrawRenderer.get(this);
            // this._shadowRenderer = ShadowRenderer.get(this);
            this._emphasisFillRenderer = EmphasisFillRenderer.get(this);
            this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this);
        }
        var pickHash = this._makePickHash();
        if (this._state.pickHash !== pickHash) {
            this._state.pickHash = pickHash;
            this._putPickRenderers();
            this._pickMeshRenderer = PickMeshRenderer.get(this);
        }
        var occlusionHash = this._makeOcclusionHash();
        if (this._state.occlusionHash !== occlusionHash) {
            this._state.occlusionHash = occlusionHash;
            this._putOcclusionRenderer();
            this._occlusionRenderer = OcclusionRenderer.get(this);
        }
    };

    Mesh.prototype._setLocalMatrixDirty = function _setLocalMatrixDirty () {
        this._localMatrixDirty = true;
        this._setWorldMatrixDirty();
    };

    Mesh.prototype._setWorldMatrixDirty = function _setWorldMatrixDirty () {
        this._worldMatrixDirty = true;
        this._worldNormalMatrixDirty = true;
    };

    Mesh.prototype._buildWorldMatrix = function _buildWorldMatrix () {
        var localMatrix = this.matrix;
        if (!this._parentNode) {
            for (var i = 0, len = localMatrix.length; i < len; i++) {
                this._worldMatrix[i] = localMatrix[i];
            }
        } else {
            math.mulMat4(this._parentNode.worldMatrix, localMatrix, this._worldMatrix);
        }
        this._worldMatrixDirty = false;
    };

    Mesh.prototype._buildWorldNormalMatrix = function _buildWorldNormalMatrix () {
        if (this._worldMatrixDirty) {
            this._buildWorldMatrix();
        }
        if (!this._worldNormalMatrix) {
            this._worldNormalMatrix = math.mat4();
        }
        // Note: order of inverse and transpose doesn't matter
        math.transposeMat4(this._worldMatrix, this._worldNormalMatrix);
        math.inverseMat4(this._worldNormalMatrix);
        this._worldNormalMatrixDirty = false;
    };

    Mesh.prototype._setAABBDirty = function _setAABBDirty () {
        if (this.collidable) {
            for (var node = this; node; node = node._parentNode) {
                node._aabbDirty = true;
            }
        }
    };

    Mesh.prototype._updateAABB = function _updateAABB () {
        this.scene._aabbDirty = true;
        if (!this._aabb) {
            this._aabb = math.AABB3();
        }
        this._buildAABB(this.worldMatrix, this._aabb); // Mesh or PerformanceModel
        this._aabbDirty = false;
    };

    Mesh.prototype._webglContextRestored = function _webglContextRestored () {
        if (this._drawRenderer) {
            this._drawRenderer.webglContextRestored();
        }
        if (this._shadowRenderer) {
            this._shadowRenderer.webglContextRestored();
        }
        if (this._emphasisFillRenderer) {
            this._emphasisFillRenderer.webglContextRestored();
        }
        if (this._emphasisEdgesRenderer) {
            this._emphasisEdgesRenderer.webglContextRestored();
        }
        if (this._pickMeshRenderer) {
            this._pickMeshRenderer.webglContextRestored();
        }
        if (this._pickTriangleRenderer) {
            this._pickMeshRenderer.webglContextRestored();
        }
        if (this._occlusionRenderer) {
            this._occlusionRenderer.webglContextRestored();
        }
    };

    Mesh.prototype._makeDrawHash = function _makeDrawHash () {
        var scene = this.scene;
        var hash = [
            scene.canvas.canvas.id,
            (scene.gammaInput ? "gi;" : ";") + (scene.gammaOutput ? "go" : ""),
            scene._lightsState.getHash(),
            scene._sectionPlanesState.getHash()
        ];
        var state = this._state;
        if (state.stationary) {
            hash.push("/s");
        }
        if (state.billboard === "none") {
            hash.push("/n");
        } else if (state.billboard === "spherical") {
            hash.push("/s");
        } else if (state.billboard === "cylindrical") {
            hash.push("/c");
        }
        if (state.receivesShadow) {
            hash.push("/rs");
        }
        hash.push(";");
        return hash.join("");
    };

    Mesh.prototype._makePickHash = function _makePickHash () {
        var scene = this.scene;
        var hash = [
            scene.canvas.canvas.id,
            scene._sectionPlanesState.getHash()
        ];
        var state = this._state;
        if (state.stationary) {
            hash.push("/s");
        }
        if (state.billboard === "none") {
            hash.push("/n");
        } else if (state.billboard === "spherical") {
            hash.push("/s");
        } else if (state.billboard === "cylindrical") {
            hash.push("/c");
        }
        hash.push(";");
        return hash.join("");
    };

    Mesh.prototype._makeOcclusionHash = function _makeOcclusionHash () {
        var scene = this.scene;
        var hash = [
            scene.canvas.canvas.id,
            scene._sectionPlanesState.getHash()
        ];
        var state = this._state;
        if (state.stationary) {
            hash.push("/s");
        }
        if (state.billboard === "none") {
            hash.push("/n");
        } else if (state.billboard === "spherical") {
            hash.push("/s");
        } else if (state.billboard === "cylindrical") {
            hash.push("/c");
        }
        hash.push(";");
        return hash.join("");
    };

    Mesh.prototype._buildAABB = function _buildAABB (worldMatrix, aabb) {

        math.transformOBB3(worldMatrix, this._geometry.obb, obb);
        math.OBB3ToAABB3(obb, aabb);

        var offset = this._state.offset;

        aabb[0] += offset[0];
        aabb[1] += offset[1];
        aabb[2] += offset[2];
        aabb[3] += offset[0];
        aabb[4] += offset[1];
        aabb[5] += offset[2];

        if (this._state.rtcCenter) {
            var rtcCenter = this._state.rtcCenter;
            aabb[0] += rtcCenter[0];
            aabb[1] += rtcCenter[1];
            aabb[2] += rtcCenter[2];
            aabb[3] += rtcCenter[0];
            aabb[4] += rtcCenter[1];
            aabb[5] += rtcCenter[2];
        }
    };

    /**
     * Defines the shape of this Mesh.
     *
     * Set to {@link Scene#geometry} by default.
     *
     * @type {Geometry}
     */
    prototypeAccessors.geometry.get = function () {
        return this._geometry;
    };

    /**
     * Defines the appearance of this Mesh when rendering normally, ie. when not xrayed, highlighted or selected.
     *
     * Set to {@link Scene#material} by default.
     *
     * @type {Material}
     */
    prototypeAccessors.material.get = function () {
        return this._material;
    };

    /**
     * Sets the Mesh's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.position.set = function (value) {
        this._position.set(value || [0, 0, 0]);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.position.get = function () {
        return this._position;
    };

    /**
     * Sets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rotation.set = function (value) {
        this._rotation.set(value || [0, 0, 0]);
        math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rotation.get = function () {
        return this._rotation;
    };

    /**
     * Sets the Mesh's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.quaternion.set = function (value) {
        this._quaternion.set(value || [0, 0, 0, 1]);
        math.quaternionToEuler(this._quaternion, "XYZ", this._rotation);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.quaternion.get = function () {
        return this._quaternion;
    };

    /**
     * Sets the Mesh's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.set = function (value) {
        this._scale.set(value || [1, 1, 1]);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.matrix.set = function (value) {
        if (!this.__localMatrix) {
            this.__localMatrix = math.identityMat4();
        }
        this.__localMatrix.set(value || identityMat$1);
        math.decomposeMat4(this.__localMatrix, this._position, this._quaternion, this._scale);
        this._localMatrixDirty = false;
        this._setWorldMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.matrix.get = function () {
        if (this._localMatrixDirty) {
            if (!this.__localMatrix) {
                this.__localMatrix = math.identityMat4();
            }
            math.composeMat4(this._position, this._quaternion, this._scale, this.__localMatrix);
            this._localMatrixDirty = false;
        }
        return this.__localMatrix;
    };

    /**
     * Gets the Mesh's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */
    prototypeAccessors.worldMatrix.get = function () {
        if (this._worldMatrixDirty) {
            this._buildWorldMatrix();
        }
        return this._worldMatrix;
    };

    /**
     * Gets the Mesh's World normal matrix.
     *
     * @type {Number[]}
     */
    prototypeAccessors.worldNormalMatrix.get = function () {
        if (this._worldNormalMatrixDirty) {
            this._buildWorldNormalMatrix();
        }
        return this._worldNormalMatrix;
    };

    /**
     * Rotates the Mesh about the given local axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */
    Mesh.prototype.rotate = function rotate (axis, angle) {
        angleAxis$1[0] = axis[0];
        angleAxis$1[1] = axis[1];
        angleAxis$1[2] = axis[2];
        angleAxis$1[3] = angle * math.DEGTORAD;
        math.angleAxisToQuaternion(angleAxis$1, q1$1);
        math.mulQuaternions(this.quaternion, q1$1, q2$1);
        this.quaternion = q2$1;
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
        return this;
    };

    /**
     * Rotates the Mesh about the given World-space axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */
    Mesh.prototype.rotateOnWorldAxis = function rotateOnWorldAxis (axis, angle) {
        angleAxis$1[0] = axis[0];
        angleAxis$1[1] = axis[1];
        angleAxis$1[2] = axis[2];
        angleAxis$1[3] = angle * math.DEGTORAD;
        math.angleAxisToQuaternion(angleAxis$1, q1$1);
        math.mulQuaternions(q1$1, this.quaternion, q1$1);
        //this.quaternion.premultiply(q1);
        return this;
    };

    /**
     * Rotates the Mesh about the local X-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Mesh.prototype.rotateX = function rotateX (angle) {
        return this.rotate(xAxis$1, angle);
    };

    /**
     * Rotates the Mesh about the local Y-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Mesh.prototype.rotateY = function rotateY (angle) {
        return this.rotate(yAxis$1, angle);
    };

    /**
     * Rotates the Mesh about the local Z-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Mesh.prototype.rotateZ = function rotateZ (angle) {
        return this.rotate(zAxis$1, angle);
    };

    /**
     * Translates the Mesh along local space vector by the given increment.
     *
     * @param {Number[]} axis Normalized local space 3D vector along which to translate.
     * @param {Number} distance Distance to translate along  the vector.
     */
    Mesh.prototype.translate = function translate (axis, distance) {
        math.vec3ApplyQuaternion(this.quaternion, axis, veca$1);
        math.mulVec3Scalar(veca$1, distance, vecb$1);
        math.addVec3(this.position, vecb$1, this.position);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
        return this;
    };

    /**
     * Translates the Mesh along the local X-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the X-axis.
     */
    Mesh.prototype.translateX = function translateX (distance) {
        return this.translate(xAxis$1, distance);
    };

    /**
     * Translates the Mesh along the local Y-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Y-axis.
     */
    Mesh.prototype.translateY = function translateY (distance) {
        return this.translate(yAxis$1, distance);
    };

    /**
     * Translates the Mesh along the local Z-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Z-axis.
     */
    Mesh.prototype.translateZ = function translateZ (distance) {
        return this.translate(zAxis$1, distance);
    };

    Mesh.prototype._putDrawRenderers = function _putDrawRenderers () {
        if (this._drawRenderer) {
            this._drawRenderer.put();
            this._drawRenderer = null;
        }
        if (this._shadowRenderer) {
            this._shadowRenderer.put();
            this._shadowRenderer = null;
        }
        if (this._emphasisFillRenderer) {
            this._emphasisFillRenderer.put();
            this._emphasisFillRenderer = null;
        }
        if (this._emphasisEdgesRenderer) {
            this._emphasisEdgesRenderer.put();
            this._emphasisEdgesRenderer = null;
        }
    };

    Mesh.prototype._putPickRenderers = function _putPickRenderers () {
        if (this._pickMeshRenderer) {
            this._pickMeshRenderer.put();
            this._pickMeshRenderer = null;
        }
        if (this._pickTriangleRenderer) {
            this._pickTriangleRenderer.put();
            this._pickTriangleRenderer = null;
        }
    };

    Mesh.prototype._putOcclusionRenderer = function _putOcclusionRenderer () {
        if (this._occlusionRenderer) {
            this._occlusionRenderer.put();
            this._occlusionRenderer = null;
        }
    };

    //------------------------------------------------------------------------------------------------------------------
    // Entity members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that Mesh implements {@link Entity}.
     *
     * @returns {Boolean}
     */
    prototypeAccessors.isEntity.get = function () {
        return true;
    };

    /**
     * Returns ````true```` if this Mesh represents a model.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and
     * may also have a corresponding {@link MetaModel}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isModel.get = function () {
        return this._isModel;
    };

    /**
     * Returns ````true```` if this Mesh represents an object.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and
     * may also have a corresponding {@link MetaObject}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isObject.get = function () {
        return this._isObject;
    };

    /**
     * Gets the Mesh's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        if (this._aabbDirty) {
            this._updateAABB();
        }
        return this._aabb;
    };

    /**
     * Center of the relative-to-center (RTC) coordinate system for this Mesh.
     *
     * When this is given, then {@link Mesh#matrix}, {@link Mesh#position} and {@link Mesh#geometry} are all assumed to be relative to this center position.
     *
     * @type {Float64Array}
     */
    prototypeAccessors.rtcCenter.set = function (rtcCenter) {
        if (rtcCenter) {
            if (!this._state.rtcCenter) {
                this._state.rtcCenter = math.vec3();
            }
            this._state.rtcCenter.set(rtcCenter);
            this._state.rtcCenterHash = rtcCenter.join();
            this._setAABBDirty();
            this.scene._aabbDirty = true;
        } else {
            if (this._state.rtcCenter) {
                this._state.rtcCenter = null;
                this._state.rtcCenterHash = null;
                this._setAABBDirty();
                this.scene._aabbDirty = true;
            }
        }
    };

    /**
     * 3D origin of the Mesh's {@link Geometry}'s vertex positions.
     *
     * When this is defined, then the positions are RTC, which means that they are relative to this position.
     *
     * @type {Float64Array}
     */
    prototypeAccessors.rtcCenter.get = function () {
        return this._state.rtcCenter;
    };

    /**
     * The approximate number of triangles in this Mesh.
     *
     * @type {Number}
     */
    prototypeAccessors.numTriangles.get = function () {
        return this._numTriangles;
    };

    /**
     * Sets if this Mesh is visible.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.visible.set = function (visible) {
        visible = visible !== false;
        this._state.visible = visible;
        if (this._isObject) {
            this.scene._objectVisibilityUpdated(this);
        }
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is visible.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.visible.get = function () {
        return this._state.visible;
    };

    /**
     * Sets if this Mesh is xrayed.
     *
     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.set = function (xrayed) {
        xrayed = !!xrayed;
        if (this._state.xrayed === xrayed) {
            return;
        }
        this._state.xrayed = xrayed;
        if (this._isObject) {
            this.scene._objectXRayedUpdated(this);
        }
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is xrayed.
     *
     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.get = function () {
        return this._state.xrayed;
    };

    /**
     * Sets if this Mesh is highlighted.
     *
     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.set = function (highlighted) {
        highlighted = !!highlighted;
        if (highlighted === this._state.highlighted) {
            return;
        }
        this._state.highlighted = highlighted;
        if (this._isObject) {
            this.scene._objectHighlightedUpdated(this);
        }
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is highlighted.
     *
     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.get = function () {
        return this._state.highlighted;
    };

    /**
     * Sets if this Mesh is selected.
     *
     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.set = function (selected) {
        selected = !!selected;
        if (selected === this._state.selected) {
            return;
        }
        this._state.selected = selected;
        if (this._isObject) {
            this.scene._objectSelectedUpdated(this);
        }
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is selected.
     *
     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.
     *
     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be
     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.get = function () {
        return this._state.selected;
    };

    /**
     * Sets if this Mesh is edge-enhanced.
     *
     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.set = function (edges) {
        edges = !!edges;
        if (edges === this._state.edges) {
            return;
        }
        this._state.edges = edges;
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is edge-enhanced.
     *
     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.get = function () {
        return this._state.edges;
    };

    /**
     * Sets if this Mesh is culled.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.set = function (value) {
        this._state.culled = !!value;
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is culled.
     *
     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.get = function () {
        return this._state.culled;
    };

    /**
     * Sets if this Mesh is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.set = function (value) {
        value = value !== false;
        if (this._state.clippable === value) {
            return;
        }
        this._state.clippable = value;
        this.glRedraw();
    };

    /**
     * Gets if this Mesh is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.get = function () {
        return this._state.clippable;
    };

    /**
     * Sets if this Mesh included in boundary calculations.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.set = function (value) {
        value = value !== false;
        if (value === this._state.collidable) {
            return;
        }
        this._state.collidable = value;
        this._setAABBDirty();
        this.scene._aabbDirty = true;

    };

    /**
     * Gets if this Mesh included in boundary calculations.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.get = function () {
        return this._state.collidable;
    };

    /**
     * Sets if this Mesh is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.set = function (value) {
        value = value !== false;
        if (this._state.pickable === value) {
            return;
        }
        this._state.pickable = value;
        // No need to trigger a render;
        // state is only used when picking
    };

    /**
     * Gets if this Mesh is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.get = function () {
        return this._state.pickable;
    };

    /**
     * Sets if this Mesh casts shadows.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.set = function (value) {
        value = value !== false;
        if (value === this._state.castsShadow) {
            return;
        }
        this._state.castsShadow = value;
        this.glRedraw();
    };

    /**
     * Gets if this Mesh casts shadows.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.get = function () {
        return this._state.castsShadow;
    };

    /**
     * Sets if this Mesh can have shadows cast upon it.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.set = function (value) {
        value = value !== false;
        if (value === this._state.receivesShadow) {
            return;
        }
        this._state.receivesShadow = value;
        this._state.hash = value ? "/mod/rs;" : "/mod;";
        this.fire("dirty", this); // Now need to (re)compile objectRenderers to include/exclude shadow mapping
    };

    /**
     * Gets if this Mesh can have shadows cast upon it.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.get = function () {
        return this._state.receivesShadow;
    };

    /**
     * Gets if this Mesh can have Scalable Ambient Obscurance (SAO) applied to it.
     *
     * SAO is configured by {@link SAO}.
     *
     * @type {Boolean}
     * @abstract
     */
    prototypeAccessors.saoEnabled.get = function () {
        return false; // TODO: Support SAO on Meshes
    };

    /**
     * Sets the RGB colorize color for this Mesh.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.set = function (value) {
        var colorize = this._state.colorize;
        if (!colorize) {
            colorize = this._state.colorize = new Float32Array(4);
            colorize[3] = 1;
        }
        if (value) {
            colorize[0] = value[0];
            colorize[1] = value[1];
            colorize[2] = value[2];
        } else {
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        var colorized = (!!value);
        this.scene._objectColorizeUpdated(this, colorized);
        this.glRedraw();
    };

    /**
     * Gets the RGB colorize color for this Mesh.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.get = function () {
        return this._state.colorize;
    };

    /**
     * Sets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.set = function (opacity) {
        var colorize = this._state.colorize;
        if (!colorize) {
            colorize = this._state.colorize = new Float32Array(4);
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        var opacityUpdated = (opacity !== null && opacity !== undefined);
        colorize[3] = opacityUpdated ? opacity : 1.0;
        this.scene._objectOpacityUpdated(this, opacityUpdated);
        this.glRedraw();
    };

    /**
     * Gets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.get = function () {
        return this._state.colorize[3];
    };

    /**
     * Gets if this Mesh is transparent.
     * @returns {Boolean}
     */
    prototypeAccessors.transparent.get = function () {
        return this._material.alphaMode === 2 /* blend */ || this._state.colorize[3] < 1
    };

    /**
     * Sets the Mesh's rendering order relative to other Meshes.
     *
     * Default value is ````0````.
     *
     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.
     *
     * @type {Number}
     */
    prototypeAccessors.layer.set = function (value) {
        // TODO: Only accept rendering layer in range [0...MAX_layer]
        value = value || 0;
        value = Math.round(value);
        if (value === this._state.layer) {
            return;
        }
        this._state.layer = value;
        this._renderer.needStateSort();
    };

    /**
     * Gets the Mesh's rendering order relative to other Meshes.
     *
     * Default value is ````0````.
     *
     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.
     *
     * @type {Number}
     */
    prototypeAccessors.layer.get = function () {
        return this._state.layer;
    };

    /**
     * Gets if the Node's position is stationary.
     *
     * When true, will disable the effect of {@link Camera} translations for this Mesh, while still allowing it to rotate. This is useful for skyboxes.
     *
     * @type {Boolean}
     */
    prototypeAccessors.stationary.get = function () {
        return this._state.stationary;
    };

    /**
     * Gets the Node's billboarding behaviour.
     *
     * Options are:
     * * ````"none"```` -  (default) - No billboarding.
     * * ````"spherical"```` - Mesh is billboarded to face the viewpoint, rotating both vertically and horizontally.
     * * ````"cylindrical"```` - Mesh is billboarded to face the viewpoint, rotating only about its vertically axis. Use this mode for things like trees on a landscape.
     * @type {String}
     */
    prototypeAccessors.billboard.get = function () {
        return this._state.billboard;
    };

    /**
     * Sets the Mesh's 3D World-space offset.
     *
     * The offset dynamically translates the Mesh in World-space.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Provide a null or undefined value to reset to the default value.
     *
     * @type {Number[]}
     */
    prototypeAccessors.offset.set = function (value) {
        this._state.offset.set(value || [0, 0, 0]);
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Mesh's 3D World-space offset.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.offset.get = function () {
        return this._state.offset;
    };

    //------------------------------------------------------------------------------------------------------------------
    // Drawable members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that Mesh implements {@link Drawable}.
     * @final
     * @type {Boolean}
     */
    prototypeAccessors.isDrawable.get = function () {
        return true;
    };

    /**
     * Property with final value ````true```` to indicate that xeokit should render this Mesh in sorted order, relative to other Meshes.
     *
     * The sort order is determined by {@link Mesh#stateSortCompare}.
     *
     * Sorting is essential for rendering performance, so that xeokit is able to avoid applying runs of the same state changes to the GPU, ie. can collapse them.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isStateSortable.get = function () {
        return true;
    };

    /**
     * Comparison function used by the renderer to determine the order in which xeokit should render the Mesh, relative to to other Meshes.
     *
     * xeokit requires this method because Mesh implements {@link Drawable}.
     *
     * Sorting is essential for rendering performance, so that xeokit is able to avoid needlessly applying runs of the same rendering state changes to the GPU, ie. can collapse them.
     *
     * @param {Mesh} mesh1
     * @param {Mesh} mesh2
     * @returns {number}
     */
    Mesh.prototype.stateSortCompare = function stateSortCompare (mesh1, mesh2) {
        return (mesh1._state.layer - mesh2._state.layer)
            || (mesh1._drawRenderer.id - mesh2._drawRenderer.id) // Program state
            || (mesh1._material._state.id - mesh2._material._state.id) // Material state
            || (mesh1._geometry._state.id - mesh2._geometry._state.id); // Geometry state
    };

    /** @private */
    Mesh.prototype.rebuildRenderFlags = function rebuildRenderFlags () {
        this.renderFlags.reset();
        if (!this._getActiveSectionPlanes()) {
            this.renderFlags.culled = true;
            return;
        }
        this.renderFlags.numLayers = 1;
        this.renderFlags.numVisibleLayers = 1;
        this.renderFlags.visibleLayers[0] = 0;
        this._updateRenderFlags();
    };

    /**
     * @private
     */
    Mesh.prototype._updateRenderFlags = function _updateRenderFlags () {

        var renderFlags = this.renderFlags;
        var state = this._state;

        if (state.xrayed) {
            var xrayMaterial = this._xrayMaterial._state;
            if (xrayMaterial.fill) {
                if (xrayMaterial.fillAlpha < 1.0) {
                    renderFlags.xrayedSilhouetteTransparent = true;
                } else {
                    renderFlags.xrayedSilhouetteOpaque = true;
                }
            }
            if (xrayMaterial.edges) {
                if (xrayMaterial.edgeAlpha < 1.0) {
                    renderFlags.xrayedEdgesTransparent = true;
                } else {
                    renderFlags.xrayedEdgesOpaque = true;
                }
            }
        } else {
            var normalMaterial = this._material._state;
            if (normalMaterial.alpha < 1.0 || state.colorize[3] < 1.0) {
                renderFlags.colorTransparent = true;
            } else {
                renderFlags.colorOpaque = true;
            }
            if (state.edges) {
                var edgeMaterial = this._edgeMaterial._state;
                if (edgeMaterial.alpha < 1.0) {
                    renderFlags.edgesTransparent = true;
                } else {
                    renderFlags.edgesOpaque = true;
                }
            }
            if (state.selected) {
                var selectedMaterial = this._selectedMaterial._state;
                if (selectedMaterial.fill) {
                    if (selectedMaterial.fillAlpha < 1.0) {
                        renderFlags.selectedSilhouetteTransparent = true;
                    } else {
                        renderFlags.selectedSilhouetteOpaque = true;
                    }
                }
                if (selectedMaterial.edges) {
                    if (selectedMaterial.edgeAlpha < 1.0) {
                        renderFlags.selectedEdgesTransparent = true;
                    } else {
                        renderFlags.selectedEdgesOpaque = true;
                    }
                }
            } else if (state.highlighted) {
                var highlightMaterial = this._highlightMaterial._state;
                if (highlightMaterial.fill) {
                    if (highlightMaterial.fillAlpha < 1.0) {
                        renderFlags.highlightedSilhouetteTransparent = true;
                    } else {
                        renderFlags.highlightedSilhouetteOpaque = true;
                    }
                }
                if (highlightMaterial.edges) {
                    if (highlightMaterial.edgeAlpha < 1.0) {
                        renderFlags.highlightedEdgesTransparent = true;
                    } else {
                        renderFlags.highlightedEdgesOpaque = true;
                    }
                }
            }
        }
    };

    Mesh.prototype._getActiveSectionPlanes = function _getActiveSectionPlanes () {

        if (this._state.clippable) {

            var sectionPlanes = this.scene._sectionPlanesState.sectionPlanes;
            var numSectionPlanes = sectionPlanes.length;

            if (numSectionPlanes > 0) {
                for (var i = 0; i < numSectionPlanes; i++) {

                    var sectionPlane = sectionPlanes[i];
                    var renderFlags = this.renderFlags;

                    if (!sectionPlane.active) {
                        renderFlags.sectionPlanesActivePerLayer[i] = false;

                    } else {

                        if (this._state.rtcCenter) {

                            var intersect = math.planeAABB3Intersect(sectionPlane.dir, sectionPlane.dist, this.aabb);
                            var outside = (intersect === -1);

                            if (outside) {
                                return false;
                            }

                            var intersecting = (intersect === 0);
                            renderFlags.sectionPlanesActivePerLayer[i] = intersecting;

                        } else {
                            renderFlags.sectionPlanesActivePerLayer[i] = true;
                        }
                    }
                }
            }
        }

        return true;
    };

    /**
     * Defines the appearance of this Mesh when xrayed.
     *
     * Mesh is xrayed when {@link Mesh#xrayed} is ````true````.
     *
     * Set to {@link Scene#xrayMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.xrayMaterial.get = function () {
        return this._xrayMaterial;
    };

    /**
     * Defines the appearance of this Mesh when highlighted.
     *
     * Mesh is xrayed when {@link Mesh#highlighted} is ````true````.
     *
     * Set to {@link Scene#highlightMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.highlightMaterial.get = function () {
        return this._highlightMaterial;
    };

    /**
     * Defines the appearance of this Mesh when selected.
     *
     * Mesh is xrayed when {@link Mesh#selected} is ````true````.
     *
     * Set to {@link Scene#selectedMaterial} by default.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.selectedMaterial.get = function () {
        return this._selectedMaterial;
    };

    /**
     * Defines the appearance of this Mesh when edges are enhanced.
     *
     * Mesh is xrayed when {@link Mesh#edges} is ````true````.
     *
     * Set to {@link Scene#edgeMaterial} by default.
     *
     * @type {EdgeMaterial}
     */
    prototypeAccessors.edgeMaterial.get = function () {
        return this._edgeMaterial;
    };

    // ---------------------- NORMAL RENDERING -----------------------------------

    /** @private  */
    Mesh.prototype.drawColorOpaque = function drawColorOpaque (frameCtx) {
        if (this._drawRenderer || (this._drawRenderer = DrawRenderer.get(this))) {
            this._drawRenderer.drawMesh(frameCtx, this);
        }
    };

    /** @private  */
    Mesh.prototype.drawColorTransparent = function drawColorTransparent (frameCtx) {
        if (this._drawRenderer || (this._drawRenderer = DrawRenderer.get(this))) {
            this._drawRenderer.drawMesh(frameCtx, this);
        }
    };

    // ---------------------- RENDERING SAO POST EFFECT TARGETS --------------

    // TODO

    // ---------------------- EMPHASIS RENDERING -----------------------------------

    /** @private  */
    Mesh.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (frameCtx) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frameCtx, this, 0); // 0 == xray
        }
    };

    /** @private  */
    Mesh.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (frameCtx) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frameCtx, this, 1); // 1 == highlight
        }
    };

    /** @private  */
    Mesh.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (frameCtx) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frameCtx, this, 2); // 2 == selected
        }
    };

    // ---------------------- EDGES RENDERING -----------------------------------

    /** @private  */
    Mesh.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (frameCtx) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 3); // 3 == edges
        }
    };

    /** @private  */
    Mesh.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (frameCtx) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 3); // 3 == edges
        }
    };

    /** @private  */
    Mesh.prototype.drawEdgesXRayed = function drawEdgesXRayed (frameCtx) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 0); // 0 == xray
        }
    };

    /** @private  */
    Mesh.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (frameCtx) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 1); // 1 == highlight
        }
    };

    /** @private  */
    Mesh.prototype.drawEdgesSelected = function drawEdgesSelected (frameCtx) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 2); // 2 == selected
        }
    };

    // ---------------------- OCCLUSION CULL RENDERING -----------------------------------

    /** @private  */
    Mesh.prototype.drawOcclusion = function drawOcclusion (frameCtx) {
        if (this._occlusionRenderer || (this._occlusionRenderer = OcclusionRenderer.get(this))) {
            this._occlusionRenderer.drawMesh(frameCtx, this);
        }
    };

    // ---------------------- SHADOW BUFFER RENDERING -----------------------------------

    /** @private  */
    Mesh.prototype.drawShadow = function drawShadow (frameCtx) {
        if (this._shadowRenderer || (this._shadowRenderer = ShadowRenderer.get(this))) {
            this._shadowRenderer.drawMesh(frameCtx, this);
        }
    };

    // ---------------------- PICKING RENDERING ----------------------------------

    /** @private  */
    Mesh.prototype.drawPickMesh = function drawPickMesh (frameCtx) {
        if (this._pickMeshRenderer || (this._pickMeshRenderer = PickMeshRenderer.get(this))) {
            this._pickMeshRenderer.drawMesh(frameCtx, this);
        }
    };

    /** @private
     */
    Mesh.prototype.canPickTriangle = function canPickTriangle () {
        return this._geometry.isReadableGeometry; // VBOGeometry does not support surface picking because it has no geometry data in browser memory
    };

    /** @private  */
    Mesh.prototype.drawPickTriangles = function drawPickTriangles (frameCtx) {
        if (this._pickTriangleRenderer || (this._pickTriangleRenderer = PickTriangleRenderer.get(this))) {
            this._pickTriangleRenderer.drawMesh(frameCtx, this);
        }
    };

    /** @private */
    Mesh.prototype.pickTriangleSurface = function pickTriangleSurface$1 (pickViewMatrix, pickProjMatrix, pickResult) {
        pickTriangleSurface(this, pickViewMatrix, pickProjMatrix, pickResult);
    };

    /** @private  */
    Mesh.prototype.drawPickVertices = function drawPickVertices (frameCtx) {

    };

    /**
     * @private
     * @returns {PerformanceNode}
     */
    Mesh.prototype.delegatePickedEntity = function delegatePickedEntity () {
        return this;
    };

    //------------------------------------------------------------------------------------------------------------------
    // Component members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Destroys this Mesh.
     */
    Mesh.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this); // xeokit.Object
        this._putDrawRenderers();
        this._putPickRenderers();
        this._putOcclusionRenderer();
        this.scene._renderer.putPickID(this._state.pickID); // TODO: somehow puch this down into xeokit framework?
        if (this._isObject) {
            this.scene._deregisterObject(this);
            if (this._visible) {
                this.scene._objectVisibilityUpdated(this, false);
            }
            if (this._xrayed) {
                this.scene._objectXRayedUpdated(this, false);
            }
            if (this._selected) {
                this.scene._objectSelectedUpdated(this, false);
            }
            if (this._highlighted) {
                this.scene._objectHighlightedUpdated(this, false);
            }
            this.scene._objectColorizeUpdated(this, false);
            this.scene._objectOpacityUpdated(this, false);
            this.scene._objectOffsetUpdated(this, false);
        }
        if (this._isModel) {
            this.scene._deregisterModel(this);
        }
        this.glRedraw();
    };

    Object.defineProperties( Mesh.prototype, prototypeAccessors );

    return Mesh;
}(Component));


var pickTriangleSurface = (function () {

    // Cached vars to avoid garbage collection

    var localRayOrigin = math.vec3();
    var localRayDir = math.vec3();
    var positionA = math.vec3();
    var positionB = math.vec3();
    var positionC = math.vec3();
    var triangleVertices = math.vec3();
    var position = math.vec4();
    var worldPos = math.vec3();
    var viewPos = math.vec3();
    var bary = math.vec3();
    var normalA = math.vec3();
    var normalB = math.vec3();
    var normalC = math.vec3();
    var uva = math.vec3();
    var uvb = math.vec3();
    var uvc = math.vec3();
    var tempVec4a = math.vec4();
    var tempVec4b = math.vec4();
    var tempVec4c = math.vec4();
    var tempVec3 = math.vec3();
    var tempVec3b = math.vec3();
    var tempVec3c = math.vec3();
    var tempVec3d = math.vec3();
    var tempVec3e = math.vec3();
    var tempVec3f = math.vec3();
    var tempVec3g = math.vec3();
    var tempVec3h = math.vec3();
    var tempVec3i = math.vec3();
    var tempVec3j = math.vec3();
    var tempVec3k = math.vec3();

    return function (mesh, pickViewMatrix, pickProjMatrix, pickResult) {

        var primIndex = pickResult.primIndex;

        if (primIndex !== undefined && primIndex !== null && primIndex > -1) {

            var geometry = mesh.geometry._state;
            var scene = mesh.scene;
            var camera = scene.camera;
            var canvas = scene.canvas;

            if (geometry.primitiveName === "triangles") {

                // Triangle picked; this only happens when the
                // Mesh has a Geometry that has primitives of type "triangle"

                pickResult.primitive = "triangle";

                // Get the World-space positions of the triangle's vertices

                var i = primIndex; // Indicates the first triangle index in the indices array

                var indices = geometry.indices; // Indices into geometry arrays, not into shared VertexBufs
                var positions = geometry.positions;

                var ia3;
                var ib3;
                var ic3;

                if (indices) {

                    var ia = indices[i + 0];
                    var ib = indices[i + 1];
                    var ic = indices[i + 2];

                    triangleVertices[0] = ia;
                    triangleVertices[1] = ib;
                    triangleVertices[2] = ic;

                    pickResult.indices = triangleVertices;

                    ia3 = ia * 3;
                    ib3 = ib * 3;
                    ic3 = ic * 3;

                } else {

                    ia3 = i * 3;
                    ib3 = ia3 + 3;
                    ic3 = ib3 + 3;
                }

                positionA[0] = positions[ia3 + 0];
                positionA[1] = positions[ia3 + 1];
                positionA[2] = positions[ia3 + 2];

                positionB[0] = positions[ib3 + 0];
                positionB[1] = positions[ib3 + 1];
                positionB[2] = positions[ib3 + 2];

                positionC[0] = positions[ic3 + 0];
                positionC[1] = positions[ic3 + 1];
                positionC[2] = positions[ic3 + 2];

                if (geometry.compressGeometry) {

                    // Decompress vertex positions

                    var positionsDecodeMatrix = geometry.positionsDecodeMatrix;
                    if (positionsDecodeMatrix) {
                        geometryCompressionUtils.decompressPosition(positionA, positionsDecodeMatrix, positionA);
                        geometryCompressionUtils.decompressPosition(positionB, positionsDecodeMatrix, positionB);
                        geometryCompressionUtils.decompressPosition(positionC, positionsDecodeMatrix, positionC);
                    }
                }

                // Attempt to ray-pick the triangle in local space

                var canvasPos;

                if (pickResult.canvasPos) {
                    canvasPos = pickResult.canvasPos;
                    math.canvasPosToLocalRay(canvas.canvas, pickViewMatrix, pickProjMatrix, mesh.worldMatrix, canvasPos, localRayOrigin, localRayDir);

                } else if (pickResult.origin && pickResult.direction) {
                    math.worldRayToLocalRay(mesh.worldMatrix, pickResult.origin, pickResult.direction, localRayOrigin, localRayDir);
                }

                math.normalizeVec3(localRayDir);
                math.rayPlaneIntersect(localRayOrigin, localRayDir, positionA, positionB, positionC, position);

                // Get Local-space cartesian coordinates of the ray-triangle intersection

                pickResult.localPos = position;
                pickResult.position = position;

                // Get interpolated World-space coordinates

                // Need to transform homogeneous coords

                tempVec4a[0] = position[0];
                tempVec4a[1] = position[1];
                tempVec4a[2] = position[2];
                tempVec4a[3] = 1;

                // Get World-space cartesian coordinates of the ray-triangle intersection

                math.transformVec4(mesh.worldMatrix, tempVec4a, tempVec4b);

                worldPos[0] = tempVec4b[0];
                worldPos[1] = tempVec4b[1];
                worldPos[2] = tempVec4b[2];

                pickResult.worldPos = worldPos;

                // Get View-space cartesian coordinates of the ray-triangle intersection

                math.transformVec4(camera.matrix, tempVec4b, tempVec4c);

                viewPos[0] = tempVec4c[0];
                viewPos[1] = tempVec4c[1];
                viewPos[2] = tempVec4c[2];

                pickResult.viewPos = viewPos;

                // Get barycentric coordinates of the ray-triangle intersection

                math.cartesianToBarycentric(position, positionA, positionB, positionC, bary);

                pickResult.bary = bary;

                // Get interpolated normal vector

                var normals = geometry.normals;

                if (normals) {

                    if (geometry.compressGeometry) {

                        // Decompress vertex normals

                        var ia2 = ia * 3;
                        var ib2 = ib * 3;
                        var ic2 = ic * 3;

                        geometryCompressionUtils.decompressNormal(normals.subarray(ia2, ia2 + 2), normalA);
                        geometryCompressionUtils.decompressNormal(normals.subarray(ib2, ib2 + 2), normalB);
                        geometryCompressionUtils.decompressNormal(normals.subarray(ic2, ic2 + 2), normalC);

                    } else {

                        normalA[0] = normals[ia3];
                        normalA[1] = normals[ia3 + 1];
                        normalA[2] = normals[ia3 + 2];

                        normalB[0] = normals[ib3];
                        normalB[1] = normals[ib3 + 1];
                        normalB[2] = normals[ib3 + 2];

                        normalC[0] = normals[ic3];
                        normalC[1] = normals[ic3 + 1];
                        normalC[2] = normals[ic3 + 2];
                    }

                    var normal = math.addVec3(math.addVec3(
                        math.mulVec3Scalar(normalA, bary[0], tempVec3),
                        math.mulVec3Scalar(normalB, bary[1], tempVec3b), tempVec3c),
                        math.mulVec3Scalar(normalC, bary[2], tempVec3d), tempVec3e);

                    pickResult.worldNormal = math.normalizeVec3(math.transformVec3(mesh.worldNormalMatrix, normal, tempVec3f));
                }

                // Get interpolated UV coordinates

                var uvs = geometry.uv;

                if (uvs) {

                    uva[0] = uvs[(ia * 2)];
                    uva[1] = uvs[(ia * 2) + 1];

                    uvb[0] = uvs[(ib * 2)];
                    uvb[1] = uvs[(ib * 2) + 1];

                    uvc[0] = uvs[(ic * 2)];
                    uvc[1] = uvs[(ic * 2) + 1];

                    if (geometry.compressGeometry) {

                        // Decompress vertex UVs

                        var uvDecodeMatrix = geometry.uvDecodeMatrix;
                        if (uvDecodeMatrix) {
                            geometryCompressionUtils.decompressUV(uva, uvDecodeMatrix, uva);
                            geometryCompressionUtils.decompressUV(uvb, uvDecodeMatrix, uvb);
                            geometryCompressionUtils.decompressUV(uvc, uvDecodeMatrix, uvc);
                        }
                    }

                    pickResult.uv = math.addVec3(
                        math.addVec3(
                            math.mulVec2Scalar(uva, bary[0], tempVec3g),
                            math.mulVec2Scalar(uvb, bary[1], tempVec3h), tempVec3i),
                        math.mulVec2Scalar(uvc, bary[2], tempVec3j), tempVec3k);
                }
            }
        }
    }
})();

/**
 * @desc Creates a cylinder-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a cylinder-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]
 *
 * ````javascript
 *
 * import {Viewer, Mesh, buildCylinderGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 *  });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildCylinderGeometry({
 *          center: [0,0,0],
 *          radiusTop: 2.0,
 *          radiusBottom: 2.0,
 *          height: 5.0,
 *          radialSegments: 20,
 *          heightSegments: 1,
 *          openEnded: false
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildCylinderGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.radiusTop=1]  Radius of top.
 * @param {Number} [cfg.radiusBottom=1]  Radius of bottom.
 * @param {Number} [cfg.height=1] Height.
 * @param {Number} [cfg.radialSegments=60]  Number of horizontal segments.
 * @param {Number} [cfg.heightSegments=1]  Number of vertical segments.
 * @param {Boolean} [cfg.openEnded=false]  Whether or not the cylinder has solid caps on the ends.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildCylinderGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var radiusTop = cfg.radiusTop || 1;
    if (radiusTop < 0) {
        console.error("negative radiusTop not allowed - will invert");
        radiusTop *= -1;
    }

    var radiusBottom = cfg.radiusBottom || 1;
    if (radiusBottom < 0) {
        console.error("negative radiusBottom not allowed - will invert");
        radiusBottom *= -1;
    }

    var height = cfg.height || 1;
    if (height < 0) {
        console.error("negative height not allowed - will invert");
        height *= -1;
    }

    var radialSegments = cfg.radialSegments || 32;
    if (radialSegments < 0) {
        console.error("negative radialSegments not allowed - will invert");
        radialSegments *= -1;
    }
    if (radialSegments < 3) {
        radialSegments = 3;
    }

    var heightSegments = cfg.heightSegments || 1;
    if (heightSegments < 0) {
        console.error("negative heightSegments not allowed - will invert");
        heightSegments *= -1;
    }
    if (heightSegments < 1) {
        heightSegments = 1;
    }

    var openEnded = !!cfg.openEnded;

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;

    var heightHalf = height / 2;
    var heightLength = height / heightSegments;
    var radialAngle = (2.0 * Math.PI / radialSegments);
    var radialLength = 1.0 / radialSegments;
    //var nextRadius = this._radiusBottom;
    var radiusChange = (radiusTop - radiusBottom) / heightSegments;

    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    var h;
    var i;

    var x;
    var z;

    var currentRadius;
    var currentHeight;

    var first;
    var second;

    var startIndex;
    var tu;
    var tv;

    // create vertices
    var normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;

    for (h = 0; h <= heightSegments; h++) {
        currentRadius = radiusTop - h * radiusChange;
        currentHeight = heightHalf - h * heightLength;

        for (i = 0; i <= radialSegments; i++) {
            x = Math.sin(i * radialAngle);
            z = Math.cos(i * radialAngle);

            normals.push(currentRadius * x);
            normals.push(normalY); //todo
            normals.push(currentRadius * z);

            uvs.push((i * radialLength));
            uvs.push(h * 1 / heightSegments);

            positions.push((currentRadius * x) + centerX);
            positions.push((currentHeight) + centerY);
            positions.push((currentRadius * z) + centerZ);
        }
    }

    // create faces
    for (h = 0; h < heightSegments; h++) {
        for (i = 0; i <= radialSegments; i++) {

            first = h * (radialSegments + 1) + i;
            second = first + radialSegments;

            indices.push(first);
            indices.push(second);
            indices.push(second + 1);

            indices.push(first);
            indices.push(second + 1);
            indices.push(first + 1);
        }
    }

    // create top cap
    if (!openEnded && radiusTop > 0) {
        startIndex = (positions.length / 3);

        // top center
        normals.push(0.0);
        normals.push(1.0);
        normals.push(0.0);

        uvs.push(0.5);
        uvs.push(0.5);

        positions.push(0 + centerX);
        positions.push(heightHalf + centerY);
        positions.push(0 + centerZ);

        // top triangle fan
        for (i = 0; i <= radialSegments; i++) {
            x = Math.sin(i * radialAngle);
            z = Math.cos(i * radialAngle);
            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

            normals.push(radiusTop * x);
            normals.push(1.0);
            normals.push(radiusTop * z);

            uvs.push(tu);
            uvs.push(tv);

            positions.push((radiusTop * x) + centerX);
            positions.push((heightHalf) + centerY);
            positions.push((radiusTop * z) + centerZ);
        }

        for (i = 0; i < radialSegments; i++) {
            center = startIndex;
            first = startIndex + 1 + i;

            indices.push(first);
            indices.push(first + 1);
            indices.push(center);
        }
    }

    // create bottom cap
    if (!openEnded && radiusBottom > 0) {

        startIndex = (positions.length / 3);

        // top center
        normals.push(0.0);
        normals.push(-1.0);
        normals.push(0.0);

        uvs.push(0.5);
        uvs.push(0.5);

        positions.push(0 + centerX);
        positions.push(0 - heightHalf + centerY);
        positions.push(0 + centerZ);

        // top triangle fan
        for (i = 0; i <= radialSegments; i++) {

            x = Math.sin(i * radialAngle);
            z = Math.cos(i * radialAngle);

            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

            normals.push(radiusBottom * x);
            normals.push(-1.0);
            normals.push(radiusBottom * z);

            uvs.push(tu);
            uvs.push(tv);

            positions.push((radiusBottom * x) + centerX);
            positions.push((0 - heightHalf) + centerY);
            positions.push((radiusBottom * z) + centerZ);
        }

        for (i = 0; i < radialSegments; i++) {

            center = startIndex;
            first = startIndex + 1 + i;

            indices.push(center);
            indices.push(first + 1);
            indices.push(first);
        }
    }

    return utils.apply(cfg, {
        positions: positions,
        normals: normals,
        uv: uvs,
        indices: indices
    });
}

/**
 * @desc Creates a sphere-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a sphere-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          center: [0,0,0],
 *          radius: 1.5,
 *          heightSegments: 60,
 *          widthSegments: 60
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildSphereGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.radius=1]  Radius.
 * @param {Number} [cfg.heightSegments=24] Number of latitudinal bands.
 * @param  {Number} [cfg.widthSegments=18] Number of longitudinal bands.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildSphereGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var lod = cfg.lod || 1;

    var centerX = cfg.center ? cfg.center[0] : 0;
    var centerY = cfg.center ? cfg.center[1] : 0;
    var centerZ = cfg.center ? cfg.center[2] : 0;

    var radius = cfg.radius || 1;
    if (radius < 0) {
        console.error("negative radius not allowed - will invert");
        radius *= -1;
    }

    var heightSegments = cfg.heightSegments || 18;
    if (heightSegments < 0) {
        console.error("negative heightSegments not allowed - will invert");
        heightSegments *= -1;
    }
    heightSegments = Math.floor(lod * heightSegments);
    if (heightSegments < 18) {
        heightSegments = 18;
    }

    var widthSegments = cfg.widthSegments || 18;
    if (widthSegments < 0) {
        console.error("negative widthSegments not allowed - will invert");
        widthSegments *= -1;
    }
    widthSegments = Math.floor(lod * widthSegments);
    if (widthSegments < 18) {
        widthSegments = 18;
    }

    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    var i;
    var j;

    var theta;
    var sinTheta;
    var cosTheta;

    var phi;
    var sinPhi;
    var cosPhi;

    var x;
    var y;
    var z;

    var u;
    var v;

    var first;
    var second;

    for (i = 0; i <= heightSegments; i++) {

        theta = i * Math.PI / heightSegments;
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);

        for (j = 0; j <= widthSegments; j++) {

            phi = j * 2 * Math.PI / widthSegments;
            sinPhi = Math.sin(phi);
            cosPhi = Math.cos(phi);

            x = cosPhi * sinTheta;
            y = cosTheta;
            z = sinPhi * sinTheta;
            u = 1.0 - j / widthSegments;
            v = i / heightSegments;

            normals.push(x);
            normals.push(y);
            normals.push(z);

            uvs.push(u);
            uvs.push(v);

            positions.push(centerX + radius * x);
            positions.push(centerY + radius * y);
            positions.push(centerZ + radius * z);
        }
    }

    for (i = 0; i < heightSegments; i++) {
        for (j = 0; j < widthSegments; j++) {

            first = (i * (widthSegments + 1)) + j;
            second = first + widthSegments + 1;

            indices.push(first + 1);
            indices.push(second + 1);
            indices.push(second);
            indices.push(first + 1);
            indices.push(second);
            indices.push(first);
        }
    }

    return utils.apply(cfg, {
        positions: positions,
        normals: normals,
        uv: uvs,
        indices: indices
    });
}

var letters = {
    ' ': {width: 16, points: []},
    '!': {
        width: 10, points: [
            [5, 21],
            [5, 7],
            [-1, -1],
            [5, 2],
            [4, 1],
            [5, 0],
            [6, 1],
            [5, 2]
        ]
    },
    '"': {
        width: 16, points: [
            [4, 21],
            [4, 14],
            [-1, -1],
            [12, 21],
            [12, 14]
        ]
    },
    '#': {
        width: 21, points: [
            [11, 25],
            [4, -7],
            [-1, -1],
            [17, 25],
            [10, -7],
            [-1, -1],
            [4, 12],
            [18, 12],
            [-1, -1],
            [3, 6],
            [17, 6]
        ]
    },
    '$': {
        width: 20, points: [
            [8, 25],
            [8, -4],
            [-1, -1],
            [12, 25],
            [12, -4],
            [-1, -1],
            [17, 18],
            [15, 20],
            [12, 21],
            [8, 21],
            [5, 20],
            [3, 18],
            [3, 16],
            [4, 14],
            [5, 13],
            [7, 12],
            [13, 10],
            [15, 9],
            [16, 8],
            [17, 6],
            [17, 3],
            [15, 1],
            [12, 0],
            [8, 0],
            [5, 1],
            [3, 3]
        ]
    },
    '%': {
        width: 24, points: [
            [21, 21],
            [3, 0],
            [-1, -1],
            [8, 21],
            [10, 19],
            [10, 17],
            [9, 15],
            [7, 14],
            [5, 14],
            [3, 16],
            [3, 18],
            [4, 20],
            [6, 21],
            [8, 21],
            [10, 20],
            [13, 19],
            [16, 19],
            [19, 20],
            [21, 21],
            [-1, -1],
            [17, 7],
            [15, 6],
            [14, 4],
            [14, 2],
            [16, 0],
            [18, 0],
            [20, 1],
            [21, 3],
            [21, 5],
            [19, 7],
            [17, 7]
        ]
    },
    '&': {
        width: 26, points: [
            [23, 12],
            [23, 13],
            [22, 14],
            [21, 14],
            [20, 13],
            [19, 11],
            [17, 6],
            [15, 3],
            [13, 1],
            [11, 0],
            [7, 0],
            [5, 1],
            [4, 2],
            [3, 4],
            [3, 6],
            [4, 8],
            [5, 9],
            [12, 13],
            [13, 14],
            [14, 16],
            [14, 18],
            [13, 20],
            [11, 21],
            [9, 20],
            [8, 18],
            [8, 16],
            [9, 13],
            [11, 10],
            [16, 3],
            [18, 1],
            [20, 0],
            [22, 0],
            [23, 1],
            [23, 2]
        ]
    },
    '\'': {
        width: 10, points: [
            [5, 19],
            [4, 20],
            [5, 21],
            [6, 20],
            [6, 18],
            [5, 16],
            [4, 15]
        ]
    },
    '(': {
        width: 14, points: [
            [11, 25],
            [9, 23],
            [7, 20],
            [5, 16],
            [4, 11],
            [4, 7],
            [5, 2],
            [7, -2],
            [9, -5],
            [11, -7]
        ]
    },
    ')': {
        width: 14, points: [
            [3, 25],
            [5, 23],
            [7, 20],
            [9, 16],
            [10, 11],
            [10, 7],
            [9, 2],
            [7, -2],
            [5, -5],
            [3, -7]
        ]
    },
    '*': {
        width: 16, points: [
            [8, 21],
            [8, 9],
            [-1, -1],
            [3, 18],
            [13, 12],
            [-1, -1],
            [13, 18],
            [3, 12]
        ]
    },
    '+': {
        width: 26, points: [
            [13, 18],
            [13, 0],
            [-1, -1],
            [4, 9],
            [22, 9]
        ]
    },
    ',': {
        width: 10, points: [
            [6, 1],
            [5, 0],
            [4, 1],
            [5, 2],
            [6, 1],
            [6, -1],
            [5, -3],
            [4, -4]
        ]
    },
    '-': {
        width: 26, points: [
            [4, 9],
            [22, 9]
        ]
    },
    '.': {
        width: 10, points: [
            [5, 2],
            [4, 1],
            [5, 0],
            [6, 1],
            [5, 2]
        ]
    },
    '/': {
        width: 22, points: [
            [20, 25],
            [2, -7]
        ]
    },
    '0': {
        width: 20, points: [
            [9, 21],
            [6, 20],
            [4, 17],
            [3, 12],
            [3, 9],
            [4, 4],
            [6, 1],
            [9, 0],
            [11, 0],
            [14, 1],
            [16, 4],
            [17, 9],
            [17, 12],
            [16, 17],
            [14, 20],
            [11, 21],
            [9, 21]
        ]
    },
    '1': {
        width: 20, points: [
            [6, 17],
            [8, 18],
            [11, 21],
            [11, 0]
        ]
    },
    '2': {
        width: 20, points: [
            [4, 16],
            [4, 17],
            [5, 19],
            [6, 20],
            [8, 21],
            [12, 21],
            [14, 20],
            [15, 19],
            [16, 17],
            [16, 15],
            [15, 13],
            [13, 10],
            [3, 0],
            [17, 0]
        ]
    },
    '3': {
        width: 20, points: [
            [5, 21],
            [16, 21],
            [10, 13],
            [13, 13],
            [15, 12],
            [16, 11],
            [17, 8],
            [17, 6],
            [16, 3],
            [14, 1],
            [11, 0],
            [8, 0],
            [5, 1],
            [4, 2],
            [3, 4]
        ]
    },
    '4': {
        width: 20, points: [
            [13, 21],
            [3, 7],
            [18, 7],
            [-1, -1],
            [13, 21],
            [13, 0]
        ]
    },
    '5': {
        width: 20, points: [
            [15, 21],
            [5, 21],
            [4, 12],
            [5, 13],
            [8, 14],
            [11, 14],
            [14, 13],
            [16, 11],
            [17, 8],
            [17, 6],
            [16, 3],
            [14, 1],
            [11, 0],
            [8, 0],
            [5, 1],
            [4, 2],
            [3, 4]
        ]
    },
    '6': {
        width: 20, points: [
            [16, 18],
            [15, 20],
            [12, 21],
            [10, 21],
            [7, 20],
            [5, 17],
            [4, 12],
            [4, 7],
            [5, 3],
            [7, 1],
            [10, 0],
            [11, 0],
            [14, 1],
            [16, 3],
            [17, 6],
            [17, 7],
            [16, 10],
            [14, 12],
            [11, 13],
            [10, 13],
            [7, 12],
            [5, 10],
            [4, 7]
        ]
    },
    '7': {
        width: 20, points: [
            [17, 21],
            [7, 0],
            [-1, -1],
            [3, 21],
            [17, 21]
        ]
    },
    '8': {
        width: 20, points: [
            [8, 21],
            [5, 20],
            [4, 18],
            [4, 16],
            [5, 14],
            [7, 13],
            [11, 12],
            [14, 11],
            [16, 9],
            [17, 7],
            [17, 4],
            [16, 2],
            [15, 1],
            [12, 0],
            [8, 0],
            [5, 1],
            [4, 2],
            [3, 4],
            [3, 7],
            [4, 9],
            [6, 11],
            [9, 12],
            [13, 13],
            [15, 14],
            [16, 16],
            [16, 18],
            [15, 20],
            [12, 21],
            [8, 21]
        ]
    },
    '9': {
        width: 20, points: [
            [16, 14],
            [15, 11],
            [13, 9],
            [10, 8],
            [9, 8],
            [6, 9],
            [4, 11],
            [3, 14],
            [3, 15],
            [4, 18],
            [6, 20],
            [9, 21],
            [10, 21],
            [13, 20],
            [15, 18],
            [16, 14],
            [16, 9],
            [15, 4],
            [13, 1],
            [10, 0],
            [8, 0],
            [5, 1],
            [4, 3]
        ]
    },
    ':': {
        width: 10, points: [
            [5, 14],
            [4, 13],
            [5, 12],
            [6, 13],
            [5, 14],
            [-1, -1],
            [5, 2],
            [4, 1],
            [5, 0],
            [6, 1],
            [5, 2]
        ]
    },
    ';': {
        width: 10, points: [
            [5, 14],
            [4, 13],
            [5, 12],
            [6, 13],
            [5, 14],
            [-1, -1],
            [6, 1],
            [5, 0],
            [4, 1],
            [5, 2],
            [6, 1],
            [6, -1],
            [5, -3],
            [4, -4]
        ]
    },
    '<': {
        width: 24, points: [
            [20, 18],
            [4, 9],
            [20, 0]
        ]
    },
    '=': {
        width: 26, points: [
            [4, 12],
            [22, 12],
            [-1, -1],
            [4, 6],
            [22, 6]
        ]
    },
    '>': {
        width: 24, points: [
            [4, 18],
            [20, 9],
            [4, 0]
        ]
    },
    '?': {
        width: 18, points: [
            [3, 16],
            [3, 17],
            [4, 19],
            [5, 20],
            [7, 21],
            [11, 21],
            [13, 20],
            [14, 19],
            [15, 17],
            [15, 15],
            [14, 13],
            [13, 12],
            [9, 10],
            [9, 7],
            [-1, -1],
            [9, 2],
            [8, 1],
            [9, 0],
            [10, 1],
            [9, 2]
        ]
    },
    '@': {
        width: 27, points: [
            [18, 13],
            [17, 15],
            [15, 16],
            [12, 16],
            [10, 15],
            [9, 14],
            [8, 11],
            [8, 8],
            [9, 6],
            [11, 5],
            [14, 5],
            [16, 6],
            [17, 8],
            [-1, -1],
            [12, 16],
            [10, 14],
            [9, 11],
            [9, 8],
            [10, 6],
            [11, 5],
            [-1, -1],
            [18, 16],
            [17, 8],
            [17, 6],
            [19, 5],
            [21, 5],
            [23, 7],
            [24, 10],
            [24, 12],
            [23, 15],
            [22, 17],
            [20, 19],
            [18, 20],
            [15, 21],
            [12, 21],
            [9, 20],
            [7, 19],
            [5, 17],
            [4, 15],
            [3, 12],
            [3, 9],
            [4, 6],
            [5, 4],
            [7, 2],
            [9, 1],
            [12, 0],
            [15, 0],
            [18, 1],
            [20, 2],
            [21, 3],
            [-1, -1],
            [19, 16],
            [18, 8],
            [18, 6],
            [19, 5]
        ]
    },
    'A': {
        width: 18, points: [
            [9, 21],
            [1, 0],
            [-1, -1],
            [9, 21],
            [17, 0],
            [-1, -1],
            [4, 7],
            [14, 7]
        ]
    },
    'B': {
        width: 21, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [13, 21],
            [16, 20],
            [17, 19],
            [18, 17],
            [18, 15],
            [17, 13],
            [16, 12],
            [13, 11],
            [-1, -1],
            [4, 11],
            [13, 11],
            [16, 10],
            [17, 9],
            [18, 7],
            [18, 4],
            [17, 2],
            [16, 1],
            [13, 0],
            [4, 0]
        ]
    },
    'C': {
        width: 21, points: [
            [18, 16],
            [17, 18],
            [15, 20],
            [13, 21],
            [9, 21],
            [7, 20],
            [5, 18],
            [4, 16],
            [3, 13],
            [3, 8],
            [4, 5],
            [5, 3],
            [7, 1],
            [9, 0],
            [13, 0],
            [15, 1],
            [17, 3],
            [18, 5]
        ]
    },
    'D': {
        width: 21, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [11, 21],
            [14, 20],
            [16, 18],
            [17, 16],
            [18, 13],
            [18, 8],
            [17, 5],
            [16, 3],
            [14, 1],
            [11, 0],
            [4, 0]
        ]
    },
    'E': {
        width: 19, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [17, 21],
            [-1, -1],
            [4, 11],
            [12, 11],
            [-1, -1],
            [4, 0],
            [17, 0]
        ]
    },
    'F': {
        width: 18, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [17, 21],
            [-1, -1],
            [4, 11],
            [12, 11]
        ]
    },
    'G': {
        width: 21, points: [
            [18, 16],
            [17, 18],
            [15, 20],
            [13, 21],
            [9, 21],
            [7, 20],
            [5, 18],
            [4, 16],
            [3, 13],
            [3, 8],
            [4, 5],
            [5, 3],
            [7, 1],
            [9, 0],
            [13, 0],
            [15, 1],
            [17, 3],
            [18, 5],
            [18, 8],
            [-1, -1],
            [13, 8],
            [18, 8]
        ]
    },
    'H': {
        width: 22, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [18, 21],
            [18, 0],
            [-1, -1],
            [4, 11],
            [18, 11]
        ]
    },
    'I': {
        width: 8, points: [
            [4, 21],
            [4, 0]
        ]
    },
    'J': {
        width: 16, points: [
            [12, 21],
            [12, 5],
            [11, 2],
            [10, 1],
            [8, 0],
            [6, 0],
            [4, 1],
            [3, 2],
            [2, 5],
            [2, 7]
        ]
    },
    'K': {
        width: 21, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [18, 21],
            [4, 7],
            [-1, -1],
            [9, 12],
            [18, 0]
        ]
    },
    'L': {
        width: 17, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 0],
            [16, 0]
        ]
    },
    'M': {
        width: 24, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [12, 0],
            [-1, -1],
            [20, 21],
            [12, 0],
            [-1, -1],
            [20, 21],
            [20, 0]
        ]
    },
    'N': {
        width: 22, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [18, 0],
            [-1, -1],
            [18, 21],
            [18, 0]
        ]
    },
    'O': {
        width: 22, points: [
            [9, 21],
            [7, 20],
            [5, 18],
            [4, 16],
            [3, 13],
            [3, 8],
            [4, 5],
            [5, 3],
            [7, 1],
            [9, 0],
            [13, 0],
            [15, 1],
            [17, 3],
            [18, 5],
            [19, 8],
            [19, 13],
            [18, 16],
            [17, 18],
            [15, 20],
            [13, 21],
            [9, 21]
        ]
    },
    'P': {
        width: 21, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [13, 21],
            [16, 20],
            [17, 19],
            [18, 17],
            [18, 14],
            [17, 12],
            [16, 11],
            [13, 10],
            [4, 10]
        ]
    },
    'Q': {
        width: 22, points: [
            [9, 21],
            [7, 20],
            [5, 18],
            [4, 16],
            [3, 13],
            [3, 8],
            [4, 5],
            [5, 3],
            [7, 1],
            [9, 0],
            [13, 0],
            [15, 1],
            [17, 3],
            [18, 5],
            [19, 8],
            [19, 13],
            [18, 16],
            [17, 18],
            [15, 20],
            [13, 21],
            [9, 21],
            [-1, -1],
            [12, 4],
            [18, -2]
        ]
    },
    'R': {
        width: 21, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 21],
            [13, 21],
            [16, 20],
            [17, 19],
            [18, 17],
            [18, 15],
            [17, 13],
            [16, 12],
            [13, 11],
            [4, 11],
            [-1, -1],
            [11, 11],
            [18, 0]
        ]
    },
    'S': {
        width: 20, points: [
            [17, 18],
            [15, 20],
            [12, 21],
            [8, 21],
            [5, 20],
            [3, 18],
            [3, 16],
            [4, 14],
            [5, 13],
            [7, 12],
            [13, 10],
            [15, 9],
            [16, 8],
            [17, 6],
            [17, 3],
            [15, 1],
            [12, 0],
            [8, 0],
            [5, 1],
            [3, 3]
        ]
    },
    'T': {
        width: 16, points: [
            [8, 21],
            [8, 0],
            [-1, -1],
            [1, 21],
            [15, 21]
        ]
    },
    'U': {
        width: 22, points: [
            [4, 21],
            [4, 6],
            [5, 3],
            [7, 1],
            [10, 0],
            [12, 0],
            [15, 1],
            [17, 3],
            [18, 6],
            [18, 21]
        ]
    },
    'V': {
        width: 18, points: [
            [1, 21],
            [9, 0],
            [-1, -1],
            [17, 21],
            [9, 0]
        ]
    },
    'W': {
        width: 24, points: [
            [2, 21],
            [7, 0],
            [-1, -1],
            [12, 21],
            [7, 0],
            [-1, -1],
            [12, 21],
            [17, 0],
            [-1, -1],
            [22, 21],
            [17, 0]
        ]
    },
    'X': {
        width: 20, points: [
            [3, 21],
            [17, 0],
            [-1, -1],
            [17, 21],
            [3, 0]
        ]
    },
    'Y': {
        width: 18, points: [
            [1, 21],
            [9, 11],
            [9, 0],
            [-1, -1],
            [17, 21],
            [9, 11]
        ]
    },
    'Z': {
        width: 20, points: [
            [17, 21],
            [3, 0],
            [-1, -1],
            [3, 21],
            [17, 21],
            [-1, -1],
            [3, 0],
            [17, 0]
        ]
    },
    '[': {
        width: 14, points: [
            [4, 25],
            [4, -7],
            [-1, -1],
            [5, 25],
            [5, -7],
            [-1, -1],
            [4, 25],
            [11, 25],
            [-1, -1],
            [4, -7],
            [11, -7]
        ]
    },
    '\\': {
        width: 14, points: [
            [0, 21],
            [14, -3]
        ]
    },
    ']': {
        width: 14, points: [
            [9, 25],
            [9, -7],
            [-1, -1],
            [10, 25],
            [10, -7],
            [-1, -1],
            [3, 25],
            [10, 25],
            [-1, -1],
            [3, -7],
            [10, -7]
        ]
    },
    '^': {
        width: 16, points: [
            [6, 15],
            [8, 18],
            [10, 15],
            [-1, -1],
            [3, 12],
            [8, 17],
            [13, 12],
            [-1, -1],
            [8, 17],
            [8, 0]
        ]
    },
    '_': {
        width: 16, points: [
            [0, -2],
            [16, -2]
        ]
    },
    '`': {
        width: 10, points: [
            [6, 21],
            [5, 20],
            [4, 18],
            [4, 16],
            [5, 15],
            [6, 16],
            [5, 17]
        ]
    },
    'a': {
        width: 19, points: [
            [15, 14],
            [15, 0],
            [-1, -1],
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'b': {
        width: 19, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 11],
            [6, 13],
            [8, 14],
            [11, 14],
            [13, 13],
            [15, 11],
            [16, 8],
            [16, 6],
            [15, 3],
            [13, 1],
            [11, 0],
            [8, 0],
            [6, 1],
            [4, 3]
        ]
    },
    'c': {
        width: 18, points: [
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'd': {
        width: 19, points: [
            [15, 21],
            [15, 0],
            [-1, -1],
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'e': {
        width: 18, points: [
            [3, 8],
            [15, 8],
            [15, 10],
            [14, 12],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'f': {
        width: 12, points: [
            [10, 21],
            [8, 21],
            [6, 20],
            [5, 17],
            [5, 0],
            [-1, -1],
            [2, 14],
            [9, 14]
        ]
    },
    'g': {
        width: 19, points: [
            [15, 14],
            [15, -2],
            [14, -5],
            [13, -6],
            [11, -7],
            [8, -7],
            [6, -6],
            [-1, -1],
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'h': {
        width: 19, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [4, 10],
            [7, 13],
            [9, 14],
            [12, 14],
            [14, 13],
            [15, 10],
            [15, 0]
        ]
    },
    'i': {
        width: 8, points: [
            [3, 21],
            [4, 20],
            [5, 21],
            [4, 22],
            [3, 21],
            [-1, -1],
            [4, 14],
            [4, 0]
        ]
    },
    'j': {
        width: 10, points: [
            [5, 21],
            [6, 20],
            [7, 21],
            [6, 22],
            [5, 21],
            [-1, -1],
            [6, 14],
            [6, -3],
            [5, -6],
            [3, -7],
            [1, -7]
        ]
    },
    'k': {
        width: 17, points: [
            [4, 21],
            [4, 0],
            [-1, -1],
            [14, 14],
            [4, 4],
            [-1, -1],
            [8, 8],
            [15, 0]
        ]
    },
    'l': {
        width: 8, points: [
            [4, 21],
            [4, 0]
        ]
    },
    'm': {
        width: 30, points: [
            [4, 14],
            [4, 0],
            [-1, -1],
            [4, 10],
            [7, 13],
            [9, 14],
            [12, 14],
            [14, 13],
            [15, 10],
            [15, 0],
            [-1, -1],
            [15, 10],
            [18, 13],
            [20, 14],
            [23, 14],
            [25, 13],
            [26, 10],
            [26, 0]
        ]
    },
    'n': {
        width: 19, points: [
            [4, 14],
            [4, 0],
            [-1, -1],
            [4, 10],
            [7, 13],
            [9, 14],
            [12, 14],
            [14, 13],
            [15, 10],
            [15, 0]
        ]
    },
    'o': {
        width: 19, points: [
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3],
            [16, 6],
            [16, 8],
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14]
        ]
    },
    'p': {
        width: 19, points: [
            [4, 14],
            [4, -7],
            [-1, -1],
            [4, 11],
            [6, 13],
            [8, 14],
            [11, 14],
            [13, 13],
            [15, 11],
            [16, 8],
            [16, 6],
            [15, 3],
            [13, 1],
            [11, 0],
            [8, 0],
            [6, 1],
            [4, 3]
        ]
    },
    'q': {
        width: 19, points: [
            [15, 14],
            [15, -7],
            [-1, -1],
            [15, 11],
            [13, 13],
            [11, 14],
            [8, 14],
            [6, 13],
            [4, 11],
            [3, 8],
            [3, 6],
            [4, 3],
            [6, 1],
            [8, 0],
            [11, 0],
            [13, 1],
            [15, 3]
        ]
    },
    'r': {
        width: 13, points: [
            [4, 14],
            [4, 0],
            [-1, -1],
            [4, 8],
            [5, 11],
            [7, 13],
            [9, 14],
            [12, 14]
        ]
    },
    's': {
        width: 17, points: [
            [14, 11],
            [13, 13],
            [10, 14],
            [7, 14],
            [4, 13],
            [3, 11],
            [4, 9],
            [6, 8],
            [11, 7],
            [13, 6],
            [14, 4],
            [14, 3],
            [13, 1],
            [10, 0],
            [7, 0],
            [4, 1],
            [3, 3]
        ]
    },
    't': {
        width: 12, points: [
            [5, 21],
            [5, 4],
            [6, 1],
            [8, 0],
            [10, 0],
            [-1, -1],
            [2, 14],
            [9, 14]
        ]
    },
    'u': {
        width: 19, points: [
            [4, 14],
            [4, 4],
            [5, 1],
            [7, 0],
            [10, 0],
            [12, 1],
            [15, 4],
            [-1, -1],
            [15, 14],
            [15, 0]
        ]
    },
    'v': {
        width: 16, points: [
            [2, 14],
            [8, 0],
            [-1, -1],
            [14, 14],
            [8, 0]
        ]
    },
    'w': {
        width: 22, points: [
            [3, 14],
            [7, 0],
            [-1, -1],
            [11, 14],
            [7, 0],
            [-1, -1],
            [11, 14],
            [15, 0],
            [-1, -1],
            [19, 14],
            [15, 0]
        ]
    },
    'x': {
        width: 17, points: [
            [3, 14],
            [14, 0],
            [-1, -1],
            [14, 14],
            [3, 0]
        ]
    },
    'y': {
        width: 16, points: [
            [2, 14],
            [8, 0],
            [-1, -1],
            [14, 14],
            [8, 0],
            [6, -4],
            [4, -6],
            [2, -7],
            [1, -7]
        ]
    },
    'z': {
        width: 17, points: [
            [14, 14],
            [3, 0],
            [-1, -1],
            [3, 14],
            [14, 14],
            [-1, -1],
            [3, 0],
            [14, 0]
        ]
    },
    '{': {
        width: 14, points: [
            [9, 25],
            [7, 24],
            [6, 23],
            [5, 21],
            [5, 19],
            [6, 17],
            [7, 16],
            [8, 14],
            [8, 12],
            [6, 10],
            [-1, -1],
            [7, 24],
            [6, 22],
            [6, 20],
            [7, 18],
            [8, 17],
            [9, 15],
            [9, 13],
            [8, 11],
            [4, 9],
            [8, 7],
            [9, 5],
            [9, 3],
            [8, 1],
            [7, 0],
            [6, -2],
            [6, -4],
            [7, -6],
            [-1, -1],
            [6, 8],
            [8, 6],
            [8, 4],
            [7, 2],
            [6, 1],
            [5, -1],
            [5, -3],
            [6, -5],
            [7, -6],
            [9, -7]
        ]
    },
    '|': {
        width: 8, points: [
            [4, 25],
            [4, -7]
        ]
    },
    '}': {
        width: 14, points: [
            [5, 25],
            [7, 24],
            [8, 23],
            [9, 21],
            [9, 19],
            [8, 17],
            [7, 16],
            [6, 14],
            [6, 12],
            [8, 10],
            [-1, -1],
            [7, 24],
            [8, 22],
            [8, 20],
            [7, 18],
            [6, 17],
            [5, 15],
            [5, 13],
            [6, 11],
            [10, 9],
            [6, 7],
            [5, 5],
            [5, 3],
            [6, 1],
            [7, 0],
            [8, -2],
            [8, -4],
            [7, -6],
            [-1, -1],
            [8, 8],
            [6, 6],
            [6, 4],
            [7, 2],
            [8, 1],
            [9, -1],
            [9, -3],
            [8, -5],
            [7, -6],
            [5, -7]
        ]
    },
    '~': {
        width: 24, points: [
            [3, 6],
            [3, 8],
            [4, 11],
            [6, 12],
            [8, 12],
            [10, 11],
            [14, 8],
            [16, 7],
            [18, 7],
            [20, 8],
            [21, 10],
            [-1, -1],
            [3, 8],
            [4, 10],
            [6, 11],
            [8, 11],
            [10, 10],
            [14, 7],
            [16, 6],
            [18, 6],
            [20, 7],
            [21, 10],
            [21, 12]
        ]
    }
};

/**
 * @desc Creates wireframe vector text {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with vector text {@link ReadableGeometry} :
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]
 *
 * ````javascript
 *
 * import {Viewer, Mesh, buildVectorTextGeometry, ReadableGeometry, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 100];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildVectorTextGeometry({
 *          origin: [0,0,0],
 *          text: "On the other side of the screen, it all looked so easy"
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildVectorTextGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number[]} [cfg.origin] 3D point indicating the top left corner.
 * @param {Number} [cfg.size=1] Size of each character.
 * @param {String} [cfg.text=""] The text.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildVectorTextGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var origin = cfg.origin || [0, 0, 0];
    var xOrigin = origin[0];
    var yOrigin = origin[1];
    var zOrigin = origin[2];
    var size = cfg.size || 1;

    var positions = [];
    var indices = [];
    var text = cfg.text;
    if (utils.isNumeric(text)) {
        text = "" + text;
    }
    var lines = (text || "").split("\n");
    var countVerts = 0;
    var y = 0;
    var x;
    var str;
    var len;
    var c;
    var mag = 1.0 / 25.0;
    var penUp;
    var p1;
    var p2;
    var pointsLen;
    var a;

    for (var iLine = 0; iLine < lines.length; iLine++) {

        x = 0;
        str = lines[iLine];
        len = str.length;

        for (var i = 0; i < len; i++) {

            c = letters[str.charAt(i)];

            if (!c) {
                continue;
            }

            penUp = 1;
            p1 = -1;
            p2 = -1;

            pointsLen = c.points.length;

            for (var j = 0; j < pointsLen; j++) {
                a = c.points[j];

                if (a[0] === -1 && a[1] === -1) {
                    penUp = 1;
                    continue;
                }

                positions.push((x + (a[0] * size) * mag) + xOrigin);
                positions.push((y + (a[1] * size) * mag) + yOrigin);
                positions.push(0 + zOrigin);

                if (p1 === -1) {
                    p1 = countVerts;
                } else if (p2 === -1) {
                    p2 = countVerts;
                } else {
                    p1 = p2;
                    p2 = countVerts;
                }
                countVerts++;

                if (penUp) {
                    penUp = false;

                } else {
                    indices.push(p1);
                    indices.push(p2);
                }
            }
            x += c.width * mag * size;

        }
        y -= 35 * mag * size;
    }

    return utils.apply(cfg, {
        primitive: "lines",
        positions: positions,
        indices: indices
    });
}

/**
 * {@link Viewer} plugin that shows the axii of the World-space coordinate system.
 *
 * ## Usage
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_AxisGizmoPlugin)]
 *
 * ````JavaScript````
 * import {Viewer, XKTLoaderPlugin, AxisGizmoPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * new AxisGizmoPlugin(viewer, {
 *     canvasId: "myAxisGizmoCanvas"
 * });
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "../assets/models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 * ````
 */
var AxisGizmoPlugin = /*@__PURE__*/(function (Plugin) {
    function AxisGizmoPlugin(viewer, cfg) {

        cfg = cfg || {};

        Plugin.call(this, "AxisGizmo", viewer, cfg);

        var camera = viewer.scene.camera;

        if (!cfg.canvasId && !cfg.canvasElement) {
            this.error("Config expected: either 'canvasId' or 'canvasElement'");
        }

        try {
            this._axisGizmoScene = new Scene(viewer, {
                canvasId: cfg.canvasId,
                canvasElement: cfg.canvasElement,
                transparent: true
            });
        } catch (error) {
            this.error(error);
            return;
        }

        var axisGizmoScene = this._axisGizmoScene;

        axisGizmoScene.clearLights();

        new AmbientLight(axisGizmoScene, {color: [0.45, 0.45, 0.5], intensity: 0.9});
        new DirLight(axisGizmoScene, {dir: [-0.5, 0.5, -0.6], color: [0.8, 0.8, 0.7], intensity: 1.0, space: "view"});
        new DirLight(axisGizmoScene, {dir: [0.5, -0.5, -0.6], color: [0.8, 0.8, 0.8], intensity: 1.0, space: "view"});

        // Rotate helper in synch with target camera

        var helperCamera = axisGizmoScene.camera;

        camera.on("matrix", function () {

            var eye = camera.eye;
            var look = camera.look;
            var up = camera.up;

            var eyeLook = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye, look, [])), 22);

            helperCamera.look = [0, 0, 0];
            helperCamera.eye = eyeLook;
            helperCamera.up = up;
        });

        // ----------------- Components that are shared among more than one mesh ---------------

        var arrowHead = new ReadableGeometry(axisGizmoScene, buildCylinderGeometry({
            radiusTop: 0.01,
            radiusBottom: 0.6,
            height: 1.7,
            radialSegments: 20,
            heightSegments: 1,
            openEnded: false
        }));

        var arrowShaft = new ReadableGeometry(axisGizmoScene, buildCylinderGeometry({
            radiusTop: 0.2,
            radiusBottom: 0.2,
            height: 4.5,
            radialSegments: 20,
            heightSegments: 1,
            openEnded: false
        }));

        var xAxisMaterial = new PhongMaterial(axisGizmoScene, { // Red by convention
            diffuse: [1, 0.3, 0.3],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var xAxisLabelMaterial = new PhongMaterial(axisGizmoScene, { // Red by convention
            emissive: [1, 0.3, 0.3],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var yAxisMaterial = new PhongMaterial(axisGizmoScene, { // Green by convention
            diffuse: [0.3, 1, 0.3],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var yAxisLabelMaterial = new PhongMaterial(axisGizmoScene, { // Green by convention
            emissive: [0.3, 1, 0.3],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var zAxisMaterial = new PhongMaterial(axisGizmoScene, { // Blue by convention
            diffuse: [0.3, 0.3, 1],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var zAxisLabelMaterial = new PhongMaterial(axisGizmoScene, {
            emissive: [0.3, 0.3, 1],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        var ballMaterial = new PhongMaterial(axisGizmoScene, {
            diffuse: [0.5, 0.5, 0.5],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        });

        // ----------------- Meshes ------------------------------

        this._meshes = [

            // Sphere behind gnomon

            new Mesh(axisGizmoScene, {
                geometry: new ReadableGeometry(axisGizmoScene, buildSphereGeometry({
                    radius: 9.0,
                    heightSegments: 60,
                    widthSegments: 60
                })),
                material: new PhongMaterial(axisGizmoScene, {
                    diffuse: [0.0, 0.0, 0.0],
                    emissive: [0.1, 0.1, 0.1],
                    ambient: [0.1, 0.1, 0.2],
                    specular: [0, 0, 0],
                    alpha: 0.4,
                    alphaMode: "blend",
                    frontface: "cw"
                }),
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false
            }),

            // Ball at center of axis

            new Mesh(axisGizmoScene, {  // Arrow
                geometry: new ReadableGeometry(axisGizmoScene, buildSphereGeometry({
                    radius: 1.0
                })),
                material: ballMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false
            }),

            // X-axis arrow, shaft and label

            new Mesh(axisGizmoScene, {  // Arrow
                geometry: arrowHead,
                material: xAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [5, 0, 0],
                rotation: [0, 0, -90]
            }),

            new Mesh(axisGizmoScene, {  // Shaft
                geometry: arrowShaft,
                material: xAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [2, 0, 0],
                rotation: [0, 0, 90]
            }),

            new Mesh(axisGizmoScene, {  // Label
                geometry: new ReadableGeometry(axisGizmoScene, buildVectorTextGeometry({text: "X", size: 1.5})),
                material: xAxisLabelMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [7, 0, 0],
                billboard: "spherical"
            }),

            // Y-axis arrow, shaft and label

            new Mesh(axisGizmoScene, {  // Arrow
                geometry: arrowHead,
                material: yAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 5, 0]
            }),

            new Mesh(axisGizmoScene, {  // Shaft
                geometry: arrowShaft,
                material: yAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 2, 0]
            }),

            new Mesh(axisGizmoScene, {  // Label
                geometry: new ReadableGeometry(axisGizmoScene, buildVectorTextGeometry({text: "Y", size: 1.5})),
                material: yAxisLabelMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 7, 0],
                billboard: "spherical"
            }),

            // Z-axis arrow, shaft and label

            new Mesh(axisGizmoScene, {  // Arrow
                geometry: arrowHead,
                material: zAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 0, 5],
                rotation: [90, 0, 0]
            }),

            new Mesh(axisGizmoScene, {  // Shaft
                geometry: arrowShaft,
                material: zAxisMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 0, 2],
                rotation: [90, 0, 0]
            }),

            new Mesh(axisGizmoScene, {  // Label
                geometry: new ReadableGeometry(axisGizmoScene, buildVectorTextGeometry({text: "Z", size: 1.5})),
                material: zAxisLabelMaterial,
                pickable: false,
                collidable: false,
                visible: cfg.visible !== false,
                position: [0, 0, 7],
                billboard: "spherical"
            })
        ];
    }

    if ( Plugin ) AxisGizmoPlugin.__proto__ = Plugin;
    AxisGizmoPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    AxisGizmoPlugin.prototype.constructor = AxisGizmoPlugin;

    /** Shows or hides this AxisGizmoPlugin.
     *
     * @param visible
     */
    AxisGizmoPlugin.prototype.setVisible = function setVisible (visible) {
        for (var i = 0; i < this._meshes.length; i++) {
            this._meshes[i].visible = visible;
        }
    };

    /**
     * Destroys this AxisGizmoPlugin.
     */
    AxisGizmoPlugin.prototype.destroy = function destroy () {
        this._axisGizmoCanvas = null;
        this._axisGizmoScene.destroy();
        this._axisGizmoScene = null;
        Plugin.prototype.destroy.call(this);
    };

    return AxisGizmoPlugin;
}(Plugin));

/**
 *  @desc An arbitrarily-aligned World-space clipping plane.
 *
 * * Slices portions off objects to create cross-section views or reveal interiors.
 * * Registered by {@link SectionPlane#id} in {@link Scene#sectionPlanes}.
 * * Indicates World-space position in {@link SectionPlane#pos} and orientation in {@link SectionPlane#dir}.
 * * Discards elements from the half-space in the direction of {@link SectionPlane#dir}.
 * * Can be be enabled or disabled via {@link SectionPlane#active}.
 *
 * ## Usage
 *
 * In the example below, we'll create two SectionPlanes to slice a model loaded from glTF. Note that we could also create them
 * using a {@link SectionPlanesPlugin}.
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin, SectionPlane} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * const gltfLoaderPlugin = new GLTFModelsPlugin(viewer, {
 *      id: "GLTFModels"
 * });
 *
 * const model = gltfLoaderPlugin.load({
 *      id: "myModel",
 *      src: "./models/gltf/mygltfmodel.gltf"
 * });
 *
 * // Create a SectionPlane on negative diagonal
 * const sectionPlane1 = new SectionPlane(viewer.scene, {
 *     pos: [1.0, 1.0, 1.0],
 *     dir: [-1.0, -1.0, -1.0],
 *     active: true
 * }),
 *
 * // Create a SectionPlane on positive diagonal
 * const sectionPlane2 = new SectionPlane(viewer.scene, {
 *     pos: [-1.0, -1.0, -1.0],
 *     dir: [1.0, 1.0, 1.0],
 *     active: true
 * });
 * ````
 */
var SectionPlane = /*@__PURE__*/(function (Component) {
    function SectionPlane(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._state = new RenderState({
            active: true,
            pos: math.vec3(),
            dir: math.vec3(),
            dist: 0
        });

        this.active = cfg.active;
        this.pos = cfg.pos;
        this.dir = cfg.dir;

        this.scene._sectionPlaneCreated(this);
    }

    if ( Component ) SectionPlane.__proto__ = Component;
    SectionPlane.prototype = Object.create( Component && Component.prototype );
    SectionPlane.prototype.constructor = SectionPlane;

    var prototypeAccessors = { type: { configurable: true },active: { configurable: true },pos: { configurable: true },dir: { configurable: true },dist: { configurable: true } };

    /**
     * Sets if this SectionPlane is active or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate else ````false```` to deactivate.
     */
    prototypeAccessors.type.get = function () {
        return "SectionPlane";
    };

    prototypeAccessors.active.set = function (value) {
        this._state.active = value !== false;
        this.glRedraw();
        this.fire("active", this._state.active);
    };

    /**
     * Gets if this SectionPlane is active or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if active.
     */
    prototypeAccessors.active.get = function () {
        return this._state.active;
    };

    /**
     * Sets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value New position.
     */
    prototypeAccessors.pos.set = function (value) {
        this._state.pos.set(value || [0, 0, 0]);
        this._state.dist = (-math.dotVec3(this._state.pos, this._state.dir));
        this.fire("pos", this._state.pos);
    };

    /**
     * Gets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns {Number[]} Current position.
     */
    prototypeAccessors.pos.get = function () {
        return this._state.pos;
    };

    /**
     * Sets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @param {Number[]} value New direction.
     */
    prototypeAccessors.dir.set = function (value) {
        this._state.dir.set(value || [0, 0, -1]);
        this._state.dist = (-math.dotVec3(this._state.pos, this._state.dir));
        this.glRedraw();
        this.fire("dir", this._state.dir);
    };

    /**
     * Gets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @returns {Number[]} value Current direction.
     */
    prototypeAccessors.dir.get = function () {
        return this._state.dir;
    };

    /**
     * Gets this SectionPlane's distance to the origin of the World-space coordinate system.
     *
     * This is the dot product of {@link SectionPlane#pos} and {@link SectionPlane#dir} and is automatically re-calculated
     * each time either of two properties are updated.
     *
     * @returns {Number}
     */
    prototypeAccessors.dist.get = function () {
        return this._state.dist;
    };

    /**
     * Inverts the direction of {@link SectionPlane#dir}.
     */
    SectionPlane.prototype.flipDir = function flipDir () {
        var dir = this._state.dir;
        dir[0] *= -1.0;
        dir[1] *= -1.0;
        dir[2] *= -1.0;
        this._state.dist = (-math.dotVec3(this._state.pos, this._state.dir));
        this.fire("dir", this._state.dir);
        this.glRedraw();
    };

    /**
     * @destroy
     */
    SectionPlane.prototype.destroy = function destroy () {
        this._state.destroy();
        this.scene._sectionPlaneDestroyed(this);
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( SectionPlane.prototype, prototypeAccessors );

    return SectionPlane;
}(Component));

var tempVec3$4 = math.vec3();

/**
 * {@link Viewer} plugin that saves and loads BCF viewpoints as JSON objects.
 *
 * BCF is a format for managing issues on a BIM project. This plugin's viewpoints conform to
 * the <a href="https://github.com/buildingSMART/BCF-API">BCF Version 2.1</a> specification.
 *
 * ## Saving a BCF Viewpoint
 *
 * In the example below we'll create a {@link Viewer}, load an ````.XKT```` model into it using an {@link XKTLoaderPlugin},
 * slice the model in half using a {@link SectionPlanesPlugin}, then use a {@link BCFViewpointsPlugin#getViewpoint}
 * to save a viewpoint to JSON, which we'll log to the JavaScript developer console.
 *
 * * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#BCF_SaveViewpoint)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, SectionPlanesPlugin, BCFViewpointsPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // Add a XKTLoaderPlugin
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // Add a SectionPlanesPlugin
 * const sectionPlanes = new SectionPlanesPlugin(viewer);
 *
 * // Add a BCFViewpointsPlugin
 * const bcfViewpoints = new BCFViewpointsPlugin(viewer);
 *
 * // Load an .XKT model
 * const modelNode = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true // Emphasise edges
 * });
 *
 * // Slice it in half
 * sectionPlanes.createSectionPlane({
 *      id: "myClip",
 *      pos: [0, 0, 0],
 *      dir: [0.5, 0.0, 0.5]
 * });
 *
 * // When model is loaded, set camera, select some objects and capture a BCF viewpoint to the console
 * modelNode.on("loaded", () => {
 *
 *      const scene = viewer.scene;
 *      const camera = scene.camera;
 *
 *      camera.eye = [-2.37, 18.97, -26.12];
 *      camera.look = [10.97, 5.82, -11.22];
 *      camera.up = [0.36, 0.83, 0.40];
 *
 *      scene.setObjectsSelected([
 *          "3b2U496P5Ebhz5FROhTwFH",
 *          "2MGtJUm9nD$Re1_MDIv0g2",
 *          "3IbuwYOm5EV9Q6cXmwVWqd",
 *          "3lhisrBxL8xgLCRdxNG$2v",
 *          "1uDn0xT8LBkP15zQc9MVDW"
 *      ], true);
 *
 *      const viewpoint = bcfViewpoints.getViewpoint();
 *      const viewpointStr = JSON.stringify(viewpoint, null, 4);
 *
 *      console.log(viewpointStr);
 * });
 * ````
 *
 * ## Saving View Setup Hints
 *
 * BCFViewpointsPlugin can optionally save hints in the viewpoint, which indicate how to set up the view when
 * loading it again.
 *
 * Here's the {@link BCFViewpointsPlugin#getViewpoint} call again, this time saving some hints:
 *
 * ````javascript
 * const viewpoint = bcfViewpoints.getViewpoint({ // Options
 *     spacesVisible: true, // Force IfcSpace types visible in the viewpoint (default is false)
 *     spaceBoundariesVisible: false, // Show IfcSpace boundaries in the viewpoint (default is false)
 *     openingsVisible: true // Force IfcOpening types visible in the viewpoint (default is false)
 * });
 * ````
 *
 * ## Loading a BCF Viewpoint
 *
 * Assuming that we have our BCF viewpoint in a JSON object, let's now restore it with {@link BCFViewpointsPlugin#setViewpoint}:
 *
 * ````javascript
 * bcfViewpoints.setViewpoint(viewpoint);
 * ````
 *
 * ## Handling BCF Incompatibility with xeokit's Camera
 *
 * xeokit's {@link Camera#look} is the current 3D *point-of-interest* (POI).
 *
 * A BCF viewpoint, however, has a direction vector instead of a POI, and so {@link BCFViewpointsPlugin#getViewpoint} saves
 * xeokit's POI as a normalized vector from {@link Camera#eye} to {@link Camera#look}, which unfortunately loses
 * that positional information. Loading the viewpoint with {@link BCFViewpointsPlugin#setViewpoint} will restore {@link Camera#look} to
 * the viewpoint's camera position, offset by the normalized vector.
 *
 * As shown below, providing a ````rayCast```` option to ````setViewpoint```` will set {@link Camera#look} to the closest
 * surface intersection on the direction vector. Internally, ````setViewpoint```` supports this option by firing a ray
 * along the vector, and if that hits an {@link Entity}, sets {@link Camera#look} to ray's intersection point with the
 * Entity's surface.
 *
 * ````javascript
 * bcfViewpoints.setViewpoint(viewpoint, {
 *      rayCast: true // <<--------------- Attempt to set Camera#look to surface intersection point (default)
 * });
 * ````
 *
 * ## Dealing With Loaded Models That Are Not in the Viewpoint
 *
 * If, for example, we load model "duplex", hide some objects, then save a BCF viewpoint with
 * ````BCFViewpointsPlugin#getViewpoint````, then load another model, "schependomlaan", then load the viewpoint again
 * with ````BCFViewpointsPlugin#setViewpoint````, then sometimes all of the objects in model "schependomlaan" become
 * visible, along with the visible objects in the viewpoint, which belong to model "duplex".
 *
 * The reason is that, when saving a BCF viewpoint, BCF logic works like the following pseudo code:
 *
 * ````
 * If numVisibleObjects < numInvisibleObjects
 *      save IDs of visible objects in BCF
 *      exceptions = "visible objects"
 * else
 *      save IDS of invisible objects in BCF
 *      exceptions = "invisible objects"
 * ````
 *
 * When loading the viewpoint again:
 *
 * ````
 * If exceptions = "visible objects"
 *      hide all objects
 *      show visible objects in BCF
 * else
 *      show all objects
 *      hide invisible objects in BCF
 * ````
 *
 * When the exception is "visible objects", loading the viewpoint shows all the objects in the first, which includes
 * objects in "schependomlaan", which can be confusing, because those were not even loaded when we first
 * saved the viewpoint..
 *
 * To solve this, we can supply a ````defaultInvisible```` option to {@link BCFViewpointsPlugin#getViewpoint}, which
 * will force the plugin to save the IDs of all visible objects while making invisible objects the exception.
 *
 * That way, when we load the viewpoint again, after loading model "schependomlaan", the plugin will hide all objects
 * in the scene first (which will include objects belonging to model "schependomlaan"), then make the objects in the
 * viewpoint visible (which will only be those of object "duplex").
 *
 * ````javascript
 * const viewpoint = bcfViewpoints.getViewpoint({ // Options
 *     //..
 *     defaultInvisible: true
 * });
 * ````
 *
 * [[Run an example](http://xeokit.github.io/xeokit-sdk/examples/#BCF_LoadViewpoint_defaultInvisible)]
 *
 * ## Behaviour with XKTLoaderPlugin globalizeObjectIds
 *
 * Whenever we use {@link XKTLoaderPlugin} to load duplicate copies of the same model, after configuring
 * {@link XKTLoaderPlugin#globalizeObjectIds} ````true```` to avoid ````Entity```` ID clashes, this has consequences
 * for BCF viewpoints created by {@link BCFViewpointsPlugin#getViewpoint}.
 *
 * When no duplicate copies of a model are loaded like this, viewpoints created by {@link BCFViewpointsPlugin#getViewpoint} will
 * continue to load as usual in other BIM viewers. Conversely, a viewpoint created for a single model in other BIM viewers
 * will continue to load as usual with ````BCFViewpointsPlugin````.
 *
 * When duplicate copies of a model are loaded, however, viewpoints created by {@link BCFViewpointsPlugin#getViewpoint}
 * will contain certain changes that will affect the viewpoint's portability, however. Such viewpoints will
 * use ````authoring_tool_id```` fields to save the globalized ````Entity#id```` values, which enables the viewpoints to
 * capture the states of the individual ````Entitys```` that represent the duplicate IFC elements. Take a look at the
 * following two examples to learn more.
 *
 * * [Example: Saving a BCF viewpoint containing duplicate models](https://xeokit.github.io/xeokit-sdk/examples/#BCF_SaveViewpoint_MultipleModels)
 * * [Example: Loading a BCF viewpoint containing duplicate models](https://xeokit.github.io/xeokit-sdk/examples/#BCF_LoadViewpoint_MultipleModels)
 *
 * **Caveat:** when loading a BCF viewpoint, we always assume that we have loaded in our target BIM viewer the same models that were
 * loaded in the viewpoint's original authoring application when the viewpoint was created.  In the case of multi-model
 * viewpoints, the target BIM viewer, whether it be xeokit or another BIM viewer, will need to first have those exact
 * models loaded, with their objects having globalized IDs, following the same prefixing scheme we're using in
 * xeokit. Then, the viewpoint's ````authoring_tool_id```` fields will be able to resolve to their objects within the
 * target viewer.
*
 * @class BCFViewpointsPlugin
 */
var BCFViewpointsPlugin = /*@__PURE__*/(function (Plugin) {
    function BCFViewpointsPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "BCFViewpoints", viewer, cfg);

        /**
         * Identifies the originating system to include in BCF viewpoints saved by this plugin.
         * @property originatingSystem
         * @type {string}
         */
        this.originatingSystem = cfg.originatingSystem || "xeokit.io";

        /**
         * Identifies the authoring tool to include in BCF viewpoints saved by this plugin.
         * @property authoringTool
         * @type {string}
         */
        this.authoringTool = cfg.authoringTool || "xeokit.io";
    }

    if ( Plugin ) BCFViewpointsPlugin.__proto__ = Plugin;
    BCFViewpointsPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    BCFViewpointsPlugin.prototype.constructor = BCFViewpointsPlugin;

    /**
     * Saves viewer state to a BCF viewpoint.
     *
     * Note that xeokit's {@link Camera#look} is the **point-of-interest**, whereas the BCF ````camera_direction```` is a
     * direction vector. Therefore, we save ````camera_direction```` as the vector from {@link Camera#eye} to {@link Camera#look}.
     *
     * @param {*} [options] Options for getting the viewpoint.
     * @param {Boolean} [options.spacesVisible=false] Indicates whether ````IfcSpace```` types should be forced visible in the viewpoint.
     * @param {Boolean} [options.openingsVisible=false] Indicates whether ````IfcOpening```` types should be forced visible in the viewpoint.
     * @param {Boolean} [options.spaceBoundariesVisible=false] Indicates whether the boundaries of ````IfcSpace```` types should be visible in the viewpoint.
     * @param {Boolean} [options.snapshot=true] Indicates whether the snapshot should be included in the viewpoint.
     * @param {Boolean} [options.defaultInvisible=false] When ````true````, will save the default visibility of all objects
     * as ````false````. This means that when we load the viewpoint again, and there are additional models loaded that
     * were not saved in the viewpoint, those models will be hidden when we load the viewpoint, and that only the
     * objects in the viewpoint will be visible.
     * @param {Boolean} [options.reverseClippingPlanes=false] When ````true````, clipping planes are reversed (https://github.com/buildingSMART/BCF-XML/issues/193)
     * @returns {*} BCF JSON viewpoint object
     * @example
     *
     * const viewer = new Viewer();
     *
     * const bcfPlugin = new BCFPlugin(viewer, {
     *     //...
     * });
     *
     * const viewpoint = bcfPlugin.getViewpoint({ // Options - see constructor
     *     spacesVisible: false,          // Default
     *     spaceBoundariesVisible: false, // Default
     *     openingsVisible: false         // Default
     * });
     *
     * // viewpoint will resemble the following:
     *
     * {
     *     perspective_camera: {
     *         camera_view_point: {
     *             x: 0.0,
     *             y: 0.0,
     *             z: 0.0
     *         },
     *         camera_direction: {
     *             x: 1.0,
     *             y: 1.0,
     *             z: 2.0
     *         },
     *         camera_up_vector: {
     *             x: 0.0,
     *             y: 0.0,
     *             z: 1.0
     *         },
     *         field_of_view: 90.0
     *     },
     *     lines: [],
     *     clipping_planes: [{
     *         location: {
     *             x: 0.5,
     *             y: 0.5,
     *             z: 0.5
     *         },
     *         direction: {
     *             x: 1.0,
     *             y: 0.0,
     *             z: 0.0
     *         }
     *     }],
     *     bitmaps: [],
     *     snapshot: {
     *         snapshot_type: png,
     *         snapshot_data: "data:image/png;base64,......"
     *     },
     *     components: {
     *         visibility: {
     *             default_visibility: false,
     *             exceptions: [{
     *                 ifc_guid: 4$cshxZO9AJBebsni$z9Yk,
     *                 originating_system: xeokit.io,
     *                 authoring_tool_id: xeokit/v1.0
     *             }]
     *        },
     *         selection: [{
     *            ifc_guid: "4$cshxZO9AJBebsni$z9Yk",
     *         }]
     *     }
     * }
     */
    BCFViewpointsPlugin.prototype.getViewpoint = function getViewpoint (options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

        var scene = this.viewer.scene;
        var camera = scene.camera;
        var realWorldOffset = scene.realWorldOffset;
        var reverseClippingPlanes = (options.reverseClippingPlanes === true);
        var bcfViewpoint = {};

        // Camera
        var lookDirection = math.normalizeVec3(math.subVec3(camera.look, camera.eye, math.vec3()));
        var eye = camera.eye;
        var up = camera.up;

        if (camera.yUp) {
            // BCF is Z up
            lookDirection = YToZ(lookDirection);
            eye = YToZ(eye);
            up = YToZ(up);
        }

        var camera_view_point = xyzArrayToObject(math.addVec3(eye, realWorldOffset));

        if (camera.projection === "ortho") {
            bcfViewpoint.orthogonal_camera = {
                camera_view_point: camera_view_point,
                camera_direction: xyzArrayToObject(lookDirection),
                camera_up_vector: xyzArrayToObject(up),
                view_to_world_scale: camera.ortho.scale,
            };
        } else {
            bcfViewpoint.perspective_camera = {
                camera_view_point: camera_view_point,
                camera_direction: xyzArrayToObject(lookDirection),
                camera_up_vector: xyzArrayToObject(up),
                field_of_view: camera.perspective.fov,
            };
        }

        // Clipping planes

        var sectionPlanes = scene.sectionPlanes;
        for (var id in sectionPlanes) {
            if (sectionPlanes.hasOwnProperty(id)) {
                var sectionPlane = sectionPlanes[id];

                var location = sectionPlane.pos;

                var direction = (void 0);
                if (reverseClippingPlanes) {
                    direction = math.negateVec3(sectionPlane.dir, math.vec3());
                } else {
                    direction = sectionPlane.dir;
                }

                if (camera.yUp) {
                    // BCF is Z up
                    location = YToZ(location);
                    direction = YToZ(direction);
                }
                math.addVec3(location, realWorldOffset);

                location = xyzArrayToObject(location);
                direction = xyzArrayToObject(direction);
                if (!bcfViewpoint.clipping_planes) {
                    bcfViewpoint.clipping_planes = [];
                }
                bcfViewpoint.clipping_planes.push({location: location, direction: direction});
            }
        }

        // Entity states

        bcfViewpoint.components = {
            visibility: {
                view_setup_hints: {
                    spaces_visible: !!options.spacesVisible,
                    space_boundaries_visible: !!options.spaceBoundariesVisible,
                    openings_visible: !!options.openingsVisible
                }
            }
        };

        var opacityObjectIds = new Set(scene.opacityObjectIds);
        var xrayedObjectIds = new Set(scene.xrayedObjectIds);
        var colorizedObjectIds = new Set(scene.colorizedObjectIds);

        var coloringMap = Object.values(scene.objects)
            .filter(function (entity) { return opacityObjectIds.has(entity.id) || colorizedObjectIds.has(entity.id) || xrayedObjectIds.has(entity.id); })
            .reduce(function (coloringMap, entity) {

                var color = colorizeToRGB(entity.colorize);
                var alpha;

                if (entity.xrayed) {
                    if (scene.xrayMaterial.fillAlpha === 0.0 && scene.xrayMaterial.edgeAlpha !== 0.0) {
                        // BCF can't deal with edges. If xRay is implemented only with edges, set an arbitrary opacity
                        alpha = 0.1;
                    } else {
                        alpha = scene.xrayMaterial.fillAlpha;
                    }
                    alpha = Math.round(alpha * 255).toString(16).padStart(2, "0");
                    color = alpha + color;
                } else if (opacityObjectIds.has(entity.id)) {
                    alpha = Math.round(entity.opacity * 255).toString(16).padStart(2, "0");
                    color = alpha + color;
                }

                if (!coloringMap[color]) {
                    coloringMap[color] = [];
                }

                var objectId = entity.id;
                var originalSystemId = entity.originalSystemId;
                var component = {
                    ifc_guid: originalSystemId,
                    originating_system: this$1.originatingSystem
                };
                if (originalSystemId !== objectId) {
                    component.authoring_tool_id = objectId;
                }

                coloringMap[color].push(component);

                return coloringMap;

            }, {});

        var coloringArray = Object.entries(coloringMap).map(function (ref) {
            var color = ref[0];
            var components = ref[1];

            return {color: color, components: components};
        });

        bcfViewpoint.components.coloring = coloringArray;

        var objectIds = scene.objectIds;
        var visibleObjects = scene.visibleObjects;
        var visibleObjectIds = scene.visibleObjectIds;
        var invisibleObjectIds = objectIds.filter(function (id) { return !visibleObjects[id]; });
        var selectedObjectIds = scene.selectedObjectIds;

        if (options.defaultInvisible || visibleObjectIds.length < invisibleObjectIds.length) {
            bcfViewpoint.components.visibility.exceptions = this._createBCFComponents(visibleObjectIds);
            bcfViewpoint.components.visibility.default_visibility = false;
        } else {
            bcfViewpoint.components.visibility.exceptions = this._createBCFComponents(invisibleObjectIds);
            bcfViewpoint.components.visibility.default_visibility = true;
        }

        bcfViewpoint.components.selection = this._createBCFComponents(selectedObjectIds);

        if (options.snapshot !== false) {
            bcfViewpoint.snapshot = {
                snapshot_type: "png",
                snapshot_data: this.viewer.getSnapshot({format: "png"})
            };
        }

        return bcfViewpoint;
    };

    BCFViewpointsPlugin.prototype._createBCFComponents = function _createBCFComponents (objectIds) {
        var scene = this.viewer.scene;
        var components = [];
        for (var i = 0, len = objectIds.length; i < len; i++) {
            var objectId = objectIds[i];
            var entity = scene.objects[objectId];
            if (entity) {
                var component = {
                    ifc_guid: entity.originalSystemId,
                    originating_system: this.originatingSystem
                };
                if (entity.originalSystemId !== objectId) {
                    component.authoring_tool_id = objectId;
                }
                components.push(component);
            }
        }
        return components;
    };

    /**
     * Sets viewer state to the given BCF viewpoint.
     *
     * Note that xeokit's {@link Camera#look} is the **point-of-interest**, whereas the BCF ````camera_direction```` is a
     * direction vector. Therefore, when loading a BCF viewpoint, we set {@link Camera#look} to the absolute position
     * obtained by offsetting the BCF ````camera_view_point````  along ````camera_direction````.
     *
     * When loading a viewpoint, we also have the option to find {@link Camera#look} as the closest point of intersection
     * (on the surface of any visible and pickable {@link Entity}) with a 3D ray fired from ````camera_view_point```` in
     * the direction of ````camera_direction````.
     *
     * @param {*} bcfViewpoint  BCF JSON viewpoint object,
     * shows default visible entities and restores camera to initial default position.
     * @param {*} [options] Options for setting the viewpoint.
     * @param {Boolean} [options.rayCast=true] When ````true```` (default), will attempt to set {@link Camera#look} to the closest
     * point of surface intersection with a ray fired from the BCF ````camera_view_point```` in the direction of ````camera_direction````.
     * @param {Boolean} [options.immediate=true] When ````true```` (default), immediately set camera position.
     * @param {Boolean} [options.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation#duration}. Only applies when ````immediate```` is ````false````.
     * @param {Boolean} [options.reset=true] When ````true```` (default), set {@link Entity#xrayed} and {@link Entity#highlighted} ````false```` on all scene objects.
     * @param {Boolean} [options.reverseClippingPlanes=false] When ````true````, clipping planes are reversed (https://github.com/buildingSMART/BCF-XML/issues/193)
     * @param {Boolean} [options.updateCompositeObjects=false] When ````true````, then when visibility and selection updates refer to composite objects (eg. an IfcBuildingStorey),
     * then this method will apply the updates to objects within those composites.
     */
    BCFViewpointsPlugin.prototype.setViewpoint = function setViewpoint (bcfViewpoint, options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

        if (!bcfViewpoint) {
            return;
        }

        var viewer = this.viewer;
        var scene = viewer.scene;
        var camera = scene.camera;
        var rayCast = (options.rayCast !== false);
        var immediate = (options.immediate !== false);
        var reset = (options.reset !== false);
        var realWorldOffset = scene.realWorldOffset;
        var reverseClippingPlanes = (options.reverseClippingPlanes === true);

        scene.clearSectionPlanes();

        if (bcfViewpoint.clipping_planes) {
            bcfViewpoint.clipping_planes.forEach(function (e) {
                var pos = xyzObjectToArray(e.location, tempVec3$4);
                var dir = xyzObjectToArray(e.direction, tempVec3$4);

                if (reverseClippingPlanes) {
                    math.negateVec3(dir);
                }
                math.subVec3(pos, realWorldOffset);

                if (camera.yUp) {
                    pos = ZToY(pos);
                    dir = ZToY(dir);
                }
                new SectionPlane(scene, {pos: pos, dir: dir});
            });
        }

        if (reset) {
            scene.setObjectsXRayed(scene.xrayedObjectIds, false);
            scene.setObjectsHighlighted(scene.highlightedObjectIds, false);
            scene.setObjectsSelected(scene.selectedObjectIds, false);
        }

        if (bcfViewpoint.components) {

            if (bcfViewpoint.components.visibility) {

                if (!bcfViewpoint.components.visibility.default_visibility) {
                    scene.setObjectsVisible(scene.objectIds, false);
                    if (bcfViewpoint.components.visibility.exceptions) {
                        bcfViewpoint.components.visibility.exceptions.forEach(function (component) { return this$1._withBCFComponent(options, component, function (entity) { return entity.visible = true; }); });
                    }
                } else {
                    scene.setObjectsVisible(scene.objectIds, true);
                    if (bcfViewpoint.components.visibility.exceptions) {
                        bcfViewpoint.components.visibility.exceptions.forEach(function (component) { return this$1._withBCFComponent(options, component, function (entity) { return entity.visible = false; }); });
                    }
                }

                var view_setup_hints = bcfViewpoint.components.visibility.view_setup_hints;
                if (view_setup_hints) {
                    if (view_setup_hints.spaces_visible === false) {
                        scene.setObjectsVisible(viewer.metaScene.getObjectIDsByType("IfcSpace"), false);
                    }
                    if (view_setup_hints.openings_visible === false) {
                        scene.setObjectsVisible(viewer.metaScene.getObjectIDsByType("IfcOpening"), false);
                    }
                    if (view_setup_hints.space_boundaries_visible !== undefined) ;
                }
            }

            if (bcfViewpoint.components.selection) {
                scene.setObjectsSelected(scene.selectedObjectIds, false);
                bcfViewpoint.components.selection.forEach(function (component) { return this$1._withBCFComponent(options, component, function (entity) { return entity.selected = true; }); });

            }

            if (bcfViewpoint.components.coloring) {
                bcfViewpoint.components.coloring.forEach(function (coloring) {

                    var color = coloring.color;
                    var alpha = 0;
                    var alphaDefined = false;

                    if (color.length === 8) {
                        alpha = parseInt(color.substring(0, 2), 16) / 256;
                        if (alpha <= 1.0 && alpha >= 0.95) {
                            alpha = 1.0;
                        }
                        color = color.substring(2);
                        alphaDefined = true;
                    }

                    var colorize = [
                        parseInt(color.substring(0, 2), 16) / 256,
                        parseInt(color.substring(2, 4), 16) / 256,
                        parseInt(color.substring(4, 6), 16) / 256
                    ];

                    coloring.components.map(function (component) { return this$1._withBCFComponent(options, component, function (entity) {
                            entity.colorize = colorize;
                            if (alphaDefined) {
                                entity.opacity = alpha;
                            }
                        }); });
                });
            }
        }

        if (bcfViewpoint.perspective_camera || bcfViewpoint.orthogonal_camera) {
            var eye;
            var look;
            var up;
            var projection;

            if (bcfViewpoint.perspective_camera) {
                eye = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_view_point, tempVec3$4);
                look = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_direction, tempVec3$4);
                up = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_up_vector, tempVec3$4);

                camera.perspective.fov = bcfViewpoint.perspective_camera.field_of_view;

                projection = "perspective";
            } else {
                eye = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_view_point, tempVec3$4);
                look = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_direction, tempVec3$4);
                up = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_up_vector, tempVec3$4);

                camera.ortho.scale = bcfViewpoint.orthogonal_camera.view_to_world_scale;

                projection = "ortho";
            }

            math.subVec3(eye, realWorldOffset);

            if (camera.yUp) {
                eye = ZToY(eye);
                look = ZToY(look);
                up = ZToY(up);
            }

            if (rayCast) {
                var hit = scene.pick({
                    pickSurface: true,  // <<------ This causes picking to find the intersection point on the entity
                    origin: eye,
                    direction: look
                });
                look = (hit ? hit.worldPos : math.addVec3(eye, look, tempVec3$4));
            } else {
                look = math.addVec3(eye, look, tempVec3$4);
            }

            if (immediate) {
                camera.eye = eye;
                camera.look = look;
                camera.up = up;
                camera.projection = projection;
            } else {
                viewer.cameraFlight.flyTo({eye: eye, look: look, up: up, duration: options.duration, projection: projection});
            }
        }
    };

    BCFViewpointsPlugin.prototype._withBCFComponent = function _withBCFComponent (options, component, callback) {

        var viewer = this.viewer;
        var scene = viewer.scene;

        if (component.authoring_tool_id && component.originating_system === this.originatingSystem) {

            var id = component.authoring_tool_id;
            var entity = scene.objects[id];

            if (entity) {
                callback(entity);
                return
            }

            if (options.updateCompositeObjects) {
                var metaObject = viewer.metaScene.metaObjects[id];
                if (metaObject) {
                    scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(id), callback);
                    return;
                }
            }
        }

        if (component.ifc_guid) {

            var originalSystemId = component.ifc_guid;
            var entity$1 = scene.objects[originalSystemId];

            if (entity$1) {
                callback(entity$1);
                return;
            }

            if (options.updateCompositeObjects) {
                var metaObject$1 = viewer.metaScene.metaObjects[originalSystemId];
                if (metaObject$1) {
                    scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(originalSystemId), callback);
                    return;
                }
            }

            Object.keys(scene.models).forEach(function (modelId) {

                var id = math.globalizeObjectId(modelId, originalSystemId);
                var entity = scene.objects[id];

                if (entity) {
                    callback(entity);
                    return;
                }

                if (options.updateCompositeObjects) {
                    var metaObject = viewer.metaScene.metaObjects[id];
                    if (metaObject) {
                        scene.withObjects(viewer.metaScene.getObjectIDsInSubtree(id), callback);
                        return;
                    }
                }
            });
        }
    };

    /**
     * Destroys this BCFViewpointsPlugin.
     */
    BCFViewpointsPlugin.prototype.destroy = function destroy () {
        Plugin.prototype.destroy.call(this);
    };

    return BCFViewpointsPlugin;
}(Plugin));

function xyzArrayToObject(arr) {
    return {"x": arr[0], "y": arr[1], "z": arr[2]};
}

function xyzObjectToArray(xyz, arry) {
    arry = new Float64Array(3);
    arry[0] = xyz.x;
    arry[1] = xyz.y;
    arry[2] = xyz.z;
    return arry;
}

function YToZ(vec) {
    return new Float64Array([vec[0], -vec[2], vec[1]]);
}

function ZToY(vec) {
    return new Float64Array([vec[0], vec[2], -vec[1]]);
}

function colorizeToRGB(color) {
    var rgb = "";
    rgb += Math.round(color[0] * 255).toString(16).padStart(2, "0");
    rgb += Math.round(color[1] * 255).toString(16).padStart(2, "0");
    rgb += Math.round(color[2] * 255).toString(16).padStart(2, "0");
    return rgb;
}

var distVec3 = math.vec3();

var lengthWire = function (x1, y1, x2, y2) {
    var a = x1 - x2;
    var b = y1 - y2;
    return Math.sqrt(a * a + b * b);
};

/**
 * @desc Measures the distance between two 3D points.
 *
 * See {@link DistanceMeasurementsPlugin} for more info.
 */
var DistanceMeasurement = /*@__PURE__*/(function (Component) {
    function DistanceMeasurement(plugin, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, plugin.viewer.scene, cfg);

        /**
         * The {@link DistanceMeasurementsPlugin} that owns this DistanceMeasurement.
         * @type {DistanceMeasurementsPlugin}
         */
        this.plugin = plugin;

        this._container = cfg.container;
        if (!this._container) {
            throw "config missing: container";
        }

        this._eventSubs = {};

        var scene = this.plugin.viewer.scene;

        this._originMarker = new Marker(scene, cfg.origin);
        this._targetMarker = new Marker(scene, cfg.target);

        this._originWorld = math.vec3();
        this._targetWorld = math.vec3();

        this._wp = new Float64Array(24);
        this._vp = new Float64Array(24);
        this._pp = new Float64Array(24);
        this._cp = new Int16Array(8);

        this._xAxisLabelCulled = false;
        this._yAxisLabelCulled = false;
        this._zAxisLabelCulled = false;

        this._originDot = new Dot(this._container, {});

        this._targetDot = new Dot(this._container, {});

        this._lengthWire = new Wire(this._container, {
            color: "#00BBFF",
            thickness: 2
        });

        this._xAxisWire = new Wire(this._container, {
            color: "red",
            thickness: 1
        });

        this._yAxisWire = new Wire(this._container, {
            color: "green",
            thickness: 1
        });

        this._zAxisWire = new Wire(this._container, {
            color: "blue",
            thickness: 1
        });

        this._lengthLabel = new Label(this._container, {
            fillColor: "#00BBFF",
            prefix: "",
            text: ""
        });

        this._xAxisLabel = new Label(this._container, {
            fillColor: "red",
            prefix: "X",
            text: ""
        });

        this._yAxisLabel = new Label(this._container, {
            fillColor: "green",
            prefix: "Y",
            text: ""
        });

        this._zAxisLabel = new Label(this._container, {
            fillColor: "blue",
            prefix: "Z",
            text: ""
        });

        this._wpDirty = false;
        this._vpDirty = false;
        this._cpDirty = false;

        this._visible = false;
        this._originVisible = false;
        this._targetVisible = false;
        this._wireVisible = false;
        this._axisVisible = false;

        this._originMarker.on("worldPos", function (value) {
            this$1._originWorld.set(value || [0, 0, 0]);
            this$1._wpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._targetMarker.on("worldPos", function (value) {
            this$1._targetWorld.set(value || [0, 0, 0]);
            this$1._wpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._onViewMatrix = scene.camera.on("viewMatrix", function () {
            this$1._vpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._onProjMatrix = scene.camera.on("projMatrix", function () {
            this$1._cpDirty = true;
            this$1._needUpdate();
        });

        this._onCanvasBoundary = scene.canvas.on("boundary", function () {
            this$1._cpDirty = true;
            this$1._needUpdate(0); // No lag
        });

        this._onMetricsUnits = scene.metrics.on("units", function () {
            this$1._cpDirty = true;
            this$1._needUpdate();
        });

        this._onMetricsScale = scene.metrics.on("scale", function () {
            this$1._cpDirty = true;
            this$1._needUpdate();
        });

        this._onMetricsOrigin = scene.metrics.on("origin", function () {
            this$1._cpDirty = true;
            this$1._needUpdate();
        });

        this.approximate = cfg.approximate;
        this.visible = cfg.visible;
        this.originVisible = cfg.originVisible;
        this.targetVisible = cfg.targetVisible;
        this.wireVisible = cfg.wireVisible;
        this.axisVisible = cfg.axisVisible;
    }

    if ( Component ) DistanceMeasurement.__proto__ = Component;
    DistanceMeasurement.prototype = Object.create( Component && Component.prototype );
    DistanceMeasurement.prototype.constructor = DistanceMeasurement;

    var prototypeAccessors = { approximate: { configurable: true },origin: { configurable: true },target: { configurable: true },length: { configurable: true },visible: { configurable: true },originVisible: { configurable: true },targetVisible: { configurable: true },axisVisible: { configurable: true },wireVisible: { configurable: true } };

    DistanceMeasurement.prototype._update = function _update () {

        if (!this._visible) {
            return;
        }

        var scene = this.plugin.viewer.scene;

        if (this._wpDirty) {

            this._wp[0] = this._originWorld[0];
            this._wp[1] = this._originWorld[1];
            this._wp[2] = this._originWorld[2];
            this._wp[3] = 1.0;

            this._wp[4] = this._targetWorld[0];
            this._wp[5] = this._originWorld[1];
            this._wp[6] = this._originWorld[2];
            this._wp[7] = 1.0;

            this._wp[8] = this._targetWorld[0];
            this._wp[9] = this._targetWorld[1];
            this._wp[10] = this._originWorld[2];
            this._wp[11] = 1.0;

            this._wp[12] = this._targetWorld[0];
            this._wp[13] = this._targetWorld[1];
            this._wp[14] = this._targetWorld[2];
            this._wp[15] = 1.0;

            this._wpDirty = false;
            this._vpDirty = true;
        }

        if (this._vpDirty) {

            math.transformPositions4(scene.camera.viewMatrix, this._wp, this._vp);

            this._vp[3] = 1.0;
            this._vp[7] = 1.0;
            this._vp[11] = 1.0;
            this._vp[15] = 1.0;

            this._vpDirty = false;
            this._cpDirty = true;
        }

        var near = -0.3;
        var vpz1 = this._originMarker.viewPos[2];
        var vpz2 = this._targetMarker.viewPos[2];

        if (vpz1 > near || vpz2 > near) {

            this._xAxisLabel.setVisible(false);
            this._yAxisLabel.setVisible(false);
            this._zAxisLabel.setVisible(false);
            this._lengthLabel.setVisible(false);

            this._xAxisWire.setVisible(false);
            this._yAxisWire.setVisible(false);
            this._zAxisWire.setVisible(false);
            this._lengthWire.setVisible(false);

            this._originDot.setVisible(false);
            this._targetDot.setVisible(false);

            return;
        }

        if (this._cpDirty) {

            math.transformPositions4(scene.camera.project.matrix, this._vp, this._pp);

            var pp = this._pp;
            var cp = this._cp;

            var canvas = scene.canvas.canvas;
            var offsets = canvas.getBoundingClientRect();
            var top = offsets.top;
            var left = offsets.left;
            var aabb = scene.canvas.boundary;
            var canvasWidth = aabb[2];
            var canvasHeight = aabb[3];
            var j = 0;

            var metrics = this.plugin.viewer.scene.metrics;
            var scale = metrics.scale;
            var units = metrics.units;
            var unitInfo = metrics.unitsInfo[units];
            var unitAbbrev = unitInfo.abbrev;

            for (var i = 0, len = pp.length; i < len; i += 4) {
                cp[j] = left + Math.floor((1 + pp[i + 0] / pp[i + 3]) * canvasWidth / 2);
                cp[j + 1] = top + Math.floor((1 - pp[i + 1] / pp[i + 3]) * canvasHeight / 2);
                j += 2;
            }

            this._originDot.setPos(cp[0], cp[1]);
            this._targetDot.setPos(cp[6], cp[7]);

            this._lengthWire.setStartAndEnd(cp[0], cp[1], cp[6], cp[7]);

            this._xAxisWire.setStartAndEnd(cp[0], cp[1], cp[2], cp[3]);
            this._yAxisWire.setStartAndEnd(cp[2], cp[3], cp[4], cp[5]);
            this._zAxisWire.setStartAndEnd(cp[4], cp[5], cp[6], cp[7]);

            this._lengthLabel.setPosOnWire(cp[0], cp[1], cp[6], cp[7]);
            this._xAxisLabel.setPosOnWire(cp[0], cp[1], cp[2], cp[3]);
            this._yAxisLabel.setPosOnWire(cp[2], cp[3], cp[4], cp[5]);
            this._zAxisLabel.setPosOnWire(cp[4], cp[5], cp[6], cp[7]);

            var tilde = this._approximate ? " ~ " : " = ";

            this._length = Math.abs(math.lenVec3(math.subVec3(this._targetWorld, this._originWorld, distVec3)));
            this._lengthLabel.setText(tilde + (this._length * scale).toFixed(2) + unitAbbrev);

            var xAxisCanvasLength = Math.abs(lengthWire(cp[0], cp[1], cp[2], cp[3]));
            var yAxisCanvasLength = Math.abs(lengthWire(cp[2], cp[3], cp[4], cp[5]));
            var zAxisCanvasLength = Math.abs(lengthWire(cp[4], cp[5], cp[6], cp[7]));

            var labelMinAxisLength = this.plugin.labelMinAxisLength;

            this._xAxisLabelCulled = (xAxisCanvasLength < labelMinAxisLength);
            this._yAxisLabelCulled = (yAxisCanvasLength < labelMinAxisLength);
            this._zAxisLabelCulled = (zAxisCanvasLength < labelMinAxisLength);

            if (!this._xAxisLabelCulled) {
                this._xAxisLabel.setText(tilde + Math.abs((this._targetWorld[0] - this._originWorld[0]) * scale).toFixed(2) + unitAbbrev);
                this._xAxisLabel.setVisible(true);
            } else {
                this._xAxisLabel.setVisible(false);
            }

            if (!this._yAxisLabelCulled) {
                this._yAxisLabel.setText(tilde + Math.abs((this._targetWorld[1] - this._originWorld[1]) * scale).toFixed(2) + unitAbbrev);
                this._yAxisLabel.setVisible(true);
            } else {
                this._yAxisLabel.setVisible(false);
            }

            if (!this._zAxisLabelCulled) {
                this._zAxisLabel.setText(tilde + Math.abs((this._targetWorld[2] - this._originWorld[2]) * scale).toFixed(2) + unitAbbrev);
                this._zAxisLabel.setVisible(true);
            } else {
                this._zAxisLabel.setVisible(false);
            }

            this._originDot.setVisible(this._visible && this._originVisible);
            this._targetDot.setVisible(this._visible && this._targetVisible);
            this._xAxisWire.setVisible(true);
            this._yAxisWire.setVisible(true);
            this._zAxisWire.setVisible(true);
            this._lengthWire.setVisible(true);
            this._lengthLabel.setVisible(true);

            this._cpDirty = false;
        }
    };

    /**
     * Sets whether this DistanceMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */
    prototypeAccessors.approximate.set = function (approximate) {
        approximate = approximate !== false;
        if (this._approximate === approximate) {
            return;
        }
        this._approximate = approximate;
        this._cpDirty = true;
        this._needUpdate(0);
    };

    /**
     * Gets whether this DistanceMeasurement indicates that its measurement is approximate.
     *
     * This is ````true```` by default.
     *
     * @type {Boolean}
     */
    prototypeAccessors.approximate.get = function () {
        return this._approximate;
    };

    /**
     * Gets the origin {@link Marker}.
     *
     * @type {Marker}
     */
    prototypeAccessors.origin.get = function () {
        return this._originMarker;
    };

    /**
     * Gets the target {@link Marker}.
     *
     * @type {Marker}
     */
    prototypeAccessors.target.get = function () {
        return this._targetMarker;
    };

    /**
     * Gets the World-space direct point-to-point distance between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     *
     * @type {Number}
     */
    prototypeAccessors.length.get = function () {
        this._update();
        var scale = this.plugin.viewer.scene.metrics.scale;
        return this._length * scale;
    };

    /**
     * Sets whether this DistanceMeasurement is visible or not.
     *
     * @type Boolean
     */
    prototypeAccessors.visible.set = function (value) {
        value = value !== false;
        this._visible = value;
        this._originDot.setVisible(this._visible && this._originVisible);
        this._targetDot.setVisible(this._visible && this._targetVisible);
        this._lengthWire.setVisible(this._visible && this._wireVisible);
        var axisVisible = this._visible && this._axisVisible;
        this._xAxisWire.setVisible(axisVisible);
        this._yAxisWire.setVisible(axisVisible);
        this._zAxisWire.setVisible(axisVisible);
        this._lengthLabel.setVisible(axisVisible);
        this._xAxisLabel.setVisible(axisVisible && !this._xAxisLabelCulled);
        this._yAxisLabel.setVisible(axisVisible && !this._yAxisLabelCulled);
        this._zAxisLabel.setVisible(axisVisible && !this._zAxisLabelCulled);
    };

    /**
     * Gets whether this DistanceMeasurement is visible or not.
     *
     * @type Boolean
     */
    prototypeAccessors.visible.get = function () {
        return this._visible;
    };

    /**
     * Sets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originVisible.set = function (value) {
        value = value !== false;
        this._originVisible = value;
        this._originDot.setVisible(this._visible && this._originVisible);
    };

    /**
     * Gets if the origin {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.originVisible.get = function () {
        return this._originVisible;
    };

    /**
     * Sets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetVisible.set = function (value) {
        value = value !== false;
        this._targetVisible = value;
        this._targetDot.setVisible(this._visible && this._targetVisible);
    };

    /**
     * Gets if the target {@link Marker} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.targetVisible.get = function () {
        return this._targetVisible;
    };

    /**
     * Sets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.axisVisible.set = function (value) {
        value = value !== false;
        this._axisVisible = value;
        var axisVisible = this._visible && this._axisVisible;
        this._xAxisWire.setVisible(axisVisible);
        this._yAxisWire.setVisible(axisVisible);
        this._zAxisWire.setVisible(axisVisible);
        this._xAxisLabel.setVisible(axisVisible && !this._xAxisLabelCulled);
        this._yAxisLabel.setVisible(axisVisible && !this._yAxisLabelCulled);
        this._zAxisLabel.setVisible(axisVisible && !this._zAxisLabelCulled);
    };

    /**
     * Gets if the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} are visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.axisVisible.get = function () {
        return this._axisVisible;
    };

    /**
     * Sets if the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.wireVisible.set = function (value) {
        value = value !== false;
        this._wireVisible = value;
        var wireVisible = this._visible && this._wireVisible;
        this._lengthLabel.setVisible(wireVisible);
        this._lengthWire.setVisible(wireVisible);
    };

    /**
     * Gets if the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target} is visible.
     *
     * @type {Boolean}
     */
    prototypeAccessors.wireVisible.get = function () {
        return this._wireVisible;
    };

    /**
     * @private
     */
    DistanceMeasurement.prototype.destroy = function destroy () {

        var scene = this.plugin.viewer.scene;
        var metrics = scene.metrics;

        if (this._onViewMatrix) {
            scene.camera.off(this._onViewMatrix);
        }
        if (this._onProjMatrix) {
            scene.camera.off(this._onProjMatrix);
        }
        if (this._onCanvasBoundary) {
            scene.canvas.off(this._onCanvasBoundary);
        }

        if (this._onMetricsUnits) {
            metrics.off(this._onMetricsUnits);
        }
        if (this._onMetricsScale) {
            metrics.off(this._onMetricsScale);
        }
        if (this._onMetricsOrigin) {
            metrics.off(this._onMetricsOrigin);
        }

        this._originDot.destroy();
        this._targetDot.destroy();
        this._xAxisWire.destroy();
        this._yAxisWire.destroy();
        this._zAxisWire.destroy();
        this._lengthLabel.destroy();
        this._xAxisLabel.destroy();
        this._yAxisLabel.destroy();
        this._zAxisLabel.destroy();
        this._lengthWire.destroy();

        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( DistanceMeasurement.prototype, prototypeAccessors );

    return DistanceMeasurement;
}(Component));

var HOVERING = 0;
var FINDING_ORIGIN = 1;
var FINDING_TARGET = 2;

/**
 * Creates {@link DistanceMeasurement}s from mouse and touch input.
 *
 * Belongs to a {@link DistanceMeasurementsPlugin}. Located at {@link DistanceMeasurementsPlugin#control}.
 *
 * Once the DistanceMeasurementControl is activated, the first click on any {@link Entity} begins constructing a {@link DistanceMeasurement}, fixing its origin to that Entity. The next click on any Entity will complete the DistanceMeasurement, fixing its target to that second Entity. The DistanceMeasurementControl will then wait for the next click on any Entity, to begin constructing another DistanceMeasurement, and so on, until deactivated.
 *
 * See {@link DistanceMeasurementsPlugin} for more info.
 */
var DistanceMeasurementsControl = /*@__PURE__*/(function (Component) {
    function DistanceMeasurementsControl(plugin) {

        Component.call(this, plugin.viewer.scene);

        /**
         * The {@link DistanceMeasurementsPlugin} that owns this DistanceMeasurementsControl.
         * @type {DistanceMeasurementsPlugin}
         */
        this.plugin = plugin;

        this._active = false;
        this._state = HOVERING;
        this._currentDistMeasurement = null;
        this._prevDistMeasurement = null;
        this._onHoverSurface = null;
        this._onHoverOff = null;
    }

    if ( Component ) DistanceMeasurementsControl.__proto__ = Component;
    DistanceMeasurementsControl.prototype = Object.create( Component && Component.prototype );
    DistanceMeasurementsControl.prototype.constructor = DistanceMeasurementsControl;

    var prototypeAccessors = { active: { configurable: true } };

    /** Gets if this DistanceMeasurementsControl is currently active, where it is responding to input.
     *
     * @returns {boolean}
     */
    prototypeAccessors.active.get = function () {
        return this._active;
    };

    /**
     * Activates this DistanceMeasurementsControl, ready to respond to input.
     */
    DistanceMeasurementsControl.prototype.activate = function activate () {
        var this$1 = this;


        if (this._active) {
            return;
        }

        var cameraControl = this.plugin.viewer.cameraControl;

        var over = false;
        var entity = null;
        var worldPos = math.vec3();
        var hoverCanvasPos = math.vec2();

        var pickSurfacePrecisionEnabled = this.plugin.viewer.scene.pickSurfacePrecisionEnabled;

        this._onHoverSurface = cameraControl.on("hoverSurface", function (e) {

            over = true;
            entity = e.entity;
            worldPos.set(e.worldPos);
            hoverCanvasPos.set(e.canvasPos);

            if (this$1._state === HOVERING) {
                document.body.style.cursor = "pointer";
                return;
            }

            if (this$1._currentDistMeasurement) {
                switch (this$1._state) {
                    case FINDING_TARGET:
                        this$1._currentDistMeasurement.wireVisible = true;
                        this$1._currentDistMeasurement.axisVisible = true;
                        this$1._currentDistMeasurement.target.entity = e.entity;
                        this$1._currentDistMeasurement.target.worldPos = e.worldPos;
                        document.body.style.cursor = "pointer";
                        break;
                }
            }
        });

        var lastX;
        var lastY;
        var tolerance = 5;

        this._onInputMouseDown = this.plugin.viewer.scene.input.on("mousedown", function (coords) {
            lastX = coords[0];
            lastY = coords[1];
        });

        this._onInputMouseUp = this.plugin.viewer.scene.input.on("mouseup", function (coords) {

            if (coords[0] > lastX + tolerance || coords[0] < lastX - tolerance || coords[1] > lastY + tolerance || coords[1] < lastY - tolerance) {
                return;
            }

            switch (this$1._state) {

                case HOVERING:

                    if (this$1._prevDistMeasurement) {
                        this$1._prevDistMeasurement.originVisible = true;
                        this$1._prevDistMeasurement.targetVisible = true;
                        this$1._prevDistMeasurement.axisVisible = true;
                    }
                    if (over) {
                        if (pickSurfacePrecisionEnabled) {
                            var pickResult = this$1.plugin.viewer.scene.pick({
                                canvasPos: hoverCanvasPos,
                                pickSurface: true,
                                pickSurfacePrecision: true
                            });
                            if (pickResult && pickResult.worldPos) {
                                worldPos.set(pickResult.worldPos);
                            }
                        }
                        this$1._currentDistMeasurement = this$1.plugin.createMeasurement({
                            id: math.createUUID(),
                            origin: {
                                entity: entity,
                                worldPos: worldPos
                            },
                            target: {
                                entity: entity,
                                worldPos: worldPos
                            },
                            approximate: true
                        });
                        this$1._currentDistMeasurement.axisVisible = false;
                        this$1._currentDistMeasurement.targetVisible = true;
                        this$1._prevDistMeasurement = this$1._currentDistMeasurement;
                        this$1._state = FINDING_TARGET;
                    }
                    break;

                case FINDING_TARGET:

                    if (over) {

                        if (pickSurfacePrecisionEnabled) {
                            var pickResult$1 = this$1.plugin.viewer.scene.pick({
                                canvasPos: hoverCanvasPos,
                                pickSurface: true,
                                pickSurfacePrecision: true
                            });
                            if (pickResult$1 && pickResult$1.worldPos) {
                                this$1._currentDistMeasurement.target.worldPos = pickResult$1.worldPos;
                            }
                            this$1._currentDistMeasurement.approximate = false;
                        }

                        this$1._currentDistMeasurement.axisVisible = true;
                        this$1._currentDistMeasurement.targetVisible = true;
                        this$1._currentDistMeasurement = null;
                        this$1._prevDistMeasurement = null;

                        this$1._state = HOVERING;

                    } else {

                        if (this$1._currentDistMeasurement) {
                            this$1._currentDistMeasurement.destroy();
                            this$1._currentDistMeasurement = null;
                            this$1._prevDistMeasurement = null;
                            this$1._state = HOVERING;
                        }
                    }
                    break;
            }
        });

        this._onHoverOff = cameraControl.on("hoverOff", function (e) {
            over = false;
            if (this$1._currentDistMeasurement) {
                switch (this$1._state) {
                    case HOVERING:
                        break;
                    case FINDING_ORIGIN:
                        this$1._currentDistMeasurement.wireVisible = false;
                        this$1._currentDistMeasurement.originVisible = false;
                        this$1._currentDistMeasurement.axisVisible = false;
                        break;
                    case FINDING_TARGET:
                        this$1._currentDistMeasurement.wireVisible = false;
                        this$1._currentDistMeasurement.targetVisible = false;
                        this$1._currentDistMeasurement.axisVisible = false;
                        break;
                }
            }
            document.body.style.cursor = "default";
        });

        this._active = true;
    };

    /**
     * Deactivates this DistanceMeasurementsControl, making it unresponsive to input.
     *
     * Destroys any {@link DistanceMeasurement} under construction.
     */
    DistanceMeasurementsControl.prototype.deactivate = function deactivate () {

        if (!this._active) {
            return;
        }

        this.reset();

        var cameraControl = this.plugin.viewer.cameraControl;
        var input = this.plugin.viewer.scene.input;

        input.off(this._onInputMouseDown);

        cameraControl.off(this._onHoverSurface);
        cameraControl.off(this._onHoverOff);

        this._currentDistMeasurement = null;

        this._active = false;
    };

    /**
     * Resets this DistanceMeasurementsControl.
     *
     * Destroys any {@link DistanceMeasurement} under construction.
     *
     * Does nothing if the DistanceMeasurementsControl is not active.
     */
    DistanceMeasurementsControl.prototype.reset = function reset () {

        if (!this._active) {
            return;
        }

        if (this._currentDistMeasurement) {
            this._currentDistMeasurement.destroy();
            this._currentDistMeasurement = null;
        }
        this._prevDistMeasurement = null;
        this._state = HOVERING;
    };

    /**
     * @private
     */
    DistanceMeasurementsControl.prototype.destroy = function destroy () {
        this.deactivate();
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( DistanceMeasurementsControl.prototype, prototypeAccessors );

    return DistanceMeasurementsControl;
}(Component));

/**
 * {@link Viewer} plugin for measuring point-to-point distances.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/63047331-867a0a80-bed4-11e9-892f-398740013c5f.gif">](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_createWithMouse)
 *
 * * [[Example 1: Model with distance measurements](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_modelWithMeasurements)]
 * * [[Example 2: Create distance measurements with mouse](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_createWithMouse)]
 * * [[Example 3: Configuring units and scale](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_unitsAndScale)]
 *
 * ## Overview
 *
 * * A {@link DistanceMeasurement} represents a point-to-point measurement between two 3D points on one or two {@link Entity}s.
 * * As shown on the screen capture above, a DistanceMeasurement has one wire (light blue) that shows the direct point-to-point measurement,
 * and three more wires (red, green and blue) that show the distance on each of the World-space X, Y and Z axis.
 * * Create DistanceMeasurements programmatically with {@link DistanceMeasurementsPlugin#createMeasurement}.
 * * Create DistanceMeasurements interactively using the {@link DistanceMeasurementsControl}, located at {@link DistanceMeasurementsPlugin#control}.
 * * Existing DistanceMeasurements are registered by ID in {@link DistanceMeasurementsPlugin#measurements}.
 * * Destroy DistanceMeasurements using {@link DistanceMeasurementsPlugin#destroyMeasurement}.
 * * Configure global measurement units and scale via {@link Metrics}, located at {@link Scene#metrics}.
 *
 * ## Example 1: Creating DistanceMeasurements Programmatically
 *
 * In our first example, we'll use an {@link XKTLoaderPlugin} to load a model, and then use a DistanceMeasurementsPlugin to programmatically create two {@link DistanceMeasurement}s.
 *
 * Note how each DistanceMeasurement has ````origin```` and ````target```` endpoints, which each indicate a 3D World-space
 * position on the surface of an {@link Entity}. The endpoints can be attached to the same Entity, or to different Entitys.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_modelWithMeasurements)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      const myMeasurement1 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement1",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [0.044, 5.998, 17.767]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FLOH"],
 *              worldPos: [4.738, 3.172, 17.768]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 *
 *      const myMeasurement2 = distanceMeasurements.createMeasurement({
 *          id: "distanceMeasurement2",
 *          origin: {
 *              entity: viewer.scene.objects["2O2Fr$t4X7Zf8NOew3FNr2"],
 *              worldPos: [0.457, 2.532, 17.766]
 *          },
 *          target: {
 *              entity: viewer.scene.objects["1CZILmCaHETO8tf3SgGEXu"],
 *              worldPos: [0.436, 0.001, 22.135]
 *          },
 *          visible: true,
 *          wireVisible: true
 *      });
 * });
 * ````
 *
 * ## Example 2: Creating DistanceMeasurements Interactively
 *
 * In our second example, we'll use an {@link XKTLoaderPlugin} to load a model, then we'll use the DistanceMeasurementPlugin's {@link DistanceMeasurementsControl} to interactively create {@link DistanceMeasurement}s with mouse or touch input.
 *
 * After we've activated the DistanceMeasurementsControl, the first click on any {@link Entity} begins constructing a DistanceMeasurement, fixing its
 * origin to that Entity. The next click on any Entity will complete the DistanceMeasurement, fixing its target to that second Entity.
 *
 * The DistanceMeasurementControl will then wait for the next click on any Entity, to begin constructing
 * another DistanceMeasurement, and so on, until deactivated again.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_createWithMouse)]
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];
 * viewer.scene.camera.look = [10.97, 5.82, -11.22];
 * viewer.scene.camera.up = [0.36, 0.83, 0.40];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const distanceMeasurements = new DistanceMeasurementsPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     src: "./models/xkt/duplex/duplex.xkt"
 * });
 *
 * distanceMeasurements.control.activate();  // <------------ Activate the DistanceMeasurementsControl
 * ````
 *
 * ## Example 3: Configuring Measurement Units and Scale
 *
 * In our third example, we'll use the  {@link Scene}'s {@link Metrics} to set the global unit of measurement to ````"meters"````. We'll also specify that a unit within the World-space coordinate system represents ten meters.
 *
 * The wires belonging to our DistanceMeasurements show their lengths in Real-space coordinates, in the current unit of measurement. They will dynamically update as we set these configurations.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#measurements_distance_unitsAndScale)]
 *
 * ````JavaScript
 * const metrics = viewer.scene.metrics;

 * metrics.units = "meters";
 * metrics.scale = 10.0;
 * ````
 */
var DistanceMeasurementsPlugin = /*@__PURE__*/(function (Plugin) {
    function DistanceMeasurementsPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "DistanceMeasurements", viewer);

        this._container = cfg.container || document.body;

        this._control = new DistanceMeasurementsControl(this);

        this._measurements = {};

        this.labelMinAxisLength = cfg.labelMinAxisLength;
    }

    if ( Plugin ) DistanceMeasurementsPlugin.__proto__ = Plugin;
    DistanceMeasurementsPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    DistanceMeasurementsPlugin.prototype.constructor = DistanceMeasurementsPlugin;

    var prototypeAccessors = { control: { configurable: true },measurements: { configurable: true },labelMinAxisLength: { configurable: true } };

    /**
     * @private
     */
    DistanceMeasurementsPlugin.prototype.send = function send (name, value) {

    };

    /**
     * Gets the {@link DistanceMeasurementsControl}, which creates {@link DistanceMeasurement}s from user input.
     *
     * @type {DistanceMeasurementsControl}
     */
    prototypeAccessors.control.get = function () {
        return this._control;
    };

    /**
     * Gets the existing {@link DistanceMeasurement}s, each mapped to its {@link DistanceMeasurement#id}.
     *
     * @type {{String:DistanceMeasurement}}
     */
    prototypeAccessors.measurements.get = function () {
        return this._measurements;
    };

    /**
     * Sets the minimum length, in pixels, of an axis wire beyond which its label is shown.
     *
     * The axis wire's label is not shown when its length is less than this value.
     *
     * This is ````25```` pixels by default.
     *
     * Must not be less than ````1````.
     *
     * @type {number}
     */
    prototypeAccessors.labelMinAxisLength.set = function (labelMinAxisLength) {
        if (labelMinAxisLength < 1) {
            this.error("labelMinAxisLength must be >= 1; defaulting to 25");
            labelMinAxisLength = 25;
        }
        this._labelMinAxisLength = labelMinAxisLength || 25;
    };

    /**
     * Gets the minimum length, in pixels, of an axis wire beyond which its label is shown.
     * @returns {number}
     */
    prototypeAccessors.labelMinAxisLength.get = function () {
        return this._labelMinAxisLength;
    };

    /**
     * Creates a {@link DistanceMeasurement}.
     *
     * The DistanceMeasurement is then registered by {@link DistanceMeasurement#id} in {@link DistanceMeasurementsPlugin#measurements}.
     *
     * @param {Object} params {@link DistanceMeasurement} configuration.
     * @param {String} params.id Unique ID to assign to {@link DistanceMeasurement#id}. The DistanceMeasurement will be registered by this in {@link DistanceMeasurementsPlugin#measurements} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.
     * @param {Number[]} params.origin.worldPos Origin World-space 3D position.
     * @param {Entity} params.origin.entity Origin Entity.
     * @param {Number[]} params.target.worldPos Target World-space 3D position.
     * @param {Entity} params.target.entity Target Entity.
     * @param {Boolean} [params.visible=true] Whether to initially show the {@link DistanceMeasurement}.
     * @param {Boolean} [params.originVisible=true] Whether to initially show the {@link DistanceMeasurement} origin.
     * @param {Boolean} [params.targetVisible=true] Whether to initially show the {@link DistanceMeasurement} target.
     * @param {Boolean} [params.wireVisible=true] Whether to initially show the direct point-to-point wire between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @param {Boolean} [params.axisVisible=true] Whether to initially show the axis-aligned wires between {@link DistanceMeasurement#origin} and {@link DistanceMeasurement#target}.
     * @returns {DistanceMeasurement} The new {@link DistanceMeasurement}.
     */
    DistanceMeasurementsPlugin.prototype.createMeasurement = function createMeasurement (params) {
        var this$1 = this;
        if ( params === void 0 ) params = {};

        if (this.viewer.scene.components[params.id]) {
            this.error("Viewer scene component with this ID already exists: " + params.id);
            delete params.id;
        }
        var origin = params.origin;
        var target = params.target;
        var measurement = new DistanceMeasurement(this, {
            id: params.id,
            plugin: this,
            container: this._container,
            origin: {
                entity: origin.entity,
                worldPos: origin.worldPos
            },
            target: {
                entity: target.entity,
                worldPos: target.worldPos
            },
            visible: params.visible,
            wireVisible: params.wireVisible,
            originVisible: params.originVisible,
            targetVisible: params.targetVisible,
        });
        this._measurements[measurement.id] = measurement;
        measurement.on("destroyed", function () {
            delete this$1._measurements[measurement.id];
        });
        return measurement;
    };

    /**
     * Destroys a {@link DistanceMeasurement}.
     *
     * @param {String} id ID of DistanceMeasurement to destroy.
     */
    DistanceMeasurementsPlugin.prototype.destroyMeasurement = function destroyMeasurement (id) {
        var measurement = this._measurements[id];
        if (!measurement) {
            this.log("DistanceMeasurement not found: " + id);
            return;
        }
        measurement.destroy();
    };

    /**
     * Destroys all {@link DistanceMeasurement}s.
     */
    DistanceMeasurementsPlugin.prototype.clear = function clear () {
        var ids = Object.keys(this._measurements);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroyMeasurement(ids[i]);
        }
    };

    /**
     * Destroys this DistanceMeasurementsPlugin.
     *
     * Destroys all {@link DistanceMeasurement}s first.
     */
    DistanceMeasurementsPlugin.prototype.destroy = function destroy () {
        this.clear();
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( DistanceMeasurementsPlugin.prototype, prototypeAccessors );

    return DistanceMeasurementsPlugin;
}(Plugin));

/**
 * {@link Viewer} plugin that improves interactivity by disabling expensive rendering effects while the {@link Camera} is moving.
 *
 * # Usage
 *
 * In the example below, we'll create a {@link Viewer}, add a {@link FastNavPlugin}, then use an {@link XKTLoaderPlugin} to load a model.
 *
 * This viewer will only render the model with enhanced edges, physically-based rendering (PBR) and scalable
 * ambient obscurance (SAO) when the camera is not moving.
 *
 * Note how we enable SAO and PBR on the ````Scene```` and the model.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#performance_FastNavPlugin)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, FastNavPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true,
 *      pbrEnabled: true,
 *      saoEnabled: true
 *  });
 *
 * viewer.scene.camera.eye = [-66.26, 105.84, -281.92];
 * viewer.scene.camera.look = [42.45, 49.62, -43.59];
 * viewer.scene.camera.up = [0.05, 0.95, 0.15];
 *
 * new FastNavPlugin(viewer, {
 *     pbrEnabled: true,
 *     saoEnabled: true,
 *     edgesEnabled: true
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/HolterTower.xkt",
 *      edges: true,
 *      saoEnabled: true,
 *      pbrEnabled: true
 * });
 * ````
 *
 * @class FastNavPlugin
 */
var FastNavPlugin = /*@__PURE__*/(function (Plugin) {
    function FastNavPlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "FastNav", viewer);

        this._pbrEnabled = (cfg.pbrEnabled !== undefined && cfg.pbrEnabled !== null) ? cfg.pbrEnabled : viewer.scene.pbrEnabled;
        this._saoEnabled = (cfg.saoEnabled !== undefined && cfg.saoEnabled !== null) ? cfg.saoEnabled : viewer.scene.sao.enabled;
        this._edgesEnabled = (cfg.edgesEnabled !== undefined && cfg.edgesEnabled !== null) ? cfg.edgesEnabled : viewer.scene.edgeMaterial.edges;

        this._pInterval = null;
        this._fadeMillisecs = 500;

        var timeoutDuration = 600; // Milliseconds
        var timer = timeoutDuration;
        var fastMode = false;

        this._onCanvasBoundary = viewer.scene.canvas.on("boundary", function () {
            timer = timeoutDuration;
            if (!fastMode) {
                this$1._cancelFade();
                viewer.scene.pbrEnabled = false;
                viewer.scene.sao.enabled = false;
                viewer.scene.edgeMaterial.edges = false;
                fastMode = true;
            }
        });

        this._onCameraMatrix = viewer.scene.camera.on("matrix", function () {
            timer = timeoutDuration;
            if (!fastMode) {
                this$1._cancelFade();
                viewer.scene.pbrEnabled = false;
                viewer.scene.sao.enabled = false;
                viewer.scene.edgeMaterial.edges = false;
                fastMode = true;
            }
        });

        this._onSceneTick = viewer.scene.on("tick", function (tickEvent) {  // Milliseconds
            if (!fastMode) {
                return;
            }
            timer -= tickEvent.deltaTime;
            if (timer <= 0) {
                if (fastMode) {
                    this$1._startFade();
                    this$1._pInterval2 = setTimeout(function () { // Needed by Firefox - https://github.com/xeokit/xeokit-sdk/issues/624
                        viewer.scene.pbrEnabled = this$1._pbrEnabled;
                        viewer.scene.sao.enabled = this$1._saoEnabled;
                        viewer.scene.edgeMaterial.edges = this$1._edgesEnabled;
                    }, 100);

                    fastMode = false;
                }
            }
        });

        var down = false;

        this._onSceneMouseDown = viewer.scene.input.on("mousedown", function () {
            down = true;
        });

        this._onSceneMouseUp = viewer.scene.input.on("mouseup", function () {
            down = false;
        });

        this._onSceneMouseMove = viewer.scene.input.on("mousemove", function () {
            if (!down) {
                return;
            }
            timer = timeoutDuration;
            if (!fastMode) {
                this$1._cancelFade();
                viewer.scene.pbrEnabled = false;
                viewer.scene.sao.enabled = false;
                viewer.scene.edgeMaterial.edges = false;
                fastMode = true;
            }
        });
    }

    if ( Plugin ) FastNavPlugin.__proto__ = Plugin;
    FastNavPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    FastNavPlugin.prototype.constructor = FastNavPlugin;

    var prototypeAccessors = { pbrEnabled: { configurable: true },saoEnabled: { configurable: true },edgesEnabled: { configurable: true } };

    FastNavPlugin.prototype._startFade = function _startFade () {
        var this$1 = this;


        if (!this._img) {
            this._initFade();
        }

        var interval = 50;
        var inc = 1 / (this._fadeMillisecs / interval);

        if (this._pInterval) {
            clearInterval(this._pInterval);
            this._pInterval = null;
        }

        var viewer = this.viewer;

        var canvas = viewer.scene.canvas.canvas;
        var canvasOffset = cumulativeOffset(canvas);
        var zIndex = (parseInt(canvas.style["z-index"]) || 0) + 1;
        this._img.style.position = "fixed";
        this._img.style["margin"] = 0 + "px";
        this._img.style["z-index"] = zIndex;
        this._img.style["background"] = canvas.style.background;
        this._img.style.left = canvasOffset.left + "px";
        this._img.style.top = canvasOffset.top + "px";
        this._img.style.width = canvas.width + "px";
        this._img.style.height = canvas.height + "px";
        this._img.width = canvas.width;
        this._img.height = canvas.height;
        this._img.src = ""; // Needed by Firefox - https://github.com/xeokit/xeokit-sdk/issues/624
        this._img.src = viewer.getSnapshot({
            format: "png",
            includeGizmos: true
        });
        this._img.style.visibility = "visible";
        this._img.style.opacity = 1;

        var opacity = 1;
        this._pInterval = setInterval(function () {
            opacity -= inc;
            if (opacity > 0) {
                this$1._img.style.opacity = opacity;
                var canvasOffset = cumulativeOffset(canvas);
                this$1._img.style.left = canvasOffset.left + "px";
                this$1._img.style.top = canvasOffset.top + "px";
                this$1._img.style.width = canvas.width + "px";
                this$1._img.style.height = canvas.height + "px";
                this$1._img.style.opacity = opacity;
                this$1._img.width = canvas.width;
                this$1._img.height = canvas.height;

            } else {
                this$1._img.style.opacity = 0;
                this$1._img.style.visibility = "hidden";
                clearInterval(this$1._pInterval);
                this$1._pInterval = null;
            }
        }, interval);
    };

    FastNavPlugin.prototype._initFade = function _initFade () {
        this._img = document.createElement('img');
        var canvas = this.viewer.scene.canvas.canvas;
        var canvasOffset = cumulativeOffset(canvas);
        (parseInt(canvas.style["z-index"]) || 0) + 1;
        this._img.style.position = "absolute";
        this._img.style.visibility = "hidden";
        this._img.style["pointer-events"] = "none";
        this._img.style["z-index"] = 5;
        this._img.style.left = canvasOffset.left + "px";
        this._img.style.top = canvasOffset.top + "px";
        this._img.style.width = canvas.width + "px";
        this._img.style.height = canvas.height + "px";
        this._img.style.opacity = 1;
        this._img.width = canvas.width;
        this._img.height = canvas.height;
        this._img.left = canvasOffset.left;
        this._img.top = canvasOffset.top;
        canvas.parentNode.insertBefore(this._img, canvas.nextSibling);
    };

    FastNavPlugin.prototype._cancelFade = function _cancelFade () {
        if (!this._img) {
            return;
        }
        if (this._pInterval) {
            clearInterval(this._pInterval);
            this._pInterval = null;
        }
        if (this._pInterval2) {
            clearInterval(this._pInterval2);
            this._pInterval2 = null;
        }
        this._img.style.opacity = 0;
        this._img.style.visibility = "hidden";
    };

    /**
     * Sets whether to enable physically-based rendering (PBR) when the camera stops moving.
     *
     * @return {Boolean} Whether PBR will be enabled.
     */
    prototypeAccessors.pbrEnabled.set = function (pbrEnabled) {
        this._pbrEnabled = pbrEnabled;
    };

    /**
     * Gets whether to enable physically-based rendering (PBR) when the camera stops moving.
     *
     * @return {Boolean} Whether PBR will be enabled.
     */
    prototypeAccessors.pbrEnabled.get = function () {
        return this._pbrEnabled
    };

    /**
     * Sets whether to enable scalable ambient occlusion (SAO) when the camera stops moving.
     *
     * @return {Boolean} Whether SAO will be enabled.
     */
    prototypeAccessors.saoEnabled.set = function (saoEnabled) {
        this._saoEnabled = saoEnabled;
    };

    /**
     * Gets whether the FastNavPlugin enables SAO when switching to quality rendering.
     *
     * @return {Boolean} Whether SAO will be enabled.
     */
    prototypeAccessors.saoEnabled.get = function () {
        return this._saoEnabled
    };

    /**
     * Sets whether to show enhanced edges when the camera stops moving.
     *
     * @return {Boolean} Whether edge enhancement will be enabled.
     */
    prototypeAccessors.edgesEnabled.set = function (edgesEnabled) {
        this._edgesEnabled = edgesEnabled;
    };

    /**
     * Gets whether to show enhanced edges when the camera stops moving.
     *
     * @return {Boolean} Whether edge enhancement will be enabled.
     */
    prototypeAccessors.edgesEnabled.get = function () {
        return this._edgesEnabled
    };

    /**
     * @private
     */
    FastNavPlugin.prototype.send = function send (name, value) {
        switch (name) {
            case "clear":
                this._cancelFade();
                break;
        }
    };

    /**
     * Destroys this plugin.
     */
    FastNavPlugin.prototype.destroy = function destroy () {
        this._cancelFade();
        this.viewer.scene.camera.off(this._onCameraMatrix);
        this.viewer.scene.canvas.off(this._onCanvasBoundary);
        this.viewer.scene.input.off(this._onSceneMouseDown);
        this.viewer.scene.input.off(this._onSceneMouseUp);
        this.viewer.scene.input.off(this._onSceneMouseMove);
        this.viewer.scene.off(this._onSceneTick);
        Plugin.prototype.destroy.call(this);
        if (this._img) {
            this._img.parentNode.removeChild(this._img);
            this._img = null;
        }
    };

    Object.defineProperties( FastNavPlugin.prototype, prototypeAccessors );

    return FastNavPlugin;
}(Plugin));

function cumulativeOffset(element) {
    var top = 0, left = 0;
    do {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
    } while (element);

    return {
        top: top,
        left: left
    };
}

/**
 * Default data access strategy for {@link GLTFLoaderPlugin}.
 *
 * This just loads assets using XMLHttpRequest.
 */
var GLTFDefaultDataSource = function GLTFDefaultDataSource() {
};

/**
 * Gets metamodel JSON.
 *
 * @param {String|Number} metaModelSrc Identifies the metamodel JSON asset.
 * @param {{Function(*)}} ok Fired on successful loading of the metamodel JSON asset.
 * @param {{Function(*)}} error Fired on error while loading the metamodel JSON asset.
 */
GLTFDefaultDataSource.prototype.getMetaModel = function getMetaModel (metaModelSrc, ok, error) {
    utils.loadJSON(metaModelSrc,
        function (json) {
            ok(json);
        },
        function (errMsg) {
            error(errMsg);
        });
};

/**
 * Gets glTF JSON.
 *
 * @param {String|Number} glTFSrc Identifies the glTF JSON asset.
 * @param {Function} ok Fired on successful loading of the glTF JSON asset.
 * @param {Function} error Fired on error while loading the glTF JSON asset.
 */
GLTFDefaultDataSource.prototype.getGLTF = function getGLTF (glTFSrc, ok, error) {
    utils.loadJSON(glTFSrc,
        function (gltf) {
            ok(gltf);
        },
        function (errMsg) {
            error(errMsg);
        });
};

/**
 * Gets glTF binary attachment.
 *
 * Note that this method requires the source of the glTF JSON asset. This is because the binary attachment
 * source could be relative to the glTF source, IE. it may not be a global ID.
 *
 * @param {String|Number} glTFSrc Identifies the glTF JSON asset.
 * @param {String|Number} binarySrc Identifies the glTF binary asset.
 * @param {Function} ok Fired on successful loading of the glTF binary asset.
 * @param {Function} error Fired on error while loading the glTF binary asset.
 */
GLTFDefaultDataSource.prototype.getArrayBuffer = function getArrayBuffer (glTFSrc, binarySrc, ok, error) {
    loadArraybuffer(glTFSrc, binarySrc,
        function (arrayBuffer) {
            ok(arrayBuffer);
        },
        function (errMsg) {
            error(errMsg);
        });
};

function loadArraybuffer(glTFSrc, binarySrc, ok, err) {
    // Check for data: URI
    var defaultCallback = function () {
    };
    ok = ok || defaultCallback;
    err = err || defaultCallback;
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = binarySrc.match(dataUriRegex);
    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest
        var isBase64 = !!dataUriRegexResult[2];
        var data = dataUriRegexResult[3];
        data = window.decodeURIComponent(data);
        if (isBase64) {
            data = window.atob(data);
        }
        try {
            var buffer = new ArrayBuffer(data.length);
            var view = new Uint8Array(buffer);
            for (var i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
            }
            window.setTimeout(function () {
                ok(buffer);
            }, 0);
        } catch (error) {
            window.setTimeout(function () {
                err(error);
            }, 0);
        }
    } else {
        var basePath = getBasePath(glTFSrc);
        var url = basePath + binarySrc;
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    ok(request.response);
                } else {
                    err('loadArrayBuffer error : ' + request.response);
                }
            }
        };
        request.send(null);
    }
}

function getBasePath(src) {
    var i = src.lastIndexOf("/");
    return (i !== 0) ? src.substring(0, i + 1) : "";
}

/**
 * @private
 * @implements Pickable
 */
var PerformanceMesh = function PerformanceMesh(model, id, color, opacity, layer, portionId) {
    if ( layer === void 0 ) layer = null;
    if ( portionId === void 0 ) portionId = 0;


    /**
     * The PerformanceModel that contains this PerformanceModelMesh.
     *
     * A PerformanceModelMesh always belongs to exactly one PerformanceModel.
     *
     * @property model
     * @type {PerformanceModel}
     * @final
     */
    this.model = model;

    /**
     * The PerformanceNode that contains this PerformanceModelMesh.
     *
     * A PerformanceModelMesh always belongs to exactly one PerformanceNode.
     *
     * @property object
     * @type {PerformanceNode}
     * @final
     */
    this.object = null;

    /**
     * The PerformanceNode that contains this PerformanceModelMesh.
     *
     * A PerformanceModelMesh always belongs to exactly one PerformanceNode.
     *
     * @property object
     * @type {PerformanceNode}
     * @final
     */
    this.parent = null;

    /**
     * ID of this PerformanceModelMesh, unique within the xeokit.Scene.
     *
     * @property id
     * @type {String}
     * @final
     */
    this.id = id;

    /**
     *
     * @type {Number}
     * @private
     */
    this.pickId = this.model.scene._renderer.getPickID(this);

    /**
     * World-space 3D axis-aligned bounding box (AABB).
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @property aabb
     * @final
     * @type {Float64Array}
     */
    this.aabb = math.AABB3();

    this._layer = layer;
    this._portionId = portionId;

    this._color = [color[0], color[1], color[2], opacity]; // [0..255]
    this._colorize = [color[0], color[1], color[2], opacity]; // [0..255]
    this._colorizing = false;

    this._transparent = (opacity < 255);

    this.numTriangles = 0;

    /**
     * 3D origin of the PerformanceMesh's vertex positions, if they are in relative-to-center (RTC) coordinates.
     *
     * When this is defined, then the positions are RTC, which means that they are relative to this position.
     *
     * @property rtcCenter
     * @type {Float64Array}
     */
    this.rtcCenter = null;
};

/**
 * @private
 */
PerformanceMesh.prototype._finalize = function _finalize (entityFlags) {
    this._layer.initFlags(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setVisible = function _setVisible (entityFlags) {
    this._layer.setVisible(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setColor = function _setColor (color) {
    this._color[0] = color[0];
    this._color[1] = color[1];
    this._color[2] = color[2];
    if (!this._colorizing) {
        this._layer.setColor(this._portionId, this._color, false);
    }
};

/** @private */
PerformanceMesh.prototype._setColorize = function _setColorize (colorize) {
    var setOpacity = false;
    if (colorize) {
        this._colorize[0] = colorize[0];
        this._colorize[1] = colorize[1];
        this._colorize[2] = colorize[2];
        this._layer.setColor(this._portionId, this._colorize, setOpacity);
        this._colorizing = true;
    } else {
        this._layer.setColor(this._portionId, this._color, setOpacity);
        this._colorizing = false;
    }
};

/** @private */
PerformanceMesh.prototype._setOpacity = function _setOpacity (opacity, entityFlags) {
    var newTransparent = (opacity < 255);
    var lastTransparent = this._transparent;
    var changingTransparency = (lastTransparent !== newTransparent);
    this._color[3] = opacity;
    this._colorize[3] = opacity;
    this._transparent = newTransparent;
    if (this._colorizing) {
        this._layer.setColor(this._portionId, this._colorize);
    } else {
        this._layer.setColor(this._portionId, this._color);
    }
    if (changingTransparency) {
        this._layer.setTransparent(this._portionId, entityFlags, newTransparent);
    }
};

/**
 * @private
 */
PerformanceMesh.prototype._setOffset = function _setOffset (offset) {
    this._layer.setOffset(this._portionId, offset);
};

/**
 * @private
 */
PerformanceMesh.prototype._setHighlighted = function _setHighlighted (entityFlags) {
    this._layer.setHighlighted(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setXRayed = function _setXRayed (entityFlags) {
    this._layer.setXRayed(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setSelected = function _setSelected (entityFlags) {
    this._layer.setSelected(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setEdges = function _setEdges (entityFlags) {
    this._layer.setEdges(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setClippable = function _setClippable (entityFlags) {
    this._layer.setClippable(this._portionId, entityFlags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setCollidable = function _setCollidable (entityFlags) {
    this._layer.setCollidable(this._portionId, entityFlags);
};

/**
 * @private
 */
PerformanceMesh.prototype._setPickable = function _setPickable (flags) {
    this._layer.setPickable(this._portionId, flags, this._transparent);
};

/**
 * @private
 */
PerformanceMesh.prototype._setCulled = function _setCulled (flags) {
    this._layer.setCulled(this._portionId, flags, this._transparent);
};

/** @private */
PerformanceMesh.prototype.canPickTriangle = function canPickTriangle () {
    return false;
};

/** @private */
PerformanceMesh.prototype.drawPickTriangles = function drawPickTriangles (renderFlags, frameCtx) {
    // NOP
};

/** @private */
PerformanceMesh.prototype.pickTriangleSurface = function pickTriangleSurface (pickResult) {
    // NOP
};

/** @private */
PerformanceMesh.prototype.precisionRayPickSurface = function precisionRayPickSurface (worldRayOrigin, worldRayDir, worldSurfacePos) {
    return this._layer.precisionRayPickSurface ? this._layer.precisionRayPickSurface(this._portionId, worldRayOrigin, worldRayDir, worldSurfacePos) : false;
};

/** @private */
PerformanceMesh.prototype.canPickWorldPos = function canPickWorldPos () {
    return true;
};

/** @private */
PerformanceMesh.prototype.drawPickDepths = function drawPickDepths (frameCtx) {
    this.model.drawPickDepths(frameCtx);
};

/** @private */
PerformanceMesh.prototype.drawPickNormals = function drawPickNormals (frameCtx) {
    this.model.drawPickNormals(frameCtx);
};

/**
 * @private
 * @returns {PerformanceNode}
 */
PerformanceMesh.prototype.delegatePickedEntity = function delegatePickedEntity () {
    return this.parent;
};

/**
 * @private
 */
PerformanceMesh.prototype._destroy = function _destroy () {
    this.model.scene._renderer.putPickID(this.pickId);
};

/**
 * Provides scratch memory for methods like TrianglesBatchingLayer setFlags() and setColors(),
 * so they don't need to allocate temporary arrays that need garbage collection.
 *
 * @private
 */
var ScratchMemory = function ScratchMemory() {
    this._uint8Arrays = {};
    this._float32Arrays = {};
};

ScratchMemory.prototype._clear = function _clear () {
    this._uint8Arrays = {};
    this._float32Arrays = {};
};

ScratchMemory.prototype.getUInt8Array = function getUInt8Array (len) {
    var uint8Array = this._uint8Arrays[len];
    if (!uint8Array) {
        uint8Array = new Uint8Array(len);
        this._uint8Arrays[len] = uint8Array;
    }
    return uint8Array;
};

ScratchMemory.prototype.getFloat32Array = function getFloat32Array (len) {
    var float32Array = this._float32Arrays[len];
    if (!float32Array) {
        float32Array = new Float32Array(len);
        this._float32Arrays[len] = float32Array;
    }
    return float32Array;
};

var batchingLayerScratchMemory = new ScratchMemory();

var countUsers = 0;

/**
 * @private
 */
function getScratchMemory() {
    countUsers++;
    return batchingLayerScratchMemory;
}

/**
 * @private
 */
function putScratchMemory() {
    if (countUsers === 0) {
        return;
    }
    countUsers--;
    if (countUsers === 0) {
        batchingLayerScratchMemory._clear();
    }
}

/**
 * @private
 */
var RENDER_PASSES = {

    // Skipped - suppress rendering

    NOT_RENDERED: 0,

    // Normal rendering - mutually exclusive modes

    COLOR_OPAQUE: 1,
    COLOR_TRANSPARENT: 2,

    // Emphasis silhouette rendering - mutually exclusive modes

    SILHOUETTE_HIGHLIGHTED: 3,
    SILHOUETTE_SELECTED: 4,
    SILHOUETTE_XRAYED: 5,

    // Edges rendering - mutually exclusive modes

    EDGES_COLOR_OPAQUE: 6,
    EDGES_COLOR_TRANSPARENT: 7,
    EDGES_HIGHLIGHTED: 8,
    EDGES_SELECTED: 9,
    EDGES_XRAYED: 10,

    // Picking

    PICK: 11
};

var tempVec4$5 = math.vec4();
var tempVec3a$S = math.vec3();

/**
 * @private
 */
var TrianglesBatchingColorRenderer = function TrianglesBatchingColorRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingColorRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesBatchingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var scene = this._scene;
    var camera = scene.camera;
    var model = batchingLayer.model;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$S);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aNormal) {
        this._aNormal.bindArrayBuffer(state.normalsBuf);
    }

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (this._withSAO) {
        this._uOcclusionTexture = "uOcclusionTexture";
        this._uSAOParams = program.getLocation("uSAOParams");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingColorRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var lights = scene._lightsState.lights;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {

        var light = lights[i];

        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4$5[0] = viewportWidth;
            tempVec4$5[1] = viewportHeight;
            tempVec4$5[2] = sao.blendCutoff;
            tempVec4$5[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4$5);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, 0);
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var light;
    var src = [];

    src.push("// Triangles batching draw vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec3 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");

    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 lightAmbient;");

    for (var i = 0, len = lightsState.lights.length; i < len; i++) {
        light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i + ";");
            src.push("uniform vec3 lightDir" + i + ";");
        }
    }

    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");

    src.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);");

    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");

    src.push("float lambertian = 1.0;");
    for (var i$1 = 0, len$1 = lightsState.lights.length; i$1 < len$1; i$1++) {
        light = lightsState.lights[i$1];
        if (light.type === "ambient") {
            continue;
        }
        if (light.type === "dir") {
            if (light.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i$1 + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i$1 + ", 0.0)).xyz);");
            }
        } else if (light.type === "point") {
            if (light.space === "view") {
                src.push("viewLightDir = -normalize(lightPos" + i$1 + " - viewPosition.xyz);");
            } else {
                src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + i$1 + ", 0.0)).xyz);");
            }
        } else if (light.type === "spot") {
            if (light.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i$1 + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i$1 + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }
        src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
        src.push("reflectedColor += lambertian * (lightColor" + i$1 + ".rgb * lightColor" + i$1 + ".a);");
    }

    src.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));");
    src.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("gl_Position = clipPos;");
    src.push("}");

    src.push("}");
    return src;
};

TrianglesBatchingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching draw fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBToFloat( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
            src.push("  if (dist > 0.0) { ");
            src.push("      discard;");
            src.push("  }");
        src.push("}");
    }

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    if (this._withSAO) {
        // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
        // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   gl_FragColor            = vec4(vColor.rgb * ambient, 1.0);");
    } else {
        src.push("   gl_FragColor            = vColor;");
    }

    src.push("}");
    return src;
};

TrianglesBatchingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec4$4 = math.vec4();
var tempVec3a$R = math.vec3();

/**
 * @private
 */
var TrianglesBatchingFlatColorRenderer = function TrianglesBatchingFlatColorRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingFlatColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingFlatColorRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesBatchingFlatColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var scene = this._scene;
    var camera = scene.camera;
    var model = batchingLayer.model;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
            gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
            if (active) {
                var sectionPlane = sectionPlanes[sectionPlaneIndex];
                if (rtcCenter) {
                    var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$R);
                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                } else {
                    gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                }
                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingFlatColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (this._withSAO) {
        this._uOcclusionTexture = "uOcclusionTexture";
        this._uSAOParams = program.getLocation("uSAOParams");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingFlatColorRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var lights = scene._lightsState.lights;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {

        var light = lights[i];

        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4$4[0] = viewportWidth;
            tempVec4$4[1] = viewportHeight;
            tempVec4$4[2] = sao.blendCutoff;
            tempVec4$4[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4$4);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, 0);
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingFlatColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingFlatColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Triangles batching flat-shading draw vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("uniform mat4 worldMatrix;");

    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vViewPosition;");
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("vViewPosition = viewPosition;");
    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("gl_Position = clipPos;");
    src.push("}");

    src.push("}");
    return src;
};

TrianglesBatchingFlatColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var lightsState = scene._lightsState;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching flat-shading draw fragment shader");
    src.push("#extension GL_OES_standard_derivatives : enable");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBToFloat( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }

    src.push("uniform mat4 viewMatrix;");

    src.push("uniform vec4 lightAmbient;");
    for (var i$1 = 0, len$1 = lightsState.lights.length; i$1 < len$1; i$1++) {
        var light = lightsState.lights[i$1];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i$1 + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i$1 + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i$1 + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i$1 + ";");
            src.push("uniform vec3 lightDir" + i$1 + ";");
        }
    }

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec4 vColor;");
        
    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$2 = 0, len$2 = sectionPlanesState.sectionPlanes.length; i$2 < len$2; i$2++) {
            src.push("if (sectionPlaneActive" + i$2 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$2 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$2 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { ");
        src.push("      discard;");
        src.push("  }");
        src.push("}");
    }

    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");

    src.push("float lambertian = 1.0;");

    src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");
    src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");
    src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");

    for (var i$3 = 0, len$3 = lightsState.lights.length; i$3 < len$3; i$3++) {
        var light$1 = lightsState.lights[i$3];
        if (light$1.type === "ambient") {
            continue;
        }
        if (light$1.type === "dir") {
            if (light$1.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i$3 + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "point") {
            if (light$1.space === "view") {
                src.push("viewLightDir = -normalize(lightPos" + i$3 + " - viewPosition.xyz);");
            } else {
                src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "spot") {
            if (light$1.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i$3 + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }

        src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
        src.push("reflectedColor += lambertian * (lightColor" + i$3 + ".rgb * lightColor" + i$3 + ".a);");
    }
        
    src.push("vec4 fragColor =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");

    if (this._withSAO) {
        // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
        // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   gl_FragColor            = vec4(fragColor.rgb * ambient, 1.0);");
    } else {
        src.push("   gl_FragColor            = fragColor;");
    }

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");
    return src;
};

TrianglesBatchingFlatColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingFlatColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var defaultColor$4 = new Float32Array([1, 1, 1]);
var tempVec3a$Q = math.vec3();

/**
 * @private
 */
var TrianglesBatchingSilhouetteRenderer = function TrianglesBatchingSilhouetteRenderer(scene, primitiveType) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, defaultColor$4);
    }

    var viewMat = (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix;
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMat);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$Q);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;

    var src = [];

    src.push("// Triangles batching silhouette vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    src.push("uniform vec4 color;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");

    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesBatchingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching silhouette fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

TrianglesBatchingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$P = math.vec3();
var defaultColor$3 = new Float32Array([0,0,0,1]);

/**
 * @private
 */
var TrianglesBatchingEdgesRenderer = function TrianglesBatchingEdgesRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingEdgesRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingEdgesRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingEdgesRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.EDGES_XRAYED) {
        var material = scene.xrayMaterial._state;
        var edgeColor = material.edgeColor;
        var edgeAlpha = material.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor[0], edgeColor[1], edgeColor[2], edgeAlpha);

    } else if (renderPass === RENDER_PASSES.EDGES_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var edgeColor$1 = material$1.edgeColor;
        var edgeAlpha$1 = material$1.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor$1[0], edgeColor$1[1], edgeColor$1[2], edgeAlpha$1);

    } else if (renderPass === RENDER_PASSES.EDGES_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var edgeColor$2 = material$2.edgeColor;
        var edgeAlpha$2 = material$2.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor$2[0], edgeColor$2[1], edgeColor$2[2], edgeAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, defaultColor$3);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$P);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }
    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }
    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }
    state.edgeIndicesBuf.bind();

    gl.drawElements(gl.LINES, state.edgeIndicesBuf.numItems, state.edgeIndicesBuf.itemType, 0);
};

TrianglesBatchingEdgesRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uColor = program.getLocation("color");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingEdgesRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingEdgesRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingEdgesRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Batched geometry edges drawing vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");
    src.push("uniform vec4 color;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vColor;");
    src.push("void main(void) {");

    // flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
    // renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED

    src.push("if (int(flags.z) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("vColor = vec4(color.r, color.g, color.b, color.a);");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesBatchingEdgesRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry edges drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vColor;");
    src.push("}");
    return src;
};

TrianglesBatchingEdgesRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingEdgesRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$O = math.vec3();

/**
 * @private
 */
var TrianglesBatchingEdgesColorRenderer = function TrianglesBatchingEdgesColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingEdgesColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingEdgesColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingEdgesColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$O);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aColor.bindArrayBuffer(state.colorsBuf);
    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }
    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }
    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }
    state.edgeIndicesBuf.bind();

    gl.drawElements(gl.LINES, state.edgeIndicesBuf.numItems, state.edgeIndicesBuf.itemType, 0);
};

TrianglesBatchingEdgesColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingEdgesColorRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingEdgesColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingEdgesColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Batched geometry edges drawing vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vColor;");
    src.push("void main(void) {");

    // flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
    // renderPass = EDGES_COLOR_OPAQUE | EDGES_COLOR_TRANSPARENT

    src.push("if (int(flags.z) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    //src.push("vColor = vec4(float(color.r-100.0) / 255.0, float(color.g-100.0) / 255.0, float(color.b-100.0) / 255.0, float(color.a) / 255.0);");
    src.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesBatchingEdgesColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry edges drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vColor;");
    src.push("}");
    return src;
};

TrianglesBatchingEdgesColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingEdgesColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$N = math.vec3();

/**
 * @private
 */
var TrianglesBatchingPickMeshRenderer = function TrianglesBatchingPickMeshRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingPickMeshRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingPickMeshRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingPickMeshRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$N);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aPickColor) {
        this._aPickColor.bindArrayBuffer(state.pickColorsBuf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingPickMeshRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aPickColor = program.getAttribute("pickColor");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingPickMeshRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program.bind();

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);
};

TrianglesBatchingPickMeshRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingPickMeshRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Batched geometry picking vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 pickColor;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vPickColor;");

    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingPickMeshRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry picking fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vPickColor; ");
    src.push("}");
    return src;
};

TrianglesBatchingPickMeshRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingPickMeshRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$M = math.vec3();

/**
 * @private
 */
var TrianglesBatchingPickDepthRenderer = function TrianglesBatchingPickDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingPickDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingPickDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingPickDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniform1f(this._uPickZNear, frameCtx.pickZNear);
    gl.uniform1f(this._uPickZFar, frameCtx.pickZFar);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(frameCtx.pickZFar + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$M);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    //=============================================================
    // TODO: Use drawElements count and offset to draw only one entity
    //=============================================================

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingPickDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._uPickZNear = program.getLocation("pickZNear");
    this._uPickZFar = program.getLocation("pickZFar");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingPickDepthRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

TrianglesBatchingPickDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingPickDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Triangles batching pick depth vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform bool pickInvisible;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vViewPosition;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vViewPosition = viewPosition;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingPickDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Triangles batching pick depth fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    src.push("uniform float pickZNear;");
    src.push("uniform float pickZFar;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vViewPosition;");
    src.push("vec4 packDepth(const in float depth) {");
    src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");
    src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");
    src.push("  vec4 res = fract(depth * bitShift);");
    src.push("  res -= res.xxyz * bitMask;");
    src.push("  return res;");
    src.push("}");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");
    src.push("    gl_FragColor = packDepth(zNormalizedDepth); ");  // Must be linear depth
    src.push("}");
    return src;
};

TrianglesBatchingPickDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingPickDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$L = math.vec3();

/**
 * @private
 */
var TrianglesBatchingPickNormalsRenderer = function TrianglesBatchingPickNormalsRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingPickNormalsRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingPickNormalsRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingPickNormalsRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);
    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2);  // TODO: Far should be from projection matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$L);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    //=============================================================
    // TODO: Use drawElements count and offset to draw only one entity
    //=============================================================

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aNormal) {
        this._aNormal.bindArrayBuffer(state.normalsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingPickNormalsRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingPickNormalsRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

TrianglesBatchingPickNormalsRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingPickNormalsRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching pick normals vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec3 normal;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec3 vWorldNormal;");
    src.push("void main(void) {");
    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK
    src.push("if (int(flags.w) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("      vec3 worldNormal =  octDecode(normal.xy); ");
    src.push("      vWorldNormal = worldNormal;");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingPickNormalsRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching pick normals fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec3 vWorldNormal;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4((vWorldNormal * 0.5) + 0.5, 1.0);");
    src.push("}");
    return src;
};

TrianglesBatchingPickNormalsRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingPickNormalsRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$K = math.vec3();

/**
 * @private
 */
var TrianglesBatchingOcclusionRenderer = function TrianglesBatchingOcclusionRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingOcclusionRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingOcclusionRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingOcclusionRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var camera = scene.camera;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$K);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);

    if (this._aFlags2) { // Won't be in shader when not clipping
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingOcclusionRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingOcclusionRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingOcclusionRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingOcclusionRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching occlusion vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE
    // Only opaque objects can be occluders

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingOcclusionRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching occlusion fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("      if (sectionPlaneActive" + i$1 + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); "); // Occluders are blue
    src.push("}");
    return src;
};

TrianglesBatchingOcclusionRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingOcclusionRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$J = math.vec3();

/**
 * @private
 */
var TrianglesBatchingDepthRenderer = function TrianglesBatchingDepthRenderer(scene) {
    this._scene = scene;
    this._allocate();
    this._hash = this._getHash();
};

TrianglesBatchingDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$J);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingDepthRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching depth vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec2 vHighPrecisionZW;");
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("vHighPrecisionZW = gl_Position.zw;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = (sectionPlanesState.sectionPlanes.length > 0);
    var src = [];
    src.push("// Triangles batching depth fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("precision highp float;");
    src.push("precision highp int;");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("const float   packUpScale = 256. / 255.;");
    src.push("const float   unpackDownscale = 255. / 256.;");
    src.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
    src.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );");
    src.push("const float   shiftRight8 = 1.0 / 256.;");

    src.push("vec4 packDepthToRGBA( const in float v ) {");
    src.push("    vec4 r = vec4( fract( v * packFactors ), v );");
    src.push("    r.yzw -= r.xyz * shiftRight8;");
    src.push("    return r * packUpScale;");
    src.push("}");
    src.push("varying vec2 vHighPrecisionZW;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");
    if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
        src.push("    gl_FragColor = vec4(vec3(1.0 - fragCoordZ), 1.0); ");
    } else {
        src.push("    gl_FragColor = packDepthToRGBA(fragCoordZ); "); // Must be linear depth
    }
    src.push("}");
    return src;
};

TrianglesBatchingDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
    stats.memory.programs--;
};

var tempVec3a$I = math.vec3();

/**
 * @private
 */
var TrianglesBatchingNormalsRenderer = function TrianglesBatchingNormalsRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingNormalsRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingNormalsRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingNormalsRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(batchingLayer);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$I);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aOffset.bindArrayBuffer(state.offsetsBuf);
    this._aNormal.bindArrayBuffer(state.normalsBuf);
    this._aColor.bindArrayBuffer(state.colorsBuf);// Needed for masking out transparent entities using alpha channel
    this._aFlags.bindArrayBuffer(state.flagsBuf);
    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }
    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingNormalsRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");

    if (this._aFlags2) { // Won't be in shader when not clipping
        this._aFlags2 = program.getAttribute("flags2");
    }

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingNormalsRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesBatchingNormalsRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingNormalsRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry normals vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec3 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec3 vViewNormal;");
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");

    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition   = viewMatrix * worldPosition; ");
    src.push("      vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");
    src.push("      vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);");
    if (clipping) {
        src.push("      vWorldPosition  = worldPosition;");
        src.push("      vFlags2         = flags2;");
    }
    src.push("      vViewNormal = viewNormal;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingNormalsRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = (sectionPlanesState.sectionPlanes.length > 0);
    var src = [];
    src.push("// Batched geometry normals fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec3 vViewNormal;");
    src.push("vec3 packNormalToRGB( const in vec3 normal ) {");
    src.push("    return normalize( normal ) * 0.5 + 0.5;");
    src.push("}");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");
    src.push("}");
    return src;
};

TrianglesBatchingNormalsRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingNormalsRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$H = math.vec3();

/**
 * Renders BatchingLayer fragment depths to a shadow map.
 *
 * @private
 */
var TrianglesBatchingShadowRenderer = function TrianglesBatchingShadowRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingShadowRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingShadowRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingShadowRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    if (!this._program) {
        this._allocate();
    }
    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }
    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);
    if (scene.logarithmicDepthBufferEnabled) {
        gl.uniform1f(this._uZFar, scene.camera.project.far);
    }
    this._aPosition.bindArrayBuffer(state.positionsBuf);
    if (this._aColor) { // Needed for masking out transparent entities using alpha channel
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }
    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }
    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }
    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }
    state.indicesBuf.bind();

    // TODO: Section planes need to be set if RTC center has changed since last RTC center recorded on frameCtx

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        var rtcCenter = batchingLayer._state.rtcCenter;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$H);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingShadowRenderer.prototype._allocate = function _allocate () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    this._program = new Program(gl, this._buildShader());
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uShadowViewMatrix = program.getLocation("shadowViewMatrix");
    this._uShadowProjMatrix = program.getLocation("shadowProjMatrix");
    if (scene.logarithmicDepthBufferEnabled) {
        this._uZFar = program.getLocation("zFar");
    }
    this._uSectionPlanes = [];
    var sectionPlanes = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
};

TrianglesBatchingShadowRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    program.bind();
    gl.uniformMatrix4fv(this._uShadowViewMatrix, false, frameCtx.shadowViewMatrix);
    gl.uniformMatrix4fv(this._uShadowProjMatrix, false, frameCtx.shadowProjMatrix);
    this._lastLightId = null;
};

TrianglesBatchingShadowRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};


TrianglesBatchingShadowRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry shadow vertex shader");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 shadowViewMatrix;");
    src.push("uniform mat4 shadowProjMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vViewPosition;");
    src.push("void main(void) {");
    src.push("  bool visible        = (float(flags.x) > 0.0);");
    src.push("  bool transparent    = ((float(color.a) / 255.0) < 1.0);");
    src.push("  if (!visible || transparent) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");
    src.push("  } else {");
    src.push("      vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = shadowViewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("      vViewPosition = viewPosition;");
    src.push("      gl_Position = shadowProjMatrix * viewPosition;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingShadowRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = (sectionPlanesState.sectionPlanes.length > 0);
    var src = [];
    src.push("// Batched geometry shadow fragment shader");
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec4 vViewPosition;");

    src.push("vec4 encodeFloat( const in float v ) {");
    src.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);");
    src.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);");
    src.push("  vec4 comp = fract(v * bitShift);");
    src.push("  comp -= comp.xxyz * bitMask;");
    src.push("  return comp;");
    src.push("}");

    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    src.push("    gl_FragColor = encodeFloat( gl_FragCoord.z); ");
    src.push("}");
    return src;
};

TrianglesBatchingShadowRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingShadowRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec4$3 = math.vec4();
var tempVec3a$G = math.vec3();

var TEXTURE_DECODE_FUNCS$1 = {
    "linear": "linearToLinear",
    "sRGB": "sRGBToLinear",
    "gamma": "gammaToLinear"
};

/**
 * @private
 */
var TrianglesBatchingColorQualityRenderer = function TrianglesBatchingColorQualityRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingColorQualityRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingColorQualityRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene.gammaOutput, scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesBatchingColorQualityRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var scene = this._scene;
    var camera = scene.camera;
    var model = batchingLayer.model;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$G);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aNormal) {
        this._aNormal.bindArrayBuffer(state.normalsBuf);
    }

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    if (this._aMetallicRoughness) {
        this._aMetallicRoughness.bindArrayBuffer(state.metallicRoughnessBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingColorQualityRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uGammaFactor = program.getLocation("gammaFactor");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    if (lightsState.reflectionMaps.length > 0) {
        this._uReflectionMap = "reflectionMap";
    }

    if (lightsState.lightMaps.length > 0) {
        this._uLightMap = "lightMap";
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aMetallicRoughness = program.getAttribute("metallicRoughness");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (this._withSAO) {
        this._uOcclusionTexture = "uOcclusionTexture";
        this._uSAOParams = program.getLocation("uSAOParams");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingColorQualityRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var maxTextureUnits = WEBGL_INFO$1.MAX_TEXTURE_UNITS;
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var lightsState = scene._lightsState;
    var lights = lightsState.lights;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {

        var light = lights[i];

        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (lightsState.reflectionMaps.length > 0 && lightsState.reflectionMaps[0].texture && this._uReflectionMap) {
        program.bindTexture(this._uReflectionMap, lightsState.reflectionMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (lightsState.lightMaps.length > 0 && lightsState.lightMaps[0].texture && this._uLightMap) {
        program.bindTexture(this._uLightMap, lightsState.lightMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4$3[0] = viewportWidth;
            tempVec4$3[1] = viewportHeight;
            tempVec4$3[2] = sao.blendCutoff;
            tempVec4$3[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4$3);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
            frameCtx.bindTexture++;
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    if (this._uGammaFactor) {
        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
    }
};

TrianglesBatchingColorQualityRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingColorQualityRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var clippingCaps = sectionPlanesState.clippingCaps;

    var src = [];

    src.push("// Triangles batching quality draw vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec3 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec2 metallicRoughness;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");

    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec3 vViewNormal;");
    src.push("varying vec4 vColor;");
    src.push("varying vec2 vMetallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("varying vec3 vWorldNormal;");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        if (clippingCaps) {
            src.push("varying vec4 vClipPosition;");
        }
    }

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");
    src.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
        if (clippingCaps) {
            src.push("vClipPosition = clipPos;");
        }
    }

    src.push("vViewPosition = viewPosition;");
    src.push("vViewNormal = viewNormal;");
    src.push("vColor = color;");
    src.push("vMetallicRoughness = metallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("vWorldNormal = worldNormal.xyz;");
    }

    src.push("gl_Position = clipPos;");
    src.push("}");

    src.push("}");
    return src;
};

TrianglesBatchingColorQualityRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {

    var scene = this._scene;
    var gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var clippingCaps = sectionPlanesState.clippingCaps;
    var src = [];

    src.push("// Triangles batching quality draw fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec3 vViewNormal;");
    src.push("varying vec4 vColor;");
    src.push("varying vec2 vMetallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("varying vec3 vWorldNormal;");
    }

    src.push("uniform mat4 viewMatrix;");

    if (lightsState.reflectionMaps.length > 0) {
        src.push("uniform samplerCube reflectionMap;");
    }

    if (lightsState.lightMaps.length > 0) {
        src.push("uniform samplerCube lightMap;");
    }

    src.push("uniform vec4 lightAmbient;");

    for (var i = 0, len = lightsState.lights.length; i < len; i++) {
        var light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i + ";");
            src.push("uniform vec3 lightDir" + i + ";");
        }
    }

    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBAToDepth( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }

    src.push("uniform float gammaFactor;");
    src.push("vec4 linearToLinear( in vec4 value ) {");
    src.push("  return value;");
    src.push("}");
    src.push("vec4 sRGBToLinear( in vec4 value ) {");
    src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");
    src.push("}");
    src.push("vec4 gammaToLinear( in vec4 value) {");
    src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");
    src.push("}");
    if (gammaOutput) {
        src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        if (clippingCaps) {
            src.push("varying vec4 vClipPosition;");
        }
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }

    // CONSTANT DEFINITIONS

    src.push("#define PI 3.14159265359");
    src.push("#define RECIPROCAL_PI 0.31830988618");
    src.push("#define RECIPROCAL_PI2 0.15915494");
    src.push("#define EPSILON 1e-6");

    src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");

    // UTILITY DEFINITIONS

    src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");
    src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");
    src.push("}");

    // STRUCTURES

    src.push("struct IncidentLight {");
    src.push("   vec3 color;");
    src.push("   vec3 direction;");
    src.push("};");

    src.push("struct ReflectedLight {");
    src.push("   vec3 diffuse;");
    src.push("   vec3 specular;");
    src.push("};");

    src.push("struct Geometry {");
    src.push("   vec3 position;");
    src.push("   vec3 viewNormal;");
    src.push("   vec3 worldNormal;");
    src.push("   vec3 viewEyeDir;");
    src.push("};");

    src.push("struct Material {");
    src.push("   vec3    diffuseColor;");
    src.push("   float   specularRoughness;");
    src.push("   vec3    specularColor;");
    src.push("   float   shine;"); // Only used for Phong
    src.push("};");

    // IRRADIANCE EVALUATION

    src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");
    src.push("   float r = ggxRoughness + 0.0001;");
    src.push("   return (2.0 / (r * r) - 2.0);");
    src.push("}");

    src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");
    src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");
    src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");
    src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");
    src.push("}");

    if (lightsState.reflectionMaps.length > 0) {
        src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");
        src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"); //TODO: a random factor - fix this
        src.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS$1[lightsState.reflectionMaps[0].encoding] + "(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;");
        src.push("  return envMapColor;");
        src.push("}");
    }

    // SPECULAR BRDF EVALUATION

    src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");
    src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");
    src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");
    src.push("}");

    src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
    src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
    src.push("   return 1.0 / ( gl * gv );");
    src.push("}");

    src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
    src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
    src.push("   return 0.5 / max( gv + gl, EPSILON );");
    src.push("}");

    src.push("float D_GGX(const in float alpha, const in float dotNH) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");
    src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");
    src.push("}");

    src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
    src.push("   float alpha = ( roughness * roughness );");
    src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");
    src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");
    src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");
    src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");
    src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");
    src.push("   vec3  F = F_Schlick( specularColor, dotLH );");
    src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");
    src.push("   float D = D_GGX( alpha, dotNH );");
    src.push("   return F * (G * D);");
    src.push("}");

    src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
    src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");
    src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");
    src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");
    src.push("   vec4 r = roughness * c0 + c1;");
    src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");
    src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");
    src.push("   return specularColor * AB.x + AB.y;");
    src.push("}");

    if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {

        src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");

        if (lightsState.lightMaps.length > 0) {
            src.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS$1[lightsState.lightMaps[0].encoding] + "(textureCube(lightMap, geometry.worldNormal)).rgb;");
            src.push("   irradiance *= PI;");
            src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
            src.push("   reflectedLight.diffuse +=  irradiance * diffuseBRDFContrib;");
        }

        if (lightsState.reflectionMaps.length > 0) {
            src.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);");
            src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
            src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");
            src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");
            src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");
            src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");
        }

        src.push("}");
    }

    // MAIN LIGHTING COMPUTATION FUNCTION

    src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
    src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");
    src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");
    src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
    src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");
    src.push("}");

    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$2 = 0, len$2 = sectionPlanesState.sectionPlanes.length; i$2 < len$2; i$2++) {
            src.push("if (sectionPlaneActive" + i$2 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$2 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$2 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        if (clippingCaps) {
            src.push("  if (dist > (0.002 * vClipPosition.w)) {");
            src.push("      discard;");
            src.push("  }");
            src.push("  if (dist > 0.0) { ");
            src.push("      gl_FragColor=vec4(1.0, 0.0, 0.0, 1.0);");
            if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
                src.push("  gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
            }
            src.push("  return;");
            src.push("}");
        } else {
            src.push("  if (dist > 0.0) { ");
            src.push("      discard;");
            src.push("  }");
        }
        src.push("}");
    }

    src.push("IncidentLight  light;");
    src.push("Material       material;");
    src.push("Geometry       geometry;");
    src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");

    src.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));");
    src.push("float alpha = float(vColor.a) / 255.0;");

    src.push("vec3  diffuseColor = rgb;");
    src.push("float specularF0 = 1.0;");
    src.push("float metallic = float(vMetallicRoughness.r) / 255.0;");
    src.push("float roughness = float(vMetallicRoughness.g) / 255.0;");
    src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");

    src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");
    src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");
    src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);");

    src.push("geometry.position      = vViewPosition.xyz;");
    src.push("geometry.viewNormal    = -normalize(vViewNormal);");
    src.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);");

    if (lightsState.lightMaps.length > 0) {
        src.push("geometry.worldNormal   = normalize(vWorldNormal);");
    }

    if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {
        src.push("computePBRLightMapping(geometry, material, reflectedLight);");
    }

    for (var i$3 = 0, len$3 = lightsState.lights.length; i$3 < len$3; i$3++) {
        var light$1 = lightsState.lights[i$3];
        if (light$1.type === "ambient") {
            continue;
        }
        if (light$1.type === "dir") {
            if (light$1.space === "view") {
                src.push("light.direction =  normalize(lightDir" + i$3 + ");");
            } else {
                src.push("light.direction =  normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "point") {
            if (light$1.space === "view") {
                src.push("light.direction =  normalize(lightPos" + i$3 + " - vViewPosition.xyz);");
            } else {
                src.push("light.direction =  normalize((viewMatrix * vec4(lightPos" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "spot") {
            if (light$1.space === "view") {
                src.push("light.direction =  normalize(lightDir" + i$3 + ");");
            } else {
                src.push("light.direction =  normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }

        src.push("light.color =  lightColor" + i$3 + ".rgb * lightColor" + i$3 + ".a;"); // a is intensity

        src.push("computePBRLighting(light, geometry, material, reflectedLight);");
    }

    src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular);");

    src.push("vec4 fragColor;");

    if (this._withSAO) {
        // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
        // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBAToDepth(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   fragColor               = vec4(outgoingLight.rgb * ambient, alpha);");
    } else {
        src.push("   fragColor            = vec4(outgoingLight.rgb, alpha);");
    }

    if (gammaOutput) {
        src.push("fragColor = linearToGamma(fragColor, gammaFactor);");
    }

    src.push("gl_FragColor = fragColor;");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");
    return src;
};

TrianglesBatchingColorQualityRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingColorQualityRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$F = math.vec3();

/**
 * @private
 */
var TrianglesBatchingPickNormalsFlatRenderer = function TrianglesBatchingPickNormalsFlatRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesBatchingPickNormalsFlatRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesBatchingPickNormalsFlatRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesBatchingPickNormalsFlatRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(batchingLayer);
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);
    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2);  // TODO: Far should be from projection matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
            gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
            if (active) {
                var sectionPlane = sectionPlanes[sectionPlaneIndex];
                if (rtcCenter) {
                    var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$F);
                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                } else {
                    gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                }
                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
            }
        }
    }

    //=============================================================
    // TODO: Use drawElements count and offset to draw only one entity
    //=============================================================

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

TrianglesBatchingPickNormalsFlatRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesBatchingPickNormalsFlatRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

TrianglesBatchingPickNormalsFlatRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesBatchingPickNormalsFlatRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching pick flat normals vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("varying vec4 vWorldPosition;");
    if (clipping) {
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");
    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK
    src.push("if (int(flags.w) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("      vWorldPosition = worldPosition;");
    if (clipping) {
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("  }");
    src.push("}");
    return src;
};

TrianglesBatchingPickNormalsFlatRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles batching pick flat normals fragment shader");
    src.push("#extension GL_OES_standard_derivatives : enable");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    src.push("varying vec4 vWorldPosition;");
    if (clipping) {
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );");
    src.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );");
    src.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");
    src.push("  gl_FragColor = vec4((worldNormal * 0.5) + 0.5, 1.0);");
    src.push("}");
    return src;
};

TrianglesBatchingPickNormalsFlatRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesBatchingPickNormalsFlatRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var TrianglesBatchingRenderers = function TrianglesBatchingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$8 = { colorRenderer: { configurable: true },colorRendererWithSAO: { configurable: true },flatColorRenderer: { configurable: true },flatColorRendererWithSAO: { configurable: true },colorQualityRenderer: { configurable: true },colorQualityRendererWithSAO: { configurable: true },silhouetteRenderer: { configurable: true },depthRenderer: { configurable: true },normalsRenderer: { configurable: true },edgesRenderer: { configurable: true },edgesColorRenderer: { configurable: true },pickMeshRenderer: { configurable: true },pickNormalsRenderer: { configurable: true },pickNormalsFlatRenderer: { configurable: true },pickDepthRenderer: { configurable: true },occlusionRenderer: { configurable: true },shadowRenderer: { configurable: true } };

TrianglesBatchingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._colorRendererWithSAO && (!this._colorRendererWithSAO.getValid())) {
        this._colorRendererWithSAO.destroy();
        this._colorRendererWithSAO = null;
    }
    if (this._flatColorRenderer && (!this._flatColorRenderer.getValid())) {
        this._flatColorRenderer.destroy();
        this._flatColorRenderer = null;
    }
    if (this._flatColorRendererWithSAO && (!this._flatColorRendererWithSAO.getValid())) {
        this._flatColorRendererWithSAO.destroy();
        this._flatColorRendererWithSAO = null;
    }
    if (this._colorQualityRenderer && (!this._colorQualityRenderer.getValid())) {
        this._colorQualityRenderer.destroy();
        this._colorQualityRenderer = null;
    }
    if (this._colorQualityRendererWithSAO && (!this._colorQualityRendererWithSAO.getValid())) {
        this._colorQualityRendererWithSAO.destroy();
        this._colorQualityRendererWithSAO = null;
    }
    if (this._depthRenderer && (!this._depthRenderer.getValid())) {
        this._depthRenderer.destroy();
        this._depthRenderer = null;
    }
    if (this._normalsRenderer && (!this._normalsRenderer.getValid())) {
        this._normalsRenderer.destroy();
        this._normalsRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
    if (this._edgesRenderer && (!this._edgesRenderer.getValid())) {
        this._edgesRenderer.destroy();
        this._edgesRenderer = null;
    }
    if (this._edgesColorRenderer && (!this._edgesColorRenderer.getValid())) {
        this._edgesColorRenderer.destroy();
        this._edgesColorRenderer = null;
    }
    if (this._pickMeshRenderer && (!this._pickMeshRenderer.getValid())) {
        this._pickMeshRenderer.destroy();
        this._pickMeshRenderer = null;
    }
    if (this._pickDepthRenderer && (!this._pickDepthRenderer.getValid())) {
        this._pickDepthRenderer.destroy();
        this._pickDepthRenderer = null;
    }
    if (this._pickNormalsRenderer && this._pickNormalsRenderer.getValid() === false) {
        this._pickNormalsRenderer.destroy();
        this._pickNormalsRenderer = null;
    }
    if (this._pickNormalsFlatRenderer && this._pickNormalsFlatRenderer.getValid() === false) {
        this._pickNormalsFlatRenderer.destroy();
        this._pickNormalsFlatRenderer = null;
    }
    if (this._occlusionRenderer && this._occlusionRenderer.getValid() === false) {
        this._occlusionRenderer.destroy();
        this._occlusionRenderer = null;
    }
    if (this._shadowRenderer && (!this._shadowRenderer.getValid())) {
        this._shadowRenderer.destroy();
        this._shadowRenderer = null;
    }
};

prototypeAccessors$8.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new TrianglesBatchingColorRenderer(this._scene, false);
    }
    return this._colorRenderer;
};

prototypeAccessors$8.colorRendererWithSAO.get = function () {
    if (!this._colorRendererWithSAO) {
        this._colorRendererWithSAO = new TrianglesBatchingColorRenderer(this._scene, true);
    }
    return this._colorRendererWithSAO;
};

prototypeAccessors$8.flatColorRenderer.get = function () {
    if (!this._flatColorRenderer) {
        this._flatColorRenderer = new TrianglesBatchingFlatColorRenderer(this._scene, false);
    }
    return this._flatColorRenderer;
};

prototypeAccessors$8.flatColorRendererWithSAO.get = function () {
    if (!this._flatColorRendererWithSAO) {
        this._flatColorRendererWithSAO = new TrianglesBatchingFlatColorRenderer(this._scene, true);
    }
    return this._flatColorRendererWithSAO;
};

prototypeAccessors$8.colorQualityRenderer.get = function () {
    if (!this._colorQualityRenderer) {
        this._colorQualityRenderer = new TrianglesBatchingColorQualityRenderer(this._scene, false);
    }
    return this._colorQualityRenderer;
};

prototypeAccessors$8.colorQualityRendererWithSAO.get = function () {
    if (!this._colorQualityRendererWithSAO) {
        this._colorQualityRendererWithSAO = new TrianglesBatchingColorQualityRenderer(this._scene, true);
    }
    return this._colorQualityRendererWithSAO;
};

prototypeAccessors$8.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new TrianglesBatchingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

prototypeAccessors$8.depthRenderer.get = function () {
    if (!this._depthRenderer) {
        this._depthRenderer = new TrianglesBatchingDepthRenderer(this._scene);
    }
    return this._depthRenderer;
};

prototypeAccessors$8.normalsRenderer.get = function () {
    if (!this._normalsRenderer) {
        this._normalsRenderer = new TrianglesBatchingNormalsRenderer(this._scene);
    }
    return this._normalsRenderer;
};

prototypeAccessors$8.edgesRenderer.get = function () {
    if (!this._edgesRenderer) {
        this._edgesRenderer = new TrianglesBatchingEdgesRenderer(this._scene);
    }
    return this._edgesRenderer;
};

prototypeAccessors$8.edgesColorRenderer.get = function () {
    if (!this._edgesColorRenderer) {
        this._edgesColorRenderer = new TrianglesBatchingEdgesColorRenderer(this._scene);
    }
    return this._edgesColorRenderer;
};

prototypeAccessors$8.pickMeshRenderer.get = function () {
    if (!this._pickMeshRenderer) {
        this._pickMeshRenderer = new TrianglesBatchingPickMeshRenderer(this._scene);
    }
    return this._pickMeshRenderer;
};

prototypeAccessors$8.pickNormalsRenderer.get = function () {
    if (!this._pickNormalsRenderer) {
        this._pickNormalsRenderer = new TrianglesBatchingPickNormalsRenderer(this._scene);
    }
    return this._pickNormalsRenderer;
};

prototypeAccessors$8.pickNormalsFlatRenderer.get = function () {
    if (!this._pickNormalsFlatRenderer) {
        this._pickNormalsFlatRenderer = new TrianglesBatchingPickNormalsFlatRenderer(this._scene);
    }
    return this._pickNormalsFlatRenderer;
};

prototypeAccessors$8.pickDepthRenderer.get = function () {
    if (!this._pickDepthRenderer) {
        this._pickDepthRenderer = new TrianglesBatchingPickDepthRenderer(this._scene);
    }
    return this._pickDepthRenderer;
};

prototypeAccessors$8.occlusionRenderer.get = function () {
    if (!this._occlusionRenderer) {
        this._occlusionRenderer = new TrianglesBatchingOcclusionRenderer(this._scene);
    }
    return this._occlusionRenderer;
};

prototypeAccessors$8.shadowRenderer.get = function () {
    if (!this._shadowRenderer) {
        this._shadowRenderer = new TrianglesBatchingShadowRenderer(this._scene);
    }
    return this._shadowRenderer;
};

TrianglesBatchingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._colorRendererWithSAO) {
        this._colorRendererWithSAO.destroy();
    }
    if (this._flatColorRenderer) {
        this._flatColorRenderer.destroy();
    }
    if (this._flatColorRendererWithSAO) {
        this._flatColorRendererWithSAO.destroy();
    }
    if (this._colorQualityRenderer) {
        this._colorQualityRenderer.destroy();
    }
    if (this._colorQualityRendererWithSAO) {
        this._colorQualityRendererWithSAO.destroy();
    }
    if (this._depthRenderer) {
        this._depthRenderer.destroy();
    }
    if (this._normalsRenderer) {
        this._normalsRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
    if (this._edgesRenderer) {
        this._edgesRenderer.destroy();
    }
    if (this._edgesColorRenderer) {
        this._edgesColorRenderer.destroy();
    }
    if (this._pickMeshRenderer) {
        this._pickMeshRenderer.destroy();
    }
    if (this._pickDepthRenderer) {
        this._pickDepthRenderer.destroy();
    }
    if (this._pickNormalsRenderer) {
        this._pickNormalsRenderer.destroy();
    }
    if (this._pickNormalsFlatRenderer) {
        this._pickNormalsFlatRenderer.destroy();
    }
    if (this._occlusionRenderer) {
        this._occlusionRenderer.destroy();
    }
    if (this._shadowRenderer) {
        this._shadowRenderer.destroy();
    }
};

Object.defineProperties( TrianglesBatchingRenderers.prototype, prototypeAccessors$8 );

var cachdRenderers = {};

/**
 * @private
 */
function getBatchingRenderers$1(scene) {
    var sceneId = scene.id;
    var batchingRenderers = cachdRenderers[sceneId];
    if (!batchingRenderers) {
        batchingRenderers = new TrianglesBatchingRenderers(scene);
        cachdRenderers[sceneId] = batchingRenderers;
        batchingRenderers._compile();
        scene.on("compile", function () {
            batchingRenderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachdRenderers[sceneId];
            batchingRenderers._destroy();
        });
    }
    return batchingRenderers;
}

var bigIndicesSupported$5 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

/**
 * @private
 */
var TrianglesBatchingBuffer = function TrianglesBatchingBuffer(maxGeometryBatchSize) {
    if ( maxGeometryBatchSize === void 0 ) maxGeometryBatchSize = 5000000;


    if (bigIndicesSupported$5) {
        if (maxGeometryBatchSize > 5000000) {
            maxGeometryBatchSize = 5000000;
        }
    } else {
        if (maxGeometryBatchSize > 65530) {
            maxGeometryBatchSize = 65530;
        }
    }

    this.maxVerts = maxGeometryBatchSize;
    this.maxIndices = maxGeometryBatchSize * 3; // Rough rule-of-thumb
    this.positions = [];
    this.colors = [];
    this.metallicRoughness = [];
    this.normals = [];
    this.pickColors = [];
    this.flags = [];
    this.flags2 = [];
    this.offsets = [];
    this.indices = [];
    this.edgeIndices = [];
};

var translate = math.mat4();
var scale = math.mat4();

/**
 * @private
 */
function quantizePositions(positions, aabb, positionsDecodeMatrix) { // http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf
    var lenPositions = positions.length;
    var quantizedPositions = new Uint16Array(lenPositions);
    var xmin = aabb[0];
    var ymin = aabb[1];
    var zmin = aabb[2];
    var xwid = aabb[3] - xmin;
    var ywid = aabb[4] - ymin;
    var zwid = aabb[5] - zmin;
    var maxInt = 65525;
    var xMultiplier = maxInt / xwid;
    var yMultiplier = maxInt / ywid;
    var zMultiplier = maxInt / zwid;
    var verify = function (num) { return num >= 0 ? num : 0; };
    for (var i = 0; i < lenPositions; i += 3) {
        quantizedPositions[i + 0] = Math.floor(verify(positions[i + 0] - xmin) * xMultiplier);
        quantizedPositions[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
        quantizedPositions[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
    }
    math.identityMat4(translate);
    math.translationMat4v(aabb, translate);
    math.identityMat4(scale);
    math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);
    math.mulMat4(translate, scale, positionsDecodeMatrix);
    return quantizedPositions;
}

/**
 * @private
 */
function transformAndOctEncodeNormals(worldNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {
    // http://jcgt.org/published/0003/02/01/
    var oct, dec, best, currentCos, bestCos;
    var i;
    var localNormal = new Float32Array([0, 0, 0, 0]);
    var worldNormal = new Float32Array([0, 0, 0, 0]);
    for (i = 0; i < lenNormals; i += 3) {
        localNormal[0] = normals[i];
        localNormal[1] = normals[i + 1];
        localNormal[2] = normals[i + 2];

        math.transformVec3(worldNormalMatrix, localNormal, worldNormal);
        math.normalizeVec3(worldNormal, worldNormal);

        // Test various combinations of ceil and floor to minimize rounding errors
        best = oct = octEncodeVec3(worldNormal, "floor", "floor");
        dec = octDecodeVec2(oct);
        currentCos = bestCos = dot(worldNormal, dec);
        oct = octEncodeVec3(worldNormal, "ceil", "floor");
        dec = octDecodeVec2(oct);
        currentCos = dot(worldNormal, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeVec3(worldNormal, "floor", "ceil");
        dec = octDecodeVec2(oct);
        currentCos = dot(worldNormal, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeVec3(worldNormal, "ceil", "ceil");
        dec = octDecodeVec2(oct);
        currentCos = dot(worldNormal, dec);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        compressedNormals[lenCompressedNormals + i + 0] = best[0];
        compressedNormals[lenCompressedNormals + i + 1] = best[1];
        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused
    }
    lenCompressedNormals += lenNormals;
    return lenCompressedNormals;
}

/**
 * @private
 */
function octEncodeNormals(normals) { // http://jcgt.org/published/0003/02/01/
    var lenNormals = normals.length;
    var compressedNormals = new Int8Array(lenNormals);
    var oct, best, currentCos, bestCos;
    for (var i = 0; i < lenNormals; i += 3) {
        // Test various combinations of ceil and floor to minimize rounding errors
        best = oct = octEncodeNormal(normals, i, "floor", "floor");
        octDecodeVec2(oct);
        currentCos = bestCos = dot(normals, i);
        oct = octEncodeNormal(normals, i, "ceil", "floor");
        octDecodeVec2(oct);
        currentCos = dot(normals, i);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeNormal(normals, i, "floor", "ceil");
        octDecodeVec2(oct);
        currentCos = dot(normals, i);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        oct = octEncodeNormal(normals, i, "ceil", "ceil");
        octDecodeVec2(oct);
        currentCos = dot(normals, i);
        if (currentCos > bestCos) {
            best = oct;
            bestCos = currentCos;
        }
        compressedNormals[i + 0] = best[0];
        compressedNormals[i + 1] = best[1];
        compressedNormals[i + 2] = 0.0; // Unused
    }
    return new Int8Array(compressedNormals)
}

/**
 * @private
 */
function octEncodeVec3(p, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes
    var x = p[0] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));
    var y = p[1] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));
    if (p[2] < 0) {
        var tempx = x;
        var tempy = y;
        tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        x = tempx;
        y = tempy;
    }
    return new Int8Array([
        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),
        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))
    ]);
}

/**
 * @private
 */
function octEncodeNormal(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes
    var x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    var y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    if (array[i + 2] < 0) {
        var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        x = tempx;
        y = tempy;
    }
    return new Int8Array([
        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),
        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))
    ]);
}

/**
 * @private
 */
function octDecodeVec2(oct) { // Decode an oct-encoded normal
    var x = oct[0];
    var y = oct[1];
    x /= x < 0 ? 127 : 128;
    y /= y < 0 ? 127 : 128;
    var z = 1 - Math.abs(x) - Math.abs(y);
    if (z < 0) {
        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    }
    var length = Math.sqrt(x * x + y * y + z * z);
    return [
        x / length,
        y / length,
        z / length
    ];
}

/**
 * @private
 */
function dot(p, vec3) { // Dot product of a normal in an array against a candidate decoding
    return p[0] * vec3[0] + p[1] * vec3[1] + p[2] * vec3[2];
}

var tempMat4$2 = math.mat4();
var tempMat4b = math.mat4();
var tempVec4a$7 = math.vec4([0, 0, 0, 1]);
var tempVec4b$7 = math.vec4([0, 0, 0, 1]);
var tempVec4c$7 = math.vec4([0, 0, 0, 1]);
var tempOBB3$2 = math.OBB3();

var tempVec3a$E = math.vec3();
var tempVec3b$7 = math.vec3();
var tempVec3c$4 = math.vec3();
var tempVec3d$2 = math.vec3();
var tempVec3e$1 = math.vec3();
var tempVec3f$1 = math.vec3();
var tempVec3g$1 = math.vec3();

/**
 * @private
 */
var TrianglesBatchingLayer = function TrianglesBatchingLayer(model, cfg) {

    /**
     * State sorting key.
     * @type {string}
     */
    this.sortId = "TrianglesBatchingLayer" + (cfg.solid ? "-solid" : "-surface") + (cfg.autoNormals ? "-autonormals" : "-normals");

    /**
     * Index of this TrianglesBatchingLayer in {@link PerformanceModel#_layerList}.
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._batchingRenderers = getBatchingRenderers$1(model.scene);
    this.model = model;
    this._buffer = new TrianglesBatchingBuffer(cfg.maxGeometryBatchSize);
    this._scratchMemory = cfg.scratchMemory;

    this._state = new RenderState({
        positionsBuf: null,
        offsetsBuf: null,
        normalsBuf: null,
        colorsBuf: null,
        metallicRoughnessBuf: null,
        flagsBuf: null,
        flags2Buf: null,
        indicesBuf: null,
        edgeIndicesBuf: null,
        positionsDecodeMatrix: math.mat4()
    });

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numEdgesLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    this._modelAABB = math.collapseAABB3(); // Model-space AABB
    this._portions = [];

    this._finalized = false;

    if (cfg.positionsDecodeMatrix) {
        this._state.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);
        this._preCompressed = true;
    } else {
        this._preCompressed = false;
    }

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    /**
     * The axis-aligned World-space boundary of this TrianglesBatchingLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();

    /**
     * When true, this layer contains solid triangle meshes, otherwise this layer contains surface triangle meshes
     * @type {boolean}
     */
    this.solid = !!cfg.solid;
};

/**
 * Tests if there is room for another portion in this TrianglesBatchingLayer.
 *
 * @param lenPositions Number of positions we'd like to create in the portion.
 * @param lenIndices Number of indices we'd like to create in this portion.
 * @returns {boolean} True if OK to create another portion.
 */
TrianglesBatchingLayer.prototype.canCreatePortion = function canCreatePortion (lenPositions, lenIndices) {
    if (this._finalized) {
        throw "Already finalized";
    }
    return ((this._buffer.positions.length + lenPositions) < (this._buffer.maxVerts * 3) && (this._buffer.indices.length + lenIndices) < (this._buffer.maxIndices));
};

/**
 * Creates a new portion within this TrianglesBatchingLayer, returns the new portion ID.
 *
 * Gives the portion the specified geometry, color and matrix.
 *
 * @param cfg.positions Flat float Local-space positions array.
 * @param [cfg.normals] Flat float normals array.
 * @param [cfg.colors] Flat float colors array.
 * @param cfg.indices  Flat int indices array.
 * @param [cfg.edgeIndices] Flat int edges indices array.
 * @param cfg.color Quantized RGB color [0..255,0..255,0..255,0..255]
 * @param cfg.metallic Metalness factor [0..255]
 * @param cfg.roughness Roughness factor [0..255]
 * @param cfg.opacity Opacity [0..255]
 * @param [cfg.meshMatrix] Flat float 4x4 matrix
 * @param [cfg.worldMatrix] Flat float 4x4 matrix
 * @param cfg.worldAABB Flat float AABB World-space AABB
 * @param cfg.pickColor Quantized pick color
 * @returns {number} Portion ID
 */
TrianglesBatchingLayer.prototype.createPortion = function createPortion (cfg) {

    if (this._finalized) {
        throw "Already finalized";
    }

    var positions = cfg.positions;
    var normals = cfg.normals;
    var indices = cfg.indices;
    var edgeIndices = cfg.edgeIndices;
    var color = cfg.color;
    var metallic = cfg.metallic;
    var roughness = cfg.roughness;
    var colors = cfg.colors;
    var opacity = cfg.opacity;
    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.worldAABB;
    var pickColor = cfg.pickColor;

    var scene = this.model.scene;
    var buffer = this._buffer;
    var positionsIndex = buffer.positions.length;
    var vertsIndex = positionsIndex / 3;
    var numVerts = positions.length / 3;
    var lenPositions = positions.length;

    if (this._preCompressed) {

        for (var i = 0, len = positions.length; i < len; i++) {
            buffer.positions.push(positions[i]);
        }

        var bounds = geometryCompressionUtils.getPositionsBounds(positions);

        var min = geometryCompressionUtils.decompressPosition(bounds.min, this._state.positionsDecodeMatrix, []);
        var max = geometryCompressionUtils.decompressPosition(bounds.max, this._state.positionsDecodeMatrix, []);

        worldAABB[0] = min[0];
        worldAABB[1] = min[1];
        worldAABB[2] = min[2];
        worldAABB[3] = max[0];
        worldAABB[4] = max[1];
        worldAABB[5] = max[2];

        if (worldMatrix) {
            math.AABB3ToOBB3(worldAABB, tempOBB3$2);
            math.transformOBB3(worldMatrix, tempOBB3$2);
            math.OBB3ToAABB3(tempOBB3$2, worldAABB);
        }

    } else {

        var positionsBase = buffer.positions.length;

        for (var i$1 = 0, len$1 = positions.length; i$1 < len$1; i$1++) {
            buffer.positions.push(positions[i$1]);
        }

        if (meshMatrix) {

            for (var i$2 = positionsBase, len$2 = positionsBase + lenPositions; i$2 < len$2; i$2 += 3) {

                tempVec4a$7[0] = buffer.positions[i$2 + 0];
                tempVec4a$7[1] = buffer.positions[i$2 + 1];
                tempVec4a$7[2] = buffer.positions[i$2 + 2];

                math.transformPoint4(meshMatrix, tempVec4a$7, tempVec4b$7);

                buffer.positions[i$2 + 0] = tempVec4b$7[0];
                buffer.positions[i$2 + 1] = tempVec4b$7[1];
                buffer.positions[i$2 + 2] = tempVec4b$7[2];

                math.expandAABB3Point3(this._modelAABB, tempVec4b$7);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4b$7, tempVec4c$7);
                    math.expandAABB3Point3(worldAABB, tempVec4c$7);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4b$7);
                }
            }

        } else {

            for (var i$3 = positionsBase, len$3 = positionsBase + lenPositions; i$3 < len$3; i$3 += 3) {

                tempVec4a$7[0] = buffer.positions[i$3 + 0];
                tempVec4a$7[1] = buffer.positions[i$3 + 1];
                tempVec4a$7[2] = buffer.positions[i$3 + 2];

                math.expandAABB3Point3(this._modelAABB, tempVec4a$7);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4a$7, tempVec4b$7);
                    math.expandAABB3Point3(worldAABB, tempVec4b$7);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4a$7);
                }
            }
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    if (normals && normals.length > 0) {

        if (this._preCompressed) {

            for (var i$4 = 0, len$4 = normals.length; i$4 < len$4; i$4++) {
                buffer.normals.push(normals[i$4]);
            }

        } else {

            var worldNormalMatrix = tempMat4$2;

            if (meshMatrix) {
                math.inverseMat4(math.transposeMat4(meshMatrix, tempMat4b), worldNormalMatrix); // Note: order of inverse and transpose doesn't matter

            } else {
                math.identityMat4(worldNormalMatrix, worldNormalMatrix);
            }

            transformAndOctEncodeNormals(worldNormalMatrix, normals, normals.length, buffer.normals, buffer.normals.length);
        }
    }

    if (colors) {

        for (var i$5 = 0, len$5 = colors.length; i$5 < len$5; i$5 += 3) {
            buffer.colors.push(colors[i$5] * 255);
            buffer.colors.push(colors[i$5 + 1] * 255);
            buffer.colors.push(colors[i$5 + 2] * 255);
            buffer.colors.push(255);
        }

    } else if (color) {

        var r = color[0]; // Color is pre-quantized by PerformanceModel
        var g = color[1];
        var b = color[2];
        var a = opacity;

        var metallicValue = (metallic !== null && metallic !== undefined) ? metallic : 0;
        var roughnessValue = (roughness !== null && roughness !== undefined) ? roughness : 255;

        for (var i$6 = 0; i$6 < numVerts; i$6++) {

            buffer.colors.push(r);
            buffer.colors.push(g);
            buffer.colors.push(b);
            buffer.colors.push(a);

            buffer.metallicRoughness.push(metallicValue);
            buffer.metallicRoughness.push(roughnessValue);
        }
    }

    if (indices) {
        for (var i$7 = 0, len$6 = indices.length; i$7 < len$6; i$7++) {
            buffer.indices.push(indices[i$7] + vertsIndex);
        }
    }

    if (edgeIndices) {
        for (var i$8 = 0, len$7 = edgeIndices.length; i$8 < len$7; i$8++) {
            buffer.edgeIndices.push(edgeIndices[i$8] + vertsIndex);
        }
    }

    {
        var pickColorsBase = buffer.pickColors.length;
        var lenPickColors = numVerts * 4;
        for (var i$9 = pickColorsBase, len$8 = pickColorsBase + lenPickColors; i$9 < len$8; i$9 += 4) {
            buffer.pickColors.push(pickColor[0]);
            buffer.pickColors.push(pickColor[1]);
            buffer.pickColors.push(pickColor[2]);
            buffer.pickColors.push(pickColor[3]);
        }
    }

    if (scene.entityOffsetsEnabled) {
        for (var i$10 = 0; i$10 < numVerts; i$10++) {
            buffer.offsets.push(0);
            buffer.offsets.push(0);
            buffer.offsets.push(0);
        }
    }

    var portionId = this._portions.length;

    var portion = {
        vertsBase: vertsIndex,
        numVerts: numVerts
    };

    if (scene.pickSurfacePrecisionEnabled) {
        // Quantized in-memory positions are initialized in finalize()
        if (indices) {
            portion.indices = indices;
        }
        if (scene.entityOffsetsEnabled) {
            portion.offset = new Float32Array(3);
        }
    }

    this._portions.push(portion);

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

/**
 * Builds batch VBOs from appended geometries.
 * No more portions can then be created.
 */
TrianglesBatchingLayer.prototype.finalize = function finalize () {

    if (this._finalized) {
        this.model.error("Already finalized");
        return;
    }

    var state = this._state;
    var gl = this.model.scene.canvas.gl;
    var buffer = this._buffer;

    if (buffer.positions.length > 0) {

        var quantizedPositions = (this._preCompressed)
            ? new Uint16Array(buffer.positions)
            : quantizePositions(buffer.positions, this._modelAABB, state.positionsDecodeMatrix); // BOTTLENECK

        state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, quantizedPositions.length, 3, gl.STATIC_DRAW);

        if (this.model.scene.pickSurfacePrecisionEnabled) {
            for (var i = 0, numPortions = this._portions.length; i < numPortions; i++) {
                var portion = this._portions[i];
                var start = portion.vertsBase * 3;
                var end = start + (portion.numVerts * 3);
                portion.quantizedPositions = quantizedPositions.slice(start, end);
            }
        }
    }

    if (buffer.normals.length > 0) {
        var normals = new Int8Array(buffer.normals);
        var normalized = true; // For oct encoded UInts
        state.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, normals, buffer.normals.length, 3, gl.STATIC_DRAW, normalized);
    }

    if (buffer.colors.length > 0) {
        var colors = new Uint8Array(buffer.colors);
        var normalized$1 = false;
        state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colors, buffer.colors.length, 4, gl.DYNAMIC_DRAW, normalized$1);
    }

    if (buffer.metallicRoughness.length > 0) {
        var metallicRoughness = new Uint8Array(buffer.metallicRoughness);
        var normalized$2 = false;
        state.metallicRoughnessBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, metallicRoughness, buffer.metallicRoughness.length, 2, gl.STATIC_DRAW, normalized$2);
    }

    if (buffer.positions.length > 0) { // Because we build flags arrays here, get their length from the positions array
        var flagsLength = (buffer.positions.length / 3) * 4;
        var flags = new Uint8Array(flagsLength);
        var flags2 = new Uint8Array(flagsLength);
        var notNormalized = false;
        var normalized$3 = true;
        state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags, flags.length, 4, gl.DYNAMIC_DRAW, notNormalized);
        state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags2, flags2.length, 4, gl.DYNAMIC_DRAW, normalized$3);
    }

    if (buffer.pickColors.length > 0) {
        var pickColors = new Uint8Array(buffer.pickColors);
        var normalized$4 = false;
        state.pickColorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, pickColors, buffer.pickColors.length, 4, gl.STATIC_DRAW, normalized$4);
    }

    if (this.model.scene.entityOffsetsEnabled) {
        if (buffer.offsets.length > 0) {
            var offsets = new Float32Array(buffer.offsets);
            state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, offsets, buffer.offsets.length, 3, gl.DYNAMIC_DRAW);
        }
    }

    var bigIndicesSupported = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

    if (buffer.indices.length > 0) {
        var indices = bigIndicesSupported ? new Uint32Array(buffer.indices) : new Uint16Array(buffer.indices);
        state.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, buffer.indices.length, 1, gl.STATIC_DRAW);
    }
    if (buffer.edgeIndices.length > 0) {
        var edgeIndices = bigIndicesSupported ? new Uint32Array(buffer.edgeIndices) : new Uint16Array(buffer.edgeIndices);
        state.edgeIndicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, edgeIndices, buffer.edgeIndices.length, 1, gl.STATIC_DRAW);
    }
    this._buffer = null;
    this._finalized = true;
};

TrianglesBatchingLayer.prototype.isEmpty = function isEmpty () {
    return (!this._state.indicesBuf);
};

TrianglesBatchingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

TrianglesBatchingLayer.prototype.setVisible = function setVisible (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setXRayed = function setXRayed (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setSelected = function setSelected (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setEdges = function setEdges (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    } else {
        this._numEdgesLayerPortions--;
        this.model.numEdgesLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

TrianglesBatchingLayer.prototype.setCulled = function setCulled (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

TrianglesBatchingLayer.prototype.setPickable = function setPickable (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype.setColor = function setColor (portionId, color) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    var portionsIdx = portionId;
    var portion = this._portions[portionsIdx];
    var vertexBase = portion.vertsBase;
    var numVerts = portion.numVerts;
    var firstColor = vertexBase * 4;
    var lenColor = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenColor);
    var r = color[0];
    var g = color[1];
    var b = color[2];
    var a = color[3];
    for (var i = 0; i < lenColor; i += 4) {
        tempArray[i + 0] = r;
        tempArray[i + 1] = g;
        tempArray[i + 2] = b;
        tempArray[i + 3] = a;
    }
    if (this._state.colorsBuf) {
        this._state.colorsBuf.setData(tempArray, firstColor, lenColor);
    }
};

TrianglesBatchingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

TrianglesBatchingLayer.prototype._setFlags = function _setFlags (portionId, flags, transparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var portionsIdx = portionId;
    var portion = this._portions[portionsIdx];
    var vertexBase = portion.vertsBase;
    var numVerts = portion.numVerts;
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var edges = !!(flags & ENTITY_FLAGS.EDGES);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Color

    var f0;
    if (!visible || culled || xrayed) { // Highlight & select are layered on top of color - not mutually exclusive
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (transparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Silhouette

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Edges

    var f2 = 0;
    if (!visible || culled) {
        f2 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f2 = RENDER_PASSES.EDGES_SELECTED;
    } else if (highlighted) {
        f2 = RENDER_PASSES.EDGES_HIGHLIGHTED;
    } else if (xrayed) {
        f2 = RENDER_PASSES.EDGES_XRAYED;
    } else if (edges) {
        if (transparent) {
            f2 = RENDER_PASSES.EDGES_COLOR_TRANSPARENT;
        } else {
            f2 = RENDER_PASSES.EDGES_COLOR_OPAQUE;
        }
    } else {
        f2 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = f0; // x - normal fill
        tempArray[i + 1] = f1; // y - emphasis fill
        tempArray[i + 2] = f2; // z - edges
        tempArray[i + 3] = f3; // w - pick
    }

    if (this._state.flagsBuf) {
        this._state.flagsBuf.setData(tempArray, firstFlag, lenFlags);
    }
};

TrianglesBatchingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var portionsIdx = portionId;
    var portion = this._portions[portionsIdx];
    var vertexBase = portion.vertsBase;
    var numVerts = portion.numVerts;
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);

    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;

    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = clippable;
    }

    if (this._state.flags2Buf) {
        this._state.flags2Buf.setData(tempArray, firstFlag, lenFlags);
    }
};

TrianglesBatchingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    var portionsIdx = portionId;
    var portion = this._portions[portionsIdx];
    var vertexBase = portion.vertsBase;
    var numVerts = portion.numVerts;
    var firstOffset = vertexBase * 3;
    var lenOffsets = numVerts * 3;
    var tempArray = this._scratchMemory.getFloat32Array(lenOffsets);
    var x = offset[0];
    var y = offset[1];
    var z = offset[2];
    for (var i = 0; i < lenOffsets; i += 3) {
        tempArray[i + 0] = x;
        tempArray[i + 1] = y;
        tempArray[i + 2] = z;
    }
    if (this._state.offsetsBuf) {
        this._state.offsetsBuf.setData(tempArray, firstOffset, lenOffsets);
    }
    if (this.model.scene.pickSurfacePrecisionEnabled) {
        portion.offset[0] = offset[0];
        portion.offset[1] = offset[1];
        portion.offset[2] = offset[2];
    }
};

// ---------------------- COLOR RENDERING -----------------------------------

TrianglesBatchingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (frameCtx.withSAO && this.model.saoEnabled) {
        if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
            if (this._batchingRenderers.colorQualityRendererWithSAO) {
                this._batchingRenderers.colorQualityRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
            }
        } else {
            if (this._state.normalsBuf) {
                if (this._batchingRenderers.colorRendererWithSAO) {
                    this._batchingRenderers.colorRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            } else {
                if (this._batchingRenderers.flatColorRendererWithSAO) {
                    this._batchingRenderers.flatColorRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            }
        }
    } else {
        if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
            if (this._batchingRenderers.colorQualityRenderer) {
                this._batchingRenderers.colorQualityRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
            }
        } else {
            if (this._state.normalsBuf) {
                if (this._batchingRenderers.colorRenderer) {
                    this._batchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            } else {
                if (this._batchingRenderers.flatColorRenderer) {
                    this._batchingRenderers.flatColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            }
        }
    }
};

TrianglesBatchingLayer.prototype._updateBackfaceCull = function _updateBackfaceCull (renderFlags, frameCtx) {
    var backfaces = this.model.backfaces || (!this.solid) || renderFlags.sectioned;
    if (frameCtx.backfaces !== backfaces) {
        var gl = frameCtx.gl;
        if (backfaces) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }
        frameCtx.backfaces = backfaces;
    }
};

TrianglesBatchingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
        if (this._batchingRenderers.colorQualityRenderer) {
            this._batchingRenderers.colorQualityRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
        }
    } else {
        if (this._state.normalsBuf) {
            if (this._batchingRenderers.colorRenderer) {
                this._batchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
            }
        } else {
            if (this._batchingRenderers.flatColorRenderer) {
                this._batchingRenderers.flatColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
            }
        }
    }
};

// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------

TrianglesBatchingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.depthRenderer) {
        this._batchingRenderers.depthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE); // Assume whatever post-effect uses depth (eg SAO) does not apply to transparent objects
    }
};

TrianglesBatchingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.normalsRenderer) {
        this._batchingRenderers.normalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);  // Assume whatever post-effect uses normals (eg SAO) does not apply to transparent objects
    }
};

// ---------------------- SILHOUETTE RENDERING -----------------------------------

TrianglesBatchingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

TrianglesBatchingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

TrianglesBatchingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

// ---------------------- EDGES RENDERING -----------------------------------

TrianglesBatchingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numEdgesLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.edgesColorRenderer) {
        this._batchingRenderers.edgesColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_COLOR_OPAQUE);
    }
};

TrianglesBatchingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numEdgesLayerPortions === 0 || this._numTransparentLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.edgesColorRenderer) {
        this._batchingRenderers.edgesColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_COLOR_TRANSPARENT);
    }
};

TrianglesBatchingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.edgesRenderer) {
        this._batchingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_HIGHLIGHTED);
    }
};

TrianglesBatchingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.edgesRenderer) {
        this._batchingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_SELECTED);
    }
};

TrianglesBatchingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.edgesRenderer) {
        this._batchingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_XRAYED);
    }
};

// ---------------------- OCCLUSION CULL RENDERING -----------------------------------

TrianglesBatchingLayer.prototype.drawOcclusion = function drawOcclusion (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.occlusionRenderer) {
        this._batchingRenderers.occlusionRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

// ---------------------- SHADOW BUFFER RENDERING -----------------------------------

TrianglesBatchingLayer.prototype.drawShadow = function drawShadow (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.shadowRenderer) {
        this._batchingRenderers.shadowRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

//---- PICKING ----------------------------------------------------------------------------------------------------

TrianglesBatchingLayer.prototype.drawPickMesh = function drawPickMesh (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.pickMeshRenderer) {
        this._batchingRenderers.pickMeshRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

TrianglesBatchingLayer.prototype.drawPickDepths = function drawPickDepths (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._batchingRenderers.pickDepthRenderer) {
        this._batchingRenderers.pickDepthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

TrianglesBatchingLayer.prototype.drawPickNormals = function drawPickNormals (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._state.normalsBuf) {
        if (this._batchingRenderers.pickNormalsRenderer) {
            this._batchingRenderers.pickNormalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
        }
    } else {
        if (this._batchingRenderers.pickNormalsFlatRenderer) {
            this._batchingRenderers.pickNormalsFlatRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
        }
    }
};

//------------------------------------------------------------------------------------------------

TrianglesBatchingLayer.prototype.precisionRayPickSurface = function precisionRayPickSurface (portionId, worldRayOrigin, worldRayDir, worldSurfacePos) {

    if (!this.model.scene.pickSurfacePrecisionEnabled) {
        return false;
    }

    var state = this._state;
    var portion = this._portions[portionId];

    if (!portion) {
        this.model.error("portion not found: " + portionId);
        return false;
    }

    var positions = portion.quantizedPositions;
    var indices = portion.indices;
    var rtcCenter = state.rtcCenter;
    var offset = portion.offset;

    var rtcRayOrigin = tempVec3a$E;
    var rtcRayDir = tempVec3b$7;

    rtcRayOrigin.set(rtcCenter ? math.subVec3(worldRayOrigin, rtcCenter, tempVec3c$4) : worldRayOrigin);  // World -> RTC
    rtcRayDir.set(worldRayDir);

    if (offset) {
        math.subVec3(rtcRayOrigin, offset);
    }

    math.transformRay(this.model.worldNormalMatrix, rtcRayOrigin, rtcRayDir, rtcRayOrigin, rtcRayDir); // RTC -> local

    var a = tempVec3d$2;
    var b = tempVec3e$1;
    var c = tempVec3f$1;

    var gotIntersect = false;
    var closestDist = 0;
    var closestIntersectPos = tempVec3g$1;

    for (var i = 0, len = indices.length; i < len; i += 3) {

        var ia = indices[i] * 3;
        var ib = indices[i + 1] * 3;
        var ic = indices[i + 2] * 3;

        a[0] = positions[ia];
        a[1] = positions[ia + 1];
        a[2] = positions[ia + 2];

        b[0] = positions[ib];
        b[1] = positions[ib + 1];
        b[2] = positions[ib + 2];

        c[0] = positions[ic];
        c[1] = positions[ic + 1];
        c[2] = positions[ic + 2];

        math.decompressPosition(a, state.positionsDecodeMatrix);
        math.decompressPosition(b, state.positionsDecodeMatrix);
        math.decompressPosition(c, state.positionsDecodeMatrix);

        if (math.rayTriangleIntersect(rtcRayOrigin, rtcRayDir, a, b, c, closestIntersectPos)) {

            math.transformPoint3(this.model.worldMatrix, closestIntersectPos, closestIntersectPos);

            if (offset) {
                math.addVec3(closestIntersectPos, offset);
            }

            if (rtcCenter) {
                math.addVec3(closestIntersectPos, rtcCenter);
            }

            var dist = Math.abs(math.lenVec3(math.subVec3(closestIntersectPos, worldRayOrigin, [])));

            if (!gotIntersect || dist > closestDist) {
                closestDist = dist;
                worldSurfacePos.set(closestIntersectPos);
                gotIntersect = true;
            }
        }
    }

    return gotIntersect;
};

// ---------

TrianglesBatchingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.normalsBuf) {
        state.normalsBuf.destroy();
        state.normalsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.metallicRoughnessBuf) {
        state.metallicRoughnessBuf.destroy();
        state.metallicRoughnessBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.pickColorsBuf) {
        state.pickColorsBuf.destroy();
        state.pickColorsBuf = null;
    }
    if (state.indicesBuf) {
        state.indicesBuf.destroy();
        state.indicessBuf = null;
    }
    if (state.edgeIndicesBuf) {
        state.edgeIndicesBuf.destroy();
        state.edgeIndicessBuf = null;
    }
    state.destroy();
};

var tempVec4$2 = math.vec4();
var tempVec3a$D = math.vec3();

/**
 * @private
 */
var TrianglesInstancingColorRenderer = function TrianglesInstancingColorRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingColorRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesInstancingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$D);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aModelNormalMatrixCol0.bindArrayBuffer(state.modelNormalMatrixCol0Buf);
    this._aModelNormalMatrixCol1.bindArrayBuffer(state.modelNormalMatrixCol1Buf);
    this._aModelNormalMatrixCol2.bindArrayBuffer(state.modelNormalMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aNormal.bindArrayBuffer(state.normalsBuf);

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");

    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aOffset = program.getAttribute("offset");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._aModelNormalMatrixCol0 = program.getAttribute("modelNormalMatrixCol0");
    this._aModelNormalMatrixCol1 = program.getAttribute("modelNormalMatrixCol1");
    this._aModelNormalMatrixCol2 = program.getAttribute("modelNormalMatrixCol2");

    this._uOcclusionTexture = "uOcclusionTexture";
    this._uSAOParams = program.getLocation("uSAOParams");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingColorRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;
    var lights = lightsState.lights;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];
        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4$2[0] = viewportWidth;
            tempVec4$2[1] = viewportHeight;
            tempVec4$2[2] = sao.blendCutoff;
            tempVec4$2[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4$2);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, 0);
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var i;
    var len;
    var light;
    var src = [];

    src.push("// Instancing geometry drawing vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec2 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("attribute vec4 modelNormalMatrixCol0;");
    src.push("attribute vec4 modelNormalMatrixCol1;");
    src.push("attribute vec4 modelNormalMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 lightAmbient;");

    for (i = 0, len = lightsState.lights.length; i < len; i++) {
        light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i + ";");
            src.push("uniform vec3 lightDir" + i + ";");
        }
    }

    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");
    src.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 0.0);");
    src.push("vec3 viewNormal = normalize(vec4(viewNormalMatrix * worldNormal).xyz);");

    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");

    src.push("float lambertian = 1.0;");
    for (i = 0, len = lightsState.lights.length; i < len; i++) {
        light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        if (light.type === "dir") {
            if (light.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i + ", 0.0)).xyz);");
            }
        } else if (light.type === "point") {
            if (light.space === "view") {
                src.push("viewLightDir = -normalize(lightPos" + i + " - viewPosition.xyz);");
            } else {
                src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + i + ", 0.0)).xyz);");
            }
        } else if (light.type === "spot") {
            if (light.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }
        src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
        src.push("reflectedColor += lambertian * (lightColor" + i + ".rgb * lightColor" + i + ".a);");
    }

    src.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));");
    src.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }

    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBToFloat( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$2 = 0, len$2 = sectionPlanesState.sectionPlanes.length; i$2 < len$2; i$2++) {
            src.push("if (sectionPlaneActive" + i$2 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$2 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$2 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { ");
        src.push("      discard;");
        src.push("  }");
        src.push("}");
    }

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
    // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject

    if (this._withSAO) {
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   gl_FragColor            = vec4(vColor.rgb * ambient, 1.0);");
    } else {
        src.push("    gl_FragColor           = vColor;");
    }
    src.push("}");
    return src;
};

TrianglesInstancingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec4$1 = math.vec4();
var tempVec3a$C = math.vec3();

/**
 * @private
 */
var TrianglesInstancingFlatColorRenderer = function TrianglesInstancingFlatColorRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingFlatColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingFlatColorRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesInstancingFlatColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
            gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
            if (active) {
                var sectionPlane = sectionPlanes[sectionPlaneIndex];
                if (rtcCenter) {
                    var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$C);
                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                } else {
                    gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                }
                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
        
    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingFlatColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

    this._uWorldMatrix = program.getLocation("worldMatrix");
        
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aOffset = program.getAttribute("offset");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");
        
    this._uOcclusionTexture = "uOcclusionTexture";
    this._uSAOParams = program.getLocation("uSAOParams");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingFlatColorRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;
    var lights = lightsState.lights;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];
        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4$1[0] = viewportWidth;
            tempVec4$1[1] = viewportHeight;
            tempVec4$1[2] = sao.blendCutoff;
            tempVec4$1[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4$1);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, 0);
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingFlatColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingFlatColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Instancing geometry flat-shading drawing vertex shader");
    src.push("#extension GL_OES_standard_derivatives : enable");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
        
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
        
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("vViewPosition = viewPosition;");
    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }

    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingFlatColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry flat-shading drawing fragment shader");
    src.push("#extension GL_OES_standard_derivatives : enable");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBToFloat( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }

    src.push("uniform mat4 viewMatrix;");

    src.push("uniform vec4 lightAmbient;");

    for (i = 0, len = lightsState.lights.length; i < len; i++) {
        var light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i + ";");
            src.push("uniform vec3 lightDir" + i + ";");
        }
    }

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec4 vColor;");
        
    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$2 = 0, len$2 = sectionPlanesState.sectionPlanes.length; i$2 < len$2; i$2++) {
            src.push("if (sectionPlaneActive" + i$2 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$2 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$2 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { ");
        src.push("      discard;");
        src.push("  }");
        src.push("}");
    }

    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");

    src.push("float lambertian = 1.0;");

    src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");
    src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");
    src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");

    for (i = 0, len = lightsState.lights.length; i < len; i++) {
        var light$1 = lightsState.lights[i];
        if (light$1.type === "ambient") {
            continue;
        }
        if (light$1.type === "dir") {
            if (light$1.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "point") {
            if (light$1.space === "view") {
                src.push("viewLightDir = -normalize(lightPos" + i + " - viewPosition.xyz);");
            } else {
                src.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + i + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "spot") {
            if (light$1.space === "view") {
                src.push("viewLightDir = normalize(lightDir" + i + ");");
            } else {
                src.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + i + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }
        src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
        src.push("reflectedColor += lambertian * (lightColor" + i + ".rgb * lightColor" + i + ".a);");
    }

    src.push("vec4 fragColor = vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");

    if (this._withSAO) {
        // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
        // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   gl_FragColor            = vec4(fragColor.rgb * ambient, 1.0);");
    } else {
        src.push("    gl_FragColor           = fragColor;");
    }

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");
    return src;
};

TrianglesInstancingFlatColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingFlatColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$B = math.vec3();

/**
 * @private
 */
var TrianglesInstancingSilhouetteRenderer = function TrianglesInstancingSilhouetteRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer.model.scene);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, math.vec3([1, 1, 1]));
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$B);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf, gl.UNSIGNED_BYTE, true);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0); // TODO: Is this needed
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Instancing fill vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 color;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing fill fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

TrianglesInstancingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$A = math.vec3();
var defaultColor$2 = new Float32Array([0,0,0,1]);

/**
 * @private
 */
var TrianglesInstancingEdgesRenderer = function TrianglesInstancingEdgesRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingEdgesRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingEdgesRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingEdgesRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.EDGES_XRAYED) {
        var material = scene.xrayMaterial._state;
        var edgeColor = material.edgeColor;
        var edgeAlpha = material.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor[0], edgeColor[1], edgeColor[2], edgeAlpha);

    } else if (renderPass === RENDER_PASSES.EDGES_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var edgeColor$1 = material$1.edgeColor;
        var edgeAlpha$1 = material$1.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor$1[0], edgeColor$1[1], edgeColor$1[2], edgeAlpha$1);

    } else if (renderPass === RENDER_PASSES.EDGES_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var edgeColor$2 = material$2.edgeColor;
        var edgeAlpha$2 = material$2.edgeAlpha;
        gl.uniform4f(this._uColor, edgeColor$2[0], edgeColor$2[1], edgeColor$2[2], edgeAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, defaultColor$2);
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$A);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.edgeIndicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.LINES, state.edgeIndicesBuf.numItems, state.edgeIndicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0); // TODO: Is this needed
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }

    if (this._aFlags) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    }

    if (this._aFlags2) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
};

TrianglesInstancingEdgesRenderer.prototype._allocate = function _allocate () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uColor = program.getLocation("color");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingEdgesRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingEdgesRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingEdgesRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles instancing edges vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("uniform vec4 color;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
    // renderPass = EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED

    src.push("if (int(flags.z) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("vColor = vec4(color.r, color.g, color.b, color.a);");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingEdgesRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry edges drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vColor;");
    src.push("}");
    return src;
};

TrianglesInstancingEdgesRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingEdgesRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$z = math.vec3();

/**
 * @private
 */
var TrianglesInstancingEdgesColorRenderer = function TrianglesInstancingEdgesColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingEdgesColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingEdgesColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingEdgesColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$z);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.edgeIndicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.LINES, state.edgeIndicesBuf.numItems, state.edgeIndicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0); // TODO: Is this needed
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }

    if (this._aFlags) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    }

    if (this._aFlags2) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
};

TrianglesInstancingEdgesColorRenderer.prototype._allocate = function _allocate () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingEdgesColorRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingEdgesColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingEdgesColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Triangles instancing edges vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.z = NOT_RENDERED | EDGES_COLOR_OPAQUE | EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED
    // renderPass = EDGES_HIGHLIGHTED | EDGES_XRAYED | EDGES_SELECTED

    src.push("if (int(flags.z) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
 //   src.push("vColor = vec4(float(color.r-100.0) / 255.0, float(color.g-100.0) / 255.0, float(color.b-100.0) / 255.0, float(color.a) / 255.0);");
    src.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingEdgesColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry edges drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vColor;");
    src.push("}");
    return src;
};

TrianglesInstancingEdgesColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingEdgesColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$y = math.vec3();

/**
 * @private
 */
var TrianglesInstancingPickMeshRenderer = function TrianglesInstancingPickMeshRenderer(scene) {

    this._scene = scene;
    this._hash = this._getHash();

    this._allocate();
};

TrianglesInstancingPickMeshRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingPickMeshRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingPickMeshRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPickColor.bindArrayBuffer(state.pickColorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aPickColor.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$y);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aPickColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingPickMeshRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;

    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._uRenderPass = program.getLocation("renderPass");
    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aPickColor = program.getAttribute("pickColor");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingPickMeshRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;

    program.bind();

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);
};

TrianglesInstancingPickMeshRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingPickMeshRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Instancing geometry picking vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 pickColor;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");


    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingPickMeshRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry picking fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vPickColor; ");
    src.push("}");
    return src;
};

TrianglesInstancingPickMeshRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingPickMeshRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$x = math.vec3();

/**
 * @private
 */
var TrianglesInstancingPickDepthRenderer = function TrianglesInstancingPickDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingPickDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingPickDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingPickDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    var camera = scene.camera;

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniform1f(this._uPickZNear, frameCtx.pickZNear);
    gl.uniform1f(this._uPickZFar, frameCtx.pickZFar);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(frameCtx.pickZFar + 1.0) / Math.LN2); // TODO: Far from pick project matrix
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$x);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingPickDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPickZNear = program.getLocation("pickZNear");
    this._uPickZFar = program.getLocation("pickZFar");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingPickDepthRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();

};

TrianglesInstancingPickDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingPickDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Instancing geometry depth vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vViewPosition;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");

    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }
    src.push("  vViewPosition = viewPosition;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingPickDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry depth fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    src.push("uniform float pickZNear;");
    src.push("uniform float pickZFar;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vViewPosition;");
    src.push("vec4 packDepth(const in float depth) {");
    src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");
    src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");
    src.push("  vec4 res = fract(depth * bitShift);");
    src.push("  res -= res.xxyz * bitMask;");
    src.push("  return res;");
    src.push("}");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");
    src.push("    gl_FragColor = packDepth(zNormalizedDepth); "); // Must be linear depth
    src.push("}");
    return src;
};

TrianglesInstancingPickDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingPickDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$w = math.vec3();

/**
 * @private
 */
var TrianglesInstancingPickNormalsRenderer = function TrianglesInstancingPickNormalsRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingPickNormalsRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingPickNormalsRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingPickNormalsRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    // In practice, these binds will only happen once per frame
    // because we pick normals on a single previously-picked mesh

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$w);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aModelNormalMatrixCol0.bindArrayBuffer(state.modelNormalMatrixCol0Buf);
    this._aModelNormalMatrixCol1.bindArrayBuffer(state.modelNormalMatrixCol1Buf);
    this._aModelNormalMatrixCol2.bindArrayBuffer(state.modelNormalMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aNormal.bindArrayBuffer(state.normalsBuf);
    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingPickNormalsRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];
    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._aModelNormalMatrixCol0 = program.getAttribute("modelNormalMatrixCol0");
    this._aModelNormalMatrixCol1 = program.getAttribute("modelNormalMatrixCol1");
    this._aModelNormalMatrixCol2 = program.getAttribute("modelNormalMatrixCol2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingPickNormalsRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

TrianglesInstancingPickNormalsRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingPickNormalsRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry normals vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec2 normal;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("attribute vec4 modelNormalMatrixCol0;");
    src.push("attribute vec4 modelNormalMatrixCol1;");
    src.push("attribute vec4 modelNormalMatrixCol2;");
    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec3 vWorldNormal;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("  vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");
    src.push("  vec3 worldNormal = vec3(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2));");
    src.push("  vWorldNormal = worldNormal;");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingPickNormalsRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry normals fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec3 vWorldNormal;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4((vWorldNormal * 0.5) + 0.5, 1.0);");
    src.push("}");
    return src;
};

TrianglesInstancingPickNormalsRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingPickNormalsRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$v = math.vec3();

/**
 * @private
 */
var TrianglesInstancingOcclusionRenderer = function TrianglesInstancingOcclusionRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingOcclusionRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingOcclusionRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingOcclusionRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$v);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);
    }

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    if (this._aColor) {
        instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    }
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingOcclusionRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingOcclusionRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingOcclusionRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingOcclusionRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing occlusion vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingOcclusionRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing occlusion fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); "); // Occluders are blue
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

TrianglesInstancingOcclusionRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingOcclusionRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$u = math.vec3();

/**
 * @private
 */
var TrianglesInstancingDepthRenderer = function TrianglesInstancingDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$u);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingDepthRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry depth drawing vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;");
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec2 vHighPrecisionZW;");
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("vHighPrecisionZW = gl_Position.zw;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry depth drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("precision highp float;");
    src.push("precision highp int;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    if (!WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {

        src.push("const float   packUpScale = 256. / 255.;");
        src.push("const float   unpackDownscale = 255. / 256.;");
        src.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );");
        src.push("const float   shiftRight8 = 1.0 / 256.;");

        src.push("vec4 packDepthToRGBA( const in float v ) {");
        src.push("    vec4 r = vec4( fract( v * packFactors ), v );");
        src.push("    r.yzw -= r.xyz * shiftRight8;");
        src.push("    return r * packUpScale;");
        src.push("}");
    }
    src.push("varying vec2 vHighPrecisionZW;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");
    if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
        src.push("    gl_FragColor = vec4(vec3(1.0 - fragCoordZ), 1.0); ");
    } else {
        src.push("    gl_FragColor = packDepthToRGBA(fragCoordZ); "); // Must be linear depth
    }
    src.push("}");
    return src;
};

TrianglesInstancingDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$t = math.vec3();

/**
 * @private
 */
var TrianglesInstancingNormalsRenderer = function TrianglesInstancingNormalsRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingNormalsRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingNormalsRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingNormalsRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$t);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aNormal.bindArrayBuffer(state.normalsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingNormalsRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");

    if (this._aFlags2) {
        this._aFlags2 = program.getAttribute("flags2");
    }

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingNormalsRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

TrianglesInstancingNormalsRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingNormalsRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry normals drawing vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec3 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;");
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec3 vViewNormal;");
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");
    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("  vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); ");
    src.push("  vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("  vViewNormal = viewNormal;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingNormalsRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry depth drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec3 vViewNormal;");
    src.push("vec3 packNormalToRGB( const in vec3 normal ) {");
    src.push("    return normalize( normal ) * 0.5 + 0.5;");
    src.push("}");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");
    src.push("}");
    return src;
};

TrianglesInstancingNormalsRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingNormalsRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$s = math.vec3();

/**
 * Renders InstancingLayer fragment depths to a shadow map.
 *
 * @private
 */
var TrianglesInstancingShadowRenderer = function TrianglesInstancingShadowRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._lastLightId = null;
    this._allocate();
};

TrianglesInstancingShadowRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingShadowRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingShadowRenderer.prototype.drawLayer = function drawLayer ( frameCtx, instancingLayer) {
    var model = instancingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx, instancingLayer);
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    // TODO: Section planes need to be set if RTC center has changed since last RTC center recorded on frameCtx

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        var rtcCenter = instancingLayer._state.rtcCenter;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$s);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingShadowRenderer.prototype._allocate = function _allocate () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    this._program = new Program(gl, this._buildShader());
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uShadowViewMatrix = program.getLocation("shadowViewMatrix");
    this._uShadowProjMatrix = program.getLocation("shadowProjMatrix");
    this._uSectionPlanes = [];
    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");
};

TrianglesInstancingShadowRenderer.prototype._bindProgram = function _bindProgram (frameCtx, instancingLayer) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    program.bind();
    gl.uniformMatrix4fv(this._uShadowViewMatrix, false, frameCtx.shadowViewMatrix);
    gl.uniformMatrix4fv(this._uShadowProjMatrix, false, frameCtx.shadowProjMatrix);
    this._lastLightId = null;
};

TrianglesInstancingShadowRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingShadowRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry shadow drawing vertex shader");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;");
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 shadowViewMatrix;");
    src.push("uniform mat4 shadowProjMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");
    src.push("bool visible      = (float(flags.x) > 0.0);");
    src.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);");
    src.push("if (!visible || transparent) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("  gl_Position = shadowProjMatrix * viewPosition;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingShadowRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry depth drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec3 vViewNormal;");
    src.push("vec3 packNormalToRGB( const in vec3 normal ) {");
    src.push("    return normalize( normal ) * 0.5 + 0.5;");
    src.push("}");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");
    src.push("}");
    return src;
};

TrianglesInstancingShadowRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingShadowRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec4 = math.vec4();
var tempVec3a$r = math.vec3();

var TEXTURE_DECODE_FUNCS = {
    "linear": "linearToLinear",
    "sRGB": "sRGBToLinear",
    "gamma": "gammaToLinear"
};

/**
 * @private
 */
var TrianglesInstancingColorQualityRenderer = function TrianglesInstancingColorQualityRenderer(scene, withSAO) {
    this._scene = scene;
    this._withSAO = withSAO;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingColorQualityRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingColorQualityRenderer.prototype._getHash = function _getHash () {
    var scene = this._scene;
    return [scene.gammaOutput, scene._lightsState.getHash(), scene._sectionPlanesState.getHash(), (this._withSAO ? "sao" : "nosao")].join(";");
};

TrianglesInstancingColorQualityRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = this._scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uWorldNormalMatrix, false, model.worldNormalMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$r);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aModelNormalMatrixCol0.bindArrayBuffer(state.modelNormalMatrixCol0Buf);
    this._aModelNormalMatrixCol1.bindArrayBuffer(state.modelNormalMatrixCol1Buf);
    this._aModelNormalMatrixCol2.bindArrayBuffer(state.modelNormalMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aNormal.bindArrayBuffer(state.normalsBuf);

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aMetallicRoughness.bindArrayBuffer(state.metallicRoughnessBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aMetallicRoughness.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelNormalMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aMetallicRoughness.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingColorQualityRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uWorldNormalMatrix = program.getLocation("worldNormalMatrix");

    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uGammaFactor = program.getLocation("gammaFactor");

    this._uLightAmbient = program.getLocation("lightAmbient");
    this._uLightColor = [];
    this._uLightDir = [];
    this._uLightPos = [];
    this._uLightAttenuation = [];

    var lights = lightsState.lights;
    var light;

    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        switch (light.type) {
            case "dir":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = null;
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                break;
            case "point":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = null;
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
            case "spot":
                this._uLightColor[i] = program.getLocation("lightColor" + i);
                this._uLightPos[i] = program.getLocation("lightPos" + i);
                this._uLightDir[i] = program.getLocation("lightDir" + i);
                this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                break;
        }
    }

    if (lightsState.reflectionMaps.length > 0) {
        this._uReflectionMap = "reflectionMap";
    }

    if (lightsState.lightMaps.length > 0) {
        this._uLightMap = "lightMap";
    }

    this._uSectionPlanes = [];

    for (var i$1 = 0, len$1 = scene._sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i$1),
            pos: program.getLocation("sectionPlanePos" + i$1),
            dir: program.getLocation("sectionPlaneDir" + i$1)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aNormal = program.getAttribute("normal");
    this._aColor = program.getAttribute("color");
    this._aMetallicRoughness = program.getAttribute("metallicRoughness");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aOffset = program.getAttribute("offset");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._aModelNormalMatrixCol0 = program.getAttribute("modelNormalMatrixCol0");
    this._aModelNormalMatrixCol1 = program.getAttribute("modelNormalMatrixCol1");
    this._aModelNormalMatrixCol2 = program.getAttribute("modelNormalMatrixCol2");

    this._uOcclusionTexture = "uOcclusionTexture";
    this._uSAOParams = program.getLocation("uSAOParams");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingColorQualityRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var maxTextureUnits = WEBGL_INFO$1.MAX_TEXTURE_UNITS;
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var lightsState = scene._lightsState;
    var lights = lightsState.lights;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (this._uLightAmbient) {
        gl.uniform4fv(this._uLightAmbient, scene._lightsState.getAmbientColorAndIntensity());
    }

    for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];
        if (this._uLightColor[i]) {
            gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
        }
        if (this._uLightPos[i]) {
            gl.uniform3fv(this._uLightPos[i], light.pos);
            if (this._uLightAttenuation[i]) {
                gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
            }
        }
        if (this._uLightDir[i]) {
            gl.uniform3fv(this._uLightDir[i], light.dir);
        }
    }

    if (lightsState.reflectionMaps.length > 0 && lightsState.reflectionMaps[0].texture && this._uReflectionMap) {
        this._program.bindTexture(this._uReflectionMap, lightsState.reflectionMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (lightsState.lightMaps.length > 0 && lightsState.lightMaps[0].texture && this._uLightMap) {
        this._program.bindTexture(this._uLightMap, lightsState.lightMaps[0].texture, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
        frameCtx.bindTexture++;
    }

    if (this._withSAO) {
        var sao = scene.sao;
        var saoEnabled = sao.possible;
        if (saoEnabled) {
            var viewportWidth = gl.drawingBufferWidth;
            var viewportHeight = gl.drawingBufferHeight;
            tempVec4[0] = viewportWidth;
            tempVec4[1] = viewportHeight;
            tempVec4[2] = sao.blendCutoff;
            tempVec4[3] = sao.blendFactor;
            gl.uniform4fv(this._uSAOParams, tempVec4);
            this._program.bindTexture(this._uOcclusionTexture, frameCtx.occlusionTexture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;
            frameCtx.bindTexture++;
        }
    }

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    if (this._uGammaFactor) {
        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
    }
};

TrianglesInstancingColorQualityRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingColorQualityRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var clippingCaps = sectionPlanesState.clippingCaps;
    var src = [];

    src.push("// Instancing geometry quality drawing vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec2 normal;");
    src.push("attribute vec4 color;");
    src.push("attribute vec2 metallicRoughness;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("attribute vec4 modelNormalMatrixCol0;");
    src.push("attribute vec4 modelNormalMatrixCol1;");
    src.push("attribute vec4 modelNormalMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 worldNormalMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 viewNormalMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("vec3 octDecode(vec2 oct) {");
    src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
    src.push("    if (v.z < 0.0) {");
    src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
    src.push("    }");
    src.push("    return normalize(v);");
    src.push("}");

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec3 vViewNormal;");
    src.push("varying vec4 vColor;");
    src.push("varying vec2 vMetallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("varying vec3 vWorldNormal;");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        if (clippingCaps) {
            src.push("varying vec4 vClipPosition;");
        }
    }

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); ");
    src.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 0.0);");
    src.push("vec3 viewNormal = vec4(viewNormalMatrix * worldNormal).xyz;");

    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
        if (clippingCaps) {
            src.push("vClipPosition = clipPos;");
        }
    }

    src.push("vViewPosition = viewPosition;");
    src.push("vViewNormal = viewNormal;");
    src.push("vColor = color;");
    src.push("vMetallicRoughness = metallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("vWorldNormal = worldNormal.xyz;");
    }

    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingColorQualityRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {

    var scene = this._scene;
    var gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
    var sectionPlanesState = scene._sectionPlanesState;
    var lightsState = scene._lightsState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var clippingCaps = sectionPlanesState.clippingCaps;
    var src = [];

    src.push("// Instancing geometry quality drawing fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }

    if (this._withSAO) {
        src.push("uniform sampler2D uOcclusionTexture;");
        src.push("uniform vec4      uSAOParams;");

        src.push("const float       packUpscale = 256. / 255.;");
        src.push("const float       unpackDownScale = 255. / 256.;");
        src.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
        src.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );");

        src.push("float unpackRGBAToDepth( const in vec4 v ) {");
        src.push("    return dot( v, unPackFactors );");
        src.push("}");
    }

    if (lightsState.reflectionMaps.length > 0) {
        src.push("uniform samplerCube reflectionMap;");
    }

    if (lightsState.lightMaps.length > 0) {
        src.push("uniform samplerCube lightMap;");
    }

    src.push("uniform vec4 lightAmbient;");

    for (var i = 0, len = lightsState.lights.length; i < len; i++) {
        var light = lightsState.lights[i];
        if (light.type === "ambient") {
            continue;
        }
        src.push("uniform vec4 lightColor" + i + ";");
        if (light.type === "dir") {
            src.push("uniform vec3 lightDir" + i + ";");
        }
        if (light.type === "point") {
            src.push("uniform vec3 lightPos" + i + ";");
        }
        if (light.type === "spot") {
            src.push("uniform vec3 lightPos" + i + ";");
            src.push("uniform vec3 lightDir" + i + ";");
        }
    }

    src.push("uniform float gammaFactor;");
    src.push("vec4 linearToLinear( in vec4 value ) {");
    src.push("  return value;");
    src.push("}");
    src.push("vec4 sRGBToLinear( in vec4 value ) {");
    src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");
    src.push("}");
    src.push("vec4 gammaToLinear( in vec4 value) {");
    src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");
    src.push("}");
    if (gammaOutput) {
        src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
        src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
        src.push("}");
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        if (clippingCaps) {
            src.push("varying vec4 vClipPosition;");
        }
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }

    src.push("varying vec4 vViewPosition;");
    src.push("varying vec3 vViewNormal;");
    src.push("varying vec4 vColor;");
    src.push("varying vec2 vMetallicRoughness;");

    if (lightsState.lightMaps.length > 0) {
        src.push("varying vec3 vWorldNormal;");
    }

    src.push("uniform mat4 viewMatrix;");

    // CONSTANT DEFINITIONS

    src.push("#define PI 3.14159265359");
    src.push("#define RECIPROCAL_PI 0.31830988618");
    src.push("#define RECIPROCAL_PI2 0.15915494");
    src.push("#define EPSILON 1e-6");

    src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");

    // UTILITY DEFINITIONS

    src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");
    src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");
    src.push("}");

    // STRUCTURES

    src.push("struct IncidentLight {");
    src.push("   vec3 color;");
    src.push("   vec3 direction;");
    src.push("};");

    src.push("struct ReflectedLight {");
    src.push("   vec3 diffuse;");
    src.push("   vec3 specular;");
    src.push("};");

    src.push("struct Geometry {");
    src.push("   vec3 position;");
    src.push("   vec3 viewNormal;");
    src.push("   vec3 worldNormal;");
    src.push("   vec3 viewEyeDir;");
    src.push("};");

    src.push("struct Material {");
    src.push("   vec3    diffuseColor;");
    src.push("   float   specularRoughness;");
    src.push("   vec3    specularColor;");
    src.push("   float   shine;"); // Only used for Phong
    src.push("};");

    // IRRADIANCE EVALUATION

    src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");
    src.push("   float r = ggxRoughness + 0.0001;");
    src.push("   return (2.0 / (r * r) - 2.0);");
    src.push("}");

    src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");
    src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");
    src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");
    src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");
    src.push("}");

    if (lightsState.reflectionMaps.length > 0) {
        src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");
        src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"); //TODO: a random factor - fix this
        src.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS[lightsState.reflectionMaps[0].encoding] + "(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;");
        src.push("  return envMapColor;");
        src.push("}");
    }

    // SPECULAR BRDF EVALUATION

    src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");
    src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");
    src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");
    src.push("}");

    src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
    src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
    src.push("   return 1.0 / ( gl * gv );");
    src.push("}");

    src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
    src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
    src.push("   return 0.5 / max( gv + gl, EPSILON );");
    src.push("}");

    src.push("float D_GGX(const in float alpha, const in float dotNH) {");
    src.push("   float a2 = ( alpha * alpha );");
    src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");
    src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");
    src.push("}");

    src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
    src.push("   float alpha = ( roughness * roughness );");
    src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");
    src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");
    src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");
    src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");
    src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");
    src.push("   vec3  F = F_Schlick( specularColor, dotLH );");
    src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");
    src.push("   float D = D_GGX( alpha, dotNH );");
    src.push("   return F * (G * D);");
    src.push("}");

    src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
    src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");
    src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");
    src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");
    src.push("   vec4 r = roughness * c0 + c1;");
    src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");
    src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");
    src.push("   return specularColor * AB.x + AB.y;");
    src.push("}");

    if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {

        src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");

        if (lightsState.lightMaps.length > 0) {
            src.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS[lightsState.lightMaps[0].encoding] + "(textureCube(lightMap, geometry.worldNormal)).rgb;");
            src.push("   irradiance *= PI;");
            src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
            src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");
        }

        if (lightsState.reflectionMaps.length > 0) {
            src.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);");
            src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
            src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");
            src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");
            src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");
            src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");
        }

        src.push("}");
    }

    // MAIN LIGHTING COMPUTATION FUNCTION

    src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
    src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");
    src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");
    src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
    src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");
    src.push("}");

    src.push("void main(void) {");

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$2 = 0, len$2 = sectionPlanesState.sectionPlanes.length; i$2 < len$2; i$2++) {
            src.push("if (sectionPlaneActive" + i$2 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$2 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$2 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        if (clippingCaps) {
            src.push("  if (dist > (0.002 * vClipPosition.w)) {");
            src.push("      discard;");
            src.push("  }");
            src.push("  if (dist > 0.0) { ");
            src.push("      gl_FragColor=vec4(1.0, 0.0, 0.0, 1.0);");
            if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
                src.push("  gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
            }
            src.push("  return;");
            src.push("}");
        } else {
            src.push("  if (dist > 0.0) { ");
            src.push("      discard;");
            src.push("  }");
        }
        src.push("}");
    }

    src.push("IncidentLight  light;");
    src.push("Material       material;");
    src.push("Geometry       geometry;");
    src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");

    src.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));");
    src.push("float alpha = float(vColor.a) / 255.0;");

    src.push("vec3  diffuseColor = rgb;");
    src.push("float specularF0 = 1.0;");
    src.push("float metallic = float(vMetallicRoughness.r) / 255.0;");
    src.push("float roughness = float(vMetallicRoughness.g) / 255.0;");
    src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");

    src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");
    src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");
    src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);");

    src.push("geometry.position      = vViewPosition.xyz;");
    src.push("geometry.viewNormal    = -normalize(vViewNormal);");
    src.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);");
    if (lightsState.lightMaps.length > 0) {
        src.push("geometry.worldNormal   = normalize(vWorldNormal);");
    }

    if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {
        src.push("computePBRLightMapping(geometry, material, reflectedLight);");
    }

    for (var i$3 = 0, len$3 = lightsState.lights.length; i$3 < len$3; i$3++) {

        var light$1 = lightsState.lights[i$3];

        if (light$1.type === "ambient") {
            continue;
        }
        if (light$1.type === "dir") {
            if (light$1.space === "view") {
                src.push("light.direction = normalize(lightDir" + i$3 + ");");
            } else {
                src.push("light.direction = normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "point") {
            if (light$1.space === "view") {
                src.push("light.direction = normalize(lightPos" + i$3 + " - vViewPosition.xyz);");
            } else {
                src.push("light.direction = normalize((viewMatrix * vec4(lightPos" + i$3 + ", 0.0)).xyz);");
            }
        } else if (light$1.type === "spot") {
            if (light$1.space === "view") {
                src.push("light.direction = normalize(lightDir" + i$3 + ");");
            } else {
                src.push("light.direction = normalize((viewMatrix * vec4(lightDir" + i$3 + ", 0.0)).xyz);");
            }
        } else {
            continue;
        }

        src.push("light.color =  lightColor" + i$3 + ".rgb * lightColor" + i$3 + ".a;"); // a is intensity

        src.push("computePBRLighting(light, geometry, material, reflectedLight);");
    }

    src.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular);");

    src.push("vec4 fragColor;");

    if (this._withSAO) {
        // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
        // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBAToDepth(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   fragColor            = vec4(outgoingLight.rgb * ambient, alpha);");
    } else {
        src.push("   fragColor            = vec4(outgoingLight.rgb, alpha);");
    }

    if (gammaOutput) {
        src.push("fragColor = linearToGamma(fragColor, gammaFactor);");
    }

    src.push("gl_FragColor = fragColor;");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }

    src.push("}");
    return src;
};

TrianglesInstancingColorQualityRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingColorQualityRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$q = math.vec3();

/**
 * @private
 */
var TrianglesInstancingPickNormalsFlatRenderer = function TrianglesInstancingPickNormalsFlatRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

TrianglesInstancingPickNormalsFlatRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
TrianglesInstancingPickNormalsFlatRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

TrianglesInstancingPickNormalsFlatRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    // In practice, these binds will only happen once per frame
    // because we pick normals on a single previously-picked mesh

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
            gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
            if (active) {
                var sectionPlane = sectionPlanes[sectionPlaneIndex];
                if (rtcCenter) {
                    var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$q);
                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                } else {
                    gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                }
                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.TRIANGLES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

TrianglesInstancingPickNormalsFlatRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];
    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

TrianglesInstancingPickNormalsFlatRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

TrianglesInstancingPickNormalsFlatRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

TrianglesInstancingPickNormalsFlatRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry normals vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vWorldPosition;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("  vWorldPosition = worldPosition;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

TrianglesInstancingPickNormalsFlatRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Batched geometry normals fragment shader");
    src.push("#extension GL_OES_standard_derivatives : enable");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    src.push("varying vec4 vWorldPosition;");
    if (clipping) {
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec3 vWorldNormal;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );");
    src.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );");
    src.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );");
    src.push("  gl_FragColor = vec4((worldNormal * 0.5) + 0.5, 1.0);");
    src.push("}");
    return src;
};

TrianglesInstancingPickNormalsFlatRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

TrianglesInstancingPickNormalsFlatRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var TrianglesInstancingRenderers = function TrianglesInstancingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$7 = { colorRenderer: { configurable: true },colorRendererWithSAO: { configurable: true },flatColorRenderer: { configurable: true },flatColorRendererWithSAO: { configurable: true },colorQualityRenderer: { configurable: true },colorQualityRendererWithSAO: { configurable: true },silhouetteRenderer: { configurable: true },depthRenderer: { configurable: true },normalsRenderer: { configurable: true },edgesRenderer: { configurable: true },edgesColorRenderer: { configurable: true },pickMeshRenderer: { configurable: true },pickNormalsRenderer: { configurable: true },pickNormalsFlatRenderer: { configurable: true },pickDepthRenderer: { configurable: true },occlusionRenderer: { configurable: true },shadowRenderer: { configurable: true } };

TrianglesInstancingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._colorRendererWithSAO && (!this._colorRendererWithSAO.getValid())) {
        this._colorRendererWithSAO.destroy();
        this._colorRendererWithSAO = null;
    }
    if (this._flatColorRenderer && (!this._flatColorRenderer.getValid())) {
        this._flatColorRenderer.destroy();
        this._flatColorRenderer = null;
    }
    if (this._flatColorRendererWithSAO && (!this._flatColorRendererWithSAO.getValid())) {
        this._flatColorRendererWithSAO.destroy();
        this._flatColorRendererWithSAO = null;
    }
    if (this._colorQualityRenderer && (!this._colorQualityRenderer.getValid())) {
        this._colorQualityRenderer.destroy();
        this._colorQualityRenderer = null;
    }
    if (this._colorQualityRendererWithSAO && (!this._colorQualityRendererWithSAO.getValid())) {
        this._colorQualityRendererWithSAO.destroy();
        this._colorQualityRendererWithSAO = null;
    }
    if (this._depthRenderer && (!this._depthRenderer.getValid())) {
        this._depthRenderer.destroy();
        this._depthRenderer = null;
    }
    if (this._normalsRenderer && (!this._normalsRenderer.getValid())) {
        this._normalsRenderer.destroy();
        this._normalsRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
    if (this._edgesRenderer && (!this._edgesRenderer.getValid())) {
        this._edgesRenderer.destroy();
        this._edgesRenderer = null;
    }
    if (this._edgesColorRenderer && (!this._edgesColorRenderer.getValid())) {
        this._edgesColorRenderer.destroy();
        this._edgesColorRenderer = null;
    }
    if (this._pickMeshRenderer && (!this._pickMeshRenderer.getValid())) {
        this._pickMeshRenderer.destroy();
        this._pickMeshRenderer = null;
    }
    if (this._pickDepthRenderer && (!this._pickDepthRenderer.getValid())) {
        this._pickDepthRenderer.destroy();
        this._pickDepthRenderer = null;
    }
    if (this._pickNormalsRenderer && this._pickNormalsRenderer.getValid() === false) {
        this._pickNormalsRenderer.destroy();
        this._pickNormalsRenderer = null;
    }
    if (this._pickNormalsFlatRenderer && (!this._pickNormalsFlatRenderer.getValid())) {
        this._pickNormalsFlatRenderer.destroy();
        this._pickNormalsFlatRenderer = null;
    }
    if (this._occlusionRenderer && this._occlusionRenderer.getValid() === false) {
        this._occlusionRenderer.destroy();
        this._occlusionRenderer = null;
    }
    if (this._shadowRenderer && (!this._shadowRenderer.getValid())) {
        this._shadowRenderer.destroy();
        this._shadowRenderer = null;
    }
};

prototypeAccessors$7.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new TrianglesInstancingColorRenderer(this._scene, false);
    }
    return this._colorRenderer;
};

prototypeAccessors$7.colorRendererWithSAO.get = function () {
    if (!this._colorRendererWithSAO) {
        this._colorRendererWithSAO = new TrianglesInstancingColorRenderer(this._scene, true);
    }
    return this._colorRendererWithSAO;
};

prototypeAccessors$7.flatColorRenderer.get = function () {
    if (!this._flatColorRenderer) {
        this._flatColorRenderer = new TrianglesInstancingFlatColorRenderer(this._scene, false);
    }
    return this._flatColorRenderer;
};

prototypeAccessors$7.flatColorRendererWithSAO.get = function () {
    if (!this._flatColorRendererWithSAO) {
        this._flatColorRendererWithSAO = new TrianglesInstancingFlatColorRenderer(this._scene, true);
    }
    return this._flatColorRendererWithSAO;
};

prototypeAccessors$7.colorQualityRenderer.get = function () {
    if (!this._colorQualityRenderer) {
        this._colorQualityRenderer = new TrianglesInstancingColorQualityRenderer(this._scene, false);
    }
    return this._colorQualityRenderer;
};

prototypeAccessors$7.colorQualityRendererWithSAO.get = function () {
    if (!this._colorQualityRendererWithSAO) {
        this._colorQualityRendererWithSAO = new TrianglesInstancingColorQualityRenderer(this._scene, true);
    }
    return this._colorQualityRendererWithSAO;
};

prototypeAccessors$7.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new TrianglesInstancingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

prototypeAccessors$7.depthRenderer.get = function () {
    if (!this._depthRenderer) {
        this._depthRenderer = new TrianglesInstancingDepthRenderer(this._scene);
    }
    return this._depthRenderer;
};

prototypeAccessors$7.normalsRenderer.get = function () {
    if (!this._normalsRenderer) {
        this._normalsRenderer = new TrianglesInstancingNormalsRenderer(this._scene);
    }
    return this._normalsRenderer;
};

prototypeAccessors$7.edgesRenderer.get = function () {
    if (!this._edgesRenderer) {
        this._edgesRenderer = new TrianglesInstancingEdgesRenderer(this._scene);
    }
    return this._edgesRenderer;
};

prototypeAccessors$7.edgesColorRenderer.get = function () {
    if (!this._edgesColorRenderer) {
        this._edgesColorRenderer = new TrianglesInstancingEdgesColorRenderer(this._scene);
    }
    return this._edgesColorRenderer;
};

prototypeAccessors$7.pickMeshRenderer.get = function () {
    if (!this._pickMeshRenderer) {
        this._pickMeshRenderer = new TrianglesInstancingPickMeshRenderer(this._scene);
    }
    return this._pickMeshRenderer;
};

prototypeAccessors$7.pickNormalsRenderer.get = function () {
    if (!this._pickNormalsRenderer) {
        this._pickNormalsRenderer = new TrianglesInstancingPickNormalsRenderer(this._scene);
    }
    return this._pickNormalsRenderer;
};

prototypeAccessors$7.pickNormalsFlatRenderer.get = function () {
    if (!this._pickNormalsFlatRenderer) {
        this._pickNormalsFlatRenderer = new TrianglesInstancingPickNormalsFlatRenderer(this._scene);
    }
    return this._pickNormalsFlatRenderer;
};

prototypeAccessors$7.pickDepthRenderer.get = function () {
    if (!this._pickDepthRenderer) {
        this._pickDepthRenderer = new TrianglesInstancingPickDepthRenderer(this._scene);
    }
    return this._pickDepthRenderer;
};

prototypeAccessors$7.occlusionRenderer.get = function () {
    if (!this._occlusionRenderer) {
        this._occlusionRenderer = new TrianglesInstancingOcclusionRenderer(this._scene);
    }
    return this._occlusionRenderer;
};

prototypeAccessors$7.shadowRenderer.get = function () {
    if (!this._shadowRenderer) {
        this._shadowRenderer = new TrianglesInstancingShadowRenderer(this._scene);
    }
    return this._shadowRenderer;
};

TrianglesInstancingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._colorRendererWithSAO) {
        this._colorRendererWithSAO.destroy();
    }
    if (this._flatColorRenderer) {
        this._flatColorRenderer.destroy();
    }
    if (this._flatColorRendererWithSAO) {
        this._flatColorRendererWithSAO.destroy();
    }
    if (this._colorQualityRenderer) {
        this._colorQualityRenderer.destroy();
    }
    if (this._colorQualityRendererWithSAO) {
        this._colorQualityRendererWithSAO.destroy();
    }
    if (this._depthRenderer) {
        this._depthRenderer.destroy();
    }
    if (this._normalsRenderer) {
        this._normalsRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
    if (this._edgesRenderer) {
        this._edgesRenderer.destroy();
    }
    if (this._edgesColorRenderer) {
        this._edgesColorRenderer.destroy();
    }
    if (this._pickMeshRenderer) {
        this._pickMeshRenderer.destroy();
    }
    if (this._pickDepthRenderer) {
        this._pickDepthRenderer.destroy();
    }
    if (this._pickNormalsRenderer) {
        this._pickNormalsRenderer.destroy();
    }
    if (this._pickNormalsFlatRenderer) {
        this._pickNormalsFlatRenderer.destroy();
    }
    if (this._occlusionRenderer) {
        this._occlusionRenderer.destroy();
    }
    if (this._shadowRenderer) {
        this._shadowRenderer.destroy();
    }
};

Object.defineProperties( TrianglesInstancingRenderers.prototype, prototypeAccessors$7 );

var cachedRenderers$4 = {};

/**
 * @private
 */
function getInstancingRenderers$1(scene) {
    var sceneId = scene.id;
    var instancingRenderers = cachedRenderers$4[sceneId];
    if (!instancingRenderers) {
        instancingRenderers = new TrianglesInstancingRenderers(scene);
        cachedRenderers$4[sceneId] = instancingRenderers;
        instancingRenderers._compile();
        scene.on("compile", function () {
            instancingRenderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachedRenderers$4[sceneId];
            instancingRenderers._destroy();
        });
    }
    return instancingRenderers;
}

var bigIndicesSupported$4 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

var tempUint8Vec4$2 = new Uint8Array(4);
var tempVec4a$6 = math.vec4([0, 0, 0, 1]);
var tempVec4b$6 = math.vec4([0, 0, 0, 1]);
var tempVec4c$6 = math.vec4([0, 0, 0, 1]);
var tempVec3fa$2 = new Float32Array(3);

var tempVec3a$p = math.vec3();
var tempVec3b$6 = math.vec3();
var tempVec3c$3 = math.vec3();
var tempVec3d$1 = math.vec3();
var tempVec3e = math.vec3();
var tempVec3f = math.vec3();
var tempVec3g = math.vec3();

/**
 * @private
 */
var TrianglesInstancingLayer = function TrianglesInstancingLayer(model, cfg) {

    /**
     * State sorting key.
     * @type {string}
     */
    this.sortId = "TrianglesInstancingLayer" + (cfg.solid ? "-solid" : "-surface") + (cfg.normals ? "-normals" : "-autoNormals");

    /**
     * Index of this InstancingLayer in PerformanceModel#_layerList
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._instancingRenderers = getInstancingRenderers$1(model.scene);
    this.model = model;
    this._aabb = math.collapseAABB3();

    var stateCfg = {
        positionsDecodeMatrix: math.mat4(),
        numInstances: 0,
        obb: math.OBB3(),
        rtcCenter: null
    };

    var preCompressed = (!!cfg.positionsDecodeMatrix);
    var pickSurfacePrecisionEnabled = this.model.scene.pickSurfacePrecisionEnabled;
    var gl = this.model.scene.canvas.gl;

    if (cfg.positions) {

        if (preCompressed) {

            var normalized = false;
            stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, cfg.positions, cfg.positions.length, 3, gl.STATIC_DRAW, normalized);
            stateCfg.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);

            var localAABB = math.collapseAABB3();
            math.expandAABB3Points3(localAABB, cfg.positions);
            geometryCompressionUtils.decompressAABB(localAABB, stateCfg.positionsDecodeMatrix);
            math.AABB3ToOBB3(localAABB, stateCfg.obb);

            if (pickSurfacePrecisionEnabled) {
                stateCfg.quantizedPositions = cfg.positions;
            }

        } else {

            var lenPositions = cfg.positions.length;
            var localAABB$1 = math.collapseAABB3();
            math.expandAABB3Points3(localAABB$1, cfg.positions);
            math.AABB3ToOBB3(localAABB$1, stateCfg.obb);
            var quantizedPositions = quantizePositions(cfg.positions, localAABB$1, stateCfg.positionsDecodeMatrix);
            var normalized$1 = false;
            stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, lenPositions, 3, gl.STATIC_DRAW, normalized$1);

            if (pickSurfacePrecisionEnabled) {
                stateCfg.quantizedPositions = quantizedPositions;
            }
        }
    }

    if (cfg.normals && cfg.normals.length > 0) {

        if (preCompressed) {

            var normalized$2 = true; // For oct-encoded UInt8
            stateCfg.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, cfg.normals, cfg.normals.length, 3, gl.STATIC_DRAW, normalized$2);

        } else {

            var compressedNormals = octEncodeNormals(cfg.normals);
            var normalized$3 = true; // For oct-encoded UInt8
            stateCfg.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, compressedNormals, compressedNormals.length, 3, gl.STATIC_DRAW, normalized$3);
        }
    }

    if (cfg.indices) {
        stateCfg.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, bigIndicesSupported$4 ? new Uint32Array(cfg.indices) : new Uint16Array(cfg.indices), cfg.indices.length, 1, gl.STATIC_DRAW);

        if (pickSurfacePrecisionEnabled) {
            stateCfg.indices = cfg.indices;
        }
    }

    var edgeIndices = cfg.edgeIndices;
    if (!edgeIndices) {
        edgeIndices = buildEdgeIndices(cfg.positions, cfg.indices, null, cfg.edgeThreshold || 10);
    }
    stateCfg.edgeIndicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, bigIndicesSupported$4 ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices), edgeIndices.length, 1, gl.STATIC_DRAW);

    this._state = new RenderState(stateCfg);

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numEdgesLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    /** @private */
    this.numIndices = (cfg.indices) ? cfg.indices.length / 3 : 0;

    // Vertex arrays
    this._colors = [];
    this._metallicRoughness = [];
    this._pickColors = [];
    this._offsets = [];

    // Modeling matrix per instance, array for each column
    this._modelMatrixCol0 = [];
    this._modelMatrixCol1 = [];
    this._modelMatrixCol2 = [];

    // Modeling normal matrix per instance, array for each column
    this._modelNormalMatrixCol0 = [];
    this._modelNormalMatrixCol1 = [];
    this._modelNormalMatrixCol2 = [];

    this._portions = [];

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    this._finalized = false;

    /**
     * The axis-aligned World-space boundary of this InstancingLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();

    /**
     * When true, this layer contains solid triangle meshes, otherwise this layer contains surface triangle meshes
     * @type {boolean}
     */
    this.solid = !!cfg.solid;
};

/**
 * Creates a new portion within this InstancingLayer, returns the new portion ID.
 *
 * The portion will instance this InstancingLayer's geometry.
 *
 * Gives the portion the specified color and matrix.
 *
 * @param cfg Portion params
 * @param cfg.color Color [0..255,0..255,0..255]
 * @param cfg.metallic Metalness factor [0..255]
 * @param cfg.roughness Roughness factor [0..255]
 * @param cfg.opacity Opacity [0..255].
 * @param cfg.meshMatrix Flat float 4x4 matrix.
 * @param [cfg.worldMatrix] Flat float 4x4 matrix.
 * @param cfg.worldAABB Flat float AABB.
 * @param cfg.pickColor Quantized pick color
 * @returns {number} Portion ID.
 */
TrianglesInstancingLayer.prototype.createPortion = function createPortion (cfg) {

    var color = cfg.color;
    var metallic = cfg.metallic;
    var roughness = cfg.roughness;
    var opacity = cfg.opacity;
    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.aabb;
    var pickColor = cfg.pickColor;

    if (this._finalized) {
        throw "Already finalized";
    }

    // TODO: find AABB for portion by transforming the geometry local AABB by the given meshMatrix?

    var r = color[0]; // Color is pre-quantized by PerformanceModel
    var g = color[1];
    var b = color[2];
    color[3];

    this._colors.push(r);
    this._colors.push(g);
    this._colors.push(b);
    this._colors.push(opacity);

    this._metallicRoughness.push((metallic !== null && metallic !== undefined) ? metallic : 0);
    this._metallicRoughness.push((roughness !== null && roughness !== undefined) ? roughness : 255);

    if (this.model.scene.entityOffsetsEnabled) {
        this._offsets.push(0);
        this._offsets.push(0);
        this._offsets.push(0);
    }

    this._modelMatrixCol0.push(meshMatrix[0]);
    this._modelMatrixCol0.push(meshMatrix[4]);
    this._modelMatrixCol0.push(meshMatrix[8]);
    this._modelMatrixCol0.push(meshMatrix[12]);

    this._modelMatrixCol1.push(meshMatrix[1]);
    this._modelMatrixCol1.push(meshMatrix[5]);
    this._modelMatrixCol1.push(meshMatrix[9]);
    this._modelMatrixCol1.push(meshMatrix[13]);

    this._modelMatrixCol2.push(meshMatrix[2]);
    this._modelMatrixCol2.push(meshMatrix[6]);
    this._modelMatrixCol2.push(meshMatrix[10]);
    this._modelMatrixCol2.push(meshMatrix[14]);

    if (this._state.normalsBuf) {

        // Note: order of inverse and transpose doesn't matter

        var transposedMat = math.transposeMat4(meshMatrix, math.mat4()); // TODO: Use cached matrix
        var normalMatrix = math.inverseMat4(transposedMat);

        this._modelNormalMatrixCol0.push(normalMatrix[0]);
        this._modelNormalMatrixCol0.push(normalMatrix[4]);
        this._modelNormalMatrixCol0.push(normalMatrix[8]);
        this._modelNormalMatrixCol0.push(normalMatrix[12]);

        this._modelNormalMatrixCol1.push(normalMatrix[1]);
        this._modelNormalMatrixCol1.push(normalMatrix[5]);
        this._modelNormalMatrixCol1.push(normalMatrix[9]);
        this._modelNormalMatrixCol1.push(normalMatrix[13]);

        this._modelNormalMatrixCol2.push(normalMatrix[2]);
        this._modelNormalMatrixCol2.push(normalMatrix[6]);
        this._modelNormalMatrixCol2.push(normalMatrix[10]);
        this._modelNormalMatrixCol2.push(normalMatrix[14]);
    }

    // Per-vertex pick colors

    this._pickColors.push(pickColor[0]);
    this._pickColors.push(pickColor[1]);
    this._pickColors.push(pickColor[2]);
    this._pickColors.push(pickColor[3]);

    // Expand AABB

    math.collapseAABB3(worldAABB);
    var obb = this._state.obb;
    var lenPositions = obb.length;
    for (var i = 0; i < lenPositions; i += 4) {
        tempVec4a$6[0] = obb[i + 0];
        tempVec4a$6[1] = obb[i + 1];
        tempVec4a$6[2] = obb[i + 2];
        math.transformPoint4(meshMatrix, tempVec4a$6, tempVec4b$6);
        if (worldMatrix) {
            math.transformPoint4(worldMatrix, tempVec4b$6, tempVec4c$6);
            math.expandAABB3Point3(worldAABB, tempVec4c$6);
        } else {
            math.expandAABB3Point3(worldAABB, tempVec4b$6);
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    this._state.numInstances++;

    var portionId = this._portions.length;

    var portion = {};

    if (this.model.scene.pickSurfacePrecisionEnabled) {
        portion.matrix = meshMatrix.slice();
        portion.inverseMatrix = null; // Lazy-computed in precisionRayPickSurface
    }

    this._portions.push(portion);

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

TrianglesInstancingLayer.prototype.finalize = function finalize () {
    if (this._finalized) {
        throw "Already finalized";
    }
    var gl = this.model.scene.canvas.gl;
    var colorsLength = this._colors.length;
    var flagsLength = colorsLength;
    if (colorsLength > 0) {
        var notNormalized = false;
        this._state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(this._colors), this._colors.length, 4, gl.DYNAMIC_DRAW, notNormalized);
        this._colors = []; // Release memory
    }
    if (this._metallicRoughness.length > 0) {
        var metallicRoughness = new Uint8Array(this._metallicRoughness);
        var normalized = false;
        this._state.metallicRoughnessBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, metallicRoughness, this._metallicRoughness.length, 2, gl.STATIC_DRAW, normalized);
    }
    if (flagsLength > 0) {
        // Because we only build flags arrays here,
        // get their length from the colors array
        var notNormalized$1 = false;
        var normalized$1 = true;
        this._state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, notNormalized$1);
        this._state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, normalized$1);
    }
    if (this.model.scene.entityOffsetsEnabled) {
        if (this._offsets.length > 0) {
            var notNormalized$2 = false;
            this._state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, gl.DYNAMIC_DRAW, notNormalized$2);
            this._offsets = []; // Release memory
        }
    }
    if (this._modelMatrixCol0.length > 0) {

        var normalized$2 = false;

        this._state.modelMatrixCol0Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, gl.STATIC_DRAW, normalized$2);
        this._state.modelMatrixCol1Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, gl.STATIC_DRAW, normalized$2);
        this._state.modelMatrixCol2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, gl.STATIC_DRAW, normalized$2);
        this._modelMatrixCol0 = [];
        this._modelMatrixCol1 = [];
        this._modelMatrixCol2 = [];

        if (this._state.normalsBuf) {
            this._state.modelNormalMatrixCol0Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol0), this._modelNormalMatrixCol0.length, 4, gl.STATIC_DRAW, normalized$2);
            this._state.modelNormalMatrixCol1Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol1), this._modelNormalMatrixCol1.length, 4, gl.STATIC_DRAW, normalized$2);
            this._state.modelNormalMatrixCol2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol2), this._modelNormalMatrixCol2.length, 4, gl.STATIC_DRAW, normalized$2);
            this._modelNormalMatrixCol0 = [];
            this._modelNormalMatrixCol1 = [];
            this._modelNormalMatrixCol2 = [];
        }
    }
    if (this._pickColors.length > 0) {
        var normalized$3 = false;
        this._state.pickColorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(this._pickColors), this._pickColors.length, 4, gl.STATIC_DRAW, normalized$3);
        this._pickColors = []; // Release memory
    }
    this._finalized = true;
};

// The following setters are called by PerformanceMesh, in turn called by PerformanceNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.

TrianglesInstancingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

TrianglesInstancingLayer.prototype.setVisible = function setVisible (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setXRayed = function setXRayed (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setSelected = function setSelected (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setEdges = function setEdges (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    } else {
        this._numEdgesLayerPortions--;
        this.model.numEdgesLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

TrianglesInstancingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

TrianglesInstancingLayer.prototype.setPickable = function setPickable (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags2(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setCulled = function setCulled (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

TrianglesInstancingLayer.prototype.setColor = function setColor (portionId, color) { // RGBA color is normalized as ints
    if (!this._finalized) {
        throw "Not finalized";
    }
    tempUint8Vec4$2[0] = color[0];
    tempUint8Vec4$2[1] = color[1];
    tempUint8Vec4$2[2] = color[2];
    tempUint8Vec4$2[3] = color[3];
    if (this._state.colorsBuf) {
        this._state.colorsBuf.setData(tempUint8Vec4$2, portionId * 4, 4);
    }
};

TrianglesInstancingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

// setMatrix(portionId, matrix) {
//
// if (!this._finalized) {
//     throw "Not finalized";
// }
//
// var offset = portionId * 4;
//
// tempFloat32Vec4[0] = matrix[0];
// tempFloat32Vec4[1] = matrix[4];
// tempFloat32Vec4[2] = matrix[8];
// tempFloat32Vec4[3] = matrix[12];
//
// this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4, offset, 4);
//
// tempFloat32Vec4[0] = matrix[1];
// tempFloat32Vec4[1] = matrix[5];
// tempFloat32Vec4[2] = matrix[9];
// tempFloat32Vec4[3] = matrix[13];
//
// this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4, offset, 4);
//
// tempFloat32Vec4[0] = matrix[2];
// tempFloat32Vec4[1] = matrix[6];
// tempFloat32Vec4[2] = matrix[10];
// tempFloat32Vec4[3] = matrix[14];
//
// this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4, offset, 4);
// }

TrianglesInstancingLayer.prototype._setFlags = function _setFlags (portionId, flags, meshTransparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var edges = !!(flags & ENTITY_FLAGS.EDGES);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Normal fill

    var f0;
    if (!visible || culled || xrayed) { // Highlight & select are layered on top of color - not mutually exclusive
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (meshTransparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Emphasis fill

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Edges

    var f2 = 0;
    if (!visible || culled) {
        f2 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f2 = RENDER_PASSES.EDGES_SELECTED;
    } else if (highlighted) {
        f2 = RENDER_PASSES.EDGES_HIGHLIGHTED;
    } else if (xrayed) {
        f2 = RENDER_PASSES.EDGES_XRAYED;
    } else if (edges) {
        if (meshTransparent) {
            f2 = RENDER_PASSES.EDGES_COLOR_TRANSPARENT;
        } else {
            f2 = RENDER_PASSES.EDGES_COLOR_OPAQUE;
        }
    } else {
        f2 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    tempUint8Vec4$2[0] = f0; // x - normal fill
    tempUint8Vec4$2[1] = f1; // y - emphasis fill
    tempUint8Vec4$2[2] = f2; // z - edges
    tempUint8Vec4$2[3] = f3; // w - pick

    if (this._state.flagsBuf) {
        this._state.flagsBuf.setData(tempUint8Vec4$2, portionId * 4, 4);
    }
};

TrianglesInstancingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;
    tempUint8Vec4$2[0] = clippable;

    if (this._state.flags2Buf) {
        this._state.flags2Buf.setData(tempUint8Vec4$2, portionId * 4, 4);
    }
};

TrianglesInstancingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    tempVec3fa$2[0] = offset[0];
    tempVec3fa$2[1] = offset[1];
    tempVec3fa$2[2] = offset[2];
    if (this._state.offsetsBuf) {
        this._state.offsetsBuf.setData(tempVec3fa$2, portionId * 3, 3);
    }
};

// ---------------------- COLOR RENDERING -----------------------------------

TrianglesInstancingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (frameCtx.withSAO && this.model.saoEnabled) {
        if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
            if (this._instancingRenderers.colorQualityRendererWithSAO) {
                this._instancingRenderers.colorQualityRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
            }
        } else {
            if (this._state.normalsBuf) {
                if (this._instancingRenderers.colorRendererWithSAO) {
                    this._instancingRenderers.colorRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            } else {
                if (this._instancingRenderers.flatColorRendererWithSAO) {
                    this._instancingRenderers.flatColorRendererWithSAO.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            }
        }
    } else {
        if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
            if (this._instancingRenderers.colorQualityRenderer) {
                this._instancingRenderers.colorQualityRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
            }
        } else {
            if (this._state.normalsBuf) {
                if (this._instancingRenderers.colorRenderer) {
                    this._instancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            } else {
                if (this._instancingRenderers.flatColorRenderer) {
                    this._instancingRenderers.flatColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
                }
            }
        }
    }
};

TrianglesInstancingLayer.prototype._updateBackfaceCull = function _updateBackfaceCull (renderFlags, frameCtx) {
    var backfaces = this.model.backfaces || (!this.solid) || renderFlags.sectioned;
    if (frameCtx.backfaces !== backfaces) {
        var gl = frameCtx.gl;
        if (backfaces) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }
        frameCtx.backfaces = backfaces;
    }
};

TrianglesInstancingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (frameCtx.pbrEnabled && this.model.pbrEnabled && this._state.normalsBuf) {
        if (this._instancingRenderers.colorQualityRenderer) {
            this._instancingRenderers.colorQualityRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
        }
    } else {
        if (this._state.normalsBuf) {
            if (this._instancingRenderers.colorRenderer) {
                this._instancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
            }
        } else {
            if (this._instancingRenderers.flatColorRenderer) {
                this._instancingRenderers.flatColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
            }
        }
    }
};

// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------

TrianglesInstancingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.depthRenderer) {
        this._instancingRenderers.depthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE); // Assume whatever post-effect uses depth (eg SAO) does not apply to transparent objects
    }
};

TrianglesInstancingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.normalsRenderer) {
        this._instancingRenderers.normalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE); // Assume whatever post-effect uses normals (eg SAO) does not apply to transparent objects
    }
};

// ---------------------- SILHOUETTE RENDERING -----------------------------------

TrianglesInstancingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.silhouetteRenderer) {
        this._instancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

TrianglesInstancingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.silhouetteRenderer) {
        this._instancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

TrianglesInstancingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.silhouetteRenderer) {
        this._instancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

// ---------------------- EDGES RENDERING -----------------------------------

TrianglesInstancingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numEdgesLayerPortions === 0) {
        return;
    }
    if (this._instancingRenderers.edgesColorRenderer) {
        this._instancingRenderers.edgesColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_COLOR_OPAQUE);
    }
};

TrianglesInstancingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numEdgesLayerPortions === 0) {
        return;
    }
    if (this._instancingRenderers.edgesColorRenderer) {
        this._instancingRenderers.edgesColorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_COLOR_TRANSPARENT);
    }
};

TrianglesInstancingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._instancingRenderers.edgesRenderer) {
        this._instancingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_XRAYED);
    }
};

TrianglesInstancingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._instancingRenderers.edgesRenderer) {
        this._instancingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_HIGHLIGHTED);
    }
};

TrianglesInstancingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._instancingRenderers.edgesRenderer) {
        this._instancingRenderers.edgesRenderer.drawLayer(frameCtx, this, RENDER_PASSES.EDGES_SELECTED);
    }
};

// ---------------------- OCCLUSION CULL RENDERING -----------------------------------

TrianglesInstancingLayer.prototype.drawOcclusion = function drawOcclusion (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.occlusionRenderer) {
        // Only opaque, filled objects can be occluders
        this._instancingRenderers.occlusionRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

// ---------------------- SHADOW BUFFER RENDERING -----------------------------------

TrianglesInstancingLayer.prototype.drawShadow = function drawShadow (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.shadowRenderer) {
        this._instancingRenderers.shadowRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

//---- PICKING ----------------------------------------------------------------------------------------------------

TrianglesInstancingLayer.prototype.drawPickMesh = function drawPickMesh (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.pickMeshRenderer) {
        this._instancingRenderers.pickMeshRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

TrianglesInstancingLayer.prototype.drawPickDepths = function drawPickDepths (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.pickDepthRenderer) {
        this._instancingRenderers.pickDepthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

TrianglesInstancingLayer.prototype.drawPickNormals = function drawPickNormals (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    this._updateBackfaceCull(renderFlags, frameCtx);
    if (this._instancingRenderers.pickNormalsRenderer) {
        this._instancingRenderers.pickNormalsRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

//-----------------------------------------------------------------------------------------

TrianglesInstancingLayer.prototype.precisionRayPickSurface = function precisionRayPickSurface (portionId, worldRayOrigin, worldRayDir, worldSurfacePos) {

    if (!this.model.scene.pickSurfacePrecisionEnabled) {
        return false;
    }

    var state = this._state;
    var portion = this._portions[portionId];

    if (!portion) {
        this.model.error("portion not found: " + portionId);
        return false;
    }

    if (!portion.inverseMatrix) {
        portion.inverseMatrix = math.inverseMat4(portion.matrix, math.mat4());
    }

    var quantizedPositions = state.quantizedPositions;
    var indices = state.indices;
    var rtcCenter = state.rtcCenter;
    var offset = portion.offset;

    var rtcRayOrigin = tempVec3a$p;
    var rtcRayDir = tempVec3b$6;

    rtcRayOrigin.set(rtcCenter ? math.subVec3(worldRayOrigin, rtcCenter, tempVec3c$3) : worldRayOrigin);  // World -> RTC
    rtcRayDir.set(worldRayDir);

    if (offset) {
        math.subVec3(rtcRayOrigin, offset);
    }

    math.transformRay(this.model.worldNormalMatrix, rtcRayOrigin, rtcRayDir, rtcRayOrigin, rtcRayDir);

    math.transformRay(portion.inverseMatrix, rtcRayOrigin, rtcRayDir, rtcRayOrigin, rtcRayDir);

    var a = tempVec3d$1;
    var b = tempVec3e;
    var c = tempVec3f;

    var gotIntersect = false;
    var closestDist = 0;
    var closestIntersectPos = tempVec3g;

    for (var i = 0, len = indices.length; i < len; i += 3) {

        var ia = indices[i + 0] * 3;
        var ib = indices[i + 1] * 3;
        var ic = indices[i + 2] * 3;

        a[0] = quantizedPositions[ia];
        a[1] = quantizedPositions[ia + 1];
        a[2] = quantizedPositions[ia + 2];

        b[0] = quantizedPositions[ib];
        b[1] = quantizedPositions[ib + 1];
        b[2] = quantizedPositions[ib + 2];

        c[0] = quantizedPositions[ic];
        c[1] = quantizedPositions[ic + 1];
        c[2] = quantizedPositions[ic + 2];

        math.decompressPosition(a, state.positionsDecodeMatrix);
        math.decompressPosition(b, state.positionsDecodeMatrix);
        math.decompressPosition(c, state.positionsDecodeMatrix);

        if (math.rayTriangleIntersect(rtcRayOrigin, rtcRayDir, a, b, c, closestIntersectPos)) {

            math.transformPoint3(portion.matrix, closestIntersectPos, closestIntersectPos);

            math.transformPoint3(this.model.worldMatrix, closestIntersectPos, closestIntersectPos);

            if (offset) {
                math.addVec3(closestIntersectPos, offset);
            }

            if (rtcCenter) {
                math.addVec3(closestIntersectPos, rtcCenter);
            }

            var dist = Math.abs(math.lenVec3(math.subVec3(closestIntersectPos, worldRayOrigin, [])));

            if (!gotIntersect || dist > closestDist) {
                closestDist = dist;
                worldSurfacePos.set(closestIntersectPos);
                gotIntersect = true;
            }
        }
    }

    return gotIntersect;
};

TrianglesInstancingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.normalsBuf) {
        state.normalsBuf.destroy();
        state.normalsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.metallicRoughnessBuf) {
        state.metallicRoughnessBuf.destroy();
        state.metallicRoughnessBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.modelMatrixCol0Buf) {
        state.modelMatrixCol0Buf.destroy();
        state.modelMatrixCol0Buf = null;
    }
    if (state.modelMatrixCol1Buf) {
        state.modelMatrixCol1Buf.destroy();
        state.modelMatrixCol1Buf = null;
    }
    if (state.modelMatrixCol2Buf) {
        state.modelMatrixCol2Buf.destroy();
        state.modelMatrixCol2Buf = null;
    }
    if (state.modelNormalMatrixCol0Buf) {
        state.modelNormalMatrixCol0Buf.destroy();
        state.modelNormalMatrixCol0Buf = null;
    }
    if (state.modelNormalMatrixCol1Buf) {
        state.modelNormalMatrixCol1Buf.destroy();
        state.modelNormalMatrixCol1Buf = null;
    }
    if (state.modelNormalMatrixCol2Buf) {
        state.modelNormalMatrixCol2Buf.destroy();
        state.modelNormalMatrixCol2Buf = null;
    }
    if (state.indicesBuf) {
        state.indicesBuf.destroy();
        state.indicessBuf = null;
    }
    if (state.edgeIndicesBuf) {
        state.edgeIndicesBuf.destroy();
        state.edgeIndicessBuf = null;
    }
    if (state.pickColorsBuf) {
        state.pickColorsBuf.destroy();
        state.pickColorsBuf = null;
    }
    state.destroy();
};

var tempVec3a$o = math.vec3();

/**
 * @private
 */
var LinesBatchingColorRenderer = function LinesBatchingColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

LinesBatchingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
LinesBatchingColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

LinesBatchingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var scene = this._scene;
    var camera = scene.camera;
    var model = batchingLayer.model;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.lineWidth(scene.linesMaterial.lineWidth);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$o);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.LINES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

LinesBatchingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

LinesBatchingColorRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

LinesBatchingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

LinesBatchingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Lines batching color vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE
    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");
    src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

LinesBatchingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Lines batching color fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("   gl_FragColor            = vColor;");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

LinesBatchingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

LinesBatchingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var defaultColor$1 = new Float32Array([1, 1, 1]);
var tempVec3a$n = math.vec3();

/**
 * @private
 */
var LinesBatchingSilhouetteRenderer = function LinesBatchingSilhouetteRenderer(scene, primitiveType) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

LinesBatchingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
LinesBatchingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

LinesBatchingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, batchingLayer, renderPass) {

    var model = batchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = batchingLayer._state;
    var rtcCenter = batchingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, defaultColor$1);
    }

    var viewMat = (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix;
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMat);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.lineWidth(scene.linesMaterial.lineWidth);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = batchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$n);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, batchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    state.indicesBuf.bind();

    gl.drawElements(gl.LINES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0);
};

LinesBatchingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

LinesBatchingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

LinesBatchingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

LinesBatchingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;

    var src = [];

    src.push("// Lines batching silhouette vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    src.push("uniform vec4 color;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");

    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

LinesBatchingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Lines batching silhouette fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

LinesBatchingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

LinesBatchingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var LinesBatchingRenderers = function LinesBatchingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$6 = { colorRenderer: { configurable: true },silhouetteRenderer: { configurable: true } };

LinesBatchingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
};

prototypeAccessors$6.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new LinesBatchingColorRenderer(this._scene, false);
    }
    return this._colorRenderer;
};

prototypeAccessors$6.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new LinesBatchingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

LinesBatchingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
};

Object.defineProperties( LinesBatchingRenderers.prototype, prototypeAccessors$6 );

var cachedRenderers$3 = {};

/**
 * @private
 */
function getBatchingRenderers(scene) {
    var sceneId = scene.id;
    var batchingRenderers = cachedRenderers$3[sceneId];
    if (!batchingRenderers) {
        batchingRenderers = new LinesBatchingRenderers(scene);
        cachedRenderers$3[sceneId] = batchingRenderers;
        batchingRenderers._compile();
        scene.on("compile", function () {
            batchingRenderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachedRenderers$3[sceneId];
            batchingRenderers._destroy();
        });
    }
    return batchingRenderers;
}

var bigIndicesSupported$3 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

/**
 * @private
 */
var LinesBatchingBuffer = function LinesBatchingBuffer(maxGeometryBatchSize) {
    if ( maxGeometryBatchSize === void 0 ) maxGeometryBatchSize = 5000000;


    if (bigIndicesSupported$3) {
        if (maxGeometryBatchSize > 5000000) {
            maxGeometryBatchSize = 5000000;
        }
    } else {
        if (maxGeometryBatchSize > 65530) {
            maxGeometryBatchSize = 65530;
        }
    }

    this.maxVerts = maxGeometryBatchSize;
    this.maxIndices = maxGeometryBatchSize * 3; // Rough rule-of-thumb
    this.positions = [];
    this.colors = [];
    this.flags = [];
    this.flags2 = [];
    this.offsets = [];
    this.indices = [];
};

var tempVec4a$5 = math.vec4([0, 0, 0, 1]);
var tempVec4b$5 = math.vec4([0, 0, 0, 1]);
var tempVec4c$5 = math.vec4([0, 0, 0, 1]);
var tempOBB3$1 = math.OBB3();

/**
 * @private
 */
var LinesBatchingLayer = function LinesBatchingLayer(model, cfg) {

    /**
     * Index of this LinesBatchingLayer in {@link PerformanceModel#_layerList}.
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._batchingRenderers = getBatchingRenderers(model.scene);
    this.model = model;
    this._buffer = new LinesBatchingBuffer(cfg.maxGeometryBatchSize);
    this._scratchMemory = cfg.scratchMemory;

    this._state = new RenderState({
        positionsBuf: null,
        offsetsBuf: null,
        colorsBuf: null,
        flagsBuf: null,
        flags2Buf: null,
        indicesBuf: null,
        positionsDecodeMatrix: math.mat4(),
        rtcCenter: null
    });

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numEdgesLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    this._modelAABB = math.collapseAABB3(); // Model-space AABB
    this._portions = [];

    this._finalized = false;
    this._positionsDecodeMatrix = cfg.positionsDecodeMatrix;
    this._preCompressed = (!!this._positionsDecodeMatrix);

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    /**
     * The axis-aligned World-space boundary of this LinesBatchingLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();
};

/**
 * Tests if there is room for another portion in this LinesBatchingLayer.
 *
 * @param lenPositions Number of positions we'd like to create in the portion.
 * @param lenIndices Number of indices we'd like to create in this portion.
 * @returns {boolean} True if OK to create another portion.
 */
LinesBatchingLayer.prototype.canCreatePortion = function canCreatePortion (lenPositions, lenIndices) {
    if (this._finalized) {
        throw "Already finalized";
    }
    return ((this._buffer.positions.length + lenPositions) < (this._buffer.maxVerts * 3) && (this._buffer.indices.length + lenIndices) < (this._buffer.maxIndices));
};

/**
 * Creates a new portion within this LinesBatchingLayer, returns the new portion ID.
 *
 * Gives the portion the specified geometry, color and matrix.
 *
 * @param cfg.positions Flat float Local-space positions array.
 * @param cfg.indices  Flat int indices array.
 * @param cfg.color Quantized RGB color [0..255,0..255,0..255,0..255]
 * @param cfg.opacity Opacity [0..255]
 * @param [cfg.meshMatrix] Flat float 4x4 matrix
 * @param [cfg.worldMatrix] Flat float 4x4 matrix
 * @param cfg.worldAABB Flat float AABB World-space AABB
 * @param cfg.pickColor Quantized pick color
 * @returns {number} Portion ID
 */
LinesBatchingLayer.prototype.createPortion = function createPortion (cfg) {

    if (this._finalized) {
        throw "Already finalized";
    }

    var positions = cfg.positions;
    var indices = cfg.indices;
    var color = cfg.color;
    var opacity = cfg.opacity;
    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.worldAABB;
    cfg.pickColor;

    var buffer = this._buffer;
    var positionsIndex = buffer.positions.length;
    var vertsIndex = positionsIndex / 3;
    var numVerts = positions.length / 3;
    var lenPositions = positions.length;

    if (this._preCompressed) {

        for (var i = 0, len = positions.length; i < len; i++) {
            buffer.positions.push(positions[i]);
        }

        var bounds = geometryCompressionUtils.getPositionsBounds(positions);

        var min = geometryCompressionUtils.decompressPosition(bounds.min, this._positionsDecodeMatrix, []);
        var max = geometryCompressionUtils.decompressPosition(bounds.max, this._positionsDecodeMatrix, []);

        worldAABB[0] = min[0];
        worldAABB[1] = min[1];
        worldAABB[2] = min[2];
        worldAABB[3] = max[0];
        worldAABB[4] = max[1];
        worldAABB[5] = max[2];

        if (worldMatrix) {
            math.AABB3ToOBB3(worldAABB, tempOBB3$1);
            math.transformOBB3(worldMatrix, tempOBB3$1);
            math.OBB3ToAABB3(tempOBB3$1, worldAABB);
        }

    } else {

        var positionsBase = buffer.positions.length;

        for (var i$1 = 0, len$1 = positions.length; i$1 < len$1; i$1++) {
            buffer.positions.push(positions[i$1]);
        }

        if (meshMatrix) {

            for (var i$2 = positionsBase, len$2 = positionsBase + lenPositions; i$2 < len$2; i$2 += 3) {

                tempVec4a$5[0] = buffer.positions[i$2 + 0];
                tempVec4a$5[1] = buffer.positions[i$2 + 1];
                tempVec4a$5[2] = buffer.positions[i$2 + 2];

                math.transformPoint4(meshMatrix, tempVec4a$5, tempVec4b$5);

                buffer.positions[i$2 + 0] = tempVec4b$5[0];
                buffer.positions[i$2 + 1] = tempVec4b$5[1];
                buffer.positions[i$2 + 2] = tempVec4b$5[2];

                math.expandAABB3Point3(this._modelAABB, tempVec4b$5);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4b$5, tempVec4c$5);
                    math.expandAABB3Point3(worldAABB, tempVec4c$5);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4b$5);
                }
            }

        } else {

            for (var i$3 = positionsBase, len$3 = positionsBase + lenPositions; i$3 < len$3; i$3 += 3) {

                tempVec4a$5[0] = buffer.positions[i$3 + 0];
                tempVec4a$5[1] = buffer.positions[i$3 + 1];
                tempVec4a$5[2] = buffer.positions[i$3 + 2];

                math.expandAABB3Point3(this._modelAABB, tempVec4a$5);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4a$5, tempVec4b$5);
                    math.expandAABB3Point3(worldAABB, tempVec4b$5);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4a$5);
                }
            }
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    if (color) {

        var r = color[0]; // Color is pre-quantized by PerformanceModel
        var g = color[1];
        var b = color[2];
        var a = opacity;

        for (var i$4 = 0; i$4 < numVerts; i$4++) {
            buffer.colors.push(r);
            buffer.colors.push(g);
            buffer.colors.push(b);
            buffer.colors.push(a);
        }
    }

    if (indices) {
        for (var i$5 = 0, len$4 = indices.length; i$5 < len$4; i$5++) {
            buffer.indices.push(indices[i$5] + vertsIndex);
        }
    }

    if (this.model.scene.entityOffsetsEnabled) {
        for (var i$6 = 0; i$6 < numVerts; i$6++) {
            buffer.offsets.push(0);
            buffer.offsets.push(0);
            buffer.offsets.push(0);
        }
    }

    var portionId = this._portions.length / 2;

    this._portions.push(vertsIndex);
    this._portions.push(numVerts);

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

/**
 * Builds batch VBOs from appended geometries.
 * No more portions can then be created.
 */
LinesBatchingLayer.prototype.finalize = function finalize () {

    if (this._finalized) {
        this.model.error("Already finalized");
        return;
    }

    var state = this._state;
    var gl = this.model.scene.canvas.gl;
    var buffer = this._buffer;

    if (buffer.positions.length > 0) {
        if (this._preCompressed) {
            state.positionsDecodeMatrix = this._positionsDecodeMatrix;
            var positions = new Uint16Array(buffer.positions);
            state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, buffer.positions.length, 3, gl.STATIC_DRAW);
        } else {
            var positions$1 = new Float32Array(buffer.positions);
            var quantizedPositions = quantizePositions(positions$1, this._modelAABB,  state.positionsDecodeMatrix);
            state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, buffer.positions.length, 3, gl.STATIC_DRAW);
        }
    }

    if (buffer.colors.length > 0) {
        var colors = new Uint8Array(buffer.colors);
        var normalized = false;
        state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colors, buffer.colors.length, 4, gl.DYNAMIC_DRAW, normalized);
    }

    if (buffer.colors.length > 0) { // Because we build flags arrays here, get their length from the colors array
        var flagsLength = buffer.colors.length;
        var flags = new Uint8Array(flagsLength);
        var flags2 = new Uint8Array(flagsLength);
        var notNormalized = false;
        var normalized$1 = true;
        state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags, flags.length, 4, gl.DYNAMIC_DRAW, notNormalized);
        state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags2, flags2.length, 4, gl.DYNAMIC_DRAW, normalized$1);
    }

    if (this.model.scene.entityOffsetsEnabled) {
        if (buffer.offsets.length > 0) {
            var offsets = new Float32Array(buffer.offsets);
            state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, offsets, buffer.offsets.length, 3, gl.DYNAMIC_DRAW);
        }
    }

    var bigIndicesSupported = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

    if (buffer.indices.length > 0) {
        var indices = bigIndicesSupported ? new Uint32Array(buffer.indices) : new Uint16Array(buffer.indices);
        state.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, buffer.indices.length, 1, gl.STATIC_DRAW);
    }

    this._buffer = null;
    this._finalized = true;
};

LinesBatchingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

LinesBatchingLayer.prototype.setVisible = function setVisible (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setXRayed = function setXRayed (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setSelected = function setSelected (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setEdges = function setEdges (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    } else {
        this._numEdgesLayerPortions--;
        this.model.numEdgesLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

LinesBatchingLayer.prototype.setCulled = function setCulled (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

LinesBatchingLayer.prototype.setPickable = function setPickable (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype.setColor = function setColor (portionId, color) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstColor = vertexBase * 4;
    var lenColor = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenColor);
    var r = color[0];
    var g = color[1];
    var b = color[2];
    var a = color[3];
    for (var i = 0; i < lenColor; i += 4) {
        tempArray[i + 0] = r;
        tempArray[i + 1] = g;
        tempArray[i + 2] = b;
        tempArray[i + 3] = a;
    }
    this._state.colorsBuf.setData(tempArray, firstColor, lenColor);
};

LinesBatchingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesBatchingLayer.prototype._setFlags = function _setFlags (portionId, flags, transparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Color

    var f0;
    if (!visible || culled || xrayed) {
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (transparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Silhouette

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = f0; // x - color
        tempArray[i + 1] = f1; // y - silhouette - select/highlight/xray
        tempArray[i + 2] = 0; // z - edges
        tempArray[i + 3] = f3; // w - pickable
    }

    this._state.flagsBuf.setData(tempArray, firstFlag, lenFlags);
};

LinesBatchingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);
    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;
    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = clippable;
    }
    this._state.flags2Buf.setData(tempArray, firstFlag, lenFlags);
};

LinesBatchingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstOffset = vertexBase * 3;
    var lenOffsets = numVerts * 3;
    var tempArray = this._scratchMemory.getFloat32Array(lenOffsets);
    var x = offset[0];
    var y = offset[1];
    var z = offset[2];
    for (var i = 0; i < lenOffsets; i += 3) {
        tempArray[i + 0] = x;
        tempArray[i + 1] = y;
        tempArray[i + 2] = z;
    }
    this._state.offsetsBuf.setData(tempArray, firstOffset, lenOffsets);
};

//-- RENDERING ----------------------------------------------------------------------------------------------

LinesBatchingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._batchingRenderers.colorRenderer) {
        this._batchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

LinesBatchingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._batchingRenderers.colorRenderer) {
        this._batchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
    }
};

LinesBatchingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

LinesBatchingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

LinesBatchingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._batchingRenderers.silhouetteRenderer) {
        this._batchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

LinesBatchingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
};

LinesBatchingLayer.prototype.drawPickMesh = function drawPickMesh (frameCtx) {
};

LinesBatchingLayer.prototype.drawPickDepths = function drawPickDepths (frameCtx) {
};

LinesBatchingLayer.prototype.drawPickNormals = function drawPickNormals (frameCtx) {
};

LinesBatchingLayer.prototype.drawOcclusion = function drawOcclusion (frameCtx) {
};

LinesBatchingLayer.prototype.drawShadow = function drawShadow (frameCtx) {
};

LinesBatchingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.indicesBuf) {
        state.indicesBuf.destroy();
        state.indicessBuf = null;
    }
    state.destroy();
};

var tempVec3a$m = math.vec3();

/**
 * @private
 */
var LinesInstancingColorRenderer = function LinesInstancingColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

LinesInstancingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
LinesInstancingColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

LinesInstancingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.lineWidth(scene.linesMaterial.lineWidth);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$m);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.LINES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

LinesInstancingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

    this._uWorldMatrix = program.getLocation("worldMatrix");

    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aOffset = program.getAttribute("offset");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uOcclusionTexture = "uOcclusionTexture";

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

LinesInstancingColorRenderer.prototype._bindProgram = function _bindProgram () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;
    this._program.bind();
    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);
    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

LinesInstancingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

LinesInstancingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Lines instancing color vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 lightAmbient;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0,  float(color.a) / 255.0);");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

LinesInstancingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Lines instancing color fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }

    // Doing SAO blend in the main solid fill draw shader just so that edge lines can be drawn over the top
    // Would be more efficient to defer this, then render lines later, using same depth buffer for Z-reject

    if (this._withSAO) {
        src.push("   float viewportWidth     = uSAOParams[0];");
        src.push("   float viewportHeight    = uSAOParams[1];");
        src.push("   float blendCutoff       = uSAOParams[2];");
        src.push("   float blendFactor       = uSAOParams[3];");
        src.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);");
        src.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBAToDepth(texture2D(uOcclusionTexture, uv))) * blendFactor;");
        src.push("   gl_FragColor            = vec4(vColor.rgb * ambient, vColor.a);");
    } else {
        src.push("    gl_FragColor           = vColor;");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

LinesInstancingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

LinesInstancingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$l = math.vec3();

/**
 * @private
 */
var LinesInstancingSilhouetteRenderer = function LinesInstancingSilhouetteRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

LinesInstancingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
LinesInstancingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

LinesInstancingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;

    if (!this._program) {
        this._allocate(instancingLayer.model.scene);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, math.vec3([1, 1, 1]));
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.lineWidth(scene.linesMaterial.lineWidth);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$l);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf, gl.UNSIGNED_BYTE, true);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    state.indicesBuf.bind();

    instanceExt.drawElementsInstancedANGLE(gl.LINES, state.indicesBuf.numItems, state.indicesBuf.itemType, 0, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0); // TODO: Is this needed
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

LinesInstancingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

LinesInstancingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

LinesInstancingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

LinesInstancingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Lines instancing silhouette vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 color;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    src.push("}");
    src.push("}");
    return src;
};

LinesInstancingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Lines instancing silhouette fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

LinesInstancingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

LinesInstancingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var LinesInstancingRenderers = function LinesInstancingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$5 = { colorRenderer: { configurable: true },silhouetteRenderer: { configurable: true } };

LinesInstancingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
};

prototypeAccessors$5.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new LinesInstancingColorRenderer(this._scene);
    }
    return this._colorRenderer;
};

prototypeAccessors$5.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new LinesInstancingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

LinesInstancingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
};

Object.defineProperties( LinesInstancingRenderers.prototype, prototypeAccessors$5 );

var cachedRenderers$2 = {};

/**
 * @private
 */
function getInstancingRenderers(scene) {
    var sceneId = scene.id;
    var instancingRenderers = cachedRenderers$2[sceneId];
    if (!instancingRenderers) {
        instancingRenderers = new LinesInstancingRenderers(scene);
        cachedRenderers$2[sceneId] = instancingRenderers;
        instancingRenderers._compile();
        scene.on("compile", function () {
            instancingRenderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachedRenderers$2[sceneId];
            instancingRenderers._destroy();
        });
    }
    return instancingRenderers;
}

var bigIndicesSupported$2 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

var tempUint8Vec4$1 = new Uint8Array(4);

var tempVec4a$4 = math.vec4([0, 0, 0, 1]);
var tempVec4b$4 = math.vec4([0, 0, 0, 1]);
var tempVec4c$4 = math.vec4([0, 0, 0, 1]);

var tempVec3fa$1 = new Float32Array(3);

/**
 * @private
 */
var LinesInstancingLayer = function LinesInstancingLayer(model, cfg) {

    /**
     * State sorting key.
     * @type {string}
     */
    this.sortId = "LinesInstancingLayer";

    /**
     * Index of this InstancingLayer in PerformanceModel#_layerList
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._linesInstancingRenderers = getInstancingRenderers(model.scene);
    this.model = model;
    this._aabb = math.collapseAABB3();

    var gl = model.scene.canvas.gl;

    var stateCfg = {
        positionsDecodeMatrix: math.mat4(),
        numInstances: 0,
        obb: math.OBB3(),
        rtcCenter: null
    };

    var preCompressed = (!!cfg.positionsDecodeMatrix);

    if (cfg.positions) {

        if (preCompressed) {

            var normalized = false;
            stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, cfg.positions, cfg.positions.length, 3, gl.STATIC_DRAW, normalized);
            stateCfg.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);

            var localAABB = math.collapseAABB3();
            math.expandAABB3Points3(localAABB, cfg.positions);
            geometryCompressionUtils.decompressAABB(localAABB, stateCfg.positionsDecodeMatrix);
            math.AABB3ToOBB3(localAABB, stateCfg.obb);

        } else {

            var lenPositions = cfg.positions.length;
            var localAABB$1 = math.collapseAABB3();
            math.expandAABB3Points3(localAABB$1, cfg.positions);
            math.AABB3ToOBB3(localAABB$1, stateCfg.obb);
            var quantizedPositions = quantizePositions(cfg.positions, localAABB$1, stateCfg.positionsDecodeMatrix);
            var normalized$1 = false;
            stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, lenPositions, 3, gl.STATIC_DRAW, normalized$1);
        }
    }

    if (cfg.indices) {
        stateCfg.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, bigIndicesSupported$2 ? new Uint32Array(cfg.indices) : new Uint16Array(cfg.indices), cfg.indices.length, 1, gl.STATIC_DRAW);
    }

    this._state = new RenderState(stateCfg);

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numEdgesLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    /** @private */
    this.numIndices = (cfg.indices) ? cfg.indices.length / 3 : 0;

    // Vertex arrays
    this._colors = [];
    this._offsets = [];

    // Modeling matrix per instance, array for each column
    this._modelMatrixCol0 = [];
    this._modelMatrixCol1 = [];
    this._modelMatrixCol2 = [];

    this._portions = [];

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    this._finalized = false;

    /**
     * The axis-aligned World-space boundary of this InstancingLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();
};

/**
 * Creates a new portion within this InstancingLayer, returns the new portion ID.
 *
 * The portion will instance this InstancingLayer's geometry.
 *
 * Gives the portion the specified color and matrix.
 *
 * @param cfg Portion params
 * @param cfg.color Color [0..255,0..255,0..255]
 * @param cfg.opacity Opacity [0..255].
 * @param cfg.meshMatrix Flat float 4x4 matrix.
 * @param [cfg.worldMatrix] Flat float 4x4 matrix.
 * @param cfg.aabb Flat float AABB.
 * @returns {number} Portion ID.
 */
LinesInstancingLayer.prototype.createPortion = function createPortion (cfg) {

    var color = cfg.color;
    var opacity = cfg.opacity;
    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.aabb;

    if (this._finalized) {
        throw "Already finalized";
    }

    // TODO: find AABB for portion by transforming the geometry local AABB by the given meshMatrix?

    var r = color[0]; // Color is pre-quantized by PerformanceModel
    var g = color[1];
    var b = color[2];
    color[3];

    this._colors.push(r);
    this._colors.push(g);
    this._colors.push(b);
    this._colors.push(opacity);

    if (this.model.scene.entityOffsetsEnabled) {
        this._offsets.push(0);
        this._offsets.push(0);
        this._offsets.push(0);
    }

    this._modelMatrixCol0.push(meshMatrix[0]);
    this._modelMatrixCol0.push(meshMatrix[4]);
    this._modelMatrixCol0.push(meshMatrix[8]);
    this._modelMatrixCol0.push(meshMatrix[12]);

    this._modelMatrixCol1.push(meshMatrix[1]);
    this._modelMatrixCol1.push(meshMatrix[5]);
    this._modelMatrixCol1.push(meshMatrix[9]);
    this._modelMatrixCol1.push(meshMatrix[13]);

    this._modelMatrixCol2.push(meshMatrix[2]);
    this._modelMatrixCol2.push(meshMatrix[6]);
    this._modelMatrixCol2.push(meshMatrix[10]);
    this._modelMatrixCol2.push(meshMatrix[14]);

    // Expand AABB

    math.collapseAABB3(worldAABB);
    var obb = this._state.obb;
    var lenPositions = obb.length;
    for (var i = 0; i < lenPositions; i += 4) {
        tempVec4a$4[0] = obb[i + 0];
        tempVec4a$4[1] = obb[i + 1];
        tempVec4a$4[2] = obb[i + 2];
        math.transformPoint4(meshMatrix, tempVec4a$4, tempVec4b$4);
        if (worldMatrix) {
            math.transformPoint4(worldMatrix, tempVec4b$4, tempVec4c$4);
            math.expandAABB3Point3(worldAABB, tempVec4c$4);
        } else {
            math.expandAABB3Point3(worldAABB, tempVec4b$4);
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    this._state.numInstances++;

    var portionId = this._portions.length;
    this._portions.push({});

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

LinesInstancingLayer.prototype.finalize = function finalize () {
    if (this._finalized) {
        throw "Already finalized";
    }
    var gl = this.model.scene.canvas.gl;
    var colorsLength = this._colors.length;
    var flagsLength = colorsLength;
    if (colorsLength > 0) {
        var notNormalized = false;
        this._state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(this._colors), this._colors.length, 4, gl.DYNAMIC_DRAW, notNormalized);
        this._colors = []; // Release memory
    }
    if (flagsLength > 0) {
        // Because we only build flags arrays here, 
        // get their length from the colors array
        var notNormalized$1 = false;
        var normalized = true;
        this._state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, notNormalized$1);
        this._state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, normalized);
    }
    if (this.model.scene.entityOffsetsEnabled) {
        if (this._offsets.length > 0) {
            var notNormalized$2 = false;
            this._state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, gl.DYNAMIC_DRAW, notNormalized$2);
            this._offsets = []; // Release memory
        }
    }
    if (this._modelMatrixCol0.length > 0) {
        var normalized$1 = false;
        this._state.modelMatrixCol0Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, gl.STATIC_DRAW, normalized$1);
        this._state.modelMatrixCol1Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, gl.STATIC_DRAW, normalized$1);
        this._state.modelMatrixCol2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, gl.STATIC_DRAW, normalized$1);
        this._modelMatrixCol0 = [];
        this._modelMatrixCol1 = [];
        this._modelMatrixCol2 = [];
    }
    this._finalized = true;
};

// The following setters are called by PerformanceMesh, in turn called by PerformanceNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.

LinesInstancingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

LinesInstancingLayer.prototype.setVisible = function setVisible (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setXRayed = function setXRayed (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setSelected = function setSelected (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setEdges = function setEdges (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    } else {
        this._numEdgesLayerPortions--;
        this.model.numEdgesLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

LinesInstancingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

LinesInstancingLayer.prototype.setPickable = function setPickable (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags2(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setCulled = function setCulled (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

LinesInstancingLayer.prototype.setColor = function setColor (portionId, color) { // RGBA color is normalized as ints
    if (!this._finalized) {
        throw "Not finalized";
    }
    tempUint8Vec4$1[0] = color[0];
    tempUint8Vec4$1[1] = color[1];
    tempUint8Vec4$1[2] = color[2];
    tempUint8Vec4$1[3] = color[3];
    this._state.colorsBuf.setData(tempUint8Vec4$1, portionId * 4, 4);
};

LinesInstancingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

LinesInstancingLayer.prototype._setFlags = function _setFlags (portionId, flags, meshTransparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var edges = !!(flags & ENTITY_FLAGS.EDGES);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Normal fill

    var f0;
    if (!visible || culled || xrayed) {
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (meshTransparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Emphasis fill

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Edges

    var f2 = 0;
    if (!visible || culled) {
        f2 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f2 = RENDER_PASSES.EDGES_SELECTED;
    } else if (highlighted) {
        f2 = RENDER_PASSES.EDGES_HIGHLIGHTED;
    } else if (xrayed) {
        f2 = RENDER_PASSES.EDGES_XRAYED;
    } else if (edges) {
        if (meshTransparent) {
            f2 = RENDER_PASSES.EDGES_COLOR_TRANSPARENT;
        } else {
            f2 = RENDER_PASSES.EDGES_COLOR_OPAQUE;
        }
    } else {
        f2 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    tempUint8Vec4$1[0] = f0; // x - normal fill
    tempUint8Vec4$1[1] = f1; // y - emphasis fill
    tempUint8Vec4$1[2] = f2; // z - edges
    tempUint8Vec4$1[3] = f3; // w - pick

    this._state.flagsBuf.setData(tempUint8Vec4$1, portionId * 4, 4);
};

LinesInstancingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;
    tempUint8Vec4$1[0] = clippable;

    this._state.flags2Buf.setData(tempUint8Vec4$1, portionId * 4, 4);
};

LinesInstancingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    tempVec3fa$1[0] = offset[0];
    tempVec3fa$1[1] = offset[1];
    tempVec3fa$1[2] = offset[2];
    this._state.offsetsBuf.setData(tempVec3fa$1, portionId * 3, 3);
};

// ---------------------- NORMAL RENDERING -----------------------------------

LinesInstancingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }

    if (this._linesInstancingRenderers.colorRenderer) {
        this._linesInstancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

LinesInstancingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._linesInstancingRenderers.colorRenderer) {
        this._linesInstancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
    }
};

// ---------------------- RENDERING SAO POST EFFECT TARGETS --------------

LinesInstancingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
};

// ---------------------- EMPHASIS RENDERING -----------------------------------

LinesInstancingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._linesInstancingRenderers.silhouetteRenderer) {
        this._linesInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

LinesInstancingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._linesInstancingRenderers.silhouetteRenderer) {
        this._linesInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

LinesInstancingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._linesInstancingRenderers.silhouetteRenderer) {
        this._linesInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

// ---------------------- EDGES RENDERING -----------------------------------

LinesInstancingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
};

// ---------------------- OCCLUSION CULL RENDERING -----------------------------------

LinesInstancingLayer.prototype.drawOcclusion = function drawOcclusion (renderFlags, frameCtx) {
};

// ---------------------- SHADOW BUFFER RENDERING -----------------------------------

LinesInstancingLayer.prototype.drawShadow = function drawShadow (renderFlags, frameCtx) {
};

//---- PICKING ----------------------------------------------------------------------------------------------------

LinesInstancingLayer.prototype.drawPickMesh = function drawPickMesh (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawPickDepths = function drawPickDepths (renderFlags, frameCtx) {
};

LinesInstancingLayer.prototype.drawPickNormals = function drawPickNormals (renderFlags, frameCtx) {
};


LinesInstancingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.modelMatrixCol0Buf) {
        state.modelMatrixCol0Buf.destroy();
        state.modelMatrixCol0Buf = null;
    }
    if (state.modelMatrixCol1Buf) {
        state.modelMatrixCol1Buf.destroy();
        state.modelMatrixCol1Buf = null;
    }
    if (state.modelMatrixCol2Buf) {
        state.modelMatrixCol2Buf.destroy();
        state.modelMatrixCol2Buf = null;
    }
    if (state.indicesBuf) {
        state.indicesBuf.destroy();
        state.indicessBuf = null;
    }
    state.destroy();
};

var tempVec3a$k = math.vec3();

/**
 * @private
 */
var PointsBatchingColorRenderer = function PointsBatchingColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsBatchingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};

PointsBatchingColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsBatchingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, pointsBatchingLayer, renderPass) {

    var scene = this._scene;
    var camera = scene.camera;
    var model = pointsBatchingLayer.model;
    var gl = scene.canvas.gl;
    var state = pointsBatchingLayer._state;
    var rtcCenter = pointsBatchingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = pointsBatchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$k);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, pointsBatchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
    }

    if (pointsMaterial.filterIntensity) {
        gl.uniform2f(this._uIntensityRange, pointsMaterial.minIntensity, pointsMaterial.maxIntensity);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    gl.drawArrays(gl.POINTS, 0, state.positionsBuf.numItems);
};

PointsBatchingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var pointsMaterial = scene.pointsMaterial._state;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader(scene));

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (pointsMaterial.filterIntensity) {
        this._uIntensityRange = program.getLocation("intensityRange");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsBatchingColorRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    var project = scene.camera.project;

    program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsBatchingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsBatchingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial;
    var src = [];

    src.push("// Points batching color vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("uniform mat4 worldMatrix;");

    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (pointsMaterial.filterIntensity) {
        src.push("uniform vec2 intensityRange;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    if (pointsMaterial.filterIntensity) {
        src.push("float intensity = float(color.a) / 255.0;");
        src.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {");
        src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
        src.push("} else {");
    }

    src.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    if (pointsMaterial.filterIntensity) {
        src.push("}");
    }
    src.push("}");
    return src;
};

PointsBatchingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];

    src.push("// Points batching color fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("   gl_FragColor = vColor;");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

PointsBatchingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsBatchingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var defaultColor = new Float32Array([1, 1, 1]);
var tempVec3a$j = math.vec3();

/**
 * @private
 */
var PointsBatchingSilhouetteRenderer = function PointsBatchingSilhouetteRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsBatchingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsBatchingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsBatchingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, pointsBatchingLayer, renderPass) {

    var model = pointsBatchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = pointsBatchingLayer._state;
    var rtcCenter = pointsBatchingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, defaultColor);
    }

    var viewMat = (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix;
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMat);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = pointsBatchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$j);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, pointsBatchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    gl.drawArrays(gl.POINTS, 0, state.positionsBuf.numItems);
};

PointsBatchingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsBatchingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsBatchingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsBatchingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points batching silhouette vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    src.push("uniform vec4 color;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");

    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsBatchingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points batching silhouette vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("  if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

PointsBatchingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsBatchingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$i = math.vec3();

/**
 * @private
 */
var PointsBatchingPickMeshRenderer = function PointsBatchingPickMeshRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsBatchingPickMeshRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsBatchingPickMeshRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + (this._scene.pointsMaterial.hash);
};

PointsBatchingPickMeshRenderer.prototype.drawLayer = function drawLayer (frameCtx, pointsBatchingLayer, renderPass) {

    var model = pointsBatchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = pointsBatchingLayer._state;
    var rtcCenter = pointsBatchingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate(pointsBatchingLayer);
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = pointsBatchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$i);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, pointsBatchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    if (this._aPickColor) {
        this._aPickColor.bindArrayBuffer(state.pickColorsBuf);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    gl.drawArrays(gl.POINTS, 0, state.positionsBuf.numItems);
};

PointsBatchingPickMeshRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aPickColor = program.getAttribute("pickColor");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsBatchingPickMeshRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    this._program.bind();
    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);
};

PointsBatchingPickMeshRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsBatchingPickMeshRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points batching pick mesh vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 pickColor;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vPickColor;");

    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("gl_PointSize += 10.0;");
    src.push("  }");
    src.push("}");
    return src;
};

PointsBatchingPickMeshRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points batching pick mesh vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vPickColor; ");
    src.push("}");
    return src;
};

PointsBatchingPickMeshRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsBatchingPickMeshRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$h = math.vec3();

/**
 * @private
 */
var PointsBatchingPickDepthRenderer = function PointsBatchingPickDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsBatchingPickDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsBatchingPickDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + (this._scene.pointsMaterial.hash);
};

PointsBatchingPickDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, pointsBatchingLayer, renderPass) {

    var model = pointsBatchingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = pointsBatchingLayer._state;
    var rtcCenter = pointsBatchingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var viewMatrix = rtcCenter ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, viewMatrix);
    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniform1f(this._uPickZNear, frameCtx.pickZNear);
    gl.uniform1f(this._uPickZFar, frameCtx.pickZFar);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(frameCtx.pickZFar + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = pointsBatchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$h);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    //=============================================================
    // TODO: Use drawElements count and offset to draw only one entity
    //=============================================================

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, pointsBatchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    if (this._aFlags) {
        this._aFlags.bindArrayBuffer(state.flagsBuf);
    }

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    gl.drawArrays(gl.POINTS, 0, state.positionsBuf.numItems);
};

PointsBatchingPickDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._uPickZNear = program.getLocation("pickZNear");
    this._uPickZFar = program.getLocation("pickZFar");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsBatchingPickDepthRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();
};

PointsBatchingPickDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsBatchingPickDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points batched pick depth vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform bool pickInvisible;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vViewPosition;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vViewPosition = viewPosition;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("gl_PointSize += 10.0;");
    src.push("  }");
    src.push("}");
    return src;
};

PointsBatchingPickDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points batched pick depth fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    src.push("uniform float pickZNear;");
    src.push("uniform float pickZFar;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("uniform bool sectionPlaneActive" + i$1 + ";");
            src.push("uniform vec3 sectionPlanePos" + i$1 + ";");
            src.push("uniform vec3 sectionPlaneDir" + i$1 + ";");
        }
    }
    src.push("varying vec4 vViewPosition;");
    src.push("vec4 packDepth(const in float depth) {");
    src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");
    src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");
    src.push("  vec4 res = fract(depth * bitShift);");
    src.push("  res -= res.xxyz * bitMask;");
    src.push("  return res;");
    src.push("}");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("      if (sectionPlaneActive" + i + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");
    src.push("    gl_FragColor = packDepth(zNormalizedDepth); ");  // Must be linear depth
    src.push("}");
    return src;
};

PointsBatchingPickDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsBatchingPickDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$g = math.vec3();

/**
 * @private
 */
var PointsBatchingOcclusionRenderer = function PointsBatchingOcclusionRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsBatchingOcclusionRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsBatchingOcclusionRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + (this._scene.pointsMaterial.hash);
};

PointsBatchingOcclusionRenderer.prototype.drawLayer = function drawLayer (frameCtx, pointsBatchingLayer, renderPass) {

    var model = pointsBatchingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = pointsBatchingLayer._state;
    var camera = scene.camera;
    var rtcCenter = pointsBatchingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate(pointsBatchingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = pointsBatchingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$g);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, pointsBatchingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);

    if (this._aFlags2) { // Won't be in shader when not clipping
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    gl.drawArrays(gl.POINTS, 0, state.positionsBuf.numItems);
};

PointsBatchingOcclusionRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsBatchingOcclusionRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsBatchingOcclusionRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsBatchingOcclusionRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var clipping = scene._sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];
    src.push("// Points batching occlusion vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE
    // Only opaque objects can be occluders

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("  } else {");
    src.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); ");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("      vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("      vWorldPosition = worldPosition;");
        src.push("      vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("  gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("  }");
    src.push("}");
    return src;
};

PointsBatchingOcclusionRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points batching occlusion fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("      float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("      if (sectionPlaneActive" + i$1 + ") {");
            src.push("          dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("      }");
        }
        src.push("      if (dist > 0.0) { discard; }");
        src.push("  }");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); "); // Occluders are blue
    src.push("}");
    return src;
};

PointsBatchingOcclusionRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsBatchingOcclusionRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var PointsBatchingRenderers = function PointsBatchingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$4 = { colorRenderer: { configurable: true },silhouetteRenderer: { configurable: true },pickMeshRenderer: { configurable: true },pickDepthRenderer: { configurable: true },occlusionRenderer: { configurable: true } };

PointsBatchingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
    if (this._pickMeshRenderer && (!this._pickMeshRenderer.getValid())) {
        this._pickMeshRenderer.destroy();
        this._pickMeshRenderer = null;
    }
    if (this._pickDepthRenderer && (!this._pickDepthRenderer.getValid())) {
        this._pickDepthRenderer.destroy();
        this._pickDepthRenderer = null;
    }
    if (this._occlusionRenderer && this._occlusionRenderer.getValid() === false) {
        this._occlusionRenderer.destroy();
        this._occlusionRenderer = null;
    }
};

prototypeAccessors$4.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new PointsBatchingColorRenderer(this._scene);
    }
    return this._colorRenderer;
};

prototypeAccessors$4.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new PointsBatchingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

prototypeAccessors$4.pickMeshRenderer.get = function () {
    if (!this._pickMeshRenderer) {
        this._pickMeshRenderer = new PointsBatchingPickMeshRenderer(this._scene);
    }
    return this._pickMeshRenderer;
};

prototypeAccessors$4.pickDepthRenderer.get = function () {
    if (!this._pickDepthRenderer) {
        this._pickDepthRenderer = new PointsBatchingPickDepthRenderer(this._scene);
    }
    return this._pickDepthRenderer;
};

prototypeAccessors$4.occlusionRenderer.get = function () {
    if (!this._occlusionRenderer) {
        this._occlusionRenderer = new PointsBatchingOcclusionRenderer(this._scene);
    }
    return this._occlusionRenderer;
};

PointsBatchingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
    if (this._pickMeshRenderer) {
        this._pickMeshRenderer.destroy();
    }
    if (this._pickDepthRenderer) {
        this._pickDepthRenderer.destroy();
    }
    if (this._occlusionRenderer) {
        this._occlusionRenderer.destroy();
    }
};

Object.defineProperties( PointsBatchingRenderers.prototype, prototypeAccessors$4 );

var cachedRenderers$1 = {};

/**
 * @private
 */
function getPointsBatchingRenderers(scene) {
    var sceneId = scene.id;
    var renderers = cachedRenderers$1[sceneId];
    if (!renderers) {
        renderers = new PointsBatchingRenderers(scene);
        cachedRenderers$1[sceneId] = renderers;
        renderers._compile();
        scene.on("compile", function () {
            renderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachedRenderers$1[sceneId];
            renderers._destroy();
        });
    }
    return renderers;
}

var bigIndicesSupported$1 = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];

/**
 * @private
 */
var PointsBatchingBuffer = function PointsBatchingBuffer(maxGeometryBatchSize) {
    if ( maxGeometryBatchSize === void 0 ) maxGeometryBatchSize = 5000000;


    if (bigIndicesSupported$1) {
        if (maxGeometryBatchSize > 5000000) {
            maxGeometryBatchSize = 5000000;
        }
    } else {
        if (maxGeometryBatchSize > 65530) {
            maxGeometryBatchSize = 65530;
        }
    }

    this.maxVerts = maxGeometryBatchSize;
    this.maxIndices = maxGeometryBatchSize * 3; // Rough rule-of-thumb
    this.positions = [];
    this.colors = [];
    this.intensities = [];
    this.pickColors = [];
    this.flags = [];
    this.flags2 = [];
    this.offsets = [];
};

var tempVec3a$f = math.vec4();
var tempVec3b$5 = math.vec4();
var tempVec4a$3 = math.vec4([0, 0, 0, 1]);
var tempVec4b$3 = math.vec4([0, 0, 0, 1]);
var tempVec4c$3 = math.vec4([0, 0, 0, 1]);
var tempOBB3 = math.OBB3();

/**
 * @private
 */
var PointsBatchingLayer = function PointsBatchingLayer(model, cfg) {

    /**
     * State sorting key.
     * @type {string}
     */
    this.sortId = "PointsBatchingLayer";

    /**
     * Index of this PointCloudLayer in {@link PerformanceModel#_layerList}.
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._pointsBatchingRenderers = getPointsBatchingRenderers(model.scene);
    this.model = model;
    this._buffer = new PointsBatchingBuffer(cfg.maxGeometryBatchSize);
    this._scratchMemory = cfg.scratchMemory;

    this._state = new RenderState({
        positionsBuf: null,
        offsetsBuf: null,
        colorsBuf: null,
        flagsBuf: null,
        flags2Buf: null,
        positionsDecodeMatrix: math.mat4(),
        rtcCenter: null
    });

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    this._modelAABB = math.collapseAABB3(); // Model-space AABB
    this._portions = [];

    this._finalized = false;
    this._positionsDecodeMatrix = cfg.positionsDecodeMatrix;
    this._preCompressed = (!!this._positionsDecodeMatrix);

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    /**
     * The axis-aligned World-space boundary of this PointCloudLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();
};

/**
 * Tests if there is room for another portion in this PointCloudLayer.
 *
 * @param lenPositions Number of positions we'd like to create in the portion.
 * @returns {boolean} True if OK to create another portion.
 */
PointsBatchingLayer.prototype.canCreatePortion = function canCreatePortion (lenPositions) {
    if (this._finalized) {
        throw "Already finalized";
    }
    return ((this._buffer.positions.length + lenPositions) < (this._buffer.maxVerts * 3));
};

/**
 * Creates a new portion within this PointCloudLayer, returns the new portion ID.
 *
 * Gives the portion the specified geometry, color and matrix.
 *
 * @param cfg.positions Flat float Local-space positions array.
 * @param [cfg.colorsCompressed] Quantized RGB colors [0..255,0..255,0..255,0..255]
 * @param [cfg.colors] Flat float colors array.
 * @param cfg.color Float RGB color [0..1,0..1,0..1]

 * @param [cfg.meshMatrix] Flat float 4x4 matrix
 * @param [cfg.worldMatrix] Flat float 4x4 matrix
 * @param cfg.worldAABB Flat float AABB World-space AABB
 * @param cfg.pickColor Quantized pick color
 * @returns {number} Portion ID
 */
PointsBatchingLayer.prototype.createPortion = function createPortion (cfg) {

    if (this._finalized) {
        throw "Already finalized";
    }

    var positions = cfg.positions;
    var color = cfg.color;
    var colorsCompressed = cfg.colorsCompressed;
    var colors = cfg.colors;
    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.worldAABB;
    var pickColor = cfg.pickColor;

    var buffer = this._buffer;
    var positionsIndex = buffer.positions.length;
    var vertsIndex = positionsIndex / 3;
    var numVerts = positions.length / 3;
    var lenPositions = positions.length;

    if (this._preCompressed) {

        for (var i = 0, len = positions.length; i < len; i++) {
            buffer.positions.push(positions[i]);
        }

        var bounds = geometryCompressionUtils.getPositionsBounds(positions);

        var min = geometryCompressionUtils.decompressPosition(bounds.min, this._positionsDecodeMatrix, tempVec3a$f);
        var max = geometryCompressionUtils.decompressPosition(bounds.max, this._positionsDecodeMatrix, tempVec3b$5);

        worldAABB[0] = min[0];
        worldAABB[1] = min[1];
        worldAABB[2] = min[2];
        worldAABB[3] = max[0];
        worldAABB[4] = max[1];
        worldAABB[5] = max[2];

        if (worldMatrix) {
            math.AABB3ToOBB3(worldAABB, tempOBB3);
            math.transformOBB3(worldMatrix, tempOBB3);
            math.OBB3ToAABB3(tempOBB3, worldAABB);
        }

    } else {

        var positionsBase = buffer.positions.length;

        for (var i$1 = 0, len$1 = positions.length; i$1 < len$1; i$1++) {
            buffer.positions.push(positions[i$1]);
        }

        if (meshMatrix) {

            for (var i$2 = positionsBase, len$2 = positionsBase + lenPositions; i$2 < len$2; i$2 += 3) {

                tempVec4a$3[0] = buffer.positions[i$2 + 0];
                tempVec4a$3[1] = buffer.positions[i$2 + 1];
                tempVec4a$3[2] = buffer.positions[i$2 + 2];

                math.transformPoint4(meshMatrix, tempVec4a$3, tempVec4b$3);

                buffer.positions[i$2 + 0] = tempVec4b$3[0];
                buffer.positions[i$2 + 1] = tempVec4b$3[1];
                buffer.positions[i$2 + 2] = tempVec4b$3[2];

                math.expandAABB3Point3(this._modelAABB, tempVec4b$3);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4b$3, tempVec4c$3);
                    math.expandAABB3Point3(worldAABB, tempVec4c$3);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4b$3);
                }
            }

        } else {

            for (var i$3 = positionsBase, len$3 = positionsBase + lenPositions; i$3 < len$3; i$3 += 3) {

                tempVec4a$3[0] = buffer.positions[i$3 + 0];
                tempVec4a$3[1] = buffer.positions[i$3 + 1];
                tempVec4a$3[2] = buffer.positions[i$3 + 2];

                math.expandAABB3Point3(this._modelAABB, tempVec4a$3);

                if (worldMatrix) {
                    math.transformPoint4(worldMatrix, tempVec4a$3, tempVec4b$3);
                    math.expandAABB3Point3(worldAABB, tempVec4b$3);
                } else {
                    math.expandAABB3Point3(worldAABB, tempVec4a$3);
                }
            }
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    if (colorsCompressed) {
        for (var i$4 = 0, len$4 = colorsCompressed.length; i$4 < len$4; i$4++) {
            buffer.colors.push(colorsCompressed[i$4]);
        }

    } else if (colors) {
        for (var i$5 = 0, len$5 = colors.length; i$5 < len$5; i$5++) {
            buffer.colors.push(colors[i$5] * 255);
        }

    } else if (color) {

        var r = color[0]; // Color is pre-quantized by PerformanceModel
        var g = color[1];
        var b = color[2];
        var a = 1.0;

        for (var i$6 = 0; i$6 < numVerts; i$6++) {
            buffer.colors.push(r);
            buffer.colors.push(g);
            buffer.colors.push(b);
            buffer.colors.push(a);
        }
    }

    {
        var pickColorsBase = buffer.pickColors.length;
        var lenPickColors = numVerts * 4;
        for (var i$7 = pickColorsBase, len$6 = pickColorsBase + lenPickColors; i$7 < len$6; i$7 += 4) {
            buffer.pickColors.push(pickColor[0]);
            buffer.pickColors.push(pickColor[1]);
            buffer.pickColors.push(pickColor[2]);
            buffer.pickColors.push(pickColor[3]);
        }
    }

    if (this.model.scene.entityOffsetsEnabled) {
        for (var i$8 = 0; i$8 < numVerts; i$8++) {
            buffer.offsets.push(0);
            buffer.offsets.push(0);
            buffer.offsets.push(0);
        }
    }

    var portionId = this._portions.length / 2;

    this._portions.push(vertsIndex);
    this._portions.push(numVerts);

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

/**
 * Builds batch VBOs from appended geometries.
 * No more portions can then be created.
 */
PointsBatchingLayer.prototype.finalize = function finalize () {

    if (this._finalized) {
        this.model.error("Already finalized");
        return;
    }

    var state = this._state;
    var gl = this.model.scene.canvas.gl;
    var buffer = this._buffer;

    if (buffer.positions.length > 0) {
        if (this._preCompressed) {
            state.positionsDecodeMatrix = this._positionsDecodeMatrix;
            var positions = new Uint16Array(buffer.positions);
            state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, buffer.positions.length, 3, gl.STATIC_DRAW);
        } else {
            var positions$1 = new Float32Array(buffer.positions);
            var quantizedPositions = quantizePositions(positions$1, this._modelAABB, state.positionsDecodeMatrix);
            state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, buffer.positions.length, 3, gl.STATIC_DRAW);
        }
    }

    if (buffer.colors.length > 0) {
        var colors = new Uint8Array(buffer.colors);
        var normalized = false;
        state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colors, buffer.colors.length, 4, gl.STATIC_DRAW, normalized);
    }

    if (buffer.positions.length > 0) { // Because we build flags arrays here, get their length from the positions array
        var flagsLength = (buffer.positions.length / 3) * 4;
        var flags = new Uint8Array(flagsLength);
        var flags2 = new Uint8Array(flagsLength);
        var notNormalized = false;
        var normalized$1 = true;
        state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags, flags.length, 4, gl.DYNAMIC_DRAW, notNormalized);
        state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, flags2, flags2.length, 4, gl.DYNAMIC_DRAW, normalized$1);
    }

    if (buffer.pickColors.length > 0) {
        var pickColors = new Uint8Array(buffer.pickColors);
        var normalized$2 = false;
        state.pickColorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, pickColors, buffer.pickColors.length, 4, gl.STATIC_DRAW, normalized$2);
    }

    if (this.model.scene.entityOffsetsEnabled) {
        if (buffer.offsets.length > 0) {
            var offsets = new Float32Array(buffer.offsets);
            state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, offsets, buffer.offsets.length, 3, gl.DYNAMIC_DRAW);
        }
    }

    this._buffer = null;
    this._finalized = true;
};

PointsBatchingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

PointsBatchingLayer.prototype.setVisible = function setVisible (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setXRayed = function setXRayed (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setSelected = function setSelected (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setEdges = function setEdges (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    // Not applicable to point clouds
};

PointsBatchingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

PointsBatchingLayer.prototype.setCulled = function setCulled (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

PointsBatchingLayer.prototype.setPickable = function setPickable (portionId, flags, transparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype.setColor = function setColor (portionId, color) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstColor = vertexBase * 4;
    var lenColor = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenColor);
    var r = color[0];
    var g = color[1];
    var b = color[2];
    for (var i = 0; i < lenColor; i += 4) {
        tempArray[i + 0] = r;
        tempArray[i + 1] = g;
        tempArray[i + 2] = b;
    }
    this._state.colorsBuf.setData(tempArray, firstColor, lenColor);
};

PointsBatchingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

PointsBatchingLayer.prototype._setFlags = function _setFlags (portionId, flags, transparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Normal fill

    var f0;
    if (!visible || culled || xrayed) {
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (transparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Emphasis fill

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = f0; // x - normal fill
        tempArray[i + 1] = f1; // y - emphasis fill
        tempArray[i + 2] = 0; // z - edges - don't care
        tempArray[i + 3] = f3; // w - pick
    }

    this._state.flagsBuf.setData(tempArray, firstFlag, lenFlags);
};

PointsBatchingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstFlag = vertexBase * 4;
    var lenFlags = numVerts * 4;
    var tempArray = this._scratchMemory.getUInt8Array(lenFlags);

    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;

    for (var i = 0; i < lenFlags; i += 4) {
        tempArray[i + 0] = clippable;
    }

    this._state.flags2Buf.setData(tempArray, firstFlag, lenFlags);
};

PointsBatchingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    var portionsIdx = portionId * 2;
    var vertexBase = this._portions[portionsIdx];
    var numVerts = this._portions[portionsIdx + 1];
    var firstOffset = vertexBase * 3;
    var lenOffsets = numVerts * 3;
    var tempArray = this._scratchMemory.getFloat32Array(lenOffsets);
    var x = offset[0];
    var y = offset[1];
    var z = offset[2];
    for (var i = 0; i < lenOffsets; i += 3) {
        tempArray[i + 0] = x;
        tempArray[i + 1] = y;
        tempArray[i + 2] = z;
    }
    this._state.offsetsBuf.setData(tempArray, firstOffset, lenOffsets);
};

//-- NORMAL RENDERING ----------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._pointsBatchingRenderers.colorRenderer) {
        this._pointsBatchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

PointsBatchingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._pointsBatchingRenderers.colorRenderer) {
        this._pointsBatchingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
    }
};

// -- RENDERING SAO POST EFFECT TARGETS ----------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
};

// -- EMPHASIS RENDERING -------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.silhouetteRenderer) {
        this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

PointsBatchingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.silhouetteRenderer) {
        this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

PointsBatchingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.silhouetteRenderer) {
        this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

//-- EDGES RENDERING -----------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
};

//---- PICKING ----------------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawPickMesh = function drawPickMesh (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.pickMeshRenderer) {
        this._pointsBatchingRenderers.pickMeshRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

PointsBatchingLayer.prototype.drawPickDepths = function drawPickDepths (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.pickDepthRenderer) {
        this._pointsBatchingRenderers.pickDepthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

PointsBatchingLayer.prototype.drawPickNormals = function drawPickNormals (renderFlags, frameCtx) {
};

//---- OCCLUSION TESTING -------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawOcclusion = function drawOcclusion (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsBatchingRenderers.occlusionRenderer) {
        this._pointsBatchingRenderers.occlusionRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

//---- SHADOWS -----------------------------------------------------------------------------------------------------

PointsBatchingLayer.prototype.drawShadow = function drawShadow (renderFlags, frameCtx) {
};

PointsBatchingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.pickColorsBuf) {
        state.pickColorsBuf.destroy();
        state.pickColorsBuf = null;
    }
    state.destroy();
};

var tempVec3a$e = math.vec3();

/**
 * @private
 */
var PointsInstancingColorRenderer = function PointsInstancingColorRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsInstancingColorRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};

PointsInstancingColorRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingColorRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);
    this._aColor.bindArrayBuffer(state.colorsBuf);

    if (pointsMaterial.filterIntensity) {
        gl.uniform2f(this._uIntensityRange, pointsMaterial.minIntensity, pointsMaterial.maxIntensity);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$e);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingColorRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var pointsMaterial = scene.pointsMaterial._state;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aOffset = program.getAttribute("offset");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uOcclusionTexture = "uOcclusionTexture";

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (pointsMaterial.filterIntensity) {
        this._uIntensityRange = program.getLocation("intensityRange");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingColorRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsInstancingColorRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingColorRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points instancing color vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (pointsMaterial.filterIntensity) {
        src.push("uniform vec2 intensityRange;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vColor;");

    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE | COLOR_TRANSPARENT

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    if (pointsMaterial.filterIntensity) {
        src.push("float intensity = float(color.a) / 255.0;");
        src.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {");
        src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
        src.push("} else {");
    }

    src.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }

    src.push("vec4 clipPos = projMatrix * viewPosition;");

    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    if (pointsMaterial.filterIntensity) {
        src.push("}");
    }
    src.push("}");
    return src;
};

PointsInstancingColorRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing color fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vColor;");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("   gl_FragColor = vColor;");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

PointsInstancingColorRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingColorRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$d = math.vec3();

/**
 * @private
 */
var PointsInstancingSilhouetteRenderer = function PointsInstancingSilhouetteRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsInstancingSilhouetteRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingSilhouetteRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingSilhouetteRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate(instancingLayer.model.scene);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
        var material = scene.xrayMaterial._state;
        var fillColor = material.fillColor;
        var fillAlpha = material.fillAlpha;
        gl.uniform4f(this._uColor, fillColor[0], fillColor[1], fillColor[2], fillAlpha);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
        var material$1 = scene.highlightMaterial._state;
        var fillColor$1 = material$1.fillColor;
        var fillAlpha$1 = material$1.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$1[0], fillColor$1[1], fillColor$1[2], fillAlpha$1);

    } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
        var material$2 = scene.selectedMaterial._state;
        var fillColor$2 = material$2.fillColor;
        var fillAlpha$2 = material$2.fillAlpha;
        gl.uniform4f(this._uColor, fillColor$2[0], fillColor$2[1], fillColor$2[2], fillAlpha$2);

    } else {
        gl.uniform4fv(this._uColor, math.vec3([1, 1, 1]));
    }

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$d);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf, gl.UNSIGNED_BYTE, true);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf, gl.UNSIGNED_BYTE, true);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0); // TODO: Is this needed
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) {
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingSilhouetteRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uColor = program.getLocation("color");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if ( scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingSilhouetteRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if ( scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsInstancingSilhouetteRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingSilhouetteRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points instancing silhouette vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    src.push("uniform vec4 color;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("void main(void) {");

    // flags.y = NOT_RENDERED | SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED
    // renderPass = SILHOUETTE_HIGHLIGHTED | SILHOUETTE_SELECTED | | SILHOUETTE_XRAYED

    src.push("if (int(flags.y) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");

    src.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsInstancingSilhouetteRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing silhouette fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("uniform vec4 color;");
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = color;");
    src.push("}");
    return src;
};

PointsInstancingSilhouetteRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingSilhouetteRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$c = math.vec3();

/**
 * @private
 */
var PointsInstancingPickMeshRenderer = function PointsInstancingPickMeshRenderer(scene) {

    this._scene = scene;
    this._hash = this._getHash();

    this._allocate();
};

PointsInstancingPickMeshRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingPickMeshRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingPickMeshRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx);
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(camera.project.far + 1.0) / Math.LN2); // TODO: Far from pick project matrix?
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPickColor.bindArrayBuffer(state.pickColorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aPickColor.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$c);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aPickColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingPickMeshRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;

    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._uRenderPass = program.getLocation("renderPass");
    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aPickColor = program.getAttribute("pickColor");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingPickMeshRenderer.prototype._bindProgram = function _bindProgram (frameCtx) {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;

    program.bind();

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);
};

PointsInstancingPickMeshRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingPickMeshRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points instancing pick mesh vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 pickColor;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");


    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");

    src.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsInstancingPickMeshRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing pick mesh fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vPickColor;");
    src.push("void main(void) {");

    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("gl_FragColor = vPickColor; ");
    src.push("}");
    return src;
};

PointsInstancingPickMeshRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingPickMeshRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$b = math.vec3();

/**
 * @private
 */
var PointsInstancingPickDepthRenderer = function PointsInstancingPickDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsInstancingPickDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingPickDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingPickDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate(instancingLayer);
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    var camera = scene.camera;

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniform1i(this._uPickInvisible, frameCtx.pickInvisible);

    var pickViewMatrix = frameCtx.pickViewMatrix || camera.viewMatrix;
    var rtcPickViewMatrix = (rtcCenter) ? createRTCViewMat(pickViewMatrix, rtcCenter) : pickViewMatrix;

    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcPickViewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);

    gl.uniform1f(this._uPickZNear, frameCtx.pickZNear);
    gl.uniform1f(this._uPickZFar, frameCtx.pickZFar);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(frameCtx.pickZFar + 1.0) / Math.LN2); // TODO: Far from pick project matrix
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$b);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);

    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingPickDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPickInvisible = program.getLocation("pickInvisible");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPickZNear = program.getLocation("pickZNear");
    this._uPickZFar = program.getLocation("pickZFar");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingPickDepthRenderer.prototype._bindProgram = function _bindProgram () {
    this._program.bind();

};

PointsInstancingPickDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingPickDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points instancing pick depth vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");

    src.push("attribute vec3 position;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform bool pickInvisible;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }

    src.push("varying vec4 vViewPosition;");
    src.push("void main(void) {");

    // flags.w = NOT_RENDERED | PICK
    // renderPass = PICK

    src.push("if (int(flags.w) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");

    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");
    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
        src.push("  vFlags2 = flags2;");
    }
    src.push("  vViewPosition = viewPosition;");
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsInstancingPickDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing pick depth fragment shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }

    src.push("uniform float pickZNear;");
    src.push("uniform float pickZFar;");

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec4 vViewPosition;");
    src.push("vec4 packDepth(const in float depth) {");
    src.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);");
    src.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);");
    src.push("  vec4 res = fract(depth * bitShift);");
    src.push("  res -= res.xxyz * bitMask;");
    src.push("  return res;");
    src.push("}");
    src.push("void main(void) {");

    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));");
    src.push("    gl_FragColor = packDepth(zNormalizedDepth); "); // Must be linear depth
    src.push("}");
    return src;
};

PointsInstancingPickDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingPickDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$a = math.vec3();

/**
 * @private
 */
var PointsInstancingOcclusionRenderer = function PointsInstancingOcclusionRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsInstancingOcclusionRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingOcclusionRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingOcclusionRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);
    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$a);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    if (this._aColor) {
        this._aColor.bindArrayBuffer(state.colorsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);
    }

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    // Cleanup

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    if (this._aColor) {
        instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    }
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);
    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }
    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingOcclusionRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");
    this._uSectionPlanes = [];

    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");

    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingOcclusionRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsInstancingOcclusionRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingOcclusionRenderer.prototype._buildVertexShader = function _buildVertexShader () {

    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];

    src.push("// Points instancing occlusion vertex shader");

    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }

    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");

    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }

    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");

    src.push("attribute vec4 modelMatrixCol0;"); // Modeling matrix
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");

    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }

    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);");

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }

    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("  vWorldPosition = worldPosition;");
    }

    src.push("vec4 clipPos = projMatrix * viewPosition;");

    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }

    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsInstancingOcclusionRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing occlusion vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("void main(void) {");
    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0; i$1 < sectionPlanesState.sectionPlanes.length; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); "); // Occluders are blue
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

PointsInstancingOcclusionRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingOcclusionRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$9 = math.vec3();

/**
 * @private
 */
var PointsInstancingDepthRenderer = function PointsInstancingDepthRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._allocate();
};

PointsInstancingDepthRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingDepthRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash;
};

PointsInstancingDepthRenderer.prototype.drawLayer = function drawLayer (frameCtx, instancingLayer, renderPass) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var camera = scene.camera;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;
    var rtcCenter = instancingLayer._state.rtcCenter;
    var pointsMaterial = scene.pointsMaterial._state;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram();
    }

    gl.uniform1i(this._uRenderPass, renderPass);

    gl.uniformMatrix4fv(this._uWorldMatrix, false, model.worldMatrix);
    gl.uniformMatrix4fv(this._uViewMatrix, false, (rtcCenter) ? createRTCViewMat(camera.viewMatrix, rtcCenter) : camera.viewMatrix);

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$9);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    gl.uniform1f(this._uPointSize, pointsMaterial.pointSize);
    var nearPlaneHeight = (scene.camera.projection === "ortho") ? 1.0 : (gl.drawingBufferHeight / (2 * Math.tan(0.5 * scene.camera.perspective.fov * Math.PI / 180.0)));
    gl.uniform1f(this._uNearPlaneHeight, nearPlaneHeight);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingDepthRenderer.prototype._allocate = function _allocate () {

    var scene = this._scene;
    var gl = scene.canvas.gl;

    this._program = new Program(gl, this._buildShader());

    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }

    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");

    var program = this._program;

    this._uRenderPass = program.getLocation("renderPass");

    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uWorldMatrix = program.getLocation("worldMatrix");
    this._uViewMatrix = program.getLocation("viewMatrix");
    this._uProjMatrix = program.getLocation("projMatrix");

    this._uSectionPlanes = [];

    for (var i = 0, len = scene._sectionPlanesState.sectionPlanes.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }

    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");

    this._uPointSize = program.getLocation("pointSize");
    this._uNearPlaneHeight = program.getLocation("nearPlaneHeight");

    if (scene.logarithmicDepthBufferEnabled) {
        this._uLogDepthBufFC = program.getLocation("logDepthBufFC");
    }
};

PointsInstancingDepthRenderer.prototype._bindProgram = function _bindProgram () {

    var scene = this._scene;
    var gl = scene.canvas.gl;
    var project = scene.camera.project;

    this._program.bind();

    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);

    if (scene.logarithmicDepthBufferEnabled) {
        var logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);
        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);
    }
};

PointsInstancingDepthRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingDepthRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var pointsMaterial = scene.pointsMaterial._state;
    var src = [];
    src.push("// Points instancing depth vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("uniform int renderPass;");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;");
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");

    src.push("uniform float pointSize;");
    if (pointsMaterial.perspectivePoints) {
        src.push("uniform float nearPlaneHeight;");
    }

    if (scene.logarithmicDepthBufferEnabled) {
        src.push("uniform float logDepthBufFC;");
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");

    // flags.x = NOT_RENDERED | COLOR_OPAQUE | COLOR_TRANSPARENT
    // renderPass = COLOR_OPAQUE

    src.push("if (int(flags.x) != renderPass) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex

    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = viewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("vec4 clipPos = projMatrix * viewPosition;");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("vFragDepth = 1.0 + clipPos.w;");
        } else {
            src.push("clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;");
            src.push("clipPos.z *= clipPos.w;");
        }
    }
    src.push("gl_Position = clipPos;");
    if (pointsMaterial.perspectivePoints) {
        src.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;");
        src.push("gl_PointSize = max(gl_PointSize, " + Math.floor(pointsMaterial.minPerspectivePointSize) + ".0);");
        src.push("gl_PointSize = min(gl_PointSize, " + Math.floor(pointsMaterial.maxPerspectivePointSize) + ".0);");
    } else {
        src.push("gl_PointSize = pointSize;");
    }
    src.push("}");
    src.push("}");
    return src;
};

PointsInstancingDepthRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var i;
    var len;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Points instancing depth vertex shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled) {
        if (WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
            src.push("uniform float logDepthBufFC;");
            src.push("varying float vFragDepth;");
        }
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }

    src.push("const float   packUpScale = 256. / 255.;");
    src.push("const float   unpackDownscale = 255. / 256.;");
    src.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
    src.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );");
    src.push("const float   shiftRight8 = 1.0 / 256.;");

    src.push("vec4 packDepthToRGBA( const in float v ) {");
    src.push("    vec4 r = vec4( fract( v * packFactors ), v );");
    src.push("    r.yzw -= r.xyz * shiftRight8;");
    src.push("    return r * packUpScale;");
    src.push("}");

    src.push("void main(void) {");

    if (scene.pointsMaterial.roundPoints) {
        src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("  float r = dot(cxy, cxy);");
        src.push("  if (r > 1.0) {");
        src.push("       discard;");
        src.push("  }");
    }

    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("if (sectionPlaneActive" + i + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    src.push("    gl_FragColor = packDepthToRGBA( gl_FragCoord.z); "); // Must be linear depth
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO$1.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("}");
    return src;
};

PointsInstancingDepthRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingDepthRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

var tempVec3a$8 = math.vec3();

/**
 * Renders InstancingLayer fragment depths to a shadow map.
 *
 * @private
 */
var PointsInstancingShadowRenderer = function PointsInstancingShadowRenderer(scene) {
    this._scene = scene;
    this._hash = this._getHash();
    this._lastLightId = null;
    this._allocate();
};

PointsInstancingShadowRenderer.prototype.getValid = function getValid () {
    return this._hash === this._getHash();
};
PointsInstancingShadowRenderer.prototype._getHash = function _getHash () {
    return this._scene._sectionPlanesState.getHash();
};

PointsInstancingShadowRenderer.prototype.drawLayer = function drawLayer ( frameCtx, instancingLayer) {

    var model = instancingLayer.model;
    var scene = model.scene;
    var gl = scene.canvas.gl;
    var state = instancingLayer._state;
    var instanceExt = this._instanceExt;

    if (!this._program) {
        this._allocate();
        if (this.errors) {
            return;
        }
    }

    if (frameCtx.lastProgramId !== this._program.id) {
        frameCtx.lastProgramId = this._program.id;
        this._bindProgram(frameCtx, instancingLayer);
    }

    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, instancingLayer._state.positionsDecodeMatrix);

    this._aModelMatrixCol0.bindArrayBuffer(state.modelMatrixCol0Buf);
    this._aModelMatrixCol1.bindArrayBuffer(state.modelMatrixCol1Buf);
    this._aModelMatrixCol2.bindArrayBuffer(state.modelMatrixCol2Buf);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 1);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 1);

    this._aPosition.bindArrayBuffer(state.positionsBuf);

    if (this._aOffset) {
        this._aOffset.bindArrayBuffer(state.offsetsBuf);
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 1);
    }

    this._aColor.bindArrayBuffer(state.colorsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 1);

    this._aFlags.bindArrayBuffer(state.flagsBuf);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 1);

    if (this._aFlags2) {
        this._aFlags2.bindArrayBuffer(state.flags2Buf);
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 1);
    }

    // TODO: Section planes need to be set if RTC center has changed since last RTC center recorded on frameCtx

    var numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;
    if (numSectionPlanes > 0) {
        var sectionPlanes = scene._sectionPlanesState.sectionPlanes;
        var baseIndex = instancingLayer.layerIndex * numSectionPlanes;
        var renderFlags = model.renderFlags;
        var rtcCenter = instancingLayer._state.rtcCenter;
        for (var sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {
            var sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];
            if (sectionPlaneUniforms) {
                var active = renderFlags.sectionPlanesActivePerLayer[baseIndex + sectionPlaneIndex];
                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);
                if (active) {
                    var sectionPlane = sectionPlanes[sectionPlaneIndex];
                    if (rtcCenter) {
                        var rtcSectionPlanePos = getPlaneRTCPos(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a$8);
                        gl.uniform3fv(sectionPlaneUniforms.pos, rtcSectionPlanePos);
                    } else {
                        gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);
                    }
                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);
                }
            }
        }
    }

    gl.uniform1f(this._uPointSize, 10);

    instanceExt.drawArraysInstancedANGLE(gl.POINTS, 0, state.positionsBuf.numItems, state.numInstances);

    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol0.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol1.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aModelMatrixCol2.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aColor.location, 0);
    instanceExt.vertexAttribDivisorANGLE(this._aFlags.location, 0);

    if (this._aFlags2) { // Won't be in shader when not clipping
        instanceExt.vertexAttribDivisorANGLE(this._aFlags2.location, 0);
    }

    if (this._aOffset) {
        instanceExt.vertexAttribDivisorANGLE(this._aOffset.location, 0);
    }
};

PointsInstancingShadowRenderer.prototype._allocate = function _allocate () {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var sectionPlanesState = scene._sectionPlanesState;
    this._program = new Program(gl, this._buildShader());
    if (this._program.errors) {
        this.errors = this._program.errors;
        return;
    }
    this._instanceExt = gl.getExtension("ANGLE_instanced_arrays");
    var program = this._program;
    this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
    this._uShadowViewMatrix = program.getLocation("shadowViewMatrix");
    this._uShadowProjMatrix = program.getLocation("shadowProjMatrix");
    this._uSectionPlanes = [];
    var clips = sectionPlanesState.sectionPlanes;
    for (var i = 0, len = clips.length; i < len; i++) {
        this._uSectionPlanes.push({
            active: program.getLocation("sectionPlaneActive" + i),
            pos: program.getLocation("sectionPlanePos" + i),
            dir: program.getLocation("sectionPlaneDir" + i)
        });
    }
    this._aPosition = program.getAttribute("position");
    this._aOffset = program.getAttribute("offset");
    this._aColor = program.getAttribute("color");
    this._aFlags = program.getAttribute("flags");
    this._aFlags2 = program.getAttribute("flags2");
    this._aModelMatrixCol0 = program.getAttribute("modelMatrixCol0");
    this._aModelMatrixCol1 = program.getAttribute("modelMatrixCol1");
    this._aModelMatrixCol2 = program.getAttribute("modelMatrixCol2");
    this._uPointSize = program.getLocation("pointSize");
};

PointsInstancingShadowRenderer.prototype._bindProgram = function _bindProgram (frameCtx, instancingLayer) {
    var scene = this._scene;
    var gl = scene.canvas.gl;
    var program = this._program;
    program.bind();
    gl.uniformMatrix4fv(this._uShadowViewMatrix, false, frameCtx.shadowViewMatrix);
    gl.uniformMatrix4fv(this._uShadowProjMatrix, false, frameCtx.shadowProjMatrix);
    this._lastLightId = null;
};

PointsInstancingShadowRenderer.prototype._buildShader = function _buildShader () {
    return {
        vertex: this._buildVertexShader(),
        fragment: this._buildFragmentShader()
    };
};

PointsInstancingShadowRenderer.prototype._buildVertexShader = function _buildVertexShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry shadow drawing vertex shader");
    src.push("attribute vec3 position;");
    if (scene.entityOffsetsEnabled) {
        src.push("attribute vec3 offset;");
    }
    src.push("attribute vec4 color;");
    src.push("attribute vec4 flags;");
    src.push("attribute vec4 flags2;");
    src.push("attribute vec4 modelMatrixCol0;");
    src.push("attribute vec4 modelMatrixCol1;");
    src.push("attribute vec4 modelMatrixCol2;");
    src.push("uniform mat4 shadowViewMatrix;");
    src.push("uniform mat4 shadowProjMatrix;");
    src.push("uniform mat4 positionsDecodeMatrix;");
    src.push("uniform float pointSize;");
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
    }
    src.push("void main(void) {");
    src.push("bool visible      = (float(flags.x) > 0.0);");
    src.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);");
    src.push("if (!visible || transparent) {");
    src.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"); // Cull vertex
    src.push("} else {");
    src.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); ");
    src.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);");
    if (scene.entityOffsetsEnabled) {
        src.push("      worldPosition.xyz = worldPosition.xyz + offset;");
    }
    src.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; ");

    if (clipping) {
        src.push("vWorldPosition = worldPosition;");
        src.push("vFlags2 = flags2;");
    }
    src.push("  gl_Position = shadowProjMatrix * viewPosition;");
    src.push("}");
    src.push("gl_PointSize = pointSize;");
    src.push("}");
    return src;
};

PointsInstancingShadowRenderer.prototype._buildFragmentShader = function _buildFragmentShader () {
    var scene = this._scene;
    var sectionPlanesState = scene._sectionPlanesState;
    var clipping = sectionPlanesState.sectionPlanes.length > 0;
    var src = [];
    src.push("// Instancing geometry depth drawing fragment shader");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("#extension GL_EXT_frag_depth : enable");
    }
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("uniform float logDepthBufFC;");
        src.push("varying float vFragDepth;");
    }
    if (clipping) {
        src.push("varying vec4 vWorldPosition;");
        src.push("varying vec4 vFlags2;");
        for (var i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {
            src.push("uniform bool sectionPlaneActive" + i + ";");
            src.push("uniform vec3 sectionPlanePos" + i + ";");
            src.push("uniform vec3 sectionPlaneDir" + i + ";");
        }
    }
    src.push("varying vec3 vViewNormal;");
    src.push("vec3 packNormalToRGB( const in vec3 normal ) {");
    src.push("    return normalize( normal ) * 0.5 + 0.5;");
    src.push("}");
    src.push("void main(void) {");
    src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
    src.push("  float r = dot(cxy, cxy);");
    src.push("  if (r > 1.0) {");
    src.push("       discard;");
    src.push("  }");
    if (clipping) {
        src.push("  bool clippable = (float(vFlags2.x) > 0.0);");
        src.push("  if (clippable) {");
        src.push("  float dist = 0.0;");
        for (var i$1 = 0, len$1 = sectionPlanesState.sectionPlanes.length; i$1 < len$1; i$1++) {
            src.push("if (sectionPlaneActive" + i$1 + ") {");
            src.push("   dist += clamp(dot(-sectionPlaneDir" + i$1 + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i$1 + ".xyz), 0.0, 1000.0);");
            src.push("}");
        }
        src.push("if (dist > 0.0) { discard; }");
        src.push("}");
    }
    if (scene.logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
        src.push("gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;");
    }
    src.push("    gl_FragColor = vec4(packNormalToRGB(vViewNormal), 1.0); ");
    src.push("}");
    return src;
};

PointsInstancingShadowRenderer.prototype.webglContextRestored = function webglContextRestored () {
    this._program = null;
};

PointsInstancingShadowRenderer.prototype.destroy = function destroy () {
    if (this._program) {
        this._program.destroy();
    }
    this._program = null;
};

/**
 * @private
 */
var PointsInstancingRenderers = function PointsInstancingRenderers(scene) {
    this._scene = scene;
};

var prototypeAccessors$3 = { colorRenderer: { configurable: true },silhouetteRenderer: { configurable: true },depthRenderer: { configurable: true },pickMeshRenderer: { configurable: true },pickDepthRenderer: { configurable: true },occlusionRenderer: { configurable: true },shadowRenderer: { configurable: true } };

PointsInstancingRenderers.prototype._compile = function _compile () {
    if (this._colorRenderer && (!this._colorRenderer.getValid())) {
        this._colorRenderer.destroy();
        this._colorRenderer = null;
    }
    if (this._depthRenderer && (!this._depthRenderer.getValid())) {
        this._depthRenderer.destroy();
        this._depthRenderer = null;
    }
    if (this._silhouetteRenderer && (!this._silhouetteRenderer.getValid())) {
        this._silhouetteRenderer.destroy();
        this._silhouetteRenderer = null;
    }
    if (this._pickMeshRenderer && (!this._pickMeshRenderer.getValid())) {
        this._pickMeshRenderer.destroy();
        this._pickMeshRenderer = null;
    }
    if (this._pickDepthRenderer && (!this._pickDepthRenderer.getValid())) {
        this._pickDepthRenderer.destroy();
        this._pickDepthRenderer = null;
    }
    if (this._occlusionRenderer && this._occlusionRenderer.getValid() === false) {
        this._occlusionRenderer.destroy();
        this._occlusionRenderer = null;
    }
    if (this._shadowRenderer && (!this._shadowRenderer.getValid())) {
        this._shadowRenderer.destroy();
        this._shadowRenderer = null;
    }
};

prototypeAccessors$3.colorRenderer.get = function () {
    if (!this._colorRenderer) {
        this._colorRenderer = new PointsInstancingColorRenderer(this._scene, false);
    }
    return this._colorRenderer;
};

prototypeAccessors$3.silhouetteRenderer.get = function () {
    if (!this._silhouetteRenderer) {
        this._silhouetteRenderer = new PointsInstancingSilhouetteRenderer(this._scene);
    }
    return this._silhouetteRenderer;
};

prototypeAccessors$3.depthRenderer.get = function () {
    if (!this._depthRenderer) {
        this._depthRenderer = new PointsInstancingDepthRenderer(this._scene);
    }
    return this._depthRenderer;
};

prototypeAccessors$3.pickMeshRenderer.get = function () {
    if (!this._pickMeshRenderer) {
        this._pickMeshRenderer = new PointsInstancingPickMeshRenderer(this._scene);
    }
    return this._pickMeshRenderer;
};

prototypeAccessors$3.pickDepthRenderer.get = function () {
    if (!this._pickDepthRenderer) {
        this._pickDepthRenderer = new PointsInstancingPickDepthRenderer(this._scene);
    }
    return this._pickDepthRenderer;
};

prototypeAccessors$3.occlusionRenderer.get = function () {
    if (!this._occlusionRenderer) {
        this._occlusionRenderer = new PointsInstancingOcclusionRenderer(this._scene);
    }
    return this._occlusionRenderer;
};

prototypeAccessors$3.shadowRenderer.get = function () {
    if (!this._shadowRenderer) {
        this._shadowRenderer = new PointsInstancingShadowRenderer(this._scene);
    }
    return this._shadowRenderer;
};

PointsInstancingRenderers.prototype._destroy = function _destroy () {
    if (this._colorRenderer) {
        this._colorRenderer.destroy();
    }
    if (this._depthRenderer) {
        this._depthRenderer.destroy();
    }
    if (this._silhouetteRenderer) {
        this._silhouetteRenderer.destroy();
    }
    if (this._pickMeshRenderer) {
        this._pickMeshRenderer.destroy();
    }
    if (this._pickDepthRenderer) {
        this._pickDepthRenderer.destroy();
    }
    if (this._occlusionRenderer) {
        this._occlusionRenderer.destroy();
    }
    if (this._shadowRenderer) {
        this._shadowRenderer.destroy();
    }
};

Object.defineProperties( PointsInstancingRenderers.prototype, prototypeAccessors$3 );

var cachedRenderers = {};

/**
 * @private
 */
function getPointsInstancingRenderers(scene) {
    var sceneId = scene.id;
    var instancingRenderers = cachedRenderers[sceneId];
    if (!instancingRenderers) {
        instancingRenderers = new PointsInstancingRenderers(scene);
        cachedRenderers[sceneId] = instancingRenderers;
        instancingRenderers._compile();
        scene.on("compile", function () {
            instancingRenderers._compile();
        });
        scene.on("destroyed", function () {
            delete cachedRenderers[sceneId];
            instancingRenderers._destroy();
        });
    }
    return instancingRenderers;
}

var tempUint8Vec4 = new Uint8Array(4);
var tempVec4a$2 = math.vec4([0, 0, 0, 1]);
var tempVec4b$2 = math.vec4([0, 0, 0, 1]);
var tempVec4c$2 = math.vec4([0, 0, 0, 1]);
var tempVec3fa = new Float32Array(3);

/**
 * @private
 */
var PointsInstancingLayer = function PointsInstancingLayer(model, cfg) {

    /**
     * State sorting key.
     * @type {string}
     */
    this.sortId = "PointsInstancingLayer";

    /**
     * Index of this InstancingLayer in PerformanceModel#_layerList
     * @type {Number}
     */
    this.layerIndex = cfg.layerIndex;

    this._pointsInstancingRenderers = getPointsInstancingRenderers(model.scene);
    this.model = model;
    this._aabb = math.collapseAABB3();

    var gl = model.scene.canvas.gl;

    var stateCfg = {
        positionsDecodeMatrix: math.mat4(),
        numInstances: 0,
        obb: math.OBB3(),
        rtcCenter: null
    };

    var preCompressedPositions = (!!cfg.positionsDecodeMatrix);

    if (!cfg.positions) {
        throw "positions expected";
    }

    var numVerts = cfg.positions.length / 3;

    if (preCompressedPositions) {

        var normalized = false;
        stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, cfg.positions, cfg.positions.length, 3, gl.STATIC_DRAW, normalized);
        stateCfg.positionsDecodeMatrix.set(cfg.positionsDecodeMatrix);

        var localAABB = math.collapseAABB3();
        math.expandAABB3Points3(localAABB, cfg.positions);
        geometryCompressionUtils.decompressAABB(localAABB, stateCfg.positionsDecodeMatrix);
        math.AABB3ToOBB3(localAABB, stateCfg.obb);

    } else {

        var lenPositions = cfg.positions.length;
        var localAABB$1 = math.collapseAABB3();
        math.expandAABB3Points3(localAABB$1, cfg.positions);
        math.AABB3ToOBB3(localAABB$1, stateCfg.obb);
        var quantizedPositions = quantizePositions(cfg.positions, localAABB$1, stateCfg.positionsDecodeMatrix);
        var normalized$1 = false;
        stateCfg.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, lenPositions, 3, gl.STATIC_DRAW, normalized$1);
    }

    if (cfg.colorsCompressed) {
        var colorsCompressed = new Uint8Array(cfg.colorsCompressed);
        var notNormalized = false;
        stateCfg.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colorsCompressed, colorsCompressed.length, 4, gl.STATIC_DRAW, notNormalized);

    } else if (cfg.colors) {
        var colors = cfg.colors;
        var colorsCompressed$1 = new Uint8Array(colors.length);
        for (var i = 0, len = colors.length; i < len; i++) {
            colorsCompressed$1[i] = colors[i] * 255;
        }
        var notNormalized$1 = false;
        stateCfg.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colorsCompressed$1, colorsCompressed$1.length, 4, gl.STATIC_DRAW, notNormalized$1);

    } else {
        var colorsCompressed$2 = new Uint8Array(numVerts * 4);
        for (var i$1 = 0, len$1 = numVerts * 4; i$1 < len$1; i$1++) {
            colorsCompressed$2[i$1] = 255;
        }
        var notNormalized$2 = false;
        stateCfg.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colorsCompressed$2, colorsCompressed$2.length, 4, gl.STATIC_DRAW, notNormalized$2);
    }

    this._state = new RenderState(stateCfg);

    // These counts are used to avoid unnecessary render passes
    this._numPortions = 0;
    this._numVisibleLayerPortions = 0;
    this._numTransparentLayerPortions = 0;
    this._numXRayedLayerPortions = 0;
    this._numHighlightedLayerPortions = 0;
    this._numSelectedLayerPortions = 0;
    this._numClippableLayerPortions = 0;
    this._numEdgesLayerPortions = 0;
    this._numPickableLayerPortions = 0;
    this._numCulledLayerPortions = 0;

    // Vertex arrays
    this._pickColors = [];
    this._offsets = [];

    // Modeling matrix per instance, array for each column
    this._modelMatrixCol0 = [];
    this._modelMatrixCol1 = [];
    this._modelMatrixCol2 = [];

    this._portions = [];

    if (cfg.rtcCenter) {
        this._state.rtcCenter = math.vec3(cfg.rtcCenter);
    }

    this._finalized = false;

    /**
     * The axis-aligned World-space boundary of this InstancingLayer's positions.
     * @type {*|Float64Array}
     */
    this.aabb = math.collapseAABB3();
};

/**
 * Creates a new portion within this InstancingLayer, returns the new portion ID.
 *
 * The portion will instance this InstancingLayer's geometry.
 *
 * Gives the portion the specified color and matrix.
 *
 * @param cfg Portion params
 * @param cfg.meshMatrix Flat float 4x4 matrix.
 * @param [cfg.worldMatrix] Flat float 4x4 matrix.
 * @param cfg.aabb Flat float AABB.
 * @param cfg.pickColor Quantized pick color
 * @returns {number} Portion ID.
 */
PointsInstancingLayer.prototype.createPortion = function createPortion (cfg) {

    var meshMatrix = cfg.meshMatrix;
    var worldMatrix = cfg.worldMatrix;
    var worldAABB = cfg.aabb;
    var pickColor = cfg.pickColor;

    if (this._finalized) {
        throw "Already finalized";
    }

    if (this.model.scene.entityOffsetsEnabled) {
        this._offsets.push(0);
        this._offsets.push(0);
        this._offsets.push(0);
    }

    this._modelMatrixCol0.push(meshMatrix[0]);
    this._modelMatrixCol0.push(meshMatrix[4]);
    this._modelMatrixCol0.push(meshMatrix[8]);
    this._modelMatrixCol0.push(meshMatrix[12]);

    this._modelMatrixCol1.push(meshMatrix[1]);
    this._modelMatrixCol1.push(meshMatrix[5]);
    this._modelMatrixCol1.push(meshMatrix[9]);
    this._modelMatrixCol1.push(meshMatrix[13]);

    this._modelMatrixCol2.push(meshMatrix[2]);
    this._modelMatrixCol2.push(meshMatrix[6]);
    this._modelMatrixCol2.push(meshMatrix[10]);
    this._modelMatrixCol2.push(meshMatrix[14]);

    // Per-vertex pick colors

    this._pickColors.push(pickColor[0]);
    this._pickColors.push(pickColor[1]);
    this._pickColors.push(pickColor[2]);
    this._pickColors.push(pickColor[3]);

    // Expand AABB

    math.collapseAABB3(worldAABB);
    var obb = this._state.obb;
    var lenPositions = obb.length;
    for (var i = 0; i < lenPositions; i += 4) {
        tempVec4a$2[0] = obb[i + 0];
        tempVec4a$2[1] = obb[i + 1];
        tempVec4a$2[2] = obb[i + 2];
        math.transformPoint4(meshMatrix, tempVec4a$2, tempVec4b$2);
        if (worldMatrix) {
            math.transformPoint4(worldMatrix, tempVec4b$2, tempVec4c$2);
            math.expandAABB3Point3(worldAABB, tempVec4c$2);
        } else {
            math.expandAABB3Point3(worldAABB, tempVec4b$2);
        }
    }

    if (this._state.rtcCenter) {
        var rtcCenter = this._state.rtcCenter;
        worldAABB[0] += rtcCenter[0];
        worldAABB[1] += rtcCenter[1];
        worldAABB[2] += rtcCenter[2];
        worldAABB[3] += rtcCenter[0];
        worldAABB[4] += rtcCenter[1];
        worldAABB[5] += rtcCenter[2];
    }

    math.expandAABB3(this.aabb, worldAABB);

    this._state.numInstances++;

    var portionId = this._portions.length;
    this._portions.push({});

    this._numPortions++;
    this.model.numPortions++;

    return portionId;
};

PointsInstancingLayer.prototype.finalize = function finalize () {
    if (this._finalized) {
        throw "Already finalized";
    }
    var gl = this.model.scene.canvas.gl;
    var flagsLength = this._pickColors.length;
    if (flagsLength > 0) {
        // Because we only build flags arrays here, 
        // get their length from the colors array
        var notNormalized = false;
        var normalized = true;
        this._state.flagsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, notNormalized);
        this._state.flags2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(flagsLength), flagsLength, 4, gl.DYNAMIC_DRAW, normalized);
    }
    if (this.model.scene.entityOffsetsEnabled) {
        if (this._offsets.length > 0) {
            var notNormalized$1 = false;
            this._state.offsetsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, gl.DYNAMIC_DRAW, notNormalized$1);
            this._offsets = []; // Release memory
        }
    }
    if (this._modelMatrixCol0.length > 0) {
        var normalized$1 = false;
        this._state.modelMatrixCol0Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, gl.STATIC_DRAW, normalized$1);
        this._state.modelMatrixCol1Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, gl.STATIC_DRAW, normalized$1);
        this._state.modelMatrixCol2Buf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, gl.STATIC_DRAW, normalized$1);
        this._modelMatrixCol0 = [];
        this._modelMatrixCol1 = [];
        this._modelMatrixCol2 = [];
    }
    if (this._pickColors.length > 0) {
        var normalized$2 = false;
        this._state.pickColorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(this._pickColors), this._pickColors.length, 4, gl.STATIC_DRAW, normalized$2);
        this._pickColors = []; // Release memory
    }
    this._finalized = true;
};

// The following setters are called by PerformanceMesh, in turn called by PerformanceNode, only after the layer is finalized.
// It's important that these are called after finalize() in order to maintain integrity of counts like _numVisibleLayerPortions etc.

PointsInstancingLayer.prototype.initFlags = function initFlags (portionId, flags, meshTransparent) {
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    }
    if (meshTransparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    }
    this._setFlags(portionId, flags, meshTransparent);
    this._setFlags2(portionId, flags);
};

PointsInstancingLayer.prototype.setVisible = function setVisible (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.VISIBLE) {
        this._numVisibleLayerPortions++;
        this.model.numVisibleLayerPortions++;
    } else {
        this._numVisibleLayerPortions--;
        this.model.numVisibleLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setHighlighted = function setHighlighted (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.HIGHLIGHTED) {
        this._numHighlightedLayerPortions++;
        this.model.numHighlightedLayerPortions++;
    } else {
        this._numHighlightedLayerPortions--;
        this.model.numHighlightedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setXRayed = function setXRayed (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.XRAYED) {
        this._numXRayedLayerPortions++;
        this.model.numXRayedLayerPortions++;
    } else {
        this._numXRayedLayerPortions--;
        this.model.numXRayedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setSelected = function setSelected (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.SELECTED) {
        this._numSelectedLayerPortions++;
        this.model.numSelectedLayerPortions++;
    } else {
        this._numSelectedLayerPortions--;
        this.model.numSelectedLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setEdges = function setEdges (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.EDGES) {
        this._numEdgesLayerPortions++;
        this.model.numEdgesLayerPortions++;
    } else {
        this._numEdgesLayerPortions--;
        this.model.numEdgesLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setClippable = function setClippable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CLIPPABLE) {
        this._numClippableLayerPortions++;
        this.model.numClippableLayerPortions++;
    } else {
        this._numClippableLayerPortions--;
        this.model.numClippableLayerPortions--;
    }
    this._setFlags2(portionId, flags);
};

PointsInstancingLayer.prototype.setCollidable = function setCollidable (portionId, flags) {
    if (!this._finalized) {
        throw "Not finalized";
    }
};

PointsInstancingLayer.prototype.setPickable = function setPickable (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.PICKABLE) {
        this._numPickableLayerPortions++;
        this.model.numPickableLayerPortions++;
    } else {
        this._numPickableLayerPortions--;
        this.model.numPickableLayerPortions--;
    }
    this._setFlags2(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setCulled = function setCulled (portionId, flags, meshTransparent) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (flags & ENTITY_FLAGS.CULLED) {
        this._numCulledLayerPortions++;
        this.model.numCulledLayerPortions++;
    } else {
        this._numCulledLayerPortions--;
        this.model.numCulledLayerPortions--;
    }
    this._setFlags(portionId, flags, meshTransparent);
};

PointsInstancingLayer.prototype.setColor = function setColor (portionId, color) { // RGBA color is normalized as ints
    if (!this._finalized) {
        throw "Not finalized";
    }
    tempUint8Vec4[0] = color[0];
    tempUint8Vec4[1] = color[1];
    tempUint8Vec4[2] = color[2];
    this._state.colorsBuf.setData(tempUint8Vec4, portionId * 3, 3);
};

PointsInstancingLayer.prototype.setTransparent = function setTransparent (portionId, flags, transparent) {
    if (transparent) {
        this._numTransparentLayerPortions++;
        this.model.numTransparentLayerPortions++;
    } else {
        this._numTransparentLayerPortions--;
        this.model.numTransparentLayerPortions--;
    }
    this._setFlags(portionId, flags, transparent);
};

// setMatrix(portionId, matrix) {
//
// if (!this._finalized) {
//     throw "Not finalized";
// }
//
// var offset = portionId * 4;
//
// tempFloat32Vec4[0] = matrix[0];
// tempFloat32Vec4[1] = matrix[4];
// tempFloat32Vec4[2] = matrix[8];
// tempFloat32Vec4[3] = matrix[12];
//
// this._state.modelMatrixCol0Buf.setData(tempFloat32Vec4, offset, 4);
//
// tempFloat32Vec4[0] = matrix[1];
// tempFloat32Vec4[1] = matrix[5];
// tempFloat32Vec4[2] = matrix[9];
// tempFloat32Vec4[3] = matrix[13];
//
// this._state.modelMatrixCol1Buf.setData(tempFloat32Vec4, offset, 4);
//
// tempFloat32Vec4[0] = matrix[2];
// tempFloat32Vec4[1] = matrix[6];
// tempFloat32Vec4[2] = matrix[10];
// tempFloat32Vec4[3] = matrix[14];
//
// this._state.modelMatrixCol2Buf.setData(tempFloat32Vec4, offset, 4);
// }

PointsInstancingLayer.prototype._setFlags = function _setFlags (portionId, flags, meshTransparent) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var visible = !!(flags & ENTITY_FLAGS.VISIBLE);
    var xrayed = !!(flags & ENTITY_FLAGS.XRAYED);
    var highlighted = !!(flags & ENTITY_FLAGS.HIGHLIGHTED);
    var selected = !!(flags & ENTITY_FLAGS.SELECTED);
    var edges = !!(flags & ENTITY_FLAGS.EDGES);
    var pickable = !!(flags & ENTITY_FLAGS.PICKABLE);
    var culled = !!(flags & ENTITY_FLAGS.CULLED);

    // Normal fill

    var f0;
    if (!visible || culled || xrayed) {
        f0 = RENDER_PASSES.NOT_RENDERED;
    } else {
        if (meshTransparent) {
            f0 = RENDER_PASSES.COLOR_TRANSPARENT;
        } else {
            f0 = RENDER_PASSES.COLOR_OPAQUE;
        }
    }

    // Emphasis fill

    var f1;
    if (!visible || culled) {
        f1 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f1 = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
        f1 = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
        f1 = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
        f1 = RENDER_PASSES.NOT_RENDERED;
    }

    // Edges

    var f2 = 0;
    if (!visible || culled) {
        f2 = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
        f2 = RENDER_PASSES.EDGES_SELECTED;
    } else if (highlighted) {
        f2 = RENDER_PASSES.EDGES_HIGHLIGHTED;
    } else if (xrayed) {
        f2 = RENDER_PASSES.EDGES_XRAYED;
    } else if (edges) {
        if (meshTransparent) {
            f2 = RENDER_PASSES.EDGES_COLOR_TRANSPARENT;
        } else {
            f2 = RENDER_PASSES.EDGES_COLOR_OPAQUE;
        }
    } else {
        f2 = RENDER_PASSES.NOT_RENDERED;
    }

    // Pick

    var f3 = (visible && !culled && pickable) ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;

    tempUint8Vec4[0] = f0; // x - normal fill
    tempUint8Vec4[1] = f1; // y - emphasis fill
    tempUint8Vec4[2] = f2; // z - edges
    tempUint8Vec4[3] = f3; // w - pick

    this._state.flagsBuf.setData(tempUint8Vec4, portionId * 4, 4);
};

PointsInstancingLayer.prototype._setFlags2 = function _setFlags2 (portionId, flags) {

    if (!this._finalized) {
        throw "Not finalized";
    }

    var clippable = !!(flags & ENTITY_FLAGS.CLIPPABLE) ? 255 : 0;
    tempUint8Vec4[0] = clippable;

    this._state.flags2Buf.setData(tempUint8Vec4, portionId * 4, 4);
};

PointsInstancingLayer.prototype.setOffset = function setOffset (portionId, offset) {
    if (!this._finalized) {
        throw "Not finalized";
    }
    if (!this.model.scene.entityOffsetsEnabled) {
        this.model.error("Entity#offset not enabled for this Viewer"); // See Viewer entityOffsetsEnabled
        return;
    }
    tempVec3fa[0] = offset[0];
    tempVec3fa[1] = offset[1];
    tempVec3fa[2] = offset[2];
    this._state.offsetsBuf.setData(tempVec3fa, portionId * 3, 3);
};

// ---------------------- NORMAL RENDERING -----------------------------------

PointsInstancingLayer.prototype.drawColorOpaque = function drawColorOpaque (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === this._numPortions || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._pointsInstancingRenderers.colorRenderer) {
        this._pointsInstancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

PointsInstancingLayer.prototype.drawColorTransparent = function drawColorTransparent (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numTransparentLayerPortions === 0 || this._numXRayedLayerPortions === this._numPortions) {
        return;
    }
    if (this._pointsInstancingRenderers.colorRenderer) {
        this._pointsInstancingRenderers.colorRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_TRANSPARENT);
    }
};

// -- RENDERING SAO POST EFFECT TARGETS ----------------------------------------------------------------------------

PointsInstancingLayer.prototype.drawDepth = function drawDepth (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.drawNormals = function drawNormals (renderFlags, frameCtx) {
};

// ---------------------- EMPHASIS RENDERING -----------------------------------

PointsInstancingLayer.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numXRayedLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.silhouetteRenderer) {
        this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
};

PointsInstancingLayer.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numHighlightedLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.silhouetteRenderer) {
        this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
};

PointsInstancingLayer.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0 || this._numSelectedLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.silhouetteRenderer) {
        this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(frameCtx, this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
};

//-- EDGES RENDERING -----------------------------------------------------------------------------------------------

PointsInstancingLayer.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.drawEdgesSelected = function drawEdgesSelected (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.drawEdgesXRayed = function drawEdgesXRayed (renderFlags, frameCtx) {
};

// ---------------------- OCCLUSION CULL RENDERING -----------------------------------

PointsInstancingLayer.prototype.drawOcclusion = function drawOcclusion (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.occlusionRenderer) {
        // Only opaque, filled objects can be occluders
        this._pointsInstancingRenderers.occlusionRenderer.drawLayer(frameCtx, this, RENDER_PASSES.COLOR_OPAQUE);
    }
};

// ---------------------- SHADOW BUFFER RENDERING -----------------------------------

PointsInstancingLayer.prototype.drawShadow = function drawShadow (renderFlags, frameCtx) {
};

//---- PICKING ----------------------------------------------------------------------------------------------------

PointsInstancingLayer.prototype.drawPickMesh = function drawPickMesh (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.pickMeshRenderer) {
        this._pointsInstancingRenderers.pickMeshRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

PointsInstancingLayer.prototype.drawPickDepths = function drawPickDepths (renderFlags, frameCtx) {
    if (this._numCulledLayerPortions === this._numPortions || this._numVisibleLayerPortions === 0) {
        return;
    }
    if (this._pointsInstancingRenderers.pickDepthRenderer) {
        this._pointsInstancingRenderers.pickDepthRenderer.drawLayer(frameCtx, this, RENDER_PASSES.PICK);
    }
};

PointsInstancingLayer.prototype.drawPickNormals = function drawPickNormals (renderFlags, frameCtx) {
};

PointsInstancingLayer.prototype.destroy = function destroy () {
    var state = this._state;
    if (state.positionsBuf) {
        state.positionsBuf.destroy();
        state.positionsBuf = null;
    }
    if (state.colorsBuf) {
        state.colorsBuf.destroy();
        state.colorsBuf = null;
    }
    if (state.flagsBuf) {
        state.flagsBuf.destroy();
        state.flagsBuf = null;
    }
    if (state.flags2Buf) {
        state.flags2Buf.destroy();
        state.flags2Buf = null;
    }
    if (state.offsetsBuf) {
        state.offsetsBuf.destroy();
        state.offsetsBuf = null;
    }
    if (state.modelMatrixCol0Buf) {
        state.modelMatrixCol0Buf.destroy();
        state.modelMatrixCol0Buf = null;
    }
    if (state.modelMatrixCol1Buf) {
        state.modelMatrixCol1Buf.destroy();
        state.modelMatrixCol1Buf = null;
    }
    if (state.modelMatrixCol2Buf) {
        state.modelMatrixCol2Buf.destroy();
        state.modelMatrixCol2Buf = null;
    }
    if (state.pickColorsBuf) {
        state.pickColorsBuf.destroy();
        state.pickColorsBuf = null;
    }
    state.destroy();
};

var instancedArraysSupported = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["ANGLE_instanced_arrays"];

var tempMat4$1 = math.mat4();

var defaultScale = math.vec3([1, 1, 1]);
var defaultPosition = math.vec3([0, 0, 0]);
var defaultRotation = math.vec3([0, 0, 0]);
var defaultQuaternion = math.identityQuaternion();

/**
 * @desc A high-performance model representation for efficient rendering and low memory usage.
 *
 * # Examples
 *
 * * [PerformanceModel using geometry batching](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching)
 * * [PerformanceModel using geometry batching and RTC coordinates](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching_rtcCenter)
 * * [PerformanceModel using geometry instancing](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_instancing)
 * * [PerformanceModel using geometry instancing and RTC coordinates](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_instancing_rtcCenter)
 *
 * # Overview
 *
 * While xeokit's standard [scene graph](https://github.com/xeokit/xeokit-sdk/wiki/Scene-Graphs) is great for gizmos and medium-sized models, it doesn't scale up to millions of objects in terms of memory and rendering efficiency.
 *
 * For huge models, we have the ````PerformanceModel```` representation, which is optimized to pack large amounts of geometry into memory and render it efficiently using WebGL.
 *
 * ````PerformanceModel```` is the default model representation loaded by {@link GLTFLoaderPlugin} and {@link XKTLoaderPlugin}.
 *
 * In this tutorial you'll learn how to use ````PerformanceModel```` to create high-detail content programmatically. Ordinarily you'd be learning about ````PerformanceModel```` if you were writing your own model loader plugins.
 *
 * # Contents
 *
 * - [PerformanceModel](#performancemodel)
 * - [GPU-Resident Geometry](#gpu-resident-geometry)
 * - [Picking](#picking)
 * - [Example 1: Geometry Instancing](#example-1--geometry-instancing)
 * - [Finalizing a PerformanceModel](#finalizing-a-performancemodel)
 * - [Finding Entities](#finding-entities)
 * - [Example 2: Geometry Batching](#example-2--geometry-batching)
 * - [Classifying with Metadata](#classifying-with-metadata)
 * - [Querying Metadata](#querying-metadata)
 * - [Metadata Structure](#metadata-structure)
 * - [RTC Coordinates](#rtc-coordinates)
 *   - [Example 3: RTC Coordinates with Geometry Instancing](#example-2--rtc-coordinates-with-geometry-instancing)
 *   - [Example 4: RTC Coordinates with Geometry Batching](#example-2--rtc-coordinates-with-geometry-batching)
 *
 * ## PerformanceModel
 *
 * ````PerformanceModel```` uses two rendering techniques internally:
 *
 * 1. ***Geometry batching*** for unique geometries, combining those into a single WebGL geometry buffer, to render in one draw call, and
 * 2. ***geometry instancing*** for geometries that are shared by multiple meshes, rendering all instances of each shared geometry in one draw call.
 *
 * <br>
 * These techniques come with certain limitations:
 *
 * * Non-realistic rendering - while scene graphs can use xeokit's full set of material workflows, ````PerformanceModel```` uses simple Lambertian shading without textures.
 * * Static transforms - transforms within a ````PerformanceModel```` are static and cannot be dynamically translated, rotated and scaled the way {@link Node}s and {@link Mesh}es in scene graphs can.
 * * Immutable model representation - while scene graph {@link Node}s and
 * {@link Mesh}es can be dynamically plugged together, ````PerformanceModel```` is immutable,
 * since it packs its geometries into buffers and instanced arrays.
 *
 * ````PerformanceModel````'s API allows us to exploit batching and instancing, while exposing its elements as
 * abstract {@link Entity} types.
 *
 * {@link Entity} is the abstract base class for
 * the various xeokit components that represent models, objects, or anonymous visible elements. An Entity has a unique ID and can be
 * individually shown, hidden, selected, highlighted, ghosted, culled, picked and clipped, and has its own World-space boundary.
 *
 * * A ````PerformanceModel```` is an {@link Entity} that represents a model.
 * * A ````PerformanceModel```` represents each of its objects with an {@link Entity}.
 * * Each {@link Entity} has one or more meshes that define its shape.
 * * Each mesh has either its own unique geometry, or shares a geometry with other meshes.
 *
 * ## GPU-Resident Geometry
 *
 * For a low memory footprint, ````PerformanceModel```` stores its geometries in GPU memory only, compressed (quantized) as integers. Unfortunately, GPU-resident geometry is
 * not readable by JavaScript.
 *
 *
 * ## Example 1: Geometry Instancing
 *
 * In the example below, we'll use a ````PerformanceModel````
 * to build a simple table model using geometry instancing.
 *
 * We'll start by adding a reusable box-shaped geometry to our ````PerformanceModel````.
 *
 * Then, for each object in our model we'll add an {@link Entity}
 * that has a mesh that instances our box geometry, transforming and coloring the instance.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_instancing)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_instancing)]
 *
 * ````javascript
 * import {Viewer, PerformanceModel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Build a PerformanceModel representing a table
 * // with four legs, using geometry instancing
 *
 * const performanceModel = new PerformanceModel(viewer.scene, {
 *     id: "table",
 *     isModel: true, // <--- Registers PerformanceModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Create a reusable geometry within the PerformanceModel
 * // We'll instance this geometry by five meshes
 *
 * performanceModel.createGeometry({
 *
 *     id: "myBoxGeometry",
 *
 *     // The primitive type - allowed values are "points", "lines" and "triangles".
 *     // See the OpenGL/WebGL specification docs
 *     // for how the coordinate arrays are supposed to be laid out.
 *     primitive: "triangles",
 *
 *     // The vertices - eight for our cube, each
 *     // one spanning three array elements for X,Y and Z
 *     positions: [
 *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
 *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right
 *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top
 *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
 *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
 *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back
 *     ],
 *
 *     // Normal vectors, one for each vertex
 *     normals: [
 *         0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
 *         1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
 *         0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
 *         -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
 *         0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
 *         0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 // v4-v7-v6-v5 back
 *     ],
 *
 *     // Indices - these organise the positions and and normals
 *     // into geometric primitives in accordance with the "primitive" parameter,
 *     // in this case a set of three indices for each triangle.
 *     //
 *     // Note that each triangle is specified in counter-clockwise winding order.
 *     //
 *     indices: [
 *         0, 1, 2, 0, 2, 3, // front
 *         4, 5, 6, 4, 6, 7, // right
 *         8, 9, 10, 8, 10, 11, // top
 *         12, 13, 14, 12, 14, 15, // left
 *         16, 17, 18, 16, 18, 19, // bottom
 *         20, 21, 22, 20, 22, 23
 *     ]
 * });
 *
 * // Red table leg
 *
 * performanceModel.createMesh({
 *     id: "redLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     id: "redLeg",
 *     meshIds: ["redLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * performanceModel.createMesh({
 *     id: "greenLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     id: "greenLeg",
 *     meshIds: ["greenLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * performanceModel.createMesh({
 *     id: "blueLegMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "blueLeg",
 *     meshIds: ["blueLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg
 *
 * performanceModel.createMesh({
 *      id: "yellowLegMesh",
 *      geometryId: "myBoxGeometry",
 *      position: [-4, -6, 4],
 *      scale: [1, 3, 1],
 *      rotation: [0, 0, 0],
 *      color: [1.0, 1.0, 0.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "yellowLeg",
 *     meshIds: ["yellowLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * performanceModel.createMesh({
 *     id: "purpleTableTopMesh",
 *     geometryId: "myBoxGeometry",
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "purpleTableTop",
 *     meshIds: ["purpleTableTopMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *  ````
 *
 * ## Finalizing a PerformanceModel
 *
 * Before we can view and interact with our ````PerformanceModel````, we need to **finalize** it. Internally, this causes the ````PerformanceModel```` to build the
 * vertex buffer objects (VBOs) that support our geometry instances. When using geometry batching (see next example),
 * this causes ````PerformanceModel```` to build the VBOs that combine the batched geometries. Note that you can do both instancing and
 * batching within the same ````PerformanceModel````.
 *
 * Once finalized, we can't add anything more to our ````PerformanceModel````.
 *
 * ```` javascript
 * performanceModel.finalize();
 * ````
 *
 * ## Finding Entities
 *
 * As mentioned earlier, {@link Entity} is
 * the abstract base class for components that represent models, objects, or just
 * anonymous visible elements.
 *
 * Since we created configured our ````PerformanceModel```` with ````isModel: true````,
 * we're able to find it as an Entity by ID in ````viewer.scene.models````. Likewise, since
 * we configured each of its Entities with ````isObject: true````, we're able to
 * find them in  ````viewer.scene.objects````.
 *
 *
 * ````javascript
 * // Get the whole table model Entity
 * const table = viewer.scene.models["table"];
 *
 *  // Get some leg object Entities
 * const redLeg = viewer.scene.objects["redLeg"];
 * const greenLeg = viewer.scene.objects["greenLeg"];
 * const blueLeg = viewer.scene.objects["blueLeg"];
 * ````
 *
 * ## Example 2: Geometry Batching
 *
 * Let's once more use a ````PerformanceModel````
 * to build the simple table model, this time exploiting geometry batching.
 *
 *  [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching)
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching)]
 *
 * ````javascript
 * import {Viewer, PerformanceModel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * // Create a PerformanceModel representing a table with four legs, using geometry batching
 * const performanceModel = new PerformanceModel(viewer.scene, {
 *     id: "table",
 *     isModel: true,  // <--- Registers PerformanceModel in viewer.scene.models
 *     position: [0, 0, 0],
 *     scale: [1, 1, 1],
 *     rotation: [0, 0, 0]
 * });
 *
 * // Red table leg
 *
 * performanceModel.createMesh({
 *     id: "redLegMesh",
 *
 *     // Geometry arrays are same as for the earlier batching example
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     id: "redLeg",
 *     meshIds: ["redLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Green table leg
 *
 * performanceModel.createMesh({
 *     id: "greenLegMesh",
 *     primitive: "triangles",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     id: "greenLeg",
 *     meshIds: ["greenLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Blue table leg
 *
 * performanceModel.createMesh({
 *     id: "blueLegMesh",
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "blueLeg",
 *     meshIds: ["blueLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Yellow table leg object
 *
 * performanceModel.createMesh({
 *     id: "yellowLegMesh",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "yellowLeg",
 *     meshIds: ["yellowLegMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Purple table top
 *
 * performanceModel.createMesh({
 *     id: "purpleTableTopMesh",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     id: "purpleTableTop",
 *     meshIds: ["purpleTableTopMesh"],
 *     isObject: true // <---- Registers Entity by ID on viewer.scene.objects
 * });
 *
 * // Finalize the PerformanceModel.
 *
 * performanceModel.finalize();
 *
 * // Find BigModelNodes by their model and object IDs
 *
 * // Get the whole table model
 * const table = viewer.scene.models["table"];
 *
 * // Get some leg objects
 * const redLeg = viewer.scene.objects["redLeg"];
 * const greenLeg = viewer.scene.objects["greenLeg"];
 * const blueLeg = viewer.scene.objects["blueLeg"];
 * ````
 *
 * ## Classifying with Metadata
 *
 * In the previous examples, we used ````PerformanceModel```` to build
 * two versions of the same table model, to demonstrate geometry batching and geometry instancing.
 *
 * We'll now classify our {@link Entity}s with metadata. This metadata
 * will work the same for both our examples, since they create the exact same structure of {@link Entity}s
 * to represent their models and objects. The abstract Entity type is, after all, intended to provide an abstract interface through which differently-implemented scene content can be accessed uniformly.
 *
 * To create the metadata, we'll create a {@link MetaModel} for our model,
 * with a {@link MetaObject} for each of it's objects. The MetaModel and MetaObjects
 * get the same IDs as the {@link Entity}s that represent their model and objects within our scene.
 *
 * ```` javascript
 * const furnitureMetaModel = viewer.metaScene.createMetaModel("furniture", {         // Creates a MetaModel in the MetaScene
 *
 *      "projectId": "myTableProject",
 *      "revisionId": "V1.0",
 *
 *      "metaObjects": [
 *          {                               // Creates a MetaObject in the MetaModel
 *              "id": "table",
 *              "name": "Table",            // Same ID as an object Entity
 *              "type": "furniture",        // Arbitrary type, could be IFC type
 *              "properties": {             // Arbitrary properties, could be IfcPropertySet
 *                  "cost": "200"
 *              }
 *          },
 *          {
 *              "id": "redLeg",
 *              "name": "Red table Leg",
 *              "type": "leg",
 *              "parent": "table",           // References first MetaObject as parent
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "greenLeg",           // Node with corresponding id does not need to exist
 *              "name": "Green table leg",  // and MetaObject does not need to exist for Node with an id
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "blueLeg",
 *              "name": "Blue table leg",
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "yellowLeg",
 *              "name": "Yellow table leg",
 *              "type": "leg",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "wood"
 *              }
 *          },
 *          {
 *              "id": "tableTop",
 *              "name": "Purple table top",
 *              "type": "surface",
 *              "parent": "table",
 *              "properties": {
 *                  "material": "formica",
 *                  "width": "60",
 *                  "depth": "60",
 *                  "thickness": "5"
 *              }
 *          }
 *      ]
 *  });
 * ````
 *
 * ## Querying Metadata
 *
 * Having created and classified our model (either the instancing or batching example), we can now find the {@link MetaModel}
 * and {@link MetaObject}s using the IDs of their
 * corresponding {@link Entity}s.
 *
 * ````JavaScript
 * const furnitureMetaModel = scene.metaScene.metaModels["furniture"];
 *
 * const redLegMetaObject = scene.metaScene.metaObjects["redLeg"];
 * ````
 *
 * In the snippet below, we'll log metadata on each {@link Entity} we click on:
 *
 * ````JavaScript
 * viewer.scene.input.on("mouseclicked", function (coords) {
 *
 *      const hit = viewer.scene.pick({
 *          canvasPos: coords
 *      });
 *
 *      if (hit) {
 *          const entity = hit.entity;
 *          const metaObject = viewer.metaScene.metaObjects[entity.id];
 *          if (metaObject) {
 *              console.log(JSON.stringify(metaObject.getJSON(), null, "\t"));
 *          }
 *      }
 *  });
 * ````
 *
 * ## Metadata Structure
 *
 * The {@link MetaModel}
 * organizes its {@link MetaObject}s in
 * a tree that describes their structural composition:
 *
 * ````JavaScript
 * // Get metadata on the root object
 * const tableMetaObject = furnitureMetaModel.rootMetaObject;
 *
 * // Get metadata on the leg objects
 * const redLegMetaObject = tableMetaObject.children[0];
 * const greenLegMetaObject = tableMetaObject.children[1];
 * const blueLegMetaObject = tableMetaObject.children[2];
 * const yellowLegMetaObject = tableMetaObject.children[3];
 * ````
 *
 * Given an {@link Entity}, we can find the object or model of which it is a part, or the objects that comprise it. We can also generate UI
 * components from the metadata, such as the tree view demonstrated in [this demo](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_glTF_OTCConferenceCenter).
 *
 * This hierarchy allows us to express the hierarchical structure of a model while representing it in
 * various ways in the 3D scene (such as with ````PerformanceModel````, which
 * has a non-hierarchical scene representation).
 *
 * Note also that a {@link MetaObject} does not need to have a corresponding
 * {@link Entity} and vice-versa.
 *
 * # RTC Coordinates for 64-Bit Precision
 *
 * ````PerformanceModel```` can emulate 64-bit precision on GPUs using relative-to-center (RTC) coordinates.
 *
 * Consider a model that contains many small objects, but with such large spatial extents that 32 bits of GPU precision (accurate to ~7 digits) will not be sufficient to render all of the the objects without jittering.
 *
 * To prevent jittering, we could spatially subdivide the objects into "tiles". Each tile would have a center position, and the positions of the objects within the tile would be relative to that center ("RTC coordinates").
 *
 * While the center positions of the tiles would be 64-bit values, the object positions only need to be 32-bit.
 *
 * Internally, when rendering an object with RTC coordinates, xeokit first temporarily translates the camera viewing matrix by the object's tile's RTC center, on the CPU, using 64-bit math.
 *
 * Then xeokit loads the viewing matrix into its WebGL shaders, where math happens at 32-bit precision. Within the shaders, the matrix is effectively down-cast to 32-bit precision, and the object's 32-bit vertex positions are transformed by the matrix.
 *
 * We see no jittering, because with RTC a detectable loss of GPU accuracy only starts happening to objects as they become very distant from the camera viewpoint, at which point they are too small to be discernible anyway.
 *
 * ## RTC Coordinates with Geometry Instancing
 *
 * To use RTC with ````PerformanceModel```` geometry instancing, we specify an RTC center for the geometry. Then ````PerformanceModel```` assumes that all meshes that instance that geometry are within the same RTC coordinate system, ie. the meshes ````position```` and ````rotation```` properties are assumed to be relative to the geometry's ````rtcCenter````.
 *
 * For simplicity, our example's meshes all instance the same geometry. Therefore, our example model has only one RTC center.
 *
 * Note that the axis-aligned World-space boundary (AABB) of our model is ````[-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching)
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_instancing_rtcCenter)]
 *
 * ````javascript
 * const rtcCenter = [100000000, 0, 100000000];
 *
 * performanceModel.createGeometry({
 *     id: "box",
 *     rtcCenter: rtcCenter, // This geometry's positions, and the transforms of all meshes that instance the geometry, are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg1",
 *     geometryId: "box",
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg1"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg2",
 *     geometryId: "box",
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg2"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg3",
 *     geometryId: "box",
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg3"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg4",
 *     geometryId: "box",
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg4"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "top",
 *     geometryId: "box",
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["top"],
 *     isObject: true
 * });
 * ````
 *
 * ## RTC Coordinates with Geometry Batching
 *
 * To use RTC with ````PerformanceModel```` geometry batching, we specify an RTC center (````rtcCenter````) for each mesh. For performance, we try to have as many meshes share the same value for ````rtcCenter```` as possible. Each mesh's ````positions````, ````position```` and ````rotation```` properties are assumed to be relative to ````rtcCenter````.
 *
 * For simplicity, the meshes in our example all share the same RTC center.
 *
 * The axis-aligned World-space boundary (AABB) of our model is ````[-6, -9, -6, 1000000006, -2.5, 1000000006]````.
 *
 * [![](http://xeokit.io/img/docs/sceneGraph.png)](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching)
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_PerformanceModel_batching_rtcCenter)]
 *
 * ````javascript
 * const rtcCenter = [100000000, 0, 100000000];
 *
 * performanceModel.createMesh({
 *     id: "leg1",
 *     rtcCenter: rtcCenter, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1, 0.3, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg1"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg2",
 *     rtcCenter: rtcCenter, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, -4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 1.0, 0.3]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg2"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg3",
 *     rtcCenter: rtcCenter, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [0.3, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg3"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "leg4",
 *     rtcCenter: rtcCenter, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [-4, -6, 4],
 *     scale: [1, 3, 1],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 1.0, 0.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["leg4"],
 *     isObject: true
 * });
 *
 * performanceModel.createMesh({
 *     id: "top",
 *     rtcCenter: rtcCenter, // This mesh's positions and transforms are relative to the RTC center
 *     primitive: "triangles",
 *     positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ... ],
 *     normals: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ],
 *     indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, ... ],
 *     position: [0, -3, 0],
 *     scale: [6, 0.5, 6],
 *     rotation: [0, 0, 0],
 *     color: [1.0, 0.3, 1.0]
 * });
 *
 * performanceModel.createEntity({
 *     meshIds: ["top"],
 *     isObject: true
 * });
 ````
 *
 * @implements {Drawable}
 * @implements {Entity}
 */
var PerformanceModel = /*@__PURE__*/(function (Component) {
    function PerformanceModel(owner, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._maxGeometryBatchSize = cfg.maxGeometryBatchSize;

        this._aabb = math.collapseAABB3();
        this._aabbDirty = false;
        this._layerList = []; // For GL state efficiency when drawing, InstancingLayers are in first part, BatchingLayers are in second
        this._nodeList = [];

        this._lastRTCCenter = null;
        this._lastDecodeMatrix = null;
        this._lastNormals = null;

        this._instancingLayers = {};
        this._currentBatchingLayers = {};

        this._scratchMemory = getScratchMemory();

        this._meshes = {};
        this._nodes = {};

        /** @private **/
        this.renderFlags = new RenderFlags();

        /**
         * @private
         */
        this.numGeometries = 0; // Number of instance-able geometries created with createGeometry()

        // These counts are used to avoid unnecessary render passes
        // They are incremented or decremented exclusively by BatchingLayer and InstancingLayer
        /**
         * @private
         */
        this.numPortions = 0;

        /**
         * @private
         */
        this.numVisibleLayerPortions = 0;

        /**
         * @private
         */
        this.numTransparentLayerPortions = 0;

        /**
         * @private
         */
        this.numXRayedLayerPortions = 0;

        /**
         * @private
         */
        this.numHighlightedLayerPortions = 0;

        /**
         * @private
         */
        this.numSelectedLayerPortions = 0;

        /**
         * @private
         */
        this.numEdgesLayerPortions = 0;

        /**
         * @private
         */
        this.numPickableLayerPortions = 0;

        /**
         * @private
         */
        this.numClippableLayerPortions = 0;

        /**
         * @private
         */
        this.numCulledLayerPortions = 0;

        /** @private */
        this.numEntities = 0;

        /** @private */
        this._numTriangles = 0;

        /** @private */
        this._numLines = 0;

        /** @private */
        this._numPoints = 0;

        this._edgeThreshold = cfg.edgeThreshold || 10;

        this.visible = cfg.visible;
        this.culled = cfg.culled;
        this.pickable = cfg.pickable;
        this.clippable = cfg.clippable;
        this.collidable = cfg.collidable;
        this.castsShadow = cfg.castsShadow;
        this.receivesShadow = cfg.receivesShadow;
        this.xrayed = cfg.xrayed;
        this.highlighted = cfg.highlighted;
        this.selected = cfg.selected;
        this.edges = cfg.edges;
        this.colorize = cfg.colorize;
        this.opacity = cfg.opacity;
        this.backfaces = cfg.backfaces;

        // Build static matrix

        this._position = new Float32Array(cfg.position || [0, 0, 0]);
        this._rotation = new Float32Array(cfg.rotation || [0, 0, 0]);
        this._quaternion = new Float32Array(cfg.quaternion || [0, 0, 0, 1]);
        if (cfg.rotation) {
            math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion);
        }
        this._scale = new Float32Array(cfg.scale || [1, 1, 1]);
        this._worldMatrix = math.mat4();
        math.composeMat4(this._position, this._quaternion, this._scale, this._worldMatrix);
        this._worldNormalMatrix = math.mat4();
        math.inverseMat4(this._worldMatrix, this._worldNormalMatrix);
        math.transposeMat4(this._worldNormalMatrix);

        if (cfg.matrix || cfg.position || cfg.rotation || cfg.scale || cfg.quaternion) {
            this._viewMatrix = math.mat4();
            this._viewNormalMatrix = math.mat4();
            this._viewMatrixDirty = true;
            this._worldMatrixNonIdentity = true;
        }

        this._opacity = 1.0;
        this._colorize = [1, 1, 1];

        this._saoEnabled = (cfg.saoEnabled !== false);

        this._pbrEnabled = (!!cfg.pbrEnabled);

        this._isModel = cfg.isModel;
        if (this._isModel) {
            this.scene._registerModel(this);
        }

        this._onCameraViewMatrix = this.scene.camera.on("matrix", function () {
            this$1._viewMatrixDirty = true;
        });
    }

    if ( Component ) PerformanceModel.__proto__ = Component;
    PerformanceModel.prototype = Object.create( Component && Component.prototype );
    PerformanceModel.prototype.constructor = PerformanceModel;

    var prototypeAccessors = { isPerformanceModel: { configurable: true },position: { configurable: true },rotation: { configurable: true },quaternion: { configurable: true },scale: { configurable: true },matrix: { configurable: true },worldMatrix: { configurable: true },worldNormalMatrix: { configurable: true },viewMatrix: { configurable: true },viewNormalMatrix: { configurable: true },backfaces: { configurable: true },entityList: { configurable: true },isEntity: { configurable: true },isModel: { configurable: true },isObject: { configurable: true },aabb: { configurable: true },numTriangles: { configurable: true },numLines: { configurable: true },numPoints: { configurable: true },visible: { configurable: true },xrayed: { configurable: true },highlighted: { configurable: true },selected: { configurable: true },edges: { configurable: true },culled: { configurable: true },clippable: { configurable: true },collidable: { configurable: true },pickable: { configurable: true },colorize: { configurable: true },opacity: { configurable: true },castsShadow: { configurable: true },receivesShadow: { configurable: true },saoEnabled: { configurable: true },pbrEnabled: { configurable: true },isDrawable: { configurable: true },isStateSortable: { configurable: true },xrayMaterial: { configurable: true },highlightMaterial: { configurable: true },selectedMaterial: { configurable: true },edgeMaterial: { configurable: true } };

    //------------------------------------------------------------------------------------------------------------------
    // PerformanceModel members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that this Component is a PerformanceModel.
     * @type {Boolean}
     */
    prototypeAccessors.isPerformanceModel.get = function () {
        return true;
    };

    /**
     * Gets the PerformanceModel's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.position.get = function () {
        return this._position;
    };

    /**
     * Gets the PerformanceModel's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rotation.get = function () {
        return this._rotation;
    };

    /**
     * Gets the PerformanceModels's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.quaternion.get = function () {
        return this._quaternion;
    };

    /**
     * Gets the PerformanceModel's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Gets the PerformanceModel's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.matrix.get = function () {
        return this._worldMatrix;
    };

    /**
     * Gets the PerformanceModel's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */
    prototypeAccessors.worldMatrix.get = function () {
        return this._worldMatrix;
    };

    /**
     * Gets the PerformanceModel's World normal matrix.
     *
     * @type {Number[]}
     */
    prototypeAccessors.worldNormalMatrix.get = function () {
        return this._worldNormalMatrix;
    };

    /**
     * Called by private renderers in ./lib, returns the view matrix with which to
     * render this PerformanceModel. The view matrix is the concatenation of the
     * Camera view matrix with the Performance model's world (modeling) matrix.
     *
     * @private
     */
    prototypeAccessors.viewMatrix.get = function () {
        if (!this._viewMatrix) {
            return this.scene.camera.viewMatrix;
        }
        if (this._viewMatrixDirty) {
            math.mulMat4(this.scene.camera.viewMatrix, this._worldMatrix, this._viewMatrix);
            math.inverseMat4(this._viewMatrix, this._viewNormalMatrix);
            math.transposeMat4(this._viewNormalMatrix);
            this._viewMatrixDirty = false;
        }
        return this._viewMatrix;
    };

    /**
     * Called by private renderers in ./lib, returns the picking view matrix with which to
     * ray-pick on this PerformanceModel.
     *
     * @private
     */
    PerformanceModel.prototype.getPickViewMatrix = function getPickViewMatrix (pickViewMatrix) {
        if (!this._viewMatrix) {
            return pickViewMatrix;
        }
        return this._viewMatrix;
    };

    /**
     * Called by private renderers in ./lib, returns the view normal matrix with which to render this PerformanceModel.
     *
     * @private
     */
    prototypeAccessors.viewNormalMatrix.get = function () {
        if (!this._viewNormalMatrix) {
            return this.scene.camera.viewNormalMatrix;
        }
        if (this._viewMatrixDirty) {
            math.mulMat4(this.scene.camera.viewMatrix, this._worldMatrix, this._viewMatrix);
            math.inverseMat4(this._viewMatrix, this._viewNormalMatrix);
            math.transposeMat4(this._viewNormalMatrix);
            this._viewMatrixDirty = false;
        }
        return this._viewNormalMatrix;
    };

    /**
     * Creates a reusable geometry within this PerformanceModel.
     *
     * We can then supply the geometry ID to {@link PerformanceModel#createMesh} when we want to create meshes that instance the geometry.
     *
     * If provide a  ````positionsDecodeMatrix```` , then ````createGeometry()```` will assume
     * that the ````positions```` and ````normals```` arrays are compressed. When compressed, ````positions```` will be
     * quantized and in World-space, and ````normals```` will be oct-encoded and in World-space.
     *
     * Note that ````positions````, ````normals```` and ````indices```` are all required together.
     *
     * @param {*} cfg Geometry properties.
     * @param {String|Number} cfg.id Mandatory ID for the geometry, to refer to with {@link PerformanceModel#createMesh}.
     * @param {String} cfg.primitive The primitive type. Accepted values are 'points', 'lines', 'triangles', 'solid' and 'surface'.
     * @param {Number[]} cfg.positions Flat array of positions.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with 'triangles' primitives. When no normals are given, the geometry will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.colors] Flat array of RGBA vertex colors as float values in range ````[0..1]````. Ignored when ````geometryId```` is given, overidden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of RGBA vertex colors as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given, overrides ````colors```` and is overriden by ````color````.
     * @param {Number[]} [cfg.indices] Array of indices. Not required for `points` primitives.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. Used only for Required for 'triangles' primitives. These are automatically generated internally if not supplied, using the ````edgeThreshold```` given to the ````PerformanceModel```` constructor.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positions````.
     * @param {Number[]} [cfg.rtcCenter] Relative-to-center (RTC) coordinate system center. When this is given, then ````positions```` are assumed to be relative to this center.
     */
    PerformanceModel.prototype.createGeometry = function createGeometry (cfg) {
        if (!instancedArraysSupported) {
            this.error("WebGL instanced arrays not supported"); // TODO: Gracefully use batching?
            return;
        }
        var geometryId = cfg.id;
        if (geometryId === undefined || geometryId === null) {
            this.error("Config missing: id");
            return;
        }
        if (this._instancingLayers[geometryId]) {
            this.error("Geometry already created: " + geometryId);
            return;
        }
        var instancingLayer;
        var primitive = cfg.primitive;
        if (primitive === undefined || primitive === null) {
            this.error("Config missing: primitive");
            return;
        }
        switch (primitive) {
            case "triangles":
                instancingLayer = new TrianglesInstancingLayer(this, utils.apply({
                    layerIndex: 0,
                    solid: true
                }, cfg));
                this._numTriangles += (cfg.indices ? Math.round(cfg.indices.length / 3) : 0);
                break;
            case "solid":
                instancingLayer = new TrianglesInstancingLayer(this, utils.apply({
                    layerIndex: 0,
                    solid: true
                }, cfg));
                this._numTriangles += (cfg.indices ? Math.round(cfg.indices.length / 3) : 0);
                break;
            case "surface":
                instancingLayer = new TrianglesInstancingLayer(this, utils.apply({
                    layerIndex: 0,
                    solid: false
                }, cfg));
                this._numTriangles += (cfg.indices ? Math.round(cfg.indices.length / 3) : 0);
                break;
            case "lines":
                instancingLayer = new LinesInstancingLayer(this, utils.apply({
                    layerIndex: 0
                }, cfg));
                this._numLines += (cfg.indices ? Math.round(cfg.indices.length / 2) : 0);
                break;
            case "points":
                instancingLayer = new PointsInstancingLayer(this, utils.apply({
                    layerIndex: 0
                }, cfg));
                this._numPoints += (cfg.positions ? Math.round(cfg.positions.length / 3) : 0);
                break;
        }
        this._instancingLayers[geometryId] = instancingLayer;
        this._layerList.push(instancingLayer);
        this.numGeometries++;
    };

    /**
     * Creates a mesh within this PerformanceModel.
     *
     * A mesh can either share geometry with other meshes, or have its own unique geometry.
     *
     * To share a geometry with other meshes, provide the ID of a geometry created earlier
     * with {@link PerformanceModel#createGeometry}.
     *
     * To create unique geometry for the mesh, provide geometry data arrays.
     *
     * Internally, PerformanceModel will batch all unique mesh geometries into the same arrays, which improves
     * rendering performance.
     *
     * If you accompany the arrays with a  ````positionsDecodeMatrix```` , then ````createMesh()```` will assume
     * that the ````positions```` and ````normals```` arrays are compressed. When compressed, ````positions```` will be
     * quantized and in World-space, and ````normals```` will be oct-encoded and in World-space.
     *
     * If you accompany the arrays with an  ````rtcCenter````, then ````createMesh()```` will assume
     * that the ````positions```` are in relative-to-center (RTC) coordinates, with ````rtcCenter```` being the origin of their
     * RTC coordinate system.
     *
     * When providing either ````positionsDecodeMatrix```` or ````rtcCenter````, ````createMesh()```` will start a new
     * batch each time either of those two parameters change since the last call. Therefore, to combine arrays into the
     * minimum number of batches, it's best for performance to create your shared meshes in runs that have the same value
     * for ````positionsDecodeMatrix```` and ````rtcCenter````.
     *
     * Note that ````positions````, ````normals```` and ````indices```` are all required together.
     *
     * @param {object} cfg Object properties.
     * @param {String} cfg.id Mandatory ID for the new mesh. Must not clash with any existing components within the {@link Scene}.
     * @param {String|Number} [cfg.geometryId] ID of a geometry to instance, previously created with {@link PerformanceModel#createGeometry:method"}}createMesh(){{/crossLink}}. Overrides all other geometry parameters given to this method.
     * @param {String} [cfg.primitive="triangles"]  Geometry primitive type. Ignored when ````geometryId```` is given. Accepted values are 'points', 'lines' and 'triangles'.
     * @param {Number[]} [cfg.positions] Flat array of vertex positions. Ignored when ````geometryId```` is given.
     * @param {Number[]} [cfg.colors] Flat array of RGB vertex colors as float values in range ````[0..1]````. Ignored when ````geometryId```` is given, overriden by ````color```` and ````colorsCompressed````.
     * @param {Number[]} [cfg.colorsCompressed] Flat array of RGB vertex colors as unsigned short integers in range ````[0..255]````. Ignored when ````geometryId```` is given, overrides ````colors```` and is overriden by ````color````.
     * @param {Number[]} [cfg.normals] Flat array of normal vectors. Only used with 'triangles' primitives. When no normals are given, the mesh will be flat shaded using auto-generated face-aligned normals.
     * @param {Number[]} [cfg.positionsDecodeMatrix] A 4x4 matrix for decompressing ````positions````.
     * @param {Number[]} [cfg.rtcCenter] Relative-to-center (RTC) coordinate system center. When this is given, then ````positions```` are assumed to be relative to this center.
     * @param {Number[]} [cfg.indices] Array of triangle indices. Ignored when ````geometryId```` is given.
     * @param {Number[]} [cfg.edgeIndices] Array of edge line indices. If ````geometryId```` is not given, edge line indices are
     * automatically generated internally if not given, using the ````edgeThreshold```` given to the ````PerformanceModel````
     * constructor. This parameter is ignored when ````geometryId```` is given.
     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position. of the mesh
     * @param {Number[]} [cfg.scale=[1,1,1]] Scale of the mesh.
     * @param {Number[]} [cfg.rotation=[0,0,0]] Rotation of the mesh as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Mesh modelling transform matrix. Overrides the ````position````, ````scale```` and ````rotation```` parameters.
     * @param {Number[]} [cfg.color=[1,1,1]] RGB color in range ````[0..1, 0..`, 0..1]````. Overrides ````colors```` and ````colorsCompressed````.
     * @param {Number} [cfg.opacity=1] Opacity in range ````[0..1]````.
     */
    PerformanceModel.prototype.createMesh = function createMesh (cfg) {
        var this$1 = this;


        var id = cfg.id;
        if (id === undefined || id === null) {
            this.error("Config missing: id");
            return;
        }
        if (this._meshes[id]) {
            this.error("PerformanceModel already has a Mesh with this ID: " + id + "");
            return;
        }

        var geometryId = cfg.geometryId;
        var instancing = (geometryId !== undefined);

        if (instancing) {
            if (!instancedArraysSupported) {
                this.error("WebGL instanced arrays not supported"); // TODO: Gracefully use batching?
                return;
            }
            if (!this._instancingLayers[geometryId]) {
                this.error("Geometry not found: " + geometryId + " - ensure that you create it first with createGeometry()");
                return;
            }
        }

        var layer;
        var portionId;

        var color = (cfg.color) ? new Uint8Array([Math.floor(cfg.color[0] * 255), Math.floor(cfg.color[1] * 255), Math.floor(cfg.color[2] * 255)]) : [255, 255, 255];
        var opacity = (cfg.opacity !== undefined && cfg.opacity !== null) ? Math.floor(cfg.opacity * 255) : 255;
        var metallic = (cfg.metallic !== undefined && cfg.metallic !== null) ? Math.floor(cfg.metallic * 255) : 0;
        var roughness = (cfg.roughness !== undefined && cfg.roughness !== null) ? Math.floor(cfg.roughness * 255) : 255;

        var mesh = new PerformanceMesh(this, id, color, opacity);

        var pickId = mesh.pickId;

        var a = pickId >> 24 & 0xFF;
        var b = pickId >> 16 & 0xFF;
        var g = pickId >> 8 & 0xFF;
        var r = pickId & 0xFF;

        var pickColor = new Uint8Array([r, g, b, a]); // Quantized pick color

        var aabb = math.collapseAABB3();

        if (instancing) {

            var meshMatrix;
            var worldMatrix = this._worldMatrixNonIdentity ? this._worldMatrix : null;

            if (cfg.matrix) {
                meshMatrix = cfg.matrix;
            } else {
                var scale = cfg.scale || defaultScale;
                var position = cfg.position || defaultPosition;
                var rotation = cfg.rotation || defaultRotation;
                math.eulerToQuaternion(rotation, "XYZ", defaultQuaternion);
                meshMatrix = math.composeMat4(position, defaultQuaternion, scale, tempMat4$1);
            }

            var instancingLayer = this._instancingLayers[geometryId];

            layer = instancingLayer;

            portionId = instancingLayer.createPortion({
                color: color,
                metallic: metallic,
                roughness: roughness,
                opacity: opacity,
                meshMatrix: meshMatrix,
                worldMatrix: worldMatrix,
                aabb: aabb,
                pickColor: pickColor
            });

            math.expandAABB3(this._aabb, aabb);

            var numTriangles = Math.round(instancingLayer.numIndices / 3);
            this._numTriangles += numTriangles;
            mesh.numTriangles = numTriangles;

            mesh.rtcCenter = instancingLayer.rtcCenter;

        } else { // Batching

            var primitive = cfg.primitive || "triangles";

            if (primitive !== "points" && primitive !== "lines" && primitive !== "triangles" && primitive !== "solid" && primitive !== "surface") {
                this.error(("Unsupported value for 'primitive': '" + primitive + "' - supported values are 'points', 'lines', 'triangles', 'solid' and 'surface'. Defaulting to 'triangles'."));
                primitive = "triangles";
            }

            var positions = cfg.positions;

            if (!positions) {
                this.error("Config missing: positions (no meshIds provided, so expecting geometry arrays instead)");
                return null;
            }

            var indices = cfg.indices;
            var edgeIndices = cfg.edgeIndices;

            if (!cfg.indices && primitive === "triangles") {
                this.error("Config missing for triangles primitive: indices (no meshIds provided, so expecting geometry arrays instead)");
                return null;
            }

            var needNewBatchingLayers = false;

            if (cfg.rtcCenter) {
                if (!this._lastRTCCenter) {
                    needNewBatchingLayers = true;
                    this._lastRTCCenter = math.vec3(cfg.rtcCenter);
                } else {
                    if (!math.compareVec3(this._lastRTCCenter, cfg.rtcCenter)) {
                        needNewBatchingLayers = true;
                        this._lastRTCCenter.set(cfg.rtcCenter);
                    }
                }
            }

            if (cfg.positionsDecodeMatrix) {
                if (!this._lastDecodeMatrix) {
                    needNewBatchingLayers = true;
                    this._lastDecodeMatrix = math.mat4(cfg.positionsDecodeMatrix);

                } else {
                    if (!math.compareMat4(this._lastDecodeMatrix, cfg.positionsDecodeMatrix)) {
                        needNewBatchingLayers = true;
                        this._lastDecodeMatrix.set(cfg.positionsDecodeMatrix);
                    }
                }
            }

            if (needNewBatchingLayers) {
                for (var prim in this._currentBatchingLayers) {
                    if (this._currentBatchingLayers.hasOwnProperty(prim)) {
                        this._currentBatchingLayers[prim].finalize();
                    }
                }
                this._currentBatchingLayers = {};
            }

            var normalsProvided = (!!cfg.normals && cfg.normals.length > 0);

            if (primitive === "triangles" || primitive === "solid" || primitive === "surface") {
                if (this._lastNormals !== null && normalsProvided !== this._lastNormals) {
                    ["triangles", "solid", "surface"].map(function (primitiveId) {
                        if (this$1._currentBatchingLayers[primitiveId]) {
                            this$1._currentBatchingLayers[primitiveId].finalize();
                            delete this$1._currentBatchingLayers[primitiveId];
                        }
                    });
                }
                this._lastNormals = normalsProvided;
            }

            var worldMatrix$1 = this._worldMatrixNonIdentity ? this._worldMatrix : null;
            var meshMatrix$1;

            if (!cfg.positionsDecodeMatrix) {
                if (cfg.matrix) {
                    meshMatrix$1 = cfg.matrix;
                } else {
                    var scale$1 = cfg.scale || defaultScale;
                    var position$1 = cfg.position || defaultPosition;
                    var rotation$1 = cfg.rotation || defaultRotation;
                    math.eulerToQuaternion(rotation$1, "XYZ", defaultQuaternion);
                    meshMatrix$1 = math.composeMat4(position$1, defaultQuaternion, scale$1, tempMat4$1);
                }
            }

            layer = this._currentBatchingLayers[primitive];

            switch (primitive) {

                case "triangles":
                case "solid":
                case "surface":

                    if (layer) {
                        if (!layer.canCreatePortion(positions.length, indices.length)) {
                            layer.finalize();
                            delete this._currentBatchingLayers[primitive];
                            layer = null;
                        }
                    }

                    if (!layer) {
                        layer = new TrianglesBatchingLayer(this, {
                            layerIndex: 0, // This is set in #finalize()
                            scratchMemory: this._scratchMemory,
                            positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                            rtcCenter: cfg.rtcCenter, // Can be undefined
                            maxGeometryBatchSize: this._maxGeometryBatchSize,
                            solid: (primitive === "solid"),
                            autoNormals: (!normalsProvided)
                        });
                        this._layerList.push(layer);
                        this._currentBatchingLayers[primitive] = layer;
                    }

                    if (!edgeIndices) {
                        edgeIndices = buildEdgeIndices(positions, indices, null, this._edgeThreshold);
                    }

                    portionId = layer.createPortion({
                        positions: positions,
                        normals: cfg.normals,
                        indices: indices,
                        edgeIndices: edgeIndices,
                        color: color,
                        metallic: metallic,
                        roughness: roughness,
                        colors: cfg.colors,
                        colorsCompressed: cfg.colorsCompressed,
                        opacity: opacity,
                        meshMatrix: meshMatrix$1,
                        worldMatrix: worldMatrix$1,
                        worldAABB: aabb,
                        pickColor: pickColor
                    });

                    var numTriangles$1 = Math.round(indices.length / 3);
                    this._numTriangles += numTriangles$1;
                    mesh.numTriangles = numTriangles$1;

                    break;

                case "lines":

                    if (layer) {
                        if (!layer.canCreatePortion(positions.length, indices.length)) {
                            layer.finalize();
                            delete this._currentBatchingLayers[primitive];
                            layer = null;
                        }
                    }

                    if (!layer) {
                        layer = new LinesBatchingLayer(this, {
                            layerIndex: 0, // This is set in #finalize()
                            scratchMemory: this._scratchMemory,
                            positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                            rtcCenter: cfg.rtcCenter, // Can be undefined
                            maxGeometryBatchSize: this._maxGeometryBatchSize
                        });
                        this._layerList.push(layer);
                        this._currentBatchingLayers[primitive] = layer;
                    }

                    portionId = layer.createPortion({
                        positions: positions,
                        indices: indices,
                        color: color,
                        colors: cfg.colors,
                        colorsCompressed: cfg.colorsCompressed,
                        opacity: opacity,
                        meshMatrix: meshMatrix$1,
                        worldMatrix: worldMatrix$1,
                        worldAABB: aabb,
                        pickColor: pickColor
                    });

                    this._numLines += Math.round(indices.length / 2);

                    break;

                case "points":

                    if (layer) {
                        if (!layer.canCreatePortion(positions.length)) {
                            layer.finalize();
                            delete this._currentBatchingLayers[primitive];
                            layer = null;
                        }
                    }

                    if (!layer) {
                        layer = new PointsBatchingLayer(this, {
                            layerIndex: 0, // This is set in #finalize()
                            scratchMemory: this._scratchMemory,
                            positionsDecodeMatrix: cfg.positionsDecodeMatrix,  // Can be undefined
                            rtcCenter: cfg.rtcCenter, // Can be undefined
                            maxGeometryBatchSize: this._maxGeometryBatchSize
                        });
                        this._layerList.push(layer);
                        this._currentBatchingLayers[primitive] = layer;
                    }

                    portionId = layer.createPortion({
                        positions: positions,
                        color: color,
                        colors: cfg.colors,
                        colorsCompressed: cfg.colorsCompressed,
                        opacity: opacity,
                        meshMatrix: meshMatrix$1,
                        worldMatrix: worldMatrix$1,
                        worldAABB: aabb,
                        pickColor: pickColor
                    });

                    this._numPoints += Math.round(positions.length / 3);

                    break;
            }

            math.expandAABB3(this._aabb, aabb);

            this.numGeometries++;

            mesh.rtcCenter = cfg.rtcCenter;
        }

        mesh.parent = null; // Will be set within PerformanceModelNode constructor
        mesh._layer = layer;
        mesh._portionId = portionId;
        mesh.aabb = aabb;

        this._meshes[id] = mesh;
    };

    /**
     * Creates an {@link Entity} within this PerformanceModel, giving it one or more meshes previously created with {@link PerformanceModel#createMesh}.
     *
     * A mesh can only belong to one {@link Entity}, so you'll get an error if you try to reuse a mesh among multiple {@link Entity}s.
     *
     * @param {Object} cfg Entity configuration.
     * @param {String} cfg.id Optional ID for the new Entity. Must not clash with any existing components within the {@link Scene}.
     * @param {String[]} cfg.meshIds IDs of one or more meshes created previously with {@link PerformanceModel@createMesh}.

     * @param {Boolean} [cfg.isObject] Set ````true```` if the {@link Entity} represents an object, in which case it will be registered by {@link Entity#id} in {@link Scene#objects} and can also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.
     * @param {Boolean} [cfg.visible=true] Indicates if the Entity is initially visible.
     * @param {Boolean} [cfg.culled=false] Indicates if the Entity is initially culled from view.
     * @param {Boolean} [cfg.pickable=true] Indicates if the Entity is initially pickable.
     * @param {Boolean} [cfg.clippable=true] Indicates if the Entity is initially clippable.
     * @param {Boolean} [cfg.collidable=true] Indicates if the Entity is initially included in boundary calculations.
     * @param {Boolean} [cfg.castsShadow=true] Indicates if the Entity initially casts shadows.
     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the Entity initially receives shadows.
     * @param {Boolean} [cfg.xrayed=false] Indicates if the Entity is initially xrayed. XRayed appearance is configured by {@link PerformanceModel#xrayMaterial}.
     * @param {Boolean} [cfg.highlighted=false] Indicates if the Entity is initially highlighted. Highlighted appearance is configured by {@link PerformanceModel#highlightMaterial}.
     * @param {Boolean} [cfg.selected=false] Indicates if the Entity is initially selected. Selected appearance is configured by {@link PerformanceModel#selectedMaterial}.
     * @param {Boolean} [cfg.edges=false] Indicates if the Entity's edges are initially emphasized. Edges appearance is configured by {@link PerformanceModel#edgeMaterial}.
     * @returns {Entity}
     */
    PerformanceModel.prototype.createEntity = function createEntity (cfg) {
        // Validate or generate Entity ID
        var id = cfg.id;
        if (id === undefined) {
            id = math.createUUID();
        } else if (this.scene.components[id]) {
            this.error("Scene already has a Component with this ID: " + id + " - will assign random ID");
            id = math.createUUID();
        }
        // Collect PerformanceModelNode's PerformanceModelMeshes
        var meshIds = cfg.meshIds;
        if (meshIds === undefined) {
            this.error("Config missing: meshIds");
            return;
        }
        var meshes = [];
        for (var i = 0, len = meshIds.length; i < len; i++) {
            var meshId = meshIds[i];
            var mesh = this._meshes[meshId];
            if (!mesh) {
                this.error("Mesh with this ID not found: " + meshId + " - ignoring this mesh");
                continue;
            }
            if (mesh.parent) {
                this.error("Mesh with ID " + meshId + " already belongs to object with ID " + mesh.parent.id + " - ignoring this mesh");
                continue;
            }
            meshes.push(mesh);
        }
        // Create PerformanceModelNode flags
        var flags = 0;
        if (this._visible && cfg.visible !== false) {
            flags = flags | ENTITY_FLAGS.VISIBLE;
        }
        if (this._pickable && cfg.pickable !== false) {
            flags = flags | ENTITY_FLAGS.PICKABLE;
        }
        if (this._culled && cfg.culled !== false) {
            flags = flags | ENTITY_FLAGS.CULLED;
        }
        if (this._clippable && cfg.clippable !== false) {
            flags = flags | ENTITY_FLAGS.CLIPPABLE;
        }
        if (this._collidable && cfg.collidable !== false) {
            flags = flags | ENTITY_FLAGS.COLLIDABLE;
        }
        if (this._edges && cfg.edges !== false) {
            flags = flags | ENTITY_FLAGS.EDGES;
        }
        if (this._xrayed && cfg.xrayed !== false) {
            flags = flags | ENTITY_FLAGS.XRAYED;
        }
        if (this._highlighted && cfg.highlighted !== false) {
            flags = flags | ENTITY_FLAGS.HIGHLIGHTED;
        }
        if (this._selected && cfg.selected !== false) {
            flags = flags | ENTITY_FLAGS.SELECTED;
        }

        // Create PerformanceModelNode AABB
        var aabb;
        if (meshes.length === 1) {
            aabb = meshes[0].aabb;
        } else {
            aabb = math.collapseAABB3();
            for (var i$1 = 0, len$1 = meshes.length; i$1 < len$1; i$1++) {
                math.expandAABB3(aabb, meshes[i$1].aabb);
            }
        }

        var node = new PerformanceNode(this, cfg.isObject, id, meshes, flags, aabb); // Internally sets PerformanceModelMesh#parent to this PerformanceModelNode
        this._nodeList.push(node);
        this._nodes[id] = node;
        this.numEntities++;
        return node;
    };

    /**
     * Finalizes this PerformanceModel.
     *
     * Immediately creates the PerformanceModel's {@link Entity}s within the {@link Scene}.
     *
     * Once finalized, you can't add anything more to this PerformanceModel.
     */
    PerformanceModel.prototype.finalize = function finalize () {

        if (this.destroyed) {
            return;
        }

        for (var geometryId in this._instancingLayers) {
            if (this._instancingLayers.hasOwnProperty(geometryId)) {
                this._instancingLayers[geometryId].finalize();
            }
        }

        for (var primitive in this._currentBatchingLayers) {
            if (this._currentBatchingLayers.hasOwnProperty(primitive)) {
                this._currentBatchingLayers[primitive].finalize();
            }
        }
        this._currentBatchingLayers = {};

        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            var node = this._nodeList[i];
            node._finalize();
        }

        // Sort layers to reduce WebGL shader switching when rendering them

        this._layerList.sort(function (a, b) {
            if (a.sortId < b.sortId) {
                return -1;
            }
            if (a.sortId > b.sortId) {
                return 1;
            }
            return 0;
        });

        for (var i$1 = 0, len$1 = this._layerList.length; i$1 < len$1; i$1++) {
            var layer = this._layerList[i$1];
            layer.layerIndex = i$1;
        }

        this.glRedraw();

        this.scene._aabbDirty = true;
    };

    //------------------------------------------------------------------------------------------------------------------
    // PerformanceModel members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Sets if backfaces are rendered for this PerformanceModel.
     *
     * Default is ````false````.
     *
     * When we set this ````true````, then backfaces are always rendered for this PerformanceModel.
     *
     * When we set this ````false````, then we allow the Viewer to decide whether to render backfaces. In this case,
     * the Viewer will:
     *
     *  * hide backfaces on watertight meshes,
     *  * show backfaces on open meshes, and
     *  * always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (backfaces) {
        backfaces = !!backfaces;
        this._backfaces = backfaces;
        this.glRedraw();
    };

    /**
     * Sets if backfaces are rendered for this PerformanceModel.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._backfaces;
    };

    /**
     * Gets the list of {@link Entity}s within this PerformanceModel.
     *
     * @returns {Entity[]}
     */
    prototypeAccessors.entityList.get = function () {
        return this._nodeList;
    };

    //------------------------------------------------------------------------------------------------------------------
    // Entity members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that PerformanceModel is an {@link Entity}.
     * @type {Boolean}
     */
    prototypeAccessors.isEntity.get = function () {
        return true;
    };

    /**
     * Returns ````true```` if this PerformanceModel represents a model.
     *
     * When ````true```` the PerformanceModel will be registered by {@link PerformanceModel#id} in
     * {@link Scene#models} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isModel.get = function () {
        return this._isModel;
    };

    /**
     * Returns ````false```` to indicate that PerformanceModel never represents an object.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isObject.get = function () {
        return false;
    };

    /**
     * Gets the PerformanceModel's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        if (this._aabbDirty) {
            this._rebuildAABB();
        }
        return this._aabb;
    };

    PerformanceModel.prototype._rebuildAABB = function _rebuildAABB () {
        math.collapseAABB3(this._aabb);
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            var node = this._nodeList[i];
            math.expandAABB3(this._aabb, node.aabb);
        }
        this._aabbDirty = false;
    };

    /**
     * The approximate number of triangle primitives in this PerformanceModel.
     *
     * @type {Number}
     */
    prototypeAccessors.numTriangles.get = function () {
        return this._numTriangles;
    };

    /**
     * The approximate number of line primitives in this PerformanceModel.
     *
     * @type {Number}
     */
    prototypeAccessors.numLines.get = function () {
        return this._numLines;
    };

    /**
     * The approximate number of point primitives in this PerformanceModel.
     *
     * @type {Number}
     */
    prototypeAccessors.numPoints.get = function () {
        return this._numPoints;
    };

    /**
     * Sets if this PerformanceModel is visible.
     *
     * The PerformanceModel is only rendered when {@link PerformanceModel#visible} is ````true```` and {@link PerformanceModel#culled} is ````false````.
     **
     * @type {Boolean}
     */
    prototypeAccessors.visible.set = function (visible) {
        visible = visible !== false;
        this._visible = visible;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].visible = visible;
        }
        this.glRedraw();
    };

    /**
     * Gets if any {@link Entity}s in this PerformanceModel are visible.
     *
     * The PerformanceModel is only rendered when {@link PerformanceModel#visible} is ````true```` and {@link PerformanceModel#culled} is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.visible.get = function () {
        return (this.numVisibleLayerPortions > 0);
    };

    /**
     * Sets if all {@link Entity}s in this PerformanceModel are xrayed.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.set = function (xrayed) {
        xrayed = !!xrayed;
        this._xrayed = xrayed;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].xrayed = xrayed;
        }
        this.glRedraw();
    };

    /**
     * Gets if any {@link Entity}s in this PerformanceModel are xrayed.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.get = function () {
        return (this.numXRayedLayerPortions > 0);
    };

    /**
     * Sets if all {@link Entity}s in this PerformanceModel are highlighted.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.set = function (highlighted) {
        highlighted = !!highlighted;
        this._highlighted = highlighted;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].highlighted = highlighted;
        }
        this.glRedraw();
    };

    /**
     * Gets if any {@link Entity}s in this PerformanceModel are highlighted.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.get = function () {
        return (this.numHighlightedLayerPortions > 0);
    };

    /**
     * Sets if all {@link Entity}s in this PerformanceModel are selected.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.set = function (selected) {
        selected = !!selected;
        this._selected = selected;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].selected = selected;
        }
        this.glRedraw();
    };

    /**
     * Gets if any {@link Entity}s in this PerformanceModel are selected.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.get = function () {
        return (this.numSelectedLayerPortions > 0);
    };

    /**
     * Sets if all {@link Entity}s in this PerformanceModel have edges emphasised.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.set = function (edges) {
        edges = !!edges;
        this._edges = edges;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].edges = edges;
        }
        this.glRedraw();
    };

    /**
     * Gets if any {@link Entity}s in this PerformanceModel have edges emphasised.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.get = function () {
        return (this.numEdgesLayerPortions > 0);
    };

    /**
     * Sets if this PerformanceModel is culled from view.
     *
     * The PerformanceModel is only rendered when {@link PerformanceModel#visible} is true and {@link PerformanceModel#culled} is false.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.set = function (culled) {
        culled = !!culled;
        this._culled = culled;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].culled = culled;
        }
        this.glRedraw();
    };

    /**
     * Gets if this PerformanceModel is culled from view.
     *
     * The PerformanceModel is only rendered when {@link PerformanceModel#visible} is true and {@link PerformanceModel#culled} is false.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.get = function () {
        return this._culled;
    };

    /**
     * Sets if {@link Entity}s in this PerformanceModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.set = function (clippable) {
        clippable = clippable !== false;
        this._clippable = clippable;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].clippable = clippable;
        }
        this.glRedraw();
    };

    /**
     * Gets if {@link Entity}s in this PerformanceModel are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.get = function () {
        return this._clippable;
    };

    /**
     * Sets if {@link Entity}s in this PerformanceModel are collidable.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.set = function (collidable) {
        collidable = collidable !== false;
        this._collidable = collidable;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].collidable = collidable;
        }
    };

    /**
     * Gets if this PerformanceModel is collidable.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.get = function () {
        return this._collidable;
    };

    /**
     * Sets if {@link Entity}s in this PerformanceModel are pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.set = function (pickable) {
        pickable = pickable !== false;
        this._pickable = pickable;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].pickable = pickable;
        }
    };

    /**
     * Gets if this PerformanceModel is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.get = function () {
        return (this.numPickableLayerPortions > 0);
    };

    /**
     * Sets the RGB colorize color for this PerformanceModel.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.set = function (colorize) {
        this._colorize = colorize;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].colorize = colorize;
        }
    };

    /**
     * Gets the RGB colorize color for this PerformanceModel.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.get = function () {
        return this._colorize;
    };

    /**
     * Sets the opacity factor for this PerformanceModel.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.set = function (opacity) {
        this._opacity = opacity;
        for (var i = 0, len = this._nodeList.length; i < len; i++) {
            this._nodeList[i].opacity = opacity;
        }
    };

    /**
     * Gets this PerformanceModel's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.get = function () {
        return this._opacity;
    };

    /**
     * Sets if this PerformanceModel casts a shadow.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.set = function (castsShadow) {
        castsShadow = (castsShadow !== false);
        if (castsShadow !== this._castsShadow) {
            this._castsShadow = castsShadow;
            this.glRedraw();
        }
    };

    /**
     * Gets if this PerformanceModel casts a shadow.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.get = function () {
        return this._castsShadow;
    };

    /**
     * Sets if this PerformanceModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.set = function (receivesShadow) {
        receivesShadow = (receivesShadow !== false);
        if (receivesShadow !== this._receivesShadow) {
            this._receivesShadow = receivesShadow;
            this.glRedraw();
        }
    };

    /**
     * Sets if this PerformanceModel can have shadow cast upon it.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.get = function () {
        return this._receivesShadow;
    };

    /**
     * Gets if Scalable Ambient Obscurance (SAO) will apply to this PerformanceModel.
     *
     * SAO is configured by the Scene's {@link SAO} component.
     *
     *  Only works when {@link SAO#enabled} is also true.
     *
     * @type {Boolean}
     */
    prototypeAccessors.saoEnabled.get = function () {
        return this._saoEnabled;
    };

    /**
     * Gets if physically-based rendering (PBR) is enabled for this PerformanceModel.
     *
     * Only works when {@link Scene#pbrEnabled} is also true.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pbrEnabled.get = function () {
        return this._pbrEnabled;
    };

    //------------------------------------------------------------------------------------------------------------------
    // Drawable members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that PerformanceModel is implements {@link Drawable}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isDrawable.get = function () {
        return true;
    };

    /** @private */
    prototypeAccessors.isStateSortable.get = function () {
        return false
    };

    /** @private */
    PerformanceModel.prototype.stateSortCompare = function stateSortCompare (drawable1, drawable2) {
    };

    /** @private */
    PerformanceModel.prototype.rebuildRenderFlags = function rebuildRenderFlags () {
        this.renderFlags.reset();
        this._updateRenderFlagsVisibleLayers();
        if (this.renderFlags.numLayers > 0 && this.renderFlags.numVisibleLayers === 0) {
            this.renderFlags.culled = true;
            return;
        }
        this._updateRenderFlags();
    };

    /**
     * @private
     */
    PerformanceModel.prototype._updateRenderFlagsVisibleLayers = function _updateRenderFlagsVisibleLayers () {
        var renderFlags = this.renderFlags;
        renderFlags.numLayers = this._layerList.length;
        renderFlags.numVisibleLayers = 0;
        for (var layerIndex = 0, len = this._layerList.length; layerIndex < len; layerIndex++) {
            var layer = this._layerList[layerIndex];
            var layerVisible = this._getActiveSectionPlanesForLayer(layer);
            if (layerVisible) {
                renderFlags.visibleLayers[renderFlags.numVisibleLayers++] = layerIndex;
            }
        }
    };

    /** @private */
    PerformanceModel.prototype._getActiveSectionPlanesForLayer = function _getActiveSectionPlanesForLayer (layer) {

        var renderFlags = this.renderFlags;
        var sectionPlanes = this.scene._sectionPlanesState.sectionPlanes;
        var numSectionPlanes = sectionPlanes.length;
        var baseIndex = layer.layerIndex * numSectionPlanes;

        if (numSectionPlanes > 0) {
            for (var i = 0; i < numSectionPlanes; i++) {

                var sectionPlane = sectionPlanes[i];

                if (!sectionPlane.active) {
                    renderFlags.sectionPlanesActivePerLayer[baseIndex + i] = false;

                } else {
                    renderFlags.sectionPlanesActivePerLayer[baseIndex + i] = true;
                    renderFlags.sectioned = true;
                }
            }
        }

        return true;
    };

    /** @private */
    PerformanceModel.prototype._updateRenderFlags = function _updateRenderFlags () {

        if (this.numVisibleLayerPortions === 0) {
            return;
        }

        if (this.numCulledLayerPortions === this.numPortions) {
            return;
        }

        var renderFlags = this.renderFlags;

        renderFlags.colorOpaque = (this.numTransparentLayerPortions < this.numPortions);

        if (this.numTransparentLayerPortions > 0) {
            renderFlags.colorTransparent = true;
        }

        if (this.numXRayedLayerPortions > 0) {
            var xrayMaterial = this.scene.xrayMaterial._state;
            if (xrayMaterial.fill) {
                if (xrayMaterial.fillAlpha < 1.0) {
                    renderFlags.xrayedSilhouetteTransparent = true;
                } else {
                    renderFlags.xrayedSilhouetteOpaque = true;
                }
            }
            if (xrayMaterial.edges) {
                if (xrayMaterial.edgeAlpha < 1.0) {
                    renderFlags.xrayedEdgesTransparent = true;
                } else {
                    renderFlags.xrayedEdgesOpaque = true;
                }
            }
        }

        if (this.numEdgesLayerPortions > 0) {
            var edgeMaterial = this.scene.edgeMaterial._state;
            if (edgeMaterial.edges) {
                renderFlags.edgesOpaque = (this.numTransparentLayerPortions < this.numPortions);
                if (this.numTransparentLayerPortions > 0) {
                    renderFlags.edgesTransparent = true;
                }
            }
        }

        if (this.numSelectedLayerPortions > 0) {
            var selectedMaterial = this.scene.selectedMaterial._state;
            if (selectedMaterial.fill) {
                if (selectedMaterial.fillAlpha < 1.0) {
                    renderFlags.selectedSilhouetteTransparent = true;
                } else {
                    renderFlags.selectedSilhouetteOpaque = true;
                }
            }
            if (selectedMaterial.edges) {
                if (selectedMaterial.edgeAlpha < 1.0) {
                    renderFlags.selectedEdgesTransparent = true;
                } else {
                    renderFlags.selectedEdgesOpaque = true;
                }
            }
        }

        if (this.numHighlightedLayerPortions > 0) {
            var highlightMaterial = this.scene.highlightMaterial._state;
            if (highlightMaterial.fill) {
                if (highlightMaterial.fillAlpha < 1.0) {
                    renderFlags.highlightedSilhouetteTransparent = true;
                } else {
                    renderFlags.highlightedSilhouetteOpaque = true;
                }
            }
            if (highlightMaterial.edges) {
                if (highlightMaterial.edgeAlpha < 1.0) {
                    renderFlags.highlightedEdgesTransparent = true;
                } else {
                    renderFlags.highlightedEdgesOpaque = true;
                }
            }
        }
    };

    /**
     * Configures the appearance of xrayed {@link Entity}s within this PerformanceModel.
     *
     * This is the {@link Scene#xrayMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.xrayMaterial.get = function () {
        return this.scene.xrayMaterial;
    };

    /**
     * Configures the appearance of highlighted {@link Entity}s within this PerformanceModel.
     *
     * This is the {@link Scene#highlightMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.highlightMaterial.get = function () {
        return this.scene.highlightMaterial;
    };

    /**
     * Configures the appearance of selected {@link Entity}s within this PerformanceModel.
     *
     * This is the {@link Scene#selectedMaterial}.
     *
     * @type {EmphasisMaterial}
     */
    prototypeAccessors.selectedMaterial.get = function () {
        return this.scene.selectedMaterial;
    };

    /**
     * Configures the appearance of edges of {@link Entity}s within this PerformanceModel.
     *
     * This is the {@link Scene#edgeMaterial}.
     *
     * @type {EdgeMaterial}
     */
    prototypeAccessors.edgeMaterial.get = function () {
        return this.scene.edgeMaterial;
    };

    // -------------- RENDERING ---------------------------------------------------------------------------------------

    /** @private */
    PerformanceModel.prototype.drawColorOpaque = function drawColorOpaque (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawColorOpaque(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawColorTransparent = function drawColorTransparent (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawColorTransparent(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawDepth = function drawDepth (frameCtx) { // Dedicated to SAO because it skips transparent objects
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawDepth(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawNormals = function drawNormals (frameCtx) { // Dedicated to SAO because it skips transparent objects
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawNormals(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawSilhouetteXRayed = function drawSilhouetteXRayed (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawSilhouetteXRayed(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawSilhouetteHighlighted = function drawSilhouetteHighlighted (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawSilhouetteHighlighted(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawSilhouetteSelected = function drawSilhouetteSelected (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawSilhouetteSelected(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawEdgesColorOpaque = function drawEdgesColorOpaque (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawEdgesColorOpaque(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawEdgesColorTransparent = function drawEdgesColorTransparent (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawEdgesColorTransparent(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawEdgesXRayed = function drawEdgesXRayed (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawEdgesXRayed(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawEdgesHighlighted = function drawEdgesHighlighted (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawEdgesHighlighted(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawEdgesSelected = function drawEdgesSelected (frameCtx) {
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawEdgesSelected(renderFlags, frameCtx);
        }
    };

    /**
     * @private
     */
    PerformanceModel.prototype.drawOcclusion = function drawOcclusion (frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawOcclusion(renderFlags, frameCtx);
        }
    };

    /**
     * @private
     */
    PerformanceModel.prototype.drawShadow = function drawShadow (frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawShadow(renderFlags, frameCtx);
        }
    };

    /** @private */
    PerformanceModel.prototype.drawPickMesh = function drawPickMesh (frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawPickMesh(renderFlags, frameCtx);
        }
    };

    /**
     * Called by PerformanceMesh.drawPickDepths()
     * @private
     */
    PerformanceModel.prototype.drawPickDepths = function drawPickDepths (frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawPickDepths(renderFlags, frameCtx);
        }
    };

    /**
     * Called by PerformanceMesh.drawPickNormals()
     * @private
     */
    PerformanceModel.prototype.drawPickNormals = function drawPickNormals (frameCtx) {
        if (this.numVisibleLayerPortions === 0) {
            return;
        }
        var renderFlags = this.renderFlags;
        for (var i = 0, len = renderFlags.visibleLayers.length; i < len; i++) {
            var layerIndex = renderFlags.visibleLayers[i];
            this._layerList[layerIndex].drawPickNormals(renderFlags, frameCtx);
        }
    };

    //------------------------------------------------------------------------------------------------------------------
    // Component members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Destroys this PerformanceModel.
     */
    PerformanceModel.prototype.destroy = function destroy () {
        for (var primitive in this._currentBatchingLayers) {
            if (this._currentBatchingLayers.hasOwnProperty(primitive)) {
                this._currentBatchingLayers[primitive].destroy();
            }
        }
        this._currentBatchingLayers = {};
        this.scene.camera.off(this._onCameraViewMatrix);
        for (var i = 0, len = this._layerList.length; i < len; i++) {
            this._layerList[i].destroy();
        }
        for (var i$1 = 0, len$1 = this._nodeList.length; i$1 < len$1; i$1++) {
            this._nodeList[i$1]._destroy();
        }
        this.scene._aabbDirty = true;
        if (this._isModel) {
            this.scene._deregisterModel(this);
        }
        putScratchMemory();
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( PerformanceModel.prototype, prototypeAccessors );

    return PerformanceModel;
}(Component));

var angleAxis = math.vec4(4);
var q1 = math.vec4();
var q2 = math.vec4();
var xAxis = math.vec3([1, 0, 0]);
var yAxis = math.vec3([0, 1, 0]);
var zAxis = math.vec3([0, 0, 1]);

var veca = math.vec3(3);
var vecb = math.vec3(3);

var identityMat = math.identityMat4();

/**
 * @desc An {@link Entity} that is a scene graph node that can have child Nodes and {@link Mesh}es.
 *
 * ## Usage
 *
 * The example below is the same as the one given for {@link Mesh}, since the two classes work together. In this example,
 * we'll create a scene graph in which a root Node represents a group and the {@link Mesh}s are leaves. Since Node
 * implements {@link Entity}, we can designate the root Node as a model, causing it to be registered by its ID in {@link Scene#models}.
 *
 * Since {@link Mesh} also implements {@link Entity}, we can designate the leaf {@link Mesh}es as objects, causing them to
 * be registered by their IDs in {@link Scene#objects}.
 *
 * We can then find those {@link Entity} types in {@link Scene#models} and {@link Scene#objects}.
 *
 * We can also update properties of our object-Meshes via calls to {@link Scene#setObjectsHighlighted} etc.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneGraph)]
 *
 * ````javascript
 * import {Viewer, Mesh, Node, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];
 * viewer.scene.camera.look = [0, -5.75, 0];
 * viewer.scene.camera.up = [0.37, 0.91, -0.11];
 *
 * new Node(viewer.scene, {
 *      id: "table",
 *      isModel: true, // <---------- Node represents a model, so is registered by ID in viewer.scene.models
 *      rotation: [0, 50, 0],
 *      position: [0, 0, 0],
 *      scale: [1, 1, 1],
 *
 *      children: [
 *
 *          new Mesh(viewer.scene, { // Red table leg
 *              id: "redLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1, 0.3, 0.3]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, { // Green table leg
 *              id: "greenLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, -4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 1.0, 0.3]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, {// Blue table leg
 *              id: "blueLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [0.3, 0.3, 1.0]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, {  // Yellow table leg
 *              id: "yellowLeg",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [-4, -6, 4],
 *              scale: [1, 3, 1],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                   diffuse: [1.0, 1.0, 0.0]
 *              })
 *          }),
 *
 *          new Mesh(viewer.scene, { // Purple table top
 *              id: "tableTop",
 *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects
 *              position: [0, -3, 0],
 *              scale: [6, 0.5, 6],
 *              rotation: [0, 0, 0],
 *              material: new PhongMaterial(viewer.scene, {
 *                  diffuse: [1.0, 0.3, 1.0]
 *              })
 *          })
 *      ]
 *  });
 *
 * // Find Nodes and Meshes by their IDs
 *
 * var table = viewer.scene.models["table"];                // Since table Node has isModel == true
 *
 * var redLeg = viewer.scene.objects["redLeg"];             // Since the Meshes have isObject == true
 * var greenLeg = viewer.scene.objects["greenLeg"];
 * var blueLeg = viewer.scene.objects["blueLeg"];
 *
 * // Highlight one of the table leg Meshes
 *
 * viewer.scene.setObjectsHighlighted(["redLeg"], true);    // Since the Meshes have isObject == true
 *
 * // Periodically update transforms on our Nodes and Meshes
 *
 * viewer.scene.on("tick", function () {
 *
 *       // Rotate legs
 *       redLeg.rotateY(0.5);
 *       greenLeg.rotateY(0.5);
 *       blueLeg.rotateY(0.5);
 *
 *       // Rotate table
 *       table.rotateY(0.5);
 *       table.rotateX(0.3);
 *   });
 * ````
 *
 * ## Metadata
 *
 * As mentioned, we can also associate {@link MetaModel}s and {@link MetaObject}s with our Nodes and {@link Mesh}es,
 * within a {@link MetaScene}. See {@link MetaScene} for an example.
 *
 * @implements {Entity}
 */
var Node = /*@__PURE__*/(function (Component) {
    function Node(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._parentNode = null;
        this._children = [];

        this._aabb = null;
        this._aabbDirty = true;

        this.scene._aabbDirty = true;

        this._numTriangles = 0;

        this._scale = math.vec3();
        this._quaternion = math.identityQuaternion();
        this._rotation = math.vec3();
        this._position = math.vec3();
        this._offset = math.vec3();

        this._localMatrix = math.identityMat4();
        this._worldMatrix = math.identityMat4();

        this._localMatrixDirty = true;
        this._worldMatrixDirty = true;

        if (cfg.matrix) {
            this.matrix = cfg.matrix;
        } else {
            this.scale = cfg.scale;
            this.position = cfg.position;
            if (cfg.quaternion) ; else {
                this.rotation = cfg.rotation;
            }
        }

        this._isModel = cfg.isModel;
        if (this._isModel) {
            this.scene._registerModel(this);
        }

        this._isObject = cfg.isObject;
        if (this._isObject) {
            this.scene._registerObject(this);
        }

        this.rtcCenter = cfg.rtcCenter;
        this.visible = cfg.visible;
        this.culled = cfg.culled;
        this.pickable = cfg.pickable;
        this.clippable = cfg.clippable;
        this.collidable = cfg.collidable;
        this.castsShadow = cfg.castsShadow;
        this.receivesShadow = cfg.receivesShadow;
        this.xrayed = cfg.xrayed;
        this.highlighted = cfg.highlighted;
        this.selected = cfg.selected;
        this.edges = cfg.edges;
        this.colorize = cfg.colorize;
        this.opacity = cfg.opacity;
        this.offset = cfg.offset;

        // Add children, which inherit state from this Node

        if (cfg.children) {
            var children = cfg.children;
            for (var i = 0, len = children.length; i < len; i++) {
                this.addChild(children[i], cfg.inheritStates);
            }
        }

        if (cfg.parentId) {
            var parentNode = this.scene.components[cfg.parentId];
            if (!parentNode) {
                this.error("Parent not found: '" + cfg.parentId + "'");
            } else if (!parentNode.isNode) {
                this.error("Parent is not a Node: '" + cfg.parentId + "'");
            } else {
                parentNode.addChild(this);
            }
        } else if (cfg.parent) {
            if (!cfg.parent.isNode) {
                this.error("Parent is not a Node");
            }
            cfg.parent.addChild(this);
        }
    }

    if ( Component ) Node.__proto__ = Component;
    Node.prototype = Object.create( Component && Component.prototype );
    Node.prototype.constructor = Node;

    var prototypeAccessors = { isEntity: { configurable: true },isModel: { configurable: true },isObject: { configurable: true },aabb: { configurable: true },rtcCenter: { configurable: true },numTriangles: { configurable: true },visible: { configurable: true },xrayed: { configurable: true },highlighted: { configurable: true },selected: { configurable: true },edges: { configurable: true },culled: { configurable: true },clippable: { configurable: true },collidable: { configurable: true },pickable: { configurable: true },colorize: { configurable: true },opacity: { configurable: true },castsShadow: { configurable: true },receivesShadow: { configurable: true },saoEnabled: { configurable: true },offset: { configurable: true },isNode: { configurable: true },numChildren: { configurable: true },children: { configurable: true },parent: { configurable: true },position: { configurable: true },rotation: { configurable: true },quaternion: { configurable: true },scale: { configurable: true },matrix: { configurable: true },worldMatrix: { configurable: true },type: { configurable: true } };

    //------------------------------------------------------------------------------------------------------------------
    // Entity members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that this Component is an Entity.
     * @type {Boolean}
     */
    prototypeAccessors.isEntity.get = function () {
        return true;
    };

    /**
     * Returns ````true```` if this Mesh represents a model.
     *
     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and
     * may also have a corresponding {@link MetaModel}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.isModel.get = function () {
        return this._isModel;
    };

    /**
     * Returns ````true```` if this Node represents an object.
     *
     * When ````true```` the Node will be registered by {@link Node#id} in
     * {@link Scene#objects} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.
     *
     * @type {Boolean}
     * @abstract
     */
    prototypeAccessors.isObject.get = function () {
        return this._isObject;
    };

    /**
     * Gets the Node's World-space 3D axis-aligned bounding box.
     *
     * Represented by a six-element Float64Array containing the min/max extents of the
     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        if (this._aabbDirty) {
            this._updateAABB();
        }
        return this._aabb;
    };

    /**
     * Sets the center of the relative-to-center (RTC) coordinate system for this Node and all child Nodes and {@link Mesh}s.
     *
     * @type {Float64Array}
     */
    prototypeAccessors.rtcCenter.set = function (rtcCenter) {
        if (rtcCenter) {
            if (!this._rtcCenter) {
                this._rtcCenter = math.vec3();
            }
            this._rtcCenter.set(rtcCenter);
        } else {
            if (this._rtcCenter) {
                this._rtcCenter = null;
            }
        }
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].rtcCenter = rtcCenter;
        }
    };

    /**
     *  Gets the center of the relative-to-center (RTC) coordinate system for this Node and all child Nodes and {@link Mesh}s.
     *
     * @type {Float64Array}
     */
    prototypeAccessors.rtcCenter.get = function () {
        return this._rtcCenter;
    };

    /**
     * The number of triangles in this Node.
     *
     * @type {Number}
     */
    prototypeAccessors.numTriangles.get = function () {
        return this._numTriangles;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are visible.
     *
     * Only rendered both {@link Node#visible} is ````true```` and {@link Node#culled} is ````false````.
     *
     * When {@link Node#isObject} and {@link Node#visible} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.visible.set = function (visible) {
        visible = visible !== false;
        this._visible = visible;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].visible = visible;
        }
        if (this._isObject) {
            this.scene._objectVisibilityUpdated(this, visible);
        }
    };

    /**
     * Gets if this Node is visible.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * When {@link Node#isObject} and {@link Node#visible} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#visibleObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.visible.get = function () {
        return this._visible;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are xrayed.
     *
     * When {@link Node#isObject} and {@link Node#xrayed} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#xrayedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.set = function (xrayed) {
        xrayed = !!xrayed;
        this._xrayed = xrayed;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].xrayed = xrayed;
        }
        if (this._isObject) {
            this.scene._objectXRayedUpdated(this, xrayed);
        }
    };

    /**
     * Gets if this Node is xrayed.
     *
     * When {@link Node#isObject} and {@link Node#xrayed} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#xrayedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.xrayed.get = function () {
        return this._xrayed;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are highlighted.
     *
     * When {@link Node#isObject} and {@link Node#highlighted} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#highlightedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.set = function (highlighted) {
        highlighted = !!highlighted;
        this._highlighted = highlighted;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].highlighted = highlighted;
        }
        if (this._isObject) {
            this.scene._objectHighlightedUpdated(this, highlighted);
        }
    };

    /**
     * Gets if this Node is highlighted.
     *
     * When {@link Node#isObject} and {@link Node#highlighted} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#highlightedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.highlighted.get = function () {
        return this._highlighted;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are selected.
     *
     * When {@link Node#isObject} and {@link Node#selected} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#selectedObjects}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.set = function (selected) {
        selected = !!selected;
        this._selected = selected;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].selected = selected;
        }
        if (this._isObject) {
            this.scene._objectSelectedUpdated(this, selected);
        }
    };

    /**
     * Gets if this Node is selected.
     *
     * When {@link Node#isObject} and {@link Node#selected} are both ````true```` the Node will be
     * registered by {@link Node#id} in {@link Scene#selectedObjects}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.selected.get = function () {
        return this._selected;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are edge-enhanced.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.set = function (edges) {
        edges = !!edges;
        this._edges = edges;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].edges = edges;
        }
    };

    /**
     * Gets if this Node's edges are enhanced.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.edges.get = function () {
        return this._edges;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are culled.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.set = function (culled) {
        culled = !!culled;
        this._culled = culled;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].culled = culled;
        }
    };

    /**
     * Gets if this Node is culled.
     *
     * @type {Boolean}
     */
    prototypeAccessors.culled.get = function () {
        return this._culled;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#clips}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.set = function (clippable) {
        clippable = clippable !== false;
        this._clippable = clippable;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].clippable = clippable;
        }
    };

    /**
     * Gets if this Node is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#clips}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.get = function () {
        return this._clippable;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are included in boundary calculations.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.set = function (collidable) {
        collidable = collidable !== false;
        this._collidable = collidable;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].collidable = collidable;
        }
    };

    /**
     * Gets if this Node is included in boundary calculations.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.get = function () {
        return this._collidable;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es are pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.set = function (pickable) {
        pickable = pickable !== false;
        this._pickable = pickable;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].pickable = pickable;
        }
    };

    /**
     * Gets if to this Node is pickable.
     *
     * Picking is done via calls to {@link Scene#pick}.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.get = function () {
        return this._pickable;
    };

    /**
     * Sets the RGB colorize color for this Node and all child Nodes and {@link Mesh}es}.
     *
     * Multiplies by rendered fragment colors.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.set = function (rgb) {
        var colorize = this._colorize;
        if (!colorize) {
            colorize = this._colorize = new Float32Array(4);
            colorize[3] = 1.0;
        }
        if (rgb) {
            colorize[0] = rgb[0];
            colorize[1] = rgb[1];
            colorize[2] = rgb[2];
        } else {
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].colorize = colorize;
        }
        if (this._isObject) {
            var colorized = (!!rgb);
            this.scene._objectColorizeUpdated(this, colorized);
        }
    };

    /**
     * Gets the RGB colorize color for this Node.
     *
     * Each element of the color is in range ````[0..1]````.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number[]}
     */
    prototypeAccessors.colorize.get = function () {
        return this._colorize.slice(0, 3);
    };

    /**
     * Sets the opacity factor for this Node and all child Nodes and {@link Mesh}es.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.set = function (opacity) {
        var colorize = this._colorize;
        if (!colorize) {
            colorize = this._colorize = new Float32Array(4);
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        colorize[3] = opacity !== null && opacity !== undefined ? opacity : 1.0;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].opacity = opacity;
        }
        if (this._isObject) {
            var opacityUpdated = (opacity !== null && opacity !== undefined);
            this.scene._objectOpacityUpdated(this, opacityUpdated);
        }
    };

    /**
     * Gets this Node's opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.get = function () {
        return this._colorize[3];
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es cast shadows.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.set = function (castsShadow) {
        castsShadow = !!castsShadow;
        this._castsShadow = castsShadow;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].castsShadow = castsShadow;
        }
    };

    /**
     * Gets if this Node casts shadows.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.castsShadow.get = function () {
        return this._castsShadow;
    };

    /**
     * Sets if this Node and all child Nodes and {@link Mesh}es can have shadows cast upon them.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.set = function (receivesShadow) {
        receivesShadow = !!receivesShadow;
        this._receivesShadow = receivesShadow;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].receivesShadow = receivesShadow;
        }
    };

    /**
     * Whether or not to this Node can have shadows cast upon it.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Boolean}
     */
    prototypeAccessors.receivesShadow.get = function () {
        return this._receivesShadow;
    };

    /**
     * Gets if this Node can have Scalable Ambient Obscurance (SAO) applied to it.
     *
     * SAO is configured by {@link SAO}.
     *
     * @type {Boolean}
     * @abstract
     */
    prototypeAccessors.saoEnabled.get = function () {
        return false; // TODO: Support SAO on Nodes
    };


    /**
     * Sets the 3D World-space offset for this Node and all child Nodes and {@link Mesh}es}.
     *
     * The offset dynamically translates those components in World-space.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Note that child Nodes and {@link Mesh}es may subsequently be given different values for this property.
     *
     * @type {Number[]}
     */
    prototypeAccessors.offset.set = function (offset) {
        if (offset) {
            this._offset[0] = offset[0];
            this._offset[1] = offset[1];
            this._offset[2] = offset[2];
        } else {
            this._offset[0] = 0;
            this._offset[1] = 0;
            this._offset[2] = 0;
        }
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i].offset = this._offset;
        }
        if (this._isObject) {
            this.scene._objectOffsetUpdated(this, offset);
        }
    };

    /**
     * Gets the Node's 3D World-space offset.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * Child Nodes and {@link Mesh}es may have different values for this property.
     *
     * @type {Number[]}
     */
    prototypeAccessors.offset.get = function () {
        return this._offset;
    };


    //------------------------------------------------------------------------------------------------------------------
    // Node members
    //------------------------------------------------------------------------------------------------------------------

    /**
     * Returns true to indicate that this Component is a Node.
     * @type {Boolean}
     */
    prototypeAccessors.isNode.get = function () {
        return true;
    };

    Node.prototype._setLocalMatrixDirty = function _setLocalMatrixDirty () {
        this._localMatrixDirty = true;
        this._setWorldMatrixDirty();
    };

    Node.prototype._setWorldMatrixDirty = function _setWorldMatrixDirty () {
        this._worldMatrixDirty = true;
        for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i]._setWorldMatrixDirty();
        }
    };

    Node.prototype._buildWorldMatrix = function _buildWorldMatrix () {
        var localMatrix = this.matrix;
        if (!this._parentNode) {
            for (var i = 0, len = localMatrix.length; i < len; i++) {
                this._worldMatrix[i] = localMatrix[i];
            }
        } else {
            math.mulMat4(this._parentNode.worldMatrix, localMatrix, this._worldMatrix);
        }
        this._worldMatrixDirty = false;
    };

    Node.prototype._setSubtreeAABBsDirty = function _setSubtreeAABBsDirty (node) {
        node._aabbDirty = true;
        if (node._children) {
            for (var i = 0, len = node._children.length; i < len; i++) {
                this._setSubtreeAABBsDirty(node._children[i]);
            }
        }
    };

    Node.prototype._setAABBDirty = function _setAABBDirty () {
        this._setSubtreeAABBsDirty(this);
        if (this.collidable) {
            for (var node = this; node; node = node._parentNode) {
                node._aabbDirty = true;
            }
        }
    };

    Node.prototype._updateAABB = function _updateAABB () {
        this.scene._aabbDirty = true;
        if (!this._aabb) {
            this._aabb = math.AABB3();
        }
        if (this._buildAABB) {
            this._buildAABB(this.worldMatrix, this._aabb); // Mesh or PerformanceModel
        } else { // Node | Node | Model
            math.collapseAABB3(this._aabb);
            var node;
            for (var i = 0, len = this._children.length; i < len; i++) {
                node = this._children[i];
                if (!node.collidable) {
                    continue;
                }
                math.expandAABB3(this._aabb, node.aabb);
            }
        }
        this._aabbDirty = false;
    };

    /**
     * Adds a child Node or {@link Mesh}.
     *
     * The child must be a Node or {@link Mesh} in the same {@link Scene}.
     *
     * If the child already has a parent, will be removed from that parent first.
     *
     * Does nothing if already a child.
     *
     * @param {Node|Mesh|String} child Instance or ID of the child to add.
     * @param [inheritStates=false] Indicates if the child should inherit rendering states from this parent as it is added. Rendering state includes {@link Node#visible}, {@link Node#culled}, {@link Node#pickable}, {@link Node#clippable}, {@link Node#castsShadow}, {@link Node#receivesShadow}, {@link Node#selected}, {@link Node#highlighted}, {@link Node#colorize} and {@link Node#opacity}.
     * @returns {Node|Mesh} The child.
     */
    Node.prototype.addChild = function addChild (child, inheritStates) {
        if (utils.isNumeric(child) || utils.isString(child)) {
            var nodeId = child;
            child = this.scene.component[nodeId];
            if (!child) {
                this.warn("Component not found: " + utils.inQuotes(nodeId));
                return;
            }
            if (!child.isNode && !child.isMesh) {
                this.error("Not a Node or Mesh: " + nodeId);
                return;
            }
        } else {
            if (!child.isNode && !child.isMesh) {
                this.error("Not a Node or Mesh: " + child.id);
                return;
            }
            if (child._parentNode) {
                if (child._parentNode.id === this.id) {
                    this.warn("Already a child: " + child.id);
                    return;
                }
                child._parentNode.removeChild(child);
            }
        }
        child.id;
        if (child.scene.id !== this.scene.id) {
            this.error("Child not in same Scene: " + child.id);
            return;
        }
        this._children.push(child);
        child._parentNode = this;
        if (!!inheritStates) {
            child.visible = this.visible;
            child.culled = this.culled;
            child.xrayed = this.xrayed;
            child.highlited = this.highlighted;
            child.selected = this.selected;
            child.edges = this.edges;
            child.clippable = this.clippable;
            child.pickable = this.pickable;
            child.collidable = this.collidable;
            child.castsShadow = this.castsShadow;
            child.receivesShadow = this.receivesShadow;
            child.colorize = this.colorize;
            child.opacity = this.opacity;
            child.offset = this.offset;
        }
        child._setWorldMatrixDirty();
        child._setAABBDirty();
        this._numTriangles += child.numTriangles;
        return child;
    };

    /**
     * Removes the given child Node or {@link Mesh}.
     *
     * @param {Node|Mesh} child Child to remove.
     */
    Node.prototype.removeChild = function removeChild (child) {
        for (var i = 0, len = this._children.length; i < len; i++) {
            if (this._children[i].id === child.id) {
                child._parentNode = null;
                this._children = this._children.splice(i, 1);
                child._setWorldMatrixDirty();
                child._setAABBDirty();
                this._setAABBDirty();
                this._numTriangles -= child.numTriangles;
                return;
            }
        }
    };

    /**
     * Removes all child Nodes and {@link Mesh}es.
     */
    Node.prototype.removeChildren = function removeChildren () {
        var child;
        for (var i = 0, len = this._children.length; i < len; i++) {
            child = this._children[i];
            child._parentNode = null;
            child._setWorldMatrixDirty();
            child._setAABBDirty();
            this._numTriangles -= child.numTriangles;
        }
        this._children = [];
        this._setAABBDirty();
    };

    /**
     * Number of child Nodes or {@link Mesh}es.
     *
     * @type {Number}
     */
    prototypeAccessors.numChildren.get = function () {
        return this._children.length;
    };

    /**
     * Array of child Nodes or {@link Mesh}es.
     *
     * @type {Array}
     */
    prototypeAccessors.children.get = function () {
        return this._children;
    };

    /**
     * The parent Node.
     *
     * The parent Node may also be set by passing the Node to the parent's {@link Node#addChild} method.
     *
     * @type {Node}
     */
    prototypeAccessors.parent.set = function (node) {
        if (utils.isNumeric(node) || utils.isString(node)) {
            var nodeId = node;
            node = this.scene.components[nodeId];
            if (!node) {
                this.warn("Node not found: " + utils.inQuotes(nodeId));
                return;
            }
            if (!node.isNode) {
                this.error("Not a Node: " + node.id);
                return;
            }
        }
        if (node.scene.id !== this.scene.id) {
            this.error("Node not in same Scene: " + node.id);
            return;
        }
        if (this._parentNode && this._parentNode.id === node.id) {
            this.warn("Already a child of Node: " + node.id);
            return;
        }
        node.addChild(this);
    };

    /**
     * The parent Node.
     *
     * @type {Node}
     */
    prototypeAccessors.parent.get = function () {
        return this._parentNode;
    };

    /**
     * Sets the Node's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.position.set = function (value) {
        this._position.set(value || [0, 0, 0]);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Node's local translation.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.position.get = function () {
        return this._position;
    };

    /**
     * Sets the Node's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rotation.set = function (value) {
        this._rotation.set(value || [0, 0, 0]);
        math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Node's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     *
     * Default value is ````[0,0,0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.rotation.get = function () {
        return this._rotation;
    };

    /**
     * Sets the Node's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.quaternion.set = function (value) {
        this._quaternion.set(value || [0, 0, 0, 1]);
        math.quaternionToEuler(this._quaternion, "XYZ", this._rotation);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Node's local rotation quaternion.
     *
     * Default value is ````[0,0,0,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.quaternion.get = function () {
        return this._quaternion;
    };

    /**
     * Sets the Node's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.set = function (value) {
        this._scale.set(value || [1, 1, 1]);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Node's local scale.
     *
     * Default value is ````[1,1,1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the Node's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.matrix.set = function (value) {
        if (!this._localMatrix) {
            this._localMatrix = math.identityMat4();
        }
        this._localMatrix.set(value || identityMat);
        math.decomposeMat4(this._localMatrix, this._position, this._quaternion, this._scale);
        this._localMatrixDirty = false;
        this._setWorldMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
    };

    /**
     * Gets the Node's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.matrix.get = function () {
        if (this._localMatrixDirty) {
            if (!this._localMatrix) {
                this._localMatrix = math.identityMat4();
            }
            math.composeMat4(this._position, this._quaternion, this._scale, this._localMatrix);
            this._localMatrixDirty = false;
        }
        return this._localMatrix;
    };

    /**
     * Gets the Node's World matrix.
     *
     * @property worldMatrix
     * @type {Number[]}
     */
    prototypeAccessors.worldMatrix.get = function () {
        if (this._worldMatrixDirty) {
            this._buildWorldMatrix();
        }
        return this._worldMatrix;
    };

    /**
     * Rotates the Node about the given local axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */
    Node.prototype.rotate = function rotate (axis, angle) {
        angleAxis[0] = axis[0];
        angleAxis[1] = axis[1];
        angleAxis[2] = axis[2];
        angleAxis[3] = angle * math.DEGTORAD;
        math.angleAxisToQuaternion(angleAxis, q1);
        math.mulQuaternions(this.quaternion, q1, q2);
        this.quaternion = q2;
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
        return this;
    };

    /**
     * Rotates the Node about the given World-space axis by the given increment.
     *
     * @param {Number[]} axis Local axis about which to rotate.
     * @param {Number} angle Angle increment in degrees.
     */
    Node.prototype.rotateOnWorldAxis = function rotateOnWorldAxis (axis, angle) {
        angleAxis[0] = axis[0];
        angleAxis[1] = axis[1];
        angleAxis[2] = axis[2];
        angleAxis[3] = angle * math.DEGTORAD;
        math.angleAxisToQuaternion(angleAxis, q1);
        math.mulQuaternions(q1, this.quaternion, q1);
        //this.quaternion.premultiply(q1);
        return this;
    };

    /**
     * Rotates the Node about the local X-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Node.prototype.rotateX = function rotateX (angle) {
        return this.rotate(xAxis, angle);
    };

    /**
     * Rotates the Node about the local Y-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Node.prototype.rotateY = function rotateY (angle) {
        return this.rotate(yAxis, angle);
    };

    /**
     * Rotates the Node about the local Z-axis by the given increment.
     *
     * @param {Number} angle Angle increment in degrees.
     */
    Node.prototype.rotateZ = function rotateZ (angle) {
        return this.rotate(zAxis, angle);
    };

    /**
     * Translates the Node along local space vector by the given increment.
     *
     * @param {Number[]} axis Normalized local space 3D vector along which to translate.
     * @param {Number} distance Distance to translate along  the vector.
     */
    Node.prototype.translate = function translate (axis, distance) {
        math.vec3ApplyQuaternion(this.quaternion, axis, veca);
        math.mulVec3Scalar(veca, distance, vecb);
        math.addVec3(this.position, vecb, this.position);
        this._setLocalMatrixDirty();
        this._setAABBDirty();
        this.glRedraw();
        return this;
    };

    /**
     * Translates the Node along the local X-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the X-axis.
     */
    Node.prototype.translateX = function translateX (distance) {
        return this.translate(xAxis, distance);
    };

    /**
     * Translates the Node along the local Y-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Y-axis.
     */
    Node.prototype.translateY = function translateY (distance) {
        return this.translate(yAxis, distance);
    };

    /**
     * Translates the Node along the local Z-axis by the given increment.
     *
     * @param {Number} distance Distance to translate along  the Z-axis.
     */
    Node.prototype.translateZ = function translateZ (distance) {
        return this.translate(zAxis, distance);
    };

    //------------------------------------------------------------------------------------------------------------------
    // Component members
    //------------------------------------------------------------------------------------------------------------------

    /**
     @private
     */
    prototypeAccessors.type.get = function () {
        return "Node";
    };

    /**
     * Destroys this Node.
     */
    Node.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        if (this._parentNode) {
            this._parentNode.removeChild(this);
        }
        if (this._isObject) {
            this.scene._deregisterObject(this);
            if (this._visible) {
                this.scene._objectVisibilityUpdated(this, false);
            }
            if (this._xrayed) {
                this.scene._objectXRayedUpdated(this, false);
            }
            if (this._selected) {
                this.scene._objectSelectedUpdated(this, false);
            }
            if (this._highlighted) {
                this.scene._objectHighlightedUpdated(this, false);
            }
            this.scene._objectColorizeUpdated(this, false);
            this.scene._objectOpacityUpdated(this, false);
            this.scene._objectOffsetUpdated(this, false);
        }
        if (this._isModel) {
            this.scene._deregisterModel(this);
        }
        if (this._children.length) {
            // Clone the _children before iterating, so our children don't mess us up when calling removeChild().
            var tempChildList = this._children.splice();
            var child;
            for (var i = 0, len = tempChildList.length; i < len; i++) {
                child = tempChildList[i];
                child.destroy();
            }
        }
        this._children = [];
        this._setAABBDirty();
        this.scene._aabbDirty = true;
    };

    Object.defineProperties( Node.prototype, prototypeAccessors );

    return Node;
}(Component));

var memoryStats = stats.memory;
var bigIndicesSupported = WEBGL_INFO$1.SUPPORTED_EXTENSIONS["OES_element_index_uint"];
var IndexArrayType = bigIndicesSupported ? Uint32Array : Uint16Array;
var tempAABB$1 = math.AABB3();

/**
 * @desc A {@link Geometry} that keeps its geometry data solely in GPU memory, without retaining it in browser memory.
 *
 * VBOGeometry uses less memory than {@link ReadableGeometry}, which keeps its geometry data in both browser and GPU memory.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a VBOGeometry that defines a single triangle, plus a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_VBOGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, VBOGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 *     });
 *
 * new Mesh(viewer.scene, {
 *         geometry: new VBOGeometry(viewer.scene, {
 *             primitive: "triangles",
 *             positions: [0.0, 3, 0.0, -3, -3, 0.0, 3, -3, 0.0],
 *             normals: [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0],
 *             uv: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
 *             indices: [0, 1, 2]
 *         }),
 *         material: new PhongMaterial(viewer.scene, {
 *             diffuseMap: new Texture(viewer.scene, {
 *                 src: "textures/diffuse/uvGrid2.jpg"
 *             }),
 *             backfaces: true
 *         })
 *     });
 * ````
 */
var VBOGeometry = /*@__PURE__*/(function (Geometry) {
    function VBOGeometry(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Geometry.call(this, owner, cfg);

        this._state = new RenderState({ // Arrays for emphasis effects are got from xeokit.GeometryLite friend methods
            compressGeometry: true,
            primitive: null, // WebGL enum
            primitiveName: null, // String
            positionsDecodeMatrix: null, // Set when compressGeometry == true
            uvDecodeMatrix: null, // Set when compressGeometry == true
            positionsBuf: null,
            normalsBuf: null,
            colorsbuf: null,
            uvBuf: null,
            indicesBuf: null,
            hash: ""
        });

        this._numTriangles = 0;

        this._edgeThreshold = cfg.edgeThreshold || 10.0;
        this._aabb = null;
        this._obb = math.OBB3();

        var state = this._state;
        var gl = this.scene.canvas.gl;

        cfg.primitive = cfg.primitive || "triangles";
        switch (cfg.primitive) {
            case "points":
                state.primitive = gl.POINTS;
                state.primitiveName = cfg.primitive;
                break;
            case "lines":
                state.primitive = gl.LINES;
                state.primitiveName = cfg.primitive;
                break;
            case "line-loop":
                state.primitive = gl.LINE_LOOP;
                state.primitiveName = cfg.primitive;
                break;
            case "line-strip":
                state.primitive = gl.LINE_STRIP;
                state.primitiveName = cfg.primitive;
                break;
            case "triangles":
                state.primitive = gl.TRIANGLES;
                state.primitiveName = cfg.primitive;
                break;
            case "triangle-strip":
                state.primitive = gl.TRIANGLE_STRIP;
                state.primitiveName = cfg.primitive;
                break;
            case "triangle-fan":
                state.primitive = gl.TRIANGLE_FAN;
                state.primitiveName = cfg.primitive;
                break;
            default:
                this.error("Unsupported value for 'primitive': '" + cfg.primitive +
                    "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', " +
                    "'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");
                state.primitive = gl.TRIANGLES;
                state.primitiveName = cfg.primitive;
        }

        if (!cfg.positions) {
            this.error("Config expected: positions");
            return; // TODO: Recover?
        }

        if (!cfg.indices) {
            this.error("Config expected: indices");
            return; // TODO: Recover?
        }

        var positions;

        {
            var positionsDecodeMatrix = cfg.positionsDecodeMatrix;

            if (positionsDecodeMatrix) ; else {

                // Uncompressed positions

                var bounds = geometryCompressionUtils.getPositionsBounds(cfg.positions);
                var result = geometryCompressionUtils.compressPositions(cfg.positions, bounds.min, bounds.max);
                positions = result.quantized;
                state.positionsDecodeMatrix = result.decodeMatrix;
                state.positionsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
                memoryStats.positions += state.positionsBuf.numItems;
                math.positions3ToAABB3(cfg.positions, this._aabb);
                math.positions3ToAABB3(positions, tempAABB$1, state.positionsDecodeMatrix);
                math.AABB3ToOBB3(tempAABB$1, this._obb);
            }
        }

        if (cfg.colors) {
            var colors = cfg.colors.constructor === Float32Array ? cfg.colors : new Float32Array(cfg.colors);
            state.colorsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, colors, colors.length, 4, gl.STATIC_DRAW);
            memoryStats.colors += state.colorsBuf.numItems;
        }

        if (cfg.uv) {
            var bounds$1 = geometryCompressionUtils.getUVBounds(cfg.uv);
            var result$1 = geometryCompressionUtils.compressUVs(cfg.uv, bounds$1.min, bounds$1.max);
            var uv = result$1.quantized;
            state.uvDecodeMatrix = result$1.decodeMatrix;
            state.uvBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW);
            memoryStats.uvs += state.uvBuf.numItems;
        }

        if (cfg.normals) {
            var normals = geometryCompressionUtils.compressNormals(cfg.normals);
            var normalized = state.compressGeometry;
            state.normalsBuf = new ArrayBuf(gl, gl.ARRAY_BUFFER, normals, normals.length, 3, gl.STATIC_DRAW, normalized);
            memoryStats.normals += state.normalsBuf.numItems;
        }

        if (!bigIndicesSupported && cfg.indices.constructor === Uint32Array) {
            this.error("This WebGL implementation does not support Uint32Array");
            return; // TODO: Recover?
        }

        {
            var indices = (cfg.indices.constructor === Uint32Array || cfg.indices.constructor === Uint16Array) ? cfg.indices : new IndexArrayType(cfg.indices);
            state.indicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);
            memoryStats.indices += state.indicesBuf.numItems;
            var edgeIndices = buildEdgeIndices(positions, indices, state.positionsDecodeMatrix, this._edgeThreshold);
            this._edgeIndicesBuf = new ArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, edgeIndices, edgeIndices.length, 1, gl.STATIC_DRAW);

            if (this._state.primitiveName === "triangles") {
                this._numTriangles = (cfg.indices.length / 3);
            }
        }

        this._buildHash();

        memoryStats.meshes++;
    }

    if ( Geometry ) VBOGeometry.__proto__ = Geometry;
    VBOGeometry.prototype = Object.create( Geometry && Geometry.prototype );
    VBOGeometry.prototype.constructor = VBOGeometry;

    var prototypeAccessors = { type: { configurable: true },isVBOGeometry: { configurable: true },primitive: { configurable: true },aabb: { configurable: true },obb: { configurable: true },numTriangles: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "VBOGeometry";
    };

    /**
     * @private
     * @returns {boolean}
     */
    prototypeAccessors.isVBOGeometry.get = function () {
        return true;
    };

    VBOGeometry.prototype._buildHash = function _buildHash () {
        var state = this._state;
        var hash = ["/g"];
        hash.push("/" + state.primitive + ";");
        if (state.positionsBuf) {
            hash.push("p");
        }
        if (state.colorsBuf) {
            hash.push("c");
        }
        if (state.normalsBuf || state.autoVertexNormals) {
            hash.push("n");
        }
        if (state.uvBuf) {
            hash.push("u");
        }
        hash.push("cp"); // Always compressed
        hash.push(";");
        state.hash = hash.join("");
    };

    VBOGeometry.prototype._getEdgeIndices = function _getEdgeIndices () {
        return this._edgeIndicesBuf;
    };

    /**
     * Gets the primitive type.
     *
     * Possible types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
     *
     * @type {String}
     */
    prototypeAccessors.primitive.get = function () {
        return this._state.primitiveName;
    };

    /**
     * Gets the local-space axis-aligned 3D boundary (AABB).
     *
     * The AABB is represented by a six-element Float64Array containing the min/max extents of the axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.aabb.get = function () {
        return this._aabb;
    };

    /**
     * Gets the local-space oriented 3D boundary (OBB).
     *
     * The OBB is represented by a 32-element Float64Array containing the eight vertices of the box, where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
     *
     * @type {Number[]}
     */
    prototypeAccessors.obb.get = function () {
        return this._obb;
    };

    /**
     * Approximate number of triangles in this VBOGeometry.
     *
     * Will be zero if {@link VBOGeometry#primitive} is not 'triangles', 'triangle-strip' or 'triangle-fan'.
     *
     * @type {Number}
     */
    prototypeAccessors.numTriangles.get = function () {
        return this._numTriangles;
    };

    /** @private */
    VBOGeometry.prototype._getState = function _getState () {
        return this._state;
    };

    /**
     * Destroys this component.
     */
    VBOGeometry.prototype.destroy = function destroy () {
        Geometry.prototype.destroy.call(this);
        var state = this._state;
        if (state.indicesBuf) {
            state.indicesBuf.destroy();
        }
        if (state.positionsBuf) {
            state.positionsBuf.destroy();
        }
        if (state.normalsBuf) {
            state.normalsBuf.destroy();
        }
        if (state.uvBuf) {
            state.uvBuf.destroy();
        }
        if (state.colorsBuf) {
            state.colorsBuf.destroy();
        }
        if (this._edgeIndicesBuf) {
            this._edgeIndicesBuf.destroy();
        }
        state.destroy();
        memoryStats.meshes--;
    };

    Object.defineProperties( VBOGeometry.prototype, prototypeAccessors );

    return VBOGeometry;
}(Geometry));

var modes = {"opaque": 0, "mask": 1, "blend": 2};
var modeNames = ["opaque", "mask", "blend"];

/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the physically-accurate *metallic-roughness* shading model.
 *
 * * Useful for conductive materials, such as metal, but also appropriate for insulators.
 * * {@link SpecularMaterial} is best for insulators, such as wood, ceramics and plastic.
 * * {@link PhongMaterial} is appropriate for non-realistic objects.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link MetallicMaterial} and {@link ReadableGeometry} loaded from OBJ.
 *
 * Note that in this example we're providing separate {@link Texture} for the {@link MetallicMaterial#metallic} and {@link MetallicMaterial#roughness}
 * channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 * within the same {@link Texture} for efficiency.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_MetallicMaterial)]
 *
 * ````javascript
 * import {Viewer, Mesh, loadOBJGeometry, ReadableGeometry, MetallicMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0.57, 1.37, 1.14];
 * viewer.scene.camera.look = [0.04, 0.58, 0.00];
 * viewer.scene.camera.up = [-0.22, 0.84, -0.48];
 *
 * loadOBJGeometry(viewer.scene, {
 *      src: "models/obj/fireHydrant/FireHydrantMesh.obj"
 * })
 * .then(function (geometry) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometry),
 *
 *          material: new MetallicMaterial(viewer.scene, {
 *
 *              baseColor: [1, 1, 1],
 *              metallic: 1.0,
 *              roughness: 1.0,
 *
 *              baseColorMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *                  encoding: "sRGB"
 *              }),
 *              normalMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *              }),
 *              roughnessMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Roughness.png"
 *              }),
 *              metallicMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Metallic.png"
 *              }),
 *              occlusionMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *              }),
 *
 *              specularF0: 0.7
 *          })
 *      });
 * }, function () {
 *          // Error
 *      });
 * ````
 *
 * ## Background Theory
 *
 * For an introduction to physically-based rendering (PBR) concepts, try these articles:
 *
 * * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)
 *
 * ## MetallicMaterial Properties
 *
 * The following table summarizes MetallicMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link MetallicMaterial#baseColor} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the base color of the material. |
 * | {@link MetallicMaterial#metallic} | Number | [0, 1] | 1 | linear | The metallic-ness the material (1 for metals, 0 for non-metals). |
 * | {@link MetallicMaterial#roughness} | Number | [0, 1] | 1 | linear | The roughness of the material surface. |
 * | {@link MetallicMaterial#specularF0} | Number | [0, 1] | 1 | linear | The specular Fresnel of the material surface. |
 * | {@link MetallicMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 * | {@link MetallicMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link MetallicMaterial#baseColorMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link MetallicMaterial#baseColor}. If the fourth component (A) is present, it multiplies by {@link MetallicMaterial#alpha}. |
 * | {@link MetallicMaterial#metallicMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#metallic}. |
 * | {@link MetallicMaterial#roughnessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#roughness}. |
 * | {@link MetallicMaterial#metallicRoughnessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#metallic} and second component multiplying by {@link MetallicMaterial#roughness}. |
 * | {@link MetallicMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link MetallicMaterial#emissive}. |
 * | {@link MetallicMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link MetallicMaterial#alpha}. |
 * | {@link MetallicMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 * | {@link MetallicMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link MetallicMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link MetallicMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link MetallicMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link ReadableGeometry} backfaces. |
 * | {@link MetallicMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link ReadableGeometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 *
 * ## Combining Channels Within the Same Textures
 *
 * In the previous example we provided separate {@link Texture} for the {@link MetallicMaterial#metallic} and
 * {@link MetallicMaterial#roughness} channels, but we can combine those channels into the same {@link Texture} to
 * reduce download time, memory footprint and rendering time (and also for glTF compatibility).
 *
 * Here's the {@link Mesh} again, with our MetallicMaterial with those channels combined in the {@link MetallicMaterial#metallicRoughnessMap}
 * {@link Texture}, where the *R* component multiplies by {@link MetallicMaterial#metallic} and *G* multiplies
 * by {@link MetallicMaterial#roughness}.
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *
 *     geometry: geometry,
 *
 *     material: new MetallicMaterial(viewer.scene, {
 *
 *         baseColor: [1, 1, 1],
 *         metallic: 1.0,
 *         roughness: 1.0,
 *
 *         baseColorMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *             encoding: "sRGB"
 *         }),
 *         normalMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *         }),
 *         metallicRoughnessMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"
 *         }),
 *         metallicRoughnessMap : new Texture(viewer.scene, {                  // <<----------- Added
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"  // R component multiplies by metallic
 *         }),                                                                   // G component multiplies by roughness
 *         occlusionMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *         }),
 *
 *         specularF0: 0.7
 *  })
 * ````
 *
 * Although not shown in this example, we can also texture {@link MetallicMaterial#alpha} with the *A* component of
 * {@link MetallicMaterial#baseColorMap}'s {@link Texture}, if required.
 *
 * ## Alpha Blending
 *
 * Let's make our {@link Mesh} transparent.
 *
 * We'll update the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMode}, causing it to blend 50%
 * with the background:
 *
 * ````javascript
 * hydrant.material.alpha = 0.5;
 * hydrant.material.alphaMode = "blend";
 * ````
 *
 * ## Alpha Masking
 *
 * Let's apply an alpha mask to our {@link Mesh}.
 *
 * We'll configure an {@link MetallicMaterial#alphaMap} to multiply by {@link MetallicMaterial#alpha},
 * with {@link MetallicMaterial#alphaMode} and {@link MetallicMaterial#alphaCutoff} to treat it as an alpha mask:
 *
 * ````javascript
 * new Mesh(viewer.scene, {
 *
 *     geometry: geometry,
 *
 *     material: new MetallicMaterial(viewer.scene, {
 *
 *         baseColor: [1, 1, 1],
 *         metallic: 1.0,
 *         roughness: 1.0,
 *         alpha: 1.0,
 *         alphaMode : "mask",  // <<---------------- Added
 *         alphaCutoff : 0.2,   // <<---------------- Added
 *
 *         alphaMap : new Texture(viewer.scene{ // <<---------------- Added
 *              src: "textures/alphaMap.jpg"
 *         }),
 *         baseColorMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *             encoding: "sRGB"
 *         }),
 *         normalMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *         }),
 *         metallicRoughnessMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"
 *         }),
 *         metallicRoughnessMap : new Texture(viewer.scene, {                  // <<----------- Added
 *             src: "models/obj/fireHydrant/fire_hydrant_MetallicRoughness.png"  // R component multiplies by metallic
 *         }),                                                                   // G component multiplies by roughness
 *         occlusionMap: new Texture(viewer.scene, {
 *             src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *         }),
 *
 *         specularF0: 0.7
 *  })
 * ````
 */
var MetallicMaterial = /*@__PURE__*/(function (Material) {
    function MetallicMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "MetallicMaterial",
            baseColor: math.vec4([1.0, 1.0, 1.0]),
            emissive: math.vec4([0.0, 0.0, 0.0]),
            metallic: null,
            roughness: null,
            specularF0: null,
            alpha: null,
            alphaMode: null, // "opaque"
            alphaCutoff: null,
            lineWidth: null,
            pointSize: null,
            backfaces: null,
            frontface: null, // Boolean for speed; true == "ccw", false == "cw"
            hash: null
        });

        this.baseColor = cfg.baseColor;
        this.metallic = cfg.metallic;
        this.roughness = cfg.roughness;
        this.specularF0 = cfg.specularF0;
        this.emissive = cfg.emissive;
        this.alpha = cfg.alpha;

        if (cfg.baseColorMap) {
            this._baseColorMap = this._checkComponent("Texture", cfg.baseColorMap);
        }
        if (cfg.metallicMap) {
            this._metallicMap = this._checkComponent("Texture", cfg.metallicMap);

        }
        if (cfg.roughnessMap) {
            this._roughnessMap = this._checkComponent("Texture", cfg.roughnessMap);
        }
        if (cfg.metallicRoughnessMap) {
            this._metallicRoughnessMap = this._checkComponent("Texture", cfg.metallicRoughnessMap);
        }
        if (cfg.emissiveMap) {
            this._emissiveMap = this._checkComponent("Texture", cfg.emissiveMap);
        }
        if (cfg.occlusionMap) {
            this._occlusionMap = this._checkComponent("Texture", cfg.occlusionMap);
        }
        if (cfg.alphaMap) {
            this._alphaMap = this._checkComponent("Texture", cfg.alphaMap);
        }
        if (cfg.normalMap) {
            this._normalMap = this._checkComponent("Texture", cfg.normalMap);
        }

        this.alphaMode = cfg.alphaMode;
        this.alphaCutoff = cfg.alphaCutoff;
        this.backfaces = cfg.backfaces;
        this.frontface = cfg.frontface;
        this.lineWidth = cfg.lineWidth;
        this.pointSize = cfg.pointSize;

        this._makeHash();
    }

    if ( Material ) MetallicMaterial.__proto__ = Material;
    MetallicMaterial.prototype = Object.create( Material && Material.prototype );
    MetallicMaterial.prototype.constructor = MetallicMaterial;

    var prototypeAccessors = { type: { configurable: true },baseColor: { configurable: true },baseColorMap: { configurable: true },metallic: { configurable: true },metallicMap: { configurable: true },roughness: { configurable: true },roughnessMap: { configurable: true },metallicRoughnessMap: { configurable: true },specularF0: { configurable: true },emissive: { configurable: true },emissiveMap: { configurable: true },occlusionMap: { configurable: true },alpha: { configurable: true },alphaMap: { configurable: true },normalMap: { configurable: true },alphaMode: { configurable: true },alphaCutoff: { configurable: true },backfaces: { configurable: true },frontface: { configurable: true },lineWidth: { configurable: true },pointSize: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "MetallicMaterial";
    };

    MetallicMaterial.prototype._makeHash = function _makeHash () {
        var state = this._state;
        var hash = ["/met"];
        if (this._baseColorMap) {
            hash.push("/bm");
            if (this._baseColorMap._state.hasMatrix) {
                hash.push("/mat");
            }
            hash.push("/" + this._baseColorMap._state.encoding);
        }
        if (this._metallicMap) {
            hash.push("/mm");
            if (this._metallicMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._roughnessMap) {
            hash.push("/rm");
            if (this._roughnessMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._metallicRoughnessMap) {
            hash.push("/mrm");
            if (this._metallicRoughnessMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._emissiveMap) {
            hash.push("/em");
            if (this._emissiveMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._occlusionMap) {
            hash.push("/ocm");
            if (this._occlusionMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._alphaMap) {
            hash.push("/am");
            if (this._alphaMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._normalMap) {
            hash.push("/nm");
            if (this._normalMap._state.hasMatrix) {
                hash.push("/mat");
            }
        }
        hash.push(";");
        state.hash = hash.join("");
    };


    /**
     * Sets the RGB diffuse color.
     *
     * Multiplies by the RGB components of {@link MetallicMaterial#baseColorMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.baseColor.set = function (value) {
        var baseColor = this._state.baseColor;
        if (!baseColor) {
            baseColor = this._state.baseColor = new Float32Array(3);
        } else if (value && baseColor[0] === value[0] && baseColor[1] === value[1] && baseColor[2] === value[2]) {
            return;
        }
        if (value) {
            baseColor[0] = value[0];
            baseColor[1] = value[1];
            baseColor[2] = value[2];
        } else {
            baseColor[0] = 1;
            baseColor[1] = 1;
            baseColor[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB diffuse color.
     *
     * Multiplies by the RGB components of {@link MetallicMaterial#baseColorMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.baseColor.get = function () {
        return this._state.baseColor;
    };


    /**
     * Gets the RGB {@link Texture} containing the diffuse color of this MetallicMaterial, with optional *A* component for alpha.
     *
     * The RGB components multiply by {@link MetallicMaterial#baseColor}, while the *A* component, if present, multiplies by {@link MetallicMaterial#alpha}.
     *
     * @type {Texture}
     */
    prototypeAccessors.baseColorMap.get = function () {
        return this._baseColorMap;
    };

    /**
     * Sets the metallic factor.
     *
     * This is in the range ````[0..1]```` and indicates how metallic this MetallicMaterial is.
     *
     * ````1```` is metal, ````0```` is non-metal.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#metallicMap} and the *A* component of {@link MetallicMaterial#metallicRoughnessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.metallic.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.metallic === value) {
            return;
        }
        this._state.metallic = value;
        this.glRedraw();
    };

    /**
     * Gets the metallic factor.
     *
     * @type {Number}
     */
    prototypeAccessors.metallic.get = function () {
        return this._state.metallic;
    };

    /**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's metallic factor in its *R* component.
     *
     * The *R* component multiplies by {@link MetallicMaterial#metallic}.
     *
     * @type {Texture}
     */
    prototypeAccessors.metallicMap.get = function () {
        return this._attached.metallicMap;
    };

    /**
     *  Sets the roughness factor.
     *
     *  This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#roughnessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.roughness.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.roughness === value) {
            return;
        }
        this._state.roughness = value;
        this.glRedraw();
    };

    /**
     * Gets the roughness factor.
     *
     * @type {Number}
     */
    prototypeAccessors.roughness.get = function () {
        return this._state.roughness;
    };

    /**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's roughness factor in its *R* component.
     *
     * The *R* component multiplies by {@link MetallicMaterial#roughness}.
     *
     * @type {Texture}
     */
    prototypeAccessors.roughnessMap.get = function () {
        return this._attached.roughnessMap;
    };

    /**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's metalness in its *R* component and roughness in its *G* component.
     *
     * Its *B* component multiplies by the {@link MetallicMaterial#metallic} property, while its *G* component multiplies by the {@link MetallicMaterial#roughness} property.
     *
     * @type {Texture}
     */
    prototypeAccessors.metallicRoughnessMap.get = function () {
        return this._attached.metallicRoughnessMap;
    };

    /**
     * Sets the factor in the range [0..1] indicating specular Fresnel value.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.specularF0.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 0.0;
        if (this._state.specularF0 === value) {
            return;
        }
        this._state.specularF0 = value;
        this.glRedraw();
    };

    /**
     * Gets the factor in the range [0..1] indicating specular Fresnel value.
     *
     * @type {Number}
     */
    prototypeAccessors.specularF0.get = function () {
        return this._state.specularF0;
    };

    /**
     * Sets the RGB emissive color.
     *
     * Multiplies by {@link MetallicMaterial#emissiveMap}.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.set = function (value) {
        var emissive = this._state.emissive;
        if (!emissive) {
            emissive = this._state.emissive = new Float32Array(3);
        } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
            return;
        }
        if (value) {
            emissive[0] = value[0];
            emissive[1] = value[1];
            emissive[2] = value[2];
        } else {
            emissive[0] = 0;
            emissive[1] = 0;
            emissive[2] = 0;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB emissive color.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.get = function () {
        return this._state.emissive;
    };

    /**
     * Gets the RGB emissive map.
     *
     * Multiplies by {@link MetallicMaterial#emissive}.
     *
     * @type {Texture}
     */
    prototypeAccessors.emissiveMap.get = function () {
        return this._attached.emissiveMap;
    };

    /**
     * Gets the RGB ambient occlusion map.
     *
     * Multiplies by the specular and diffuse light reflected by surfaces.
     *
     * @type {Texture}
     */
    prototypeAccessors.occlusionMap.get = function () {
        return this._attached.occlusionMap;
    };

    /**
     * Sets factor in the range ````[0..1]```` that indicates the alpha value.
     *
     * Multiplies by the *R* component of {@link MetallicMaterial#alphaMap} and the *A* component, if present, of {@link MetallicMaterial#baseColorMap}.
     *
     * The value of {@link MetallicMaterial#alphaMode} indicates how alpha is interpreted when rendering.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.alpha === value) {
            return;
        }
        this._state.alpha = value;
        this.glRedraw();
    };

    /**
     * Gets factor in the range ````[0..1]```` that indicates the alpha value.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.get = function () {
        return this._state.alpha;
    };

    /**
     * Gets the RGB {@link Texture} containing this MetallicMaterial's alpha in its *R* component.
     *
     * The *R* component multiplies by the {@link MetallicMaterial#alpha} property.
     *
     * @type {Texture}
     */
    prototypeAccessors.alphaMap.get = function () {
        return this._attached.alphaMap;
    };

    /**
     * Gets the RGB tangent-space normal map {@link Texture}.
     *
     * @type {Texture}
     */
    prototypeAccessors.normalMap.get = function () {
        return this._attached.normalMap;
    };

    /**
     * Sets the alpha rendering mode.
     *
     * This specifies how alpha is interpreted. Alpha is the combined result of the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMap} properties.
     *
     * Accepted values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha and {@link MetallicMaterial#alphaCutoff}.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).
     *
     * @type {String}
     */
    prototypeAccessors.alphaMode.set = function (alphaMode) {
        alphaMode = alphaMode || "opaque";
        var value = modes[alphaMode];
        if (value === undefined) {
            this.error("Unsupported value for 'alphaMode': " + alphaMode + " defaulting to 'opaque'");
            value = "opaque";
        }
        if (this._state.alphaMode === value) {
            return;
        }
        this._state.alphaMode = value;
        this.glRedraw();
    };

    /**
     * Gets the alpha rendering mode.
     *
     * @type {String}
     */
    prototypeAccessors.alphaMode.get = function () {
        return modeNames[this._state.alphaMode];
    };

    /**
     * Sets the alpha cutoff value.
     *
     * Specifies the cutoff threshold when {@link MetallicMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire
     * material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of the {@link MetallicMaterial#alpha} and {@link MetallicMaterial#alphaMap} properties.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.set = function (alphaCutoff) {
        if (alphaCutoff === null || alphaCutoff === undefined) {
            alphaCutoff = 0.5;
        }
        if (this._state.alphaCutoff === alphaCutoff) {
            return;
        }
        this._state.alphaCutoff = alphaCutoff;
    };

    /**
     * Gets the alpha cutoff value.
     *
     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.get = function () {
        return this._state.alphaCutoff;
    };

    /**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link ReadableGeometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (value) {
        value = !!value;
        if (this._state.backfaces === value) {
            return;
        }
        this._state.backfaces = value;
        this.glRedraw();
    };

    /**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._state.backfaces;
    };

    /**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */
    prototypeAccessors.frontface.set = function (value) {
        value = value !== "cw";
        if (this._state.frontface === value) {
            return;
        }
        this._state.frontface = value;
        this.glRedraw();
    };

    /**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
*
     * @type {String}
     */
    prototypeAccessors.frontface.get = function () {
        return this._state.frontface ? "ccw" : "cw";
    };

    /**
     * Sets the MetallicMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.set = function (value) {
        this._state.lineWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the MetallicMaterial's line width.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.get = function () {
        return this._state.lineWidth;
    };

    /**
     * Sets the MetallicMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.set = function (value) {
        this._state.pointSize = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the MetallicMaterial's point size.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.get = function () {
        return this._state.pointSize;
    };

    /**
     * Destroys this MetallicMaterial.
     */
    MetallicMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( MetallicMaterial.prototype, prototypeAccessors );

    return MetallicMaterial;
}(Material));

var alphaModes = {"opaque": 0, "mask": 1, "blend": 2};
var alphaModeNames = ["opaque", "mask", "blend"];

/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the physically-accurate *specular-glossiness* shading model.
 *
 * * Useful for insulators, such as wood, ceramics and plastic.
 * * {@link MetallicMaterial} is best for conductive materials, such as metal.
 * * {@link PhongMaterial} is appropriate for non-realistic objects.
 * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a {@link buildTorusGeometry} and a SpecularMaterial.
 *
 * Note that in this example we're providing separate {@link Texture} for the {@link SpecularMaterial#specular} and {@link SpecularMaterial#glossiness}
 * channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 * within the same {@link Texture} for efficiency.
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry, SpecularMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({ canvasId: "myCanvas" });
 *
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,
 *
 *          // Textures to multiply some of the channels
 *
 *          diffuseMap: new Texture(viewer.scene, { // RGB components multiply by diffuse
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularMap: new Texture(viewer.scene, { // RGB component multiplies by specular
 *              src: "textures/specular.jpg"
 *          }),
 *          glossinessMap: new Texture(viewer.scene, { // R component multiplies by glossiness
 *              src: "textures/glossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Combining Channels Within the Same Textures
 *
 *  In the previous example we provided separate {@link Texture} for the {@link SpecularMaterial#specular} and
 * {@link SpecularMaterial#glossiness} channels, but we can combine those channels into the same {@link Texture} to reduce
 * download time, memory footprint and rendering time (and also for glTF compatibility).
 *
 * Here's our SpecularMaterial again with those channels combined in the {@link SpecularMaterial#specularGlossinessMap}
 * {@link Texture}, where the *RGB* component multiplies by {@link SpecularMaterial#specular} and *A* multiplies by {@link SpecularMaterial#glossiness}.
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,
 *
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * Although not shown in this example, we can also texture {@link SpecularMaterial#alpha} with
 * the *A* component of {@link SpecularMaterial#diffuseMap}'s {@link Texture}, if required.
 *
 * ## Alpha Blending
 *
 * Let's make our {@link Mesh} transparent. We'll redefine {@link SpecularMaterial#alpha}
 * and {@link SpecularMaterial#alphaMode}, causing it to blend 50% with the background:
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry()),
 *
 *      material: new SpecularMaterial(viewer.scene,{
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 0.5,         // <<----------- Changed
 *          alphaMode: "blend", // <<----------- Added
 *
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Alpha Masking
 *
 * Now let's make holes in our {@link Mesh}. We'll give its SpecularMaterial an {@link SpecularMaterial#alphaMap}
 * and configure {@link SpecularMaterial#alpha}, {@link SpecularMaterial#alphaMode},
 * and {@link SpecularMaterial#alphaCutoff} to treat it as an alpha mask:
 *
 * ````javascript
 * const myMesh = new Mesh(viewer.scene,{
 *
 *     geometry: buildTorusGeometry(viewer.scene, ReadableGeometry, {}),
 *
 *      material: new SpecularMaterial(viewer.scene, {
 *
 *          // Channels with default values, just to show them
 *
 *          diffuse: [1.0, 1.0, 1.0],
 *          specular: [1.0, 1.0, 1.0],
 *          glossiness: 1.0,
 *          emissive: [0.0, 0.0, 0.0]
 *          alpha: 1.0,         // <<----------- Changed
 *          alphaMode: "mask",  // <<----------- Changed
 *          alphaCutoff: 0.2,   // <<----------- Added
 *
 *          alphaMap: new Texture(viewer.scene, { // <<---------- Added
 *              src: "textures/diffuse/crossGridColorMap.jpg"
 *          }),
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse.jpg"
 *          }),
 *          specularGlossinessMap: new Texture(viewer.scene, { // RGB multiplies by specular, A by glossiness
 *              src: "textures/specularGlossiness.jpg"
 *          }),
 *          normalMap: new Texture(viewer.scene, {
 *              src: "textures/normalMap.jpg"
 *          })
 *      })
 * });
 * ````
 *
 * ## Background Theory
 *
 * For an introduction to physically-based rendering (PBR) concepts, try these articles:
 *
 * * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)
 *
 * ## SpecularMaterial Properties
 *
 * The following table summarizes SpecularMaterial properties:
 *
 * | Property | Type | Range | Default Value | Space | Description |
 * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 * | {@link SpecularMaterial#diffuse} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse color of the material. |
 * | {@link SpecularMaterial#specular} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular color of the material. |
 * | {@link SpecularMaterial#glossiness} | Number | [0, 1] | 1 | linear | The glossiness the material. |
 * | {@link SpecularMaterial#specularF0} | Number | [0, 1] | 1 | linear | The specularF0 of the material surface. |
 * | {@link SpecularMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 * | {@link SpecularMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 * | {@link SpecularMaterial#diffuseMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link SpecularMaterial#diffuse}. If the fourth component (A) is present, it multiplies by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#specularMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link SpecularMaterial#specular}. If the fourth component (A) is present, it multiplies by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#glossinessMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link SpecularMaterial#glossiness}. |
 * | {@link SpecularMaterial#specularGlossinessMap} | {@link Texture} |  | null | linear | Texture with first three components multiplying by {@link SpecularMaterial#specular} and fourth component multiplying by {@link SpecularMaterial#glossiness}. |
 * | {@link SpecularMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link SpecularMaterial#emissive}. |
 * | {@link SpecularMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link SpecularMaterial#alpha}. |
 * | {@link SpecularMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 * | {@link SpecularMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |
 * | {@link SpecularMaterial#alphaMode} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 * | {@link SpecularMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 * | {@link SpecularMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link Geometry} backfaces. |
 * | {@link SpecularMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link Geometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 */
var SpecularMaterial = /*@__PURE__*/(function (Material) {
    function SpecularMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "SpecularMaterial",
            diffuse: math.vec3([1.0, 1.0, 1.0]),
            emissive: math.vec3([0.0, 0.0, 0.0]),
            specular: math.vec3([1.0, 1.0, 1.0]),
            glossiness: null,
            specularF0: null,
            alpha: null,
            alphaMode: null,
            alphaCutoff: null,
            lineWidth: null,
            pointSize: null,
            backfaces: null,
            frontface: null, // Boolean for speed; true == "ccw", false == "cw"
            hash: null
        });

        this.diffuse = cfg.diffuse;
        this.specular = cfg.specular;
        this.glossiness = cfg.glossiness;
        this.specularF0 = cfg.specularF0;
        this.emissive = cfg.emissive;
        this.alpha = cfg.alpha;

        if (cfg.diffuseMap) {
            this._diffuseMap = this._checkComponent("Texture", cfg.diffuseMap);
        }
        if (cfg.emissiveMap) {
            this._emissiveMap = this._checkComponent("Texture", cfg.emissiveMap);
        }
        if (cfg.specularMap) {
            this._specularMap = this._checkComponent("Texture", cfg.specularMap);
        }
        if (cfg.glossinessMap) {
            this._glossinessMap = this._checkComponent("Texture", cfg.glossinessMap);
        }
        if (cfg.specularGlossinessMap) {
            this._specularGlossinessMap = this._checkComponent("Texture", cfg.specularGlossinessMap);
        }
        if (cfg.occlusionMap) {
            this._occlusionMap = this._checkComponent("Texture", cfg.occlusionMap);
        }
        if (cfg.alphaMap) {
            this._alphaMap = this._checkComponent("Texture", cfg.alphaMap);
        }
        if (cfg.normalMap) {
            this._normalMap = this._checkComponent("Texture", cfg.normalMap);
        }

        this.alphaMode = cfg.alphaMode;
        this.alphaCutoff = cfg.alphaCutoff;
        this.backfaces = cfg.backfaces;
        this.frontface = cfg.frontface;

        this.lineWidth = cfg.lineWidth;
        this.pointSize = cfg.pointSize;

        this._makeHash();
    }

    if ( Material ) SpecularMaterial.__proto__ = Material;
    SpecularMaterial.prototype = Object.create( Material && Material.prototype );
    SpecularMaterial.prototype.constructor = SpecularMaterial;

    var prototypeAccessors = { type: { configurable: true },diffuse: { configurable: true },diffuseMap: { configurable: true },specular: { configurable: true },specularMap: { configurable: true },specularGlossinessMap: { configurable: true },glossiness: { configurable: true },glossinessMap: { configurable: true },specularF0: { configurable: true },emissive: { configurable: true },emissiveMap: { configurable: true },alpha: { configurable: true },alphaMap: { configurable: true },normalMap: { configurable: true },occlusionMap: { configurable: true },alphaMode: { configurable: true },alphaCutoff: { configurable: true },backfaces: { configurable: true },frontface: { configurable: true },lineWidth: { configurable: true },pointSize: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "SpecularMaterial";
    };

    SpecularMaterial.prototype._makeHash = function _makeHash () {
        var state = this._state;
        var hash = ["/spe"];
        if (this._diffuseMap) {
            hash.push("/dm");
            if (this._diffuseMap.hasMatrix) {
                hash.push("/mat");
            }
            hash.push("/" + this._diffuseMap.encoding);
        }
        if (this._emissiveMap) {
            hash.push("/em");
            if (this._emissiveMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._glossinessMap) {
            hash.push("/gm");
            if (this._glossinessMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._specularMap) {
            hash.push("/sm");
            if (this._specularMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._specularGlossinessMap) {
            hash.push("/sgm");
            if (this._specularGlossinessMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._occlusionMap) {
            hash.push("/ocm");
            if (this._occlusionMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._normalMap) {
            hash.push("/nm");
            if (this._normalMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        if (this._alphaMap) {
            hash.push("/opm");
            if (this._alphaMap.hasMatrix) {
                hash.push("/mat");
            }
        }
        hash.push(";");
        state.hash = hash.join("");
    };

    /**
     * Sets the RGB diffuse color of this SpecularMaterial.
     *
     * Multiplies by the *RGB* components of {@link SpecularMaterial#diffuseMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     * @type {Number[]}
     */
    prototypeAccessors.diffuse.set = function (value) {
        var diffuse = this._state.diffuse;
        if (!diffuse) {
            diffuse = this._state.diffuse = new Float32Array(3);
        } else if (value && diffuse[0] === value[0] && diffuse[1] === value[1] && diffuse[2] === value[2]) {
            return;
        }
        if (value) {
            diffuse[0] = value[0];
            diffuse[1] = value[1];
            diffuse[2] = value[2];
        } else {
            diffuse[0] = 1;
            diffuse[1] = 1;
            diffuse[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB diffuse color of this SpecularMaterial.
     *
     * @type {Number[]}
     */
    prototypeAccessors.diffuse.get = function () {
        return this._state.diffuse;
    };

    /**
     * Gets the RGB {@link Texture} containing the diffuse color of this SpecularMaterial, with optional *A* component for alpha.
     *
     * The *RGB* components multipliues by the {@link SpecularMaterial#diffuse} property, while the *A* component, if present, multiplies by the {@link SpecularMaterial#alpha} property.
     *
     * @type {Texture}
     */
    prototypeAccessors.diffuseMap.get = function () {
        return this._diffuseMap;
    };

    /**
     * Sets the RGB specular color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#specularMap} and the *A* component of {@link SpecularMaterial#specularGlossinessMap}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.specular.set = function (value) {
        var specular = this._state.specular;
        if (!specular) {
            specular = this._state.specular = new Float32Array(3);
        } else if (value && specular[0] === value[0] && specular[1] === value[1] && specular[2] === value[2]) {
            return;
        }
        if (value) {
            specular[0] = value[0];
            specular[1] = value[1];
            specular[2] = value[2];
        } else {
            specular[0] = 1;
            specular[1] = 1;
            specular[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB specular color of this SpecularMaterial.
     *
     * @type {Number[]}
     */
    prototypeAccessors.specular.get = function () {
        return this._state.specular;
    };

    /**
     * Gets the RGB texture containing the specular color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#specular}.
     *
     * @type {Texture}
     */
    prototypeAccessors.specularMap.get = function () {
        return this._specularMap;
    };

    /**
     * Gets the RGBA texture containing this SpecularMaterial's specular color in its *RGB* components and glossiness in its *A* component.
     *
     * The *RGB* components multiplies {@link SpecularMaterial#specular}, while the *A* component multiplies by {@link SpecularMaterial#glossiness}.
     *
     * @type {Texture}
     */
    prototypeAccessors.specularGlossinessMap.get = function () {
        return this._specularGlossinessMap;
    };

    /**
     * Sets the Factor in the range [0..1] indicating how glossy this SpecularMaterial is.
     *
     * ````0```` is no glossiness, ````1```` is full glossiness.
     *
     * Multiplies by the *R* component of {@link SpecularMaterial#glossinessMap} and the *A* component of {@link SpecularMaterial#specularGlossinessMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.glossiness.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.glossiness === value) {
            return;
        }
        this._state.glossiness = value;
        this.glRedraw();
    };

    /**
     * Gets the Factor in the range ````[0..1]```` indicating how glossy this SpecularMaterial is.

     * @type {Number}
     */
    prototypeAccessors.glossiness.get = function () {
        return this._state.glossiness;
    };

    /**
     * Gets the RGB texture containing this SpecularMaterial's glossiness in its *R* component.
     *
     * The *R* component multiplies by {@link SpecularMaterial#glossiness}.
     ** @type {Texture}
     */
    prototypeAccessors.glossinessMap.get = function () {
        return this._glossinessMap;
    };

    /**
     * Sets the factor in the range ````[0..1]```` indicating amount of specular Fresnel.
     *
     * Default value is ````0.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.specularF0.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 0.0;
        if (this._state.specularF0 === value) {
            return;
        }
        this._state.specularF0 = value;
        this.glRedraw();
    };

    /**
     * Gets the factor in the range ````[0..1]```` indicating amount of specular Fresnel.
     *
     * @type {Number}
     */
    prototypeAccessors.specularF0.get = function () {
        return this._state.specularF0;
    };

    /**
     * Sets the RGB emissive color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#emissiveMap}.

     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.set = function (value) {
        var emissive = this._state.emissive;
        if (!emissive) {
            emissive = this._state.emissive = new Float32Array(3);
        } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
            return;
        }
        if (value) {
            emissive[0] = value[0];
            emissive[1] = value[1];
            emissive[2] = value[2];
        } else {
            emissive[0] = 0;
            emissive[1] = 0;
            emissive[2] = 0;
        }
        this.glRedraw();
    };

    /**
     * Gets the RGB emissive color of this SpecularMaterial.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.get = function () {
        return this._state.emissive;
    };

    /**
     * Gets the RGB texture containing the emissive color of this SpecularMaterial.
     *
     * Multiplies by {@link SpecularMaterial#emissive}.
     *
     * @type {Texture}
     */
    prototypeAccessors.emissiveMap.get = function () {
        return this._emissiveMap;
    };

    /**
     * Sets the factor in the range [0..1] indicating how transparent this SpecularMaterial is.
     *
     * A value of ````0.0```` is fully transparent, while ````1.0```` is fully opaque.
     *
     * Multiplies by the *R* component of {@link SpecularMaterial#alphaMap} and the *A* component, if present, of {@link SpecularMaterial#diffuseMap}.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.alpha === value) {
            return;
        }
        this._state.alpha = value;
        this.glRedraw();
    };

    /**
     * Gets the factor in the range [0..1] indicating how transparent this SpecularMaterial is.
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.get = function () {
        return this._state.alpha;
    };

    /**
     * Gets the RGB {@link Texture} with alpha in its *R* component.
     *
     * The *R* component multiplies by the {@link SpecularMaterial#alpha} property.
     *
     * @type {Texture}
     */
    prototypeAccessors.alphaMap.get = function () {
        return this._alphaMap;
    };

    /**
     * Gets the RGB tangent-space normal {@link Texture} attached to this SpecularMaterial.
     *
     * @type {Texture}
     */
    prototypeAccessors.normalMap.get = function () {
        return this._normalMap;
    };

    /**
     * Gets the RGB ambient occlusion {@link Texture} attached to this SpecularMaterial.
     *
     * Multiplies by the specular and diffuse light reflected by surfaces.
     *
     * @type {Texture}
     */
    prototypeAccessors.occlusionMap.get = function () {
        return this._occlusionMap;
    };

    /**
     * Sets the alpha rendering mode.
     *
     * This governs how alpha is treated. Alpha is the combined result of the {@link SpecularMaterial#alpha} and {@link SpecularMaterial#alphaMap} properties.
     *
     * Accepted values are:
     *
     * * "opaque" - The alpha value is ignored and the rendered output is fully opaque (default).
     * * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
     * * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
     *
     * @type {String}
     */
    prototypeAccessors.alphaMode.set = function (alphaMode) {
        alphaMode = alphaMode || "opaque";
        var value = alphaModes[alphaMode];
        if (value === undefined) {
            this.error("Unsupported value for 'alphaMode': " + alphaMode + " defaulting to 'opaque'");
            value = "opaque";
        }
        if (this._state.alphaMode === value) {
            return;
        }
        this._state.alphaMode = value;
        this.glRedraw();
    };

    prototypeAccessors.alphaMode.get = function () {
        return alphaModeNames[this._state.alphaMode];
    };

    /**
     * Sets the alpha cutoff value.
     *
     * Specifies the cutoff threshold when {@link SpecularMaterial#alphaMode} equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes.
     *
     * Alpha is the combined result of the {@link SpecularMaterial#alpha} and {@link SpecularMaterial#alphaMap} properties.
     *
     * Default value is ````0.5````.
     *
     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.set = function (alphaCutoff) {
        if (alphaCutoff === null || alphaCutoff === undefined) {
            alphaCutoff = 0.5;
        }
        if (this._state.alphaCutoff === alphaCutoff) {
            return;
        }
        this._state.alphaCutoff = alphaCutoff;
    };

    /**
     * Gets the alpha cutoff value.

     * @type {Number}
     */
    prototypeAccessors.alphaCutoff.get = function () {
        return this._state.alphaCutoff;
    };

    /**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * The backfaces will belong to {@link ReadableGeometry} compoents that are also attached to the {@link Mesh}es.
     *
     * Default is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (value) {
        value = !!value;
        if (this._state.backfaces === value) {
            return;
        }
        this._state.backfaces = value;
        this.glRedraw();
    };

    /**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._state.backfaces;
    };

    /**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */
    prototypeAccessors.frontface.set = function (value) {
        value = value !== "cw";
        if (this._state.frontface === value) {
            return;
        }
        this._state.frontface = value;
        this.glRedraw();
    };

    /**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * @type {String}
     */
    prototypeAccessors.frontface.get = function () {
        return this._state.frontface ? "ccw" : "cw";
    };

    /**
     * Sets the SpecularMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.set = function (value) {
        this._state.lineWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the SpecularMaterial's line width.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.get = function () {
        return this._state.lineWidth;
    };

    /**
     * Sets the SpecularMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.set = function (value) {
        this._state.pointSize = value || 1;
        this.glRedraw();
    };

    /**
     * Sets the SpecularMaterial's point size.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.get = function () {
        return this._state.pointSize;
    };

    /**
     * Destroys this SpecularMaterial.
     */
    SpecularMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( SpecularMaterial.prototype, prototypeAccessors );

    return SpecularMaterial;
}(Material));

/**
 * @author xeolabs / https://github.com/xeolabs
 */

/**
 * @desc Human-readable WebGL enumeration mappings.
 * @private
 */
var webglEnums = {
    funcAdd: "FUNC_ADD",
    funcSubtract: "FUNC_SUBTRACT",
    funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
    zero: "ZERO",
    one: "ONE",
    srcColor: "SRC_COLOR",
    oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
    dstColor: "DST_COLOR",
    oneMinusDstColor: "ONE_MINUS_DST_COLOR",
    srcAlpha: "SRC_ALPHA",
    oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
    dstAlpha: "DST_ALPHA",
    oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
    contantColor: "CONSTANT_COLOR",
    oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
    constantAlpha: "CONSTANT_ALPHA",
    oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
    srcAlphaSaturate: "SRC_ALPHA_SATURATE",
    front: "FRONT",
    back: "BACK",
    frontAndBack: "FRONT_AND_BACK",
    never: "NEVER",
    less: "LESS",
    equal: "EQUAL",
    lequal: "LEQUAL",
    greater: "GREATER",
    notequal: "NOTEQUAL",
    gequal: "GEQUAL",
    always: "ALWAYS",
    cw: "CW",
    ccw: "CCW",
    linear: "LINEAR",
    nearest: "NEAREST",
    linearMipmapNearest: "LINEAR_MIPMAP_NEAREST",
    nearestMipmapNearest: "NEAREST_MIPMAP_NEAREST",
    nearestMipmapLinear: "NEAREST_MIPMAP_LINEAR",
    linearMipmapLinear: "LINEAR_MIPMAP_LINEAR",
    repeat: "REPEAT",
    clampToEdge: "CLAMP_TO_EDGE",
    mirroredRepeat: "MIRRORED_REPEAT",
    alpha: "ALPHA",
    rgb: "RGB",
    rgba: "RGBA",
    luminance: "LUMINANCE",
    luminanceAlpha: "LUMINANCE_ALPHA",
    textureBinding2D: "TEXTURE_BINDING_2D",
    textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
    compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
    unsignedByte: "UNSIGNED_BYTE"
};

function getGLEnum(gl, name, defaultVal) {
    if (name === undefined) {
        return defaultVal;
    }
    var glName = webglEnums[name];
    if (glName === undefined) {
        return defaultVal;
    }
    return gl[glName];
}

var color$2 = new Uint8Array([0, 0, 0, 1]);

/**
 * @desc A low-level component that represents a 2D WebGL texture.
 *
 * @private
 */
var Texture2D = function Texture2D(gl, target) {
    this.gl = gl;
    this.target = target || gl.TEXTURE_2D;
    this.texture = gl.createTexture();
    this.setPreloadColor([0, 0, 0, 0]); // Prevents "there is no texture bound to the unit 0" error
    this.allocated = true;
};

Texture2D.prototype.setPreloadColor = function setPreloadColor (value) {

    if (!value) {
        color$2[0] = 0;
        color$2[1] = 0;
        color$2[2] = 0;
        color$2[3] = 255;
    } else {
        color$2[0] = Math.floor(value[0] * 255);
        color$2[1] = Math.floor(value[1] * 255);
        color$2[2] = Math.floor(value[2] * 255);
        color$2[3] = Math.floor((value[3] !== undefined ? value[3] : 1) * 255);
    }

    var gl = this.gl;

    gl.bindTexture(this.target, this.texture);
    gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    if (this.target === gl.TEXTURE_CUBE_MAP) {

        var faces = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];

        for (var i = 0, len = faces.length; i < len; i++) {
            gl.texImage2D(faces[i], 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color$2);
        }

    } else {
        gl.texImage2D(this.target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color$2);
    }

    gl.bindTexture(this.target, null);
};

Texture2D.prototype.setTarget = function setTarget (target) {
    this.target = target || this.gl.TEXTURE_2D;
};

Texture2D.prototype.setImage = function setImage (image, props) {
    var gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, props.flipY);
    if (this.target === gl.TEXTURE_CUBE_MAP) {
        if (utils.isArray(image)) {
            var images = image;
            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];
            for (var i = 0, len = faces.length; i < len; i++) {
                gl.texImage2D(faces[i], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[i]);
            }
        }
    } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    }
    gl.bindTexture(this.target, null);
};

Texture2D.prototype.setProps = function setProps (props) {
    var gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    if (props.minFilter) {
        var minFilter = getGLEnum(gl, props.minFilter);
        if (minFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, minFilter);
            if (minFilter === gl.NEAREST_MIPMAP_NEAREST ||
                minFilter === gl.LINEAR_MIPMAP_NEAREST ||
                minFilter === gl.NEAREST_MIPMAP_LINEAR ||
                minFilter === gl.LINEAR_MIPMAP_LINEAR) {

                gl.generateMipmap(this.target);
            }
        }
    }
    if (props.magFilter) {
        var magFilter = getGLEnum(gl, props.magFilter);
        if (magFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, magFilter);
        }
    }
    if (props.wrapS) {
        var wrapS = getGLEnum(gl, props.wrapS);
        if (wrapS) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
        }
    }
    if (props.wrapT) {
        var wrapT = getGLEnum(gl, props.wrapT);
        if (wrapT) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
        }
    }
    gl.bindTexture(this.target, null);
};

Texture2D.prototype.bind = function bind (unit) {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, this.texture);
        return true;
    }
    return false;
};

Texture2D.prototype.unbind = function unbind (unit) {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, null);
    }
};

Texture2D.prototype.destroy = function destroy () {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        this.gl.deleteTexture(this.texture);
        this.texture = null;
    }
};

function ensureImageSizePowerOfTwo$1(image) {
    if (!isPowerOfTwo$1(image.width) || !isPowerOfTwo$1(image.height)) {
        var canvas = document.createElement("canvas");
        canvas.width = nextHighestPowerOfTwo$1(image.width);
        canvas.height = nextHighestPowerOfTwo$1(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image,
            0, 0, image.width, image.height,
            0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
}

function isPowerOfTwo$1(x) {
    return (x & (x - 1)) === 0;
}

function nextHighestPowerOfTwo$1(x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
}

/**
 * @desc A 2D texture map.
 *
 * * Textures are attached to {@link Material}s, which are attached to {@link Mesh}es.
 * * To create a Texture from an image file, set {@link Texture#src} to the image file path.
 * * To create a Texture from an HTMLImageElement, set the Texture's {@link Texture#image} to the HTMLImageElement.
 *
 * ## Usage
 *
 * In this example we have a Mesh with a {@link PhongMaterial} which applies diffuse {@link Texture}, and a {@link buildTorusGeometry} which builds a {@link ReadableGeometry}.
 *
 * Note that xeokit will ignore {@link PhongMaterial#diffuse} and {@link PhongMaterial#specular}, since we override those
 * with {@link PhongMaterial#diffuseMap} and {@link PhongMaterial#specularMap}. The {@link Texture} pixel colors directly
 * provide the diffuse and specular components for each fragment across the {@link ReadableGeometry} surface.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_Texture)]
 *
 * ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *      ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          ambient: [0.9, 0.3, 0.9],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *````
 */
var Texture = /*@__PURE__*/(function (Component) {
    function Texture(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._state = new RenderState({
            texture: new Texture2D(this.scene.canvas.gl),
            matrix: math.identityMat4(),
            hasMatrix: (cfg.translate && (cfg.translate[0] !== 0 || cfg.translate[1] !== 0)) || (!!cfg.rotate) || (cfg.scale && (cfg.scale[0] !== 0 || cfg.scale[1] !== 0)),
            minFilter: this._checkMinFilter(cfg.minFilter),
            magFilter: this._checkMagFilter(cfg.magFilter),
            wrapS: this._checkWrapS(cfg.wrapS),
            wrapT: this._checkWrapT(cfg.wrapT),
            flipY: this._checkFlipY(cfg.flipY),
            encoding: this._checkEncoding(cfg.encoding)
        });

        // Data source

        this._src = null;
        this._image = null;

        // Transformation

        this._translate = math.vec2([0, 0]);
        this._scale = math.vec2([1, 1]);
        this._rotate = math.vec2([0, 0]);

        this._matrixDirty = false;

        // Transform

        this.translate = cfg.translate;
        this.scale = cfg.scale;
        this.rotate = cfg.rotate;

        // Data source

        if (cfg.src) {
            this.src = cfg.src; // Image file
        } else if (cfg.image) {
            this.image = cfg.image; // Image object
        }

        stats.memory.textures++;
    }

    if ( Component ) Texture.__proto__ = Component;
    Texture.prototype = Object.create( Component && Component.prototype );
    Texture.prototype.constructor = Texture;

    var prototypeAccessors = { type: { configurable: true },image: { configurable: true },src: { configurable: true },translate: { configurable: true },scale: { configurable: true },rotate: { configurable: true },minFilter: { configurable: true },magFilter: { configurable: true },wrapS: { configurable: true },wrapT: { configurable: true },flipY: { configurable: true },encoding: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "Texture";
    };

    Texture.prototype._checkMinFilter = function _checkMinFilter (value) {
        value = value || "linearMipmapLinear";
        if (value !== "linear" &&
            value !== "linearMipmapNearest" &&
            value !== "linearMipmapLinear" &&
            value !== "nearestMipmapLinear" &&
            value !== "nearestMipmapNearest") {
            this.error("Unsupported value for 'minFilter': '" + value +
                "' - supported values are 'linear', 'linearMipmapNearest', 'nearestMipmapNearest', " +
                "'nearestMipmapLinear' and 'linearMipmapLinear'. Defaulting to 'linearMipmapLinear'.");
            value = "linearMipmapLinear";
        }
        return value;
    };

    Texture.prototype._checkMagFilter = function _checkMagFilter (value) {
        value = value || "linear";
        if (value !== "linear" && value !== "nearest") {
            this.error("Unsupported value for 'magFilter': '" + value +
                "' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");
            value = "linear";
        }
        return value;
    };

    Texture.prototype._checkFilter = function _checkFilter (value) {
        value = value || "linear";
        if (value !== "linear" && value !== "nearest") {
            this.error("Unsupported value for 'magFilter': '" + value +
                "' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");
            value = "linear";
        }
        return value;
    };

    Texture.prototype._checkWrapS = function _checkWrapS (value) {
        value = value || "repeat";
        if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {
            this.error("Unsupported value for 'wrapS': '" + value +
                "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");
            value = "repeat";
        }
        return value;
    };

    Texture.prototype._checkWrapT = function _checkWrapT (value) {
        value = value || "repeat";
        if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {
            this.error("Unsupported value for 'wrapT': '" + value +
                "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");
            value = "repeat";
        }
        return value;
    };

    Texture.prototype._checkFlipY = function _checkFlipY (value) {
        return !!value;
    };

    Texture.prototype._checkEncoding = function _checkEncoding (value) {
        value = value || "linear";
        if (value !== "linear" && value !== "sRGB" && value !== "gamma") {
            this.error("Unsupported value for 'encoding': '" + value + "' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");
            value = "linear";
        }
        return value;
    };

    Texture.prototype._webglContextRestored = function _webglContextRestored () {
        this._state.texture = new Texture2D(this.scene.canvas.gl);
        if (this._image) {
            this.image = this._image;
        } else if (this._src) {
            this.src = this._src;
        }
    };

    Texture.prototype._update = function _update () {
        var state = this._state;
        if (this._matrixDirty) {
            var matrix;
            var t;
            if (this._translate[0] !== 0 || this._translate[1] !== 0) {
                matrix = math.translationMat4v([this._translate[0], this._translate[1], 0], this._state.matrix);
            }
            if (this._scale[0] !== 1 || this._scale[1] !== 1) {
                t = math.scalingMat4v([this._scale[0], this._scale[1], 1]);
                matrix = matrix ? math.mulMat4(matrix, t) : t;
            }
            if (this._rotate !== 0) {
                t = math.rotationMat4v(this._rotate * 0.0174532925, [0, 0, 1]);
                matrix = matrix ? math.mulMat4(matrix, t) : t;
            }
            if (matrix) {
                state.matrix = matrix;
            }
            this._matrixDirty = false;
        }
        this.glRedraw();
    };


    /**
     * Sets an HTML DOM Image object to source this Texture from.
     *
     * Sets {@link Texture#src} null.
     *
     * @type {HTMLImageElement}
     */
    prototypeAccessors.image.set = function (value) {
        this._image = ensureImageSizePowerOfTwo$1(value);
        this._image.crossOrigin = "Anonymous";
        this._state.texture.setImage(this._image, this._state);
        this._state.texture.setProps(this._state); // Generate mipmaps
        this._src = null;
        this.glRedraw();
    };

    /**
     * Gets HTML DOM Image object this Texture is sourced from, if any.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */
    prototypeAccessors.image.get = function () {
        return this._image;
    };

    /**
     * Sets path to an image file to source this Texture from.
     *
     * Sets {@link Texture#image} null.
     *
     * @type {String}
     */
    prototypeAccessors.src.set = function (src) {
        this.scene.loading++;
        this.scene.canvas.spinner.processes++;
        var self = this;
        var image = new Image();
        image.onload = function () {
            image = ensureImageSizePowerOfTwo$1(image);
            //self._image = image; // For faster WebGL context restore - memory inefficient?
            self._state.texture.setImage(image, self._state);
            self._state.texture.setProps(self._state); // Generate mipmaps
            self.scene.loading--;
            self.glRedraw();
            self.scene.canvas.spinner.processes--;
        };
        image.src = src;
        this._src = src;
        this._image = null;
    };

    /**
     * Gets path to the image file this Texture from, if any.
     *
     * Returns null if not set.
     *
     * @type {String}
     */
    prototypeAccessors.src.get = function () {
        return this._src;
    };

    /**
     * Sets the 2D translation vector added to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[0, 0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.translate.set = function (value) {
        this._translate.set(value || [0, 0]);
        this._matrixDirty = true;
        this._needUpdate();
    };

    /**
     * Gets the 2D translation vector added to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[0, 0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.translate.get = function () {
        return this._translate;
    };

    /**
     * Sets the 2D scaling vector that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[1, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.set = function (value) {
        this._scale.set(value || [1, 1]);
        this._matrixDirty = true;
        this._needUpdate();
    };

    /**
     * Gets the 2D scaling vector that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````[1, 1]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.scale.get = function () {
        return this._scale;
    };

    /**
     * Sets the rotation angles, in degrees, that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.rotate.set = function (value) {
        value = value || 0;
        if (this._rotate === value) {
            return;
        }
        this._rotate = value;
        this._matrixDirty = true;
        this._needUpdate();
    };

    /**
     * Gets the rotation angles, in degrees, that will be applied to this Texture's *S* and *T* UV coordinates.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.rotate.get = function () {
        return this._rotate;
    };

    /**
     * Gets how this Texture is sampled when a texel covers less than one pixel.
     *
     * Options are:
     *
     * * "nearest" - Uses the value of the texture element that is nearest
     * (in Manhattan distance) to the center of the pixel being textured.
     *
     * * "linear" - Uses the weighted average of the four texture elements that are
     * closest to the center of the pixel being textured.
     *
     * * "nearestMipmapNearest" - Chooses the mipmap that most closely matches the
     * size of the pixel being textured and uses the "nearest" criterion (the texture
     * element nearest to the center of the pixel) to produce a texture value.
     *
     * * "linearMipmapNearest" - Chooses the mipmap that most closely matches the size of
     * the pixel being textured and uses the "linear" criterion (a weighted average of the
     * four texture elements that are closest to the center of the pixel) to produce a
     * texture value.
     *
     * * "nearestMipmapLinear" - Chooses the two mipmaps that most closely
     * match the size of the pixel being textured and uses the "nearest" criterion
     * (the texture element nearest to the center of the pixel) to produce a texture
     * value from each mipmap. The final texture value is a weighted average of those two
     * values.
     *
     * * "linearMipmapLinear" - (default) - Chooses the two mipmaps that most closely match the size
     * of the pixel being textured and uses the "linear" criterion (a weighted average
     * of the four texture elements that are closest to the center of the pixel) to
     * produce a texture value from each mipmap. The final texture value is a weighted
     * average of those two values.
     *
     * Default value is "linearMipmapLinear".
     *
     *  @type {String}
     */
    prototypeAccessors.minFilter.get = function () {
        return this._state.minFilter;
    };

    /**
     * Gets how this Texture is sampled when a texel covers more than one pixel.
     *
     * * "nearest" - Uses the value of the texture element that is nearest
     * (in Manhattan distance) to the center of the pixel being textured.
     * * "linear" - (default) - Uses the weighted average of the four texture elements that are
     * closest to the center of the pixel being textured.
     *
     * Default value is "linearMipmapLinear".
     *
     * @type {String}
     */
    prototypeAccessors.magFilter.get = function () {
        return this._state.magFilter;
    };

    /**
     * Gets the wrap parameter for this Texture's *S* coordinate.
     *
     * Values can be:
     *
     * * "clampToEdge" -  causes *S* coordinates to be clamped to the size of the texture.
     * * "mirroredRepeat" - causes the *S* coordinate to be set to the fractional part of the texture coordinate
     * if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
     * set to *1 - frac  S* , where *frac  S* represents the fractional part of *S*.
     * * "repeat" - (default) - causes the integer part of the *S* coordinate to be ignored; xeokit uses only the
     * fractional part, thereby creating a repeating pattern.
     *
     * Default value is "repeat".
     *
     * @type {String}
     */
    prototypeAccessors.wrapS.get = function () {
        return this._state.wrapS;
    };

    /**
     * Gets the wrap parameter for this Texture's *T* coordinate.
     *
     * Values can be:
     *
     * * "clampToEdge" -  causes *S* coordinates to be clamped to the size of the texture.
     *  * "mirroredRepeat" - causes the *S* coordinate to be set to the fractional part of the texture coordinate
     * if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
     * set to *1 - frac  S* , where *frac  S* represents the fractional part of *S*.
     * * "repeat" - (default) - causes the integer part of the *S* coordinate to be ignored; xeokit uses only the
     * fractional part, thereby creating a repeating pattern.
     *
     * Default value is "repeat".
     *
     * @type {String}
     */
    prototypeAccessors.wrapT.get = function () {
        return this._state.wrapT;
    };

    /**
     * Gets if this Texture's source data is flipped along its vertical axis.
     *
     * @type {Boolean}
     */
    prototypeAccessors.flipY.get = function () {
        return this._state.flipY;
    };

    /**
     * Gets the Texture's encoding format.
     *
     * @type {String}
     */
    prototypeAccessors.encoding.get = function () {
        return this._state.encoding;
    };

    /**
     * Destroys this Texture
     */
    Texture.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        if (this._state.texture) {
            this._state.texture.destroy();
        }
        this._state.destroy();
        stats.memory.textures--;
    };

    Object.defineProperties( Texture.prototype, prototypeAccessors );

    return Texture;
}(Component));

/**
 * @private
 */
var GLTFSceneGraphLoader = function GLTFSceneGraphLoader(cfg) { // TODO: Loading options fallbacks on loader, eg. handleGLTFNode etc
};

GLTFSceneGraphLoader.prototype.load = function load (plugin, modelNode, src, options, ok, error) {
    options = options || {};
    var spinner = modelNode.scene.canvas.spinner;
    spinner.processes++;
    loadGLTF$1(plugin, modelNode, src, options, function () {
            spinner.processes--;
            core.scheduleTask(function () {
                modelNode.scene.fire("modelLoaded", modelNode.id); // FIXME: Assumes listeners know order of these two events
                modelNode.fire("loaded", true, false);
            });
            if (ok) {
                ok();
            }
        },
        function (msg) {
            spinner.processes--;
            modelNode.error(msg);
            if (error) {
                error(msg);
            }
            modelNode.fire("error", msg);
        });
};

GLTFSceneGraphLoader.prototype.parse = function parse (plugin, modelNode, gltf, options, ok, error) {
    options = options || {};
    var spinner = modelNode.scene.canvas.spinner;
    spinner.processes++;
    parseGLTF$1(plugin, gltf, "", options, modelNode, function () {
            spinner.processes--;
            modelNode.scene.fire("modelLoaded", modelNode.id); // FIXME: Assumes listeners know order of these two events
            modelNode.fire("loaded", true, false);
            if (ok) {
                ok();
            }
        },
        function (msg) {
            spinner.processes--;
            modelNode.error(msg);
            modelNode.fire("error", msg);
            if (error) {
                error(msg);
            }
        });
};


var loadGLTF$1 = (function () {
    return function (plugin, modelNode, src, options, ok, error) {
        plugin.dataSource.getGLTF(src, function (json) { // OK
                options.basePath = getBasePath(src);
                parseGLTF$1(plugin, json, src, options, modelNode, ok, error);
            },
            error);
    };

    function getBasePath(src) {
        var i = src.lastIndexOf("/");
        return (i !== 0) ? src.substring(0, i + 1) : "";
    }
})();

var parseGLTF$1 = (function () {

    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };

    var WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };

    return function (plugin, json, src, options, modelNode, ok) {
        modelNode.clear();
        var ctx = {
            src: src,
            loadBuffer: options.loadBuffer,
            basePath: options.basePath,
            prioritizeGLTFNode: options.prioritizeGLTFNode,
            handleGLTFNode: options.handleGLTFNode,
            ignoreMaterials: !!options.ignoreMaterials,
            edgeThreshold: options.edgeThreshold,
            readableGeometry: !!options.readableGeometry,
            json: json,
            scene: modelNode.scene,
            plugin: plugin,
            modelNode: modelNode,
            modelNodeProps: {
                visible: modelNode.visible,
                culled: modelNode.culled,
                xrayed: modelNode.xrayed,
                highlighted: modelNode.highlighted,
                selected: modelNode.selected,
                outlined: modelNode.outlined,
                clippable: modelNode.clippable,
                pickable: modelNode.pickable,
                collidable: modelNode.collidable,
                castsShadow: modelNode.castsShadow,
                receivesShadow: modelNode.receivesShadow,
                colorize: modelNode.colorize,
                opacity: modelNode.opacity,
                edges: modelNode.edges
            }
        };

        modelNode.scene.loading++; // Disables (re)compilation

        loadBuffers(ctx, function () {

            loadBufferViews(ctx);
            loadAccessors(ctx);
            loadTextures(ctx);
            loadMaterials(ctx);
            loadMeshes(ctx);
            loadDefaultScene(ctx);

            modelNode.scene.loading--; // Re-enables (re)compilation

            ok();
        });
    };

    function loadBuffers(ctx, ok) {
        var buffers = ctx.json.buffers;
        if (buffers) {
            var numToLoad = buffers.length;
            for (var i = 0, len = buffers.length; i < len; i++) {
                loadBuffer(ctx, buffers[i], function () {
                    if (--numToLoad === 0) {
                        ok();
                    }
                }, function (msg) {
                    ctx.plugin.error(msg);
                    if (--numToLoad === 0) {
                        ok();
                    }
                });
            }
        } else {
            ok();
        }
    }

    function loadBuffer(ctx, bufferInfo, ok, err) {
        var uri = bufferInfo.uri;
        if (uri) {
            ctx.plugin.dataSource.getArrayBuffer(ctx.src, uri, function (data) {
                    bufferInfo._buffer = data;
                    ok();
                },
                err);
        } else {
            err('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));
        }
    }

    function loadBufferViews(ctx) {
        var bufferViewsInfo = ctx.json.bufferViews;
        if (bufferViewsInfo) {
            for (var i = 0, len = bufferViewsInfo.length; i < len; i++) {
                loadBufferView(ctx, bufferViewsInfo[i]);
            }
        }
    }

    function loadBufferView(ctx, bufferViewInfo) {

        var buffer = ctx.json.buffers[bufferViewInfo.buffer];

        bufferViewInfo._typedArray = null;

        var byteLength = bufferViewInfo.byteLength || 0;
        var byteOffset = bufferViewInfo.byteOffset || 0;

        bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);
    }

    function loadAccessors(ctx) {
        var accessorsInfo = ctx.json.accessors;
        if (accessorsInfo) {
            for (var i = 0, len = accessorsInfo.length; i < len; i++) {
                loadAccessor(ctx, accessorsInfo[i]);
            }
        }
    }

    function loadAccessor(ctx, accessorInfo) {
        var bufferViewInfo = ctx.json.bufferViews[accessorInfo.bufferView];
        var itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];

        // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;

        // The buffer is not interleaved if the stride is the item size in bytes.
        if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) ; else {
            accessorInfo._typedArray = new TypedArray(bufferViewInfo._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);
            accessorInfo._itemSize = itemSize;
        }
    }


    function loadTextures(ctx) {
        var texturesInfo = ctx.json.textures;
        if (texturesInfo) {
            for (var i = 0, len = texturesInfo.length; i < len; i++) {
                loadTexture(ctx, texturesInfo[i]);
            }
        }
    }

    function loadTexture(ctx, textureInfo) {
        textureInfo._texture = new Texture(ctx.modelNode, {
            src: ctx.json.images[textureInfo.source].uri ? ctx.basePath + ctx.json.images[textureInfo.source].uri : undefined,
            flipY: !!textureInfo.flipY,
            encoding: "sRGB"
        });
    }

    function loadMaterials(ctx) {
        var materialsInfo = ctx.json.materials;
        if (materialsInfo) {
            var materialInfo;
            var material;
            for (var i = 0, len = materialsInfo.length; i < len; i++) {
                materialInfo = materialsInfo[i];
                material = loadMaterial(ctx, materialInfo);
                materialInfo._material = material;
            }
        }
    }

    function loadMaterial(ctx, materialInfo) {

        var json = ctx.json;
        var cfg = {};
        var textureInfo;

        // Common attributes

        var normalTexture = materialInfo.normalTexture;
        if (normalTexture) {
            textureInfo = json.textures[normalTexture.index];
            if (textureInfo) {
                cfg.normalMap = textureInfo._texture;
                //cfg.normalMap.encoding = "linear";
            }
        }

        var occlusionTexture = materialInfo.occlusionTexture;
        if (occlusionTexture) {
            textureInfo = json.textures[occlusionTexture.index];
            if (textureInfo) {
                cfg.occlusionMap = textureInfo._texture;
            }
        }

        var emissiveTexture = materialInfo.emissiveTexture;
        if (emissiveTexture) {
            textureInfo = json.textures[emissiveTexture.index];
            if (textureInfo) {
                cfg.emissiveMap = textureInfo._texture;
                //cfg.emissiveMap.encoding = "sRGB";
            }
        }

        var emissiveFactor = materialInfo.emissiveFactor;
        if (emissiveFactor) {
            cfg.emissive = emissiveFactor;
        }

        cfg.backfaces = !!materialInfo.doubleSided;

        var alphaMode = materialInfo.alphaMode;
        switch (alphaMode) {
            case "NORMAL_OPAQUE":
                cfg.alphaMode = "opaque";
                break;
            case "MASK":
                cfg.alphaMode = "mask";
                break;
            case "BLEND":
                cfg.alphaMode = "blend";
                break;
        }

        var alphaCutoff = materialInfo.alphaCutoff;
        if (alphaCutoff !== undefined) {
            cfg.alphaCutoff = alphaCutoff;
        }

        var extensions = materialInfo.extensions;
        if (extensions) {

            // Specular PBR material

            var specularPBR = extensions["KHR_materials_pbrSpecularGlossiness"];
            if (specularPBR) {

                var diffuseFactor = specularPBR.diffuseFactor;
                if (diffuseFactor !== null && diffuseFactor !== undefined) {
                    cfg.diffuse = diffuseFactor.slice(0, 3);
                    cfg.alpha = diffuseFactor[3];
                }

                var diffuseTexture = specularPBR.diffuseTexture;
                if (diffuseTexture) {
                    textureInfo = json.textures[diffuseTexture.index];
                    if (textureInfo) {
                        cfg.diffuseMap = textureInfo._texture;
                        //cfg.diffuseMap.encoding = "sRGB";
                    }
                }

                var specularFactor = specularPBR.specularFactor;
                if (specularFactor !== null && specularFactor !== undefined) {
                    cfg.specular = specularFactor.slice(0, 3);
                }

                var glossinessFactor = specularPBR.glossinessFactor;
                if (glossinessFactor !== null && glossinessFactor !== undefined) {
                    cfg.glossiness = glossinessFactor;
                }

                var specularGlossinessTexture = specularPBR.specularGlossinessTexture;
                if (specularGlossinessTexture) {
                    textureInfo = json.textures[specularGlossinessTexture.index];
                    if (textureInfo) {
                        cfg.specularGlossinessMap = textureInfo._texture;
                        //cfg.specularGlossinessMap.encoding = "linear";
                    }
                }

                return new SpecularMaterial(ctx.modelNode, cfg);
            }

            // Common Phong, Blinn, Lambert or Constant materials

            var common = extensions["KHR_materials_common"];
            if (common) {

                var technique = common.technique;
                var values = common.values || {};

                var blinn = technique === "BLINN";
                var phong = technique === "PHONG";
                var lambert = technique === "LAMBERT";

                var shininess = values.shininess;
                if ((blinn || phong) && shininess !== null && shininess !== undefined) {
                    cfg.shininess = shininess;
                } else {
                    cfg.shininess = 0;
                }
                var texture;
                var diffuse = values.diffuse;
                if (diffuse && (blinn || phong || lambert)) {
                    if (utils.isString(diffuse)) {
                        texture = ctx.textures[diffuse];
                        if (texture) {
                            cfg.diffuseMap = texture;
                            //  cfg.diffuseMap.encoding = "sRGB";
                        }
                    } else {
                        cfg.diffuse = diffuse.slice(0, 3);
                    }
                } else {
                    cfg.diffuse = [0, 0, 0];
                }

                var specular = values.specular;
                if (specular && (blinn || phong)) {
                    if (utils.isString(specular)) {
                        texture = ctx.textures[specular];
                        if (texture) {
                            cfg.specularMap = texture;
                        }
                    } else {
                        cfg.specular = specular.slice(0, 3);
                    }
                } else {
                    cfg.specular = [0, 0, 0];
                }

                var emission = values.emission;
                if (emission) {
                    if (utils.isString(emission)) {
                        texture = ctx.textures[emission];
                        if (texture) {
                            cfg.emissiveMap = texture;
                        }
                    } else {
                        cfg.emissive = emission.slice(0, 3);
                    }
                } else {
                    cfg.emissive = [0, 0, 0];
                }

                var transparency = values.transparency;
                if (transparency !== null && transparency !== undefined) {
                    cfg.alpha = transparency;
                } else {
                    cfg.alpha = 1.0;
                }

                values.transparent;

                return new PhongMaterial(ctx.scene, cfg);
            }
        }

        // Metallic PBR naterial

        var metallicPBR = materialInfo.pbrMetallicRoughness;
        if (metallicPBR) {

            var baseColorFactor = metallicPBR.baseColorFactor;
            if (baseColorFactor) {
                cfg.baseColor = baseColorFactor.slice(0, 3);
                cfg.alpha = baseColorFactor[3];
            }

            var baseColorTexture = metallicPBR.baseColorTexture;
            if (baseColorTexture) {
                textureInfo = json.textures[baseColorTexture.index];
                if (textureInfo) {
                    cfg.baseColorMap = textureInfo._texture;
                    //cfg.baseColorMap.encoding = "sRGB";
                }
            }

            var metallicFactor = metallicPBR.metallicFactor;
            if (metallicFactor !== null && metallicFactor !== undefined) {
                cfg.metallic = metallicFactor;
            }

            var roughnessFactor = metallicPBR.roughnessFactor;
            if (roughnessFactor !== null && roughnessFactor !== undefined) {
                cfg.roughness = roughnessFactor;
            }

            var metallicRoughnessTexture = metallicPBR.metallicRoughnessTexture;
            if (metallicRoughnessTexture) {
                textureInfo = json.textures[metallicRoughnessTexture.index];
                if (textureInfo) {
                    cfg.metallicRoughnessMap = textureInfo._texture;
                    // cfg.metallicRoughnessMap.encoding = "linear";
                }
            }

            return new MetallicMaterial(ctx.scene, cfg);
        }

        // Default material

        return new PhongMaterial(ctx.scene, cfg);
    }

    function loadMeshes(ctx) {
        var meshes = ctx.json.meshes;
        if (meshes) {
            for (var i = 0, len = meshes.length; i < len; i++) {
                loadMesh(ctx, meshes[i]);
            }
        }
    }

    function loadMesh(ctx, meshInfo) {
        var json = ctx.json;
        var mesh = [];
        var primitivesInfo = meshInfo.primitives;
        var materialIndex;
        var materialInfo;
        var accessorInfo;
        var attributes;

        if (primitivesInfo) {

            var primitiveInfo;
            var indicesIndex;
            var positionsIndex;
            var normalsIndex;
            var uv0Index;
            var geometryCfg;
            var meshCfg;
            var geometry;

            for (var i = 0, len = primitivesInfo.length; i < len; i++) {

                geometryCfg = {
                    primitive: "triangles",
                    compressGeometry: true,
                    edgeThreshold: ctx.edgeThreshold
                };

                primitiveInfo = primitivesInfo[i];
                indicesIndex = primitiveInfo.indices;

                if (indicesIndex !== null && indicesIndex !== undefined) {
                    accessorInfo = json.accessors[indicesIndex];
                    geometryCfg.indices = accessorInfo._typedArray;
                }

                attributes = primitiveInfo.attributes;
                if (!attributes) {
                    continue;
                }

                positionsIndex = attributes.POSITION;

                if (positionsIndex !== null && positionsIndex !== undefined) {
                    accessorInfo = json.accessors[positionsIndex];
                    geometryCfg.positions = accessorInfo._typedArray;
                }

                normalsIndex = attributes.NORMAL;

                if (normalsIndex !== null && normalsIndex !== undefined) {
                    accessorInfo = json.accessors[normalsIndex];
                    geometryCfg.normals = accessorInfo._typedArray;
                }

                uv0Index = attributes.TEXCOORD_0;

                if (uv0Index !== null && uv0Index !== undefined) {
                    accessorInfo = json.accessors[uv0Index];
                    geometryCfg.uv = accessorInfo._typedArray;
                }

                meshCfg = {};

                if (ctx.readableGeometry) {
                    geometry = new ReadableGeometry(ctx.modelNode, geometryCfg);
                } else {
                    geometry = new VBOGeometry(ctx.modelNode, geometryCfg);
                }

                meshCfg.geometry = geometry;

                materialIndex = primitiveInfo.material;
                if (materialIndex !== null && materialIndex !== undefined) {
                    materialInfo = json.materials[materialIndex];
                    if (materialInfo) {
                        meshCfg.material = materialInfo._material;
                    }
                }

                mesh.push(meshCfg);
            }
        }
        meshInfo._mesh = mesh;
    }

    function loadDefaultScene(ctx) {
        var json = ctx.json;
        var scene = json.scene || 0;
        var defaultSceneInfo = json.scenes[scene];
        if (!defaultSceneInfo) {
            error(ctx, "glTF has no default scene");
            return;
        }
        loadScene(ctx, defaultSceneInfo);
    }

    function loadScene(ctx, sceneInfo) {
        var nodes = sceneInfo.nodes;
        if (!nodes) {
            return;
        }
        var json = ctx.json;
        var glTFNode;
        for (var i = 0, len = nodes.length; i < len; i++) {
            glTFNode = json.nodes[nodes[i]];
            if (!glTFNode) {
                error(ctx, "Node not found: " + i);
                continue;
            }
            loadNode(ctx, glTFNode, null, null);
        }
    }

    function loadNode(ctx, glTFNode, matrix, parent) {

        parent = parent || ctx.modelNode;

        var createEntity;

        if (ctx.prioritizeGLTFNode) {
            var priority = ctx.prioritizeGLTFNode(ctx.modelNode.id, glTFNode);
            if (priority === undefined || priority === null) {
                return;
            }
        }

        if (ctx.handleGLTFNode) {
            var actions = {};
            if (!ctx.handleGLTFNode(ctx.modelNode.id, glTFNode, actions)) {
                return;
            }
            if (actions.createEntity) {
                createEntity = actions.createEntity;
            }
        }

        var json = ctx.json;
        var modelNode = ctx.modelNode;
        var hasChildNodes = glTFNode.children && glTFNode.children.length > 0;

        var localMatrix;

        if (glTFNode.matrix) {
            localMatrix = glTFNode.matrix;
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, math.mat4());
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.translation) {
            localMatrix = math.translationMat4v(glTFNode.translation);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, localMatrix);
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.rotation) {
            localMatrix = math.quaternionToMat4(glTFNode.rotation);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, localMatrix);
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.scale) {
            localMatrix = math.scalingMat4v(glTFNode.scale);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, localMatrix);
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.mesh !== undefined) {

            var meshInfo = json.meshes[glTFNode.mesh];

            if (meshInfo) {

                var meshesInfo = meshInfo._mesh;
                var meshesInfoMesh;
                var mesh;
                var numMeshes = meshesInfo.length;

                if (!createEntity && numMeshes > 0 && !hasChildNodes) {

                    // Case 1: Not creating object, node has meshes, node has no child nodes

                    for (var i = 0, len = numMeshes; i < len; i++) {
                        meshesInfoMesh = meshesInfo[i];
                        var meshCfg = {
                            geometry: meshesInfoMesh.geometry,
                            matrix: matrix
                        };
                        utils.apply(ctx.modelNodeProps, meshCfg);
                        meshCfg.material = meshesInfoMesh.material;
                        mesh = new Mesh(modelNode, meshCfg);
                        parent.addChild(mesh, false); // Don't automatically inherit properties
                    }
                    return;
                }

                if (createEntity && numMeshes === 1 && !hasChildNodes) {

                    // Case 2: Creating object, node has one mesh, node has no child nodes

                    meshesInfoMesh = meshesInfo[0];
                    var meshCfg$1 = {
                        geometry: meshesInfoMesh.geometry,
                        matrix: matrix
                    };
                    utils.apply(ctx.modelNodeProps, meshCfg$1);
                    meshCfg$1.material = meshesInfoMesh.material;
                    utils.apply(createEntity, meshCfg$1);
                    mesh = new Mesh(modelNode, meshCfg$1);
                    parent.addChild(mesh, false); // Don't automatically inherit properties
                    return;
                }

                if (createEntity && numMeshes > 0 && !hasChildNodes) {

                    // Case 3: Creating object, node has meshes, node has no child nodes

                    var nodeCfg = {
                        matrix: matrix
                    };
                    utils.apply(ctx.modelNodeProps, nodeCfg);
                    utils.apply(createEntity, nodeCfg);
                    var childNode = new Node(modelNode, nodeCfg);
                    parent.addChild(childNode, false);
                    for (var i$1 = 0, len$1 = numMeshes; i$1 < len$1; i$1++) {
                        meshesInfoMesh = meshesInfo[i$1];
                        var meshCfg$2 = {
                            geometry: meshesInfoMesh.geometry
                        };
                        utils.apply(ctx.modelNodeProps, meshCfg$2);
                        meshCfg$2.material = meshesInfoMesh.material;
                        utils.apply(createEntity, meshCfg$2);
                        meshCfg$2.id = null; // Avoid ID clash with parent Node
                        mesh = new Mesh(modelNode, meshCfg$2);
                        childNode.addChild(mesh, false);
                    }
                    return;
                }

                if (!createEntity && numMeshes > 0 && hasChildNodes) {

                    // Case 4: Not creating object, node has meshes, node has child nodes

                    var nodeCfg$1 = {
                        matrix: matrix
                    };
                    utils.apply(ctx.modelNodeProps, nodeCfg$1);
                    var childNode$1 = new Node(modelNode, nodeCfg$1);
                    parent.addChild(childNode$1, false);
                    for (var i$2 = 0, len$2 = numMeshes; i$2 < len$2; i$2++) {
                        meshesInfoMesh = meshesInfo[i$2];
                        var meshCfg$3 = {
                            geometry: meshesInfoMesh.geometry
                        };
                        utils.apply(nodeCfg$1, meshCfg$3);
                        meshCfg$3.id = null; // Avoid ID clash with parent Node
                        meshCfg$3.matrix = null; // Node has matrix
                        meshCfg$3.material = meshesInfoMesh.material;
                        mesh = new Mesh(modelNode, meshCfg$3);
                        childNode$1.addChild(mesh, false);
                    }
                    matrix = null;
                    parent = childNode$1;
                }

                if (createEntity && numMeshes === 0 && hasChildNodes) {

                    // Case 5: Creating explicit object, node has meshes OR node has child nodes

                    var nodeCfg$2 = {
                        matrix: matrix
                    };
                    utils.apply(ctx.modelNodeProps, nodeCfg$2);
                    utils.apply(createEntity, nodeCfg$2);
                    createEntity.matrix = matrix;
                    var childNode$2 = new Node(modelNode, nodeCfg$2);
                    parent.addChild(childNode$2, false); // Don't automatically inherit properties
                    matrix = null;
                    parent = childNode$2;
                }

                if (createEntity && numMeshes > 0 || hasChildNodes) {

                    // Case 6: Creating explicit object, node has meshes OR node has child nodes

                    var nodeCfg$3 = {
                        matrix: matrix
                    };
                    utils.apply(ctx.modelNodeProps, nodeCfg$3);
                    if (createEntity) {
                        utils.apply(createEntity, nodeCfg$3);
                    }
                    var childNode$3 = new Node(modelNode, nodeCfg$3);
                    parent.addChild(childNode$3, false); // Don't automatically inherit properties
                    for (var i$3 = 0, len$3 = numMeshes; i$3 < len$3; i$3++) {
                        meshesInfoMesh = meshesInfo[i$3];
                        var meshCfg$4 = {
                            geometry: meshesInfoMesh.geometry
                        };
                        utils.apply(ctx.modelProps, meshCfg$4);
                        meshCfg$4.material = meshesInfoMesh.material;
                        if (createEntity) {
                            utils.apply(createEntity, meshCfg$4);
                        }
                        meshCfg$4.id = null; // Avoid ID clash with parent Node
                        mesh = new Mesh(modelNode, meshCfg$4);
                        childNode$3.addChild(mesh, false); // Don't automatically inherit properties
                    }
                    matrix = null;
                    parent = childNode$3;
                }
            }
        }

        if (glTFNode.children) {
            var children = glTFNode.children;
            var childNodeInfo;
            var childNodeIdx;
            for (var i$4 = 0, len$4 = children.length; i$4 < len$4; i$4++) {
                childNodeIdx = children[i$4];
                childNodeInfo = json.nodes[childNodeIdx];
                if (!childNodeInfo) {
                    error(ctx, "Node not found: " + i$4);
                    continue;
                }
                loadNode(ctx, childNodeInfo, matrix, parent);
            }
        }
    }

    function error(ctx, msg) {
        ctx.plugin.error(msg);
    }
})();

/**
 * @private
 */
var GLTFPerformanceModelLoader = function GLTFPerformanceModelLoader(cfg) { // TODO: Loading options fallbacks on loader, eg. handleGLTFNode etc
};

GLTFPerformanceModelLoader.prototype.load = function load (plugin, performanceModel, src, options, ok, error) {
    options = options || {};
    loadGLTF(plugin, performanceModel, src, options, function () {
            core.scheduleTask(function () {
                performanceModel.scene.fire("modelLoaded", performanceModel.id); // FIXME: Assumes listeners know order of these two events
                performanceModel.fire("loaded", true, false);
            });
            if (ok) {
                ok();
            }
        },
        function (msg) {
            plugin.error(msg);
            if (error) {
                error(msg);
            }
            performanceModel.fire("error", msg);
        });
};

GLTFPerformanceModelLoader.prototype.parse = function parse (plugin, performanceModel, gltf, options, ok, error) {
    options = options || {};
    parseGLTF(plugin, gltf, "", options, performanceModel, function () {
            performanceModel.scene.fire("modelLoaded", performanceModel.id); // FIXME: Assumes listeners know order of these two events
            performanceModel.fire("loaded", true, false);
            if (ok) {
                ok();
            }
        },
        function (msg) {
            performanceModel.error(msg);
            performanceModel.fire("error", msg);
            if (error) {
                error(msg);
            }
        });
};

var INSTANCE_THRESHOLD = 1;

var loadGLTF = (function () {

    return function (plugin, performanceModel, src, options, ok, error) {
        var spinner = plugin.viewer.scene.canvas.spinner;
        spinner.processes++;
        plugin.dataSource.getGLTF(src, function (json) { // OK
                spinner.processes--;
                parseGLTF(plugin, json, src, options, performanceModel, ok, error);
            },
            error);
    };
})();

var parseGLTF = (function () {

    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };

    var WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };

    return function (plugin, json, src, options, performanceModel, ok) {
        var ctx = {
            src: src,
            loadBuffer: options.loadBuffer,
            handleGLTFNode: options.handleGLTFNode,
            json: json,
            scene: performanceModel.scene,
            plugin: plugin,
            performanceModel: performanceModel,
            geometryCreated: {},
            numObjects: 0,
            nodes: []
        };
        var spinner = plugin.viewer.scene.canvas.spinner;
        spinner.processes++;
        loadBuffers(ctx, function () {
            loadBufferViews(ctx);
            freeBuffers(ctx); // Don't need buffers once we've created views of them
            loadMaterials(ctx);
            spinner.processes--;
            loadDefaultScene(ctx);
            performanceModel.finalize();
            ok();
        });
    };

    function loadBuffers(ctx, ok) {
        var buffers = ctx.json.buffers;
        if (buffers) {
            var numToLoad = buffers.length;
            for (var i = 0, len = buffers.length; i < len; i++) {
                loadBuffer(ctx, buffers[i], function () {
                    if (--numToLoad === 0) {
                        ok();
                    }
                }, function (msg) {
                    ctx.plugin.error(msg);
                    if (--numToLoad === 0) {
                        ok();
                    }
                });
            }
        } else {
            ok();
        }
    }

    function loadBuffer(ctx, bufferInfo, ok, err) {
        var uri = bufferInfo.uri;
        if (uri) {
            ctx.plugin.dataSource.getArrayBuffer(ctx.src, uri, function (data) {
                    bufferInfo._buffer = data;
                    ok();
                },
                err);
        } else {
            err('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));
        }
    }

    function loadBufferViews(ctx) {
        var bufferViewsInfo = ctx.json.bufferViews;
        if (bufferViewsInfo) {
            for (var i = 0, len = bufferViewsInfo.length; i < len; i++) {
                loadBufferView(ctx, bufferViewsInfo[i]);
            }
        }
    }

    function loadBufferView(ctx, bufferViewInfo) {
        var buffer = ctx.json.buffers[bufferViewInfo.buffer];
        bufferViewInfo._typedArray = null;
        var byteLength = bufferViewInfo.byteLength || 0;
        var byteOffset = bufferViewInfo.byteOffset || 0;
        bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);
    }

    function freeBuffers(ctx) {
        var buffers = ctx.json.buffers;
        if (buffers) {
            for (var i = 0, len = buffers.length; i < len; i++) {
                buffers[i]._buffer = null;
            }
        }
    }

    function loadMaterials(ctx) {
        var materialsInfo = ctx.json.materials;
        if (materialsInfo) {
            for (var i = 0, len = materialsInfo.length; i < len; i++) {
                var materialInfo = materialsInfo[i];
                var material = loadMaterialColorize(ctx, materialInfo);
                materialInfo._rgbaColor = material;
            }
        }
    }

    function loadMaterialColorize(ctx, materialInfo) { // Substitute RGBA for material, to use fast flat shading instead
        var colorize = new Float32Array([1, 1, 1, 1]);
        var extensions = materialInfo.extensions;
        if (extensions) {
            var specularPBR = extensions["KHR_materials_pbrSpecularGlossiness"];
            if (specularPBR) {
                var diffuseFactor = specularPBR.diffuseFactor;
                if (diffuseFactor !== null && diffuseFactor !== undefined) {
                    colorize.set(diffuseFactor);
                }
            }
            var common = extensions["KHR_materials_common"];
            if (common) {
                var technique = common.technique;
                var values = common.values || {};
                var blinn = technique === "BLINN";
                var phong = technique === "PHONG";
                var lambert = technique === "LAMBERT";
                var diffuse = values.diffuse;
                if (diffuse && (blinn || phong || lambert)) {
                    if (!utils.isString(diffuse)) {
                        colorize.set(diffuse);
                    }
                }
                var transparency = values.transparency;
                if (transparency !== null && transparency !== undefined) {
                    colorize[3] = transparency;
                }
                var transparent = values.transparent;
                if (transparent !== null && transparent !== undefined) {
                    colorize[3] = transparent;
                }
            }
        }
        var metallicPBR = materialInfo.pbrMetallicRoughness;
        if (metallicPBR) {
            var baseColorFactor = metallicPBR.baseColorFactor;
            if (baseColorFactor) {
                colorize.set(baseColorFactor);
            }
        }
        return colorize;
    }

    function loadDefaultScene(ctx) {
        var json = ctx.json;
        var scene = json.scene || 0;
        var defaultSceneInfo = json.scenes[scene];
        if (!defaultSceneInfo) {
            error(ctx, "glTF has no default scene");
            return;
        }
        preprocessScene(ctx, defaultSceneInfo);
        loadScene(ctx, defaultSceneInfo);
    }

    function preprocessScene(ctx, sceneInfo) {
        var nodes = sceneInfo.nodes;
        if (!nodes) {
            return;
        }
        var json = ctx.json;
        for (var i = 0, len = nodes.length; i < len; i++) {
            var glTFNode = json.nodes[nodes[i]];
            if (!glTFNode) {
                error(ctx, "Node not found: " + i);
                continue;
            }
            countMeshUsage(ctx, i);
        }
    }

    function loadScene(ctx, sceneInfo) {
        var nodes = sceneInfo.nodes;
        if (!nodes) {
            return;
        }
        var json = ctx.json;
        for (var i = 0, len = nodes.length; i < len; i++) {
            var glTFNode = json.nodes[nodes[i]];
            if (!glTFNode) {
                error(ctx, "Node not found: " + i);
                continue;
            }
            countMeshUsage(ctx, glTFNode);
        }
        ctx.plugin.viewer.scene.canvas.spinner.processes++;
        for (var i$1 = 0, len$1 = nodes.length; i$1 < len$1; i$1++) {
            var glTFNode$1 = json.nodes[nodes[i$1]];
            loadNode(ctx, glTFNode$1, null);
        }
        ctx.plugin.viewer.scene.canvas.spinner.processes--;
    }

    function countMeshUsage(ctx, glTFNode) {
        var json = ctx.json;
        var mesh = glTFNode.mesh;
        if (mesh !== undefined) {
            var meshInfo = json.meshes[glTFNode.mesh];
            if (meshInfo) {
                meshInfo.instances = meshInfo.instances ? meshInfo.instances + 1 : 1;
            }
        }
        if (glTFNode.children) {
            var children = glTFNode.children;
            for (var i = 0, len = children.length; i < len; i++) {
                var childNodeIdx = children[i];
                var childNodeInfo = json.nodes[childNodeIdx];
                if (!childNodeInfo) {
                    error(ctx, "Node not found: " + i);
                    continue;
                }
                countMeshUsage(ctx, childNodeInfo);
            }
        }
    }

    function loadNode(ctx, glTFNode, matrix) {

        var json = ctx.json;
        var localMatrix;

        if (glTFNode.matrix) {
            localMatrix = glTFNode.matrix;
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, math.mat4());
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.translation) {
            localMatrix = math.translationMat4v(glTFNode.translation);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, math.mat4());
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.rotation) {
            localMatrix = math.quaternionToMat4(glTFNode.rotation);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, math.mat4());
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.scale) {
            localMatrix = math.scalingMat4v(glTFNode.scale);
            if (matrix) {
                matrix = math.mulMat4(matrix, localMatrix, math.mat4());
            } else {
                matrix = localMatrix;
            }
        }

        if (glTFNode.mesh !== undefined) {

            var meshInfo = json.meshes[glTFNode.mesh];

            if (meshInfo) {

                var createEntity;

                if (ctx.handleGLTFNode) {
                    var actions = {};
                    if (!ctx.handleGLTFNode(ctx.performanceModel.id, glTFNode, actions)) {
                        return;
                    }
                    if (actions.createEntity) {
                        createEntity = actions.createEntity;
                    }
                }

                var performanceModel = ctx.performanceModel;
                var worldMatrix = matrix ? matrix.slice() : math.identityMat4();
                var numPrimitives = meshInfo.primitives.length;

                if (numPrimitives > 0) {

                    var meshIds = [];

                    for (var i = 0; i < numPrimitives; i++) {
                        var meshCfg = {
                            id: performanceModel.id + "." + ctx.numObjects++,
                            matrix: worldMatrix
                        };
                        var primitiveInfo = meshInfo.primitives[i];

                        var materialIndex = primitiveInfo.material;
                        var materialInfo = (void 0);
                        if (materialIndex !== null && materialIndex !== undefined) {
                            materialInfo = json.materials[materialIndex];
                        }
                        if (materialInfo) {
                            meshCfg.color = materialInfo._rgbaColor;
                            meshCfg.opacity = materialInfo._rgbaColor[3];

                        } else {
                            meshCfg.color = new Float32Array([1.0, 1.0, 1.0]);
                            meshCfg.opacity = 1.0;
                        }

                        if (createEntity) {
                            if (createEntity.colorize) {
                                meshCfg.color = createEntity.colorize;
                            }
                            if (createEntity.opacity !== undefined && createEntity.opacity !== null) {
                                meshCfg.opacity = createEntity.opacity;
                            }
                        }

                        if (meshInfo.instances > INSTANCE_THRESHOLD) {

                            // Instancing

                            var geometryId = performanceModel.id + "." + glTFNode.mesh + "." + i;
                            if (!ctx.geometryCreated[geometryId]) {
                                var geometryCfg = {
                                    id: geometryId
                                };
                                loadPrimitiveGeometry(ctx, primitiveInfo, geometryCfg);
                                performanceModel.createGeometry(geometryCfg);
                                ctx.geometryCreated[geometryId] = true;
                            }

                            meshCfg.geometryId = geometryId;

                            performanceModel.createMesh(meshCfg);
                            meshIds.push(meshCfg.id);

                        } else {

                            // Batching

                            loadPrimitiveGeometry(ctx, primitiveInfo, meshCfg);

                            performanceModel.createMesh(meshCfg);
                            meshIds.push(meshCfg.id);
                        }
                    }

                    if (createEntity) {
                        performanceModel.createEntity(utils.apply(createEntity, {
                            meshIds: meshIds
                        }));
                    } else {
                        performanceModel.createEntity({
                            meshIds: meshIds
                        });
                    }
                }
            }
        }

        if (glTFNode.children) {
            var children = glTFNode.children;
            for (var i$1 = 0, len = children.length; i$1 < len; i$1++) {
                var childNodeIdx = children[i$1];
                var childNodeInfo = json.nodes[childNodeIdx];
                if (!childNodeInfo) {
                    error(ctx, "Node not found: " + i$1);
                    continue;
                }
                loadNode(ctx, childNodeInfo, matrix);
            }
        }
    }

    function loadPrimitiveGeometry(ctx, primitiveInfo, geometryCfg) {
        var attributes = primitiveInfo.attributes;
        if (!attributes) {
            return;
        }
        geometryCfg.primitive = "triangles";
        var indicesIndex = primitiveInfo.indices;
        if (indicesIndex !== null && indicesIndex !== undefined) {
            var accessorInfo = ctx.json.accessors[indicesIndex];
            geometryCfg.indices = loadAccessorTypedArray(ctx, accessorInfo);
        }
        var positionsIndex = attributes.POSITION;
        if (positionsIndex !== null && positionsIndex !== undefined) {
            var accessorInfo$1 = ctx.json.accessors[positionsIndex];
            geometryCfg.positions = loadAccessorTypedArray(ctx, accessorInfo$1);
            //  scalePositionsArray(geometryCfg.positions);
        }
        var normalsIndex = attributes.NORMAL;
        if (normalsIndex !== null && normalsIndex !== undefined) {
            var accessorInfo$2 = ctx.json.accessors[normalsIndex];
            geometryCfg.normals = loadAccessorTypedArray(ctx, accessorInfo$2);
        }
        if (geometryCfg.indices) {
            geometryCfg.edgeIndices = buildEdgeIndices(geometryCfg.positions, geometryCfg.indices, null, 10); // Save PerformanceModel from building edges
        }
    }

    function loadAccessorTypedArray(ctx, accessorInfo) {
        var bufferViewInfo = ctx.json.bufferViews[accessorInfo.bufferView];
        var itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];
        var elementBytes = TypedArray.BYTES_PER_ELEMENT; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
        var itemBytes = elementBytes * itemSize;
        if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) { // The buffer is not interleaved if the stride is the item size in bytes.
            error("interleaved buffer!"); // TODO
        } else {
            return new TypedArray(bufferViewInfo._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);
        }
    }

    function error(ctx, msg) {
        ctx.plugin.error(msg);
    }
})();

/**
 * @desc Default initial properties for {@link Entity}s loaded from models accompanied by metadata.
 *
 * When loading a model, plugins such as {@link XKTLoaderPlugin} create
 * a tree of {@link Entity}s that represent the model. These loaders can optionally load metadata, to create
 * a {@link MetaModel} corresponding to the root {@link Entity}, with a {@link MetaObject} corresponding to each
 * object {@link Entity} within the tree.
 *
 * @type {{String:Object}}
 */
var IFCObjectDefaults = {

    IfcOpeningElement: {
        pickable: false,
        visible: false
    },

    IfcSpace: {
        colorize: [0.137255, 0.403922, 0.870588],
        pickable: false,
        visible: false,
        opacity: 0.4
    },

    IfcWindow: {
        colorize: [0.137255, 0.403922, 0.870588],
        opacity: 0.3
    },

    IfcPlate: {
        colorize: [0.8470588235, 0.427450980392, 0, 0.5],
        opacity: 0.3
    },

    DEFAULT: {
    }
};

/**
 * {@link Viewer} plugin that loads models from [glTF](https://www.khronos.org/gltf/).
 *
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which is indicated by each glTF ````node```` that has a ````name```` attribute. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 *
 * ## Metadata
 *
 * GLTFLoaderPlugin can also load an accompanying JSON metadata file with each model, which creates a {@link MetaModel} corresponding
 * to the model {@link Entity} and a {@link MetaObject} corresponding to each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding {@link Entity}. When loading
 * metadata, we can also provide GLTFLoaderPlugin with a custom lookup table of initial values to set on the properties of each type of {@link Entity}. By default, GLTFLoaderPlugin
 * uses its own map of default colors and visibilities for IFC element types.
 *
 * ## Quality Setting
 *
 * By default, GLTFLoaderPlugin will load a high-performance scene representation that's optimized for low memory usage and
 * optimal rendering. The high-performance representation renders large numbers of objects efficiently, using geometry
 * batching and instancing, with simple Lambertian shading that ignores any textures and realistic materials in the glTF.
 *
 * Specifying ````performance:false```` to {@link GLTFLoaderPlugin#load} will internally load a heavier scene
 * representation comprised of {@link Node}, {@link Mesh}, {@link Geometry}, {@link Material} and {@link Texture} components,
 * that will exactly preserve the materials specified in the glTF. Use this when you want to load a model for a realistic preview,
 * maybe using PBR etc.
 *
 * We tend to use the default ````performance:true```` setting for CAD and BIM models, where structure is more important that
 * surface appearance.
 *
 * Publically, GLTFLoaderPlugin creates the same {@link Entity}s for both levels of performance. Privately, however, it implements
 * {@link Entity}s using two different sets of concrete subtypes, for its two different internally-managed scene representations.
 *
 * ## Usage
 *
 * In the example below we'll load the Schependomlaan model from a [glTF file](http://xeokit.github.io/xeokit-sdk/examples/models/gltf/schependomlaan/), along
 * with an accompanying JSON [IFC metadata file](http://xeokit.github.io/xeokit-sdk/examples/metaModels/schependomlaan/).
 *
 * This will create a bunch of {@link Entity}s that represents the model and its objects, along with a {@link MetaModel} and {@link MetaObject}s
 * that hold their metadata.
 *
 * Since this model contains IFC types, the GLTFLoaderPlugin will set the initial colors of object {@link Entity}s according
 * to the standard IFC element colors in the GLTFModel's current map. Override that with your own map via property {@link GLTFLoaderPlugin#objectDefaults}.
 *
 * Read more about this example in the user guide on [Viewing BIM Models Offline](https://www.notion.so/xeokit/Viewing-an-IFC-Model-with-xeokit-c373e48bc4094ff5b6e5c5700ff580ee).
 *
 * We're leaving ````performance: true```` since our model has many objects and we're not interested in realistic rendering.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_glTF_OTCConferenceCenter)]
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a Viewer,
 * // 2. Arrange the camera,
 * // 3. Tweak the selection material (tone it down a bit)
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // 2
 * viewer.camera.orbitPitch(20);
 * viewer.camera.orbitYaw(-45);
 *
 * // 3
 * viewer.scene.selectedMaterial.fillAlpha = 0.1;
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a glTF loader plugin,
 * // 2. Load a glTF building model and JSON IFC metadata
 * // 3. Emphasis the edges to make it look nice
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * // 2
 * var model = gltfLoader.load({                                    // Returns an Entity that represents the model
 *      id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",     // Creates a MetaModel (see below)
 *      edges: true,
 *      performance: true  // Load high-performance scene representation (default is false)
 * });
 *
 * model.on("loaded", () => {
 *
 *      //--------------------------------------------------------------------------------------------------------------
 *      // 1. Find metadata on the third storey
 *      // 2. Select all the objects in the building's third storey
 *      // 3. Fit the camera to all the objects on the third storey
 *      //--------------------------------------------------------------------------------------------------------------
 *
 *      // 1
 *      const metaModel = viewer.metaScene.metaModels["myModel"];       // MetaModel with ID "myModel"
 *      const metaObject
 *          = viewer.metaScene.metaObjects["0u4wgLe6n0ABVaiXyikbkA"];   // MetaObject with ID "0u4wgLe6n0ABVaiXyikbkA"
 *
 *      const name = metaObject.name;                                   // "01 eerste verdieping"
 *      const type = metaObject.type;                                   // "IfcBuildingStorey"
 *      const parent = metaObject.parent;                               // MetaObject with type "IfcBuilding"
 *      const children = metaObject.children;                           // Array of child MetaObjects
 *      const objectId = metaObject.id;                                 // "0u4wgLe6n0ABVaiXyikbkA"
 *      const objectIds = viewer.metaScene.getObjectIDsInSubtree(objectId);   // IDs of leaf sub-objects
 *      const aabb = viewer.scene.getAABB(objectIds);                   // Axis-aligned boundary of the leaf sub-objects
 *
 *      // 2
 *      viewer.scene.setObjectsSelected(objectIds, true);
 *
 *      // 3
 *      viewer.cameraFlight.flyTo(aabb);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 *
 * ## Transforming
 *
 * We have the option to rotate, scale and translate each  *````.glTF````* model as we load it.
 *
 * This lets us load multiple models, or even multiple copies of the same model, and position them apart from each other.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_glTF_Duplex_transform)]
 *
 * ````javascript
 * const model = gltfLoader.load({
 *      src: "./models/gltf/Duplex/scene.gltf",
 *      metaModelSrc: "./models/gltf/Duplex/Duplex.json",
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      position: [100, 0, 0]
 * });
 * ````
 *
 * ## Including and excluding IFC types
 *
 * We can also load only those objects that have the specified IFC types. In the example below, we'll load only the
 * objects that represent walls.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_glTF_includeTypes_PlanView)]
 *
 * ````javascript
 * const model = gltfLoader.load({
 *     id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",
 *      includeTypes: ["IfcWallStandardCase"]
 * });
 * ````
 *
 * We can also load only those objects that **don't** have the specified IFC types. In the example below, we'll load only the
 * objects that do not represent empty space.
 *
 * ````javascript
 * const model = gltfLoader.load({
 *     id: "myModel",
 *      src: "./models/gltf/OTCConferenceCenter/scene.gltf",
 *      metaModelSrc: "./models/gltf/OTCConferenceCenter/metaModel.json",
 *      excludeTypes: ["IfcSpace"]
 * });
 * ````
 * @class GLTFLoaderPlugin
 */
var GLTFLoaderPlugin = /*@__PURE__*/(function (Plugin) {
    function GLTFLoaderPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "GLTFLoader", viewer, cfg);

        /**
         * @private
         */
        this._sceneGraphLoader = new GLTFSceneGraphLoader(this, cfg);

        /**
         * @private
         */
        this._performanceModelLoader = new GLTFPerformanceModelLoader(this, cfg);

        this.dataSource = cfg.dataSource;
        this.objectDefaults = cfg.objectDefaults;
    }

    if ( Plugin ) GLTFLoaderPlugin.__proto__ = Plugin;
    GLTFLoaderPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    GLTFLoaderPlugin.prototype.constructor = GLTFLoaderPlugin;

    var prototypeAccessors = { dataSource: { configurable: true },objectDefaults: { configurable: true } };

    /**
     * Sets a custom data source through which the GLTFLoaderPlugin can load metadata, glTF and binary attachments.
     *
     * Default value is {@link GLTFDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.set = function (value) {
        this._dataSource = value || new GLTFDefaultDataSource();
    };

    /**
     * Gets the custom data source through which the GLTFLoaderPlugin can load metadata, glTF and binary attachments.
     *
     * Default value is {@link GLTFDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.get = function () {
        return this._dataSource;
    };

    /**
     * Sets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectDefaults.set = function (value) {
        this._objectDefaults = value || IFCObjectDefaults;
    };

    /**
     * Gets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectDefaults.get = function () {
        return this._objectDefaults;
    };

    /**
     * Loads a glTF model from a file into this GLTFLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a glTF file, as an alternative to the ````gltf```` parameter.
     * @param {*} [params.gltf] glTF JSON, as an alternative to the ````src```` parameter.
     * @param {String} [params.metaModelSrc] Path to an optional metadata file, as an alternative to the ````metaModelData```` parameter.
     * @param {*} [params.metaModelData] JSON model metadata, as an alternative to the ````metaModelSrc```` parameter.
     * @param {{String:Object}} [params.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object. Default value is {@link IFCObjectDefaults}.
     * @params {String[]} [params.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @params {String[]} [params.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the model with edges emphasized.
     * @param {Number[]} [params.position=[0,0,0]] The model World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the glTF. When false, ignores backfaces.
     * @param {Number} [params.edgeThreshold=10] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @params {Boolean} [params.performance=true] Set ````false```` to load all the materials and textures provided by the glTF file, otherwise leave ````true```` to load the default high-performance representation optimized for low memory usage and efficient rendering.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */
    GLTFLoaderPlugin.prototype.load = function load (params) {
        var this$1 = this;
        if ( params === void 0 ) params = {};


        if (params.id && this.viewer.scene.components[params.id]) {
            this.error("Component with this ID already exists in viewer: " + params.id + " - will autogenerate this ID");
            delete params.id;
        }

        var performance = params.performance !== false;

        var model = performance

            // PerformanceModel provides performance-oriented scene representation
            // converting glTF materials to simple flat-shading without textures

            ? new PerformanceModel(this.viewer.scene, utils.apply(params, {
                isModel: true
            }))

            // Scene Node graph supports original glTF materials

            : new Node(this.viewer.scene, utils.apply(params, {
                isModel: true
            }));

        var modelId = model.id;  // In case ID was auto-generated

        if (!params.src && !params.gltf) {
            this.error("load() param expected: src or gltf");
            return model; // Return new empty model
        }

        var loader = performance ? this._performanceModelLoader : this._sceneGraphLoader;

        if (params.metaModelSrc || params.metaModelData) {

            var objectDefaults = params.objectDefaults || this._objectDefaults || IFCObjectDefaults;

            var processMetaModelData = function (metaModelData) {

                this$1.viewer.metaScene.createMetaModel(modelId, metaModelData, {
                    includeTypes: params.includeTypes,
                    excludeTypes: params.excludeTypes
                });

                this$1.viewer.scene.canvas.spinner.processes--;

                var includeTypes;
                if (params.includeTypes) {
                    includeTypes = {};
                    for (var i = 0, len = params.includeTypes.length; i < len; i++) {
                        includeTypes[params.includeTypes[i]] = true;
                    }
                }
                if (params.excludeTypes) {
                    if (!includeTypes) {
                        includeTypes = {};
                    }
                    for (var i$1 = 0, len$1 = params.excludeTypes.length; i$1 < len$1; i$1++) {
                        includeTypes[params.excludeTypes[i$1]] = true;
                    }
                }

                params.readableGeometry = false;

                params.handleGLTFNode = function (modelId, glTFNode, actions) {

                    var name = glTFNode.name;

                    if (!name) {
                        return true; // Continue descending this node subtree
                    }

                    var nodeId = name;
                    var metaObject = this$1.viewer.metaScene.metaObjects[nodeId];
                    var type = (metaObject ? metaObject.type : "DEFAULT") || "DEFAULT";

                    actions.createEntity = {
                        id: nodeId,
                        isObject: true // Registers the Entity in Scene#objects
                    };

                    var props = objectDefaults[type];

                    if (props) { // Set Entity's initial rendering state for recognized type

                        if (props.visible === false) {
                            actions.createEntity.visible = false;
                        }

                        if (props.colorize) {
                            actions.createEntity.colorize = props.colorize;
                        }

                        if (props.pickable === false) {
                            actions.createEntity.pickable = false;
                        }

                        if (props.opacity !== undefined && props.opacity !== null) {
                            actions.createEntity.opacity = props.opacity;
                        }
                    }

                    return true; // Continue descending this glTF node subtree
                };

                if (params.src) {
                    loader.load(this$1, model, params.src, params);
                } else {
                    loader.parse(this$1, model, params.gltf, params);
                }
            };

            if (params.metaModelSrc) {

                var metaModelSrc = params.metaModelSrc;

                this.viewer.scene.canvas.spinner.processes++;

                this._dataSource.getMetaModel(metaModelSrc, function (metaModelData) {

                    this$1.viewer.scene.canvas.spinner.processes--;

                    processMetaModelData(metaModelData);

                }, function (errMsg) {
                    this$1.error(("load(): Failed to load model metadata for model '" + modelId + " from  '" + metaModelSrc + "' - " + errMsg));
                    this$1.viewer.scene.canvas.spinner.processes--;
                });

            } else if (params.metaModelData) {

                processMetaModelData(params.metaModelData);
            }

        } else {

            params.handleGLTFNode = function (modelId, glTFNode, actions) {

                var name = glTFNode.name;

                if (!name) {
                    return true; // Continue descending this node subtree
                }

                var id = name;

                actions.createEntity = { // Create an Entity for this glTF scene node
                    id: id,
                    isObject: true // Registers the Entity in Scene#objects
                };

                return true; // Continue descending this glTF node subtree
            };

            if (params.src) {
                loader.load(this, model, params.src, params);
            } else {
                loader.parse(this, model, params.gltf, params);
            }
        }

        model.once("destroyed", function () {
            this$1.viewer.metaScene.destroyMetaModel(modelId);
        });

        return model;
    };

    /**
     * Destroys this GLTFLoaderPlugin.
     */
    GLTFLoaderPlugin.prototype.destroy = function destroy () {
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( GLTFLoaderPlugin.prototype, prototypeAccessors );

    return GLTFLoaderPlugin;
}(Plugin));

/**
 * @private
 */
function CubeTextureCanvas(viewer, cfg) {
    if ( cfg === void 0 ) cfg = {};


    var cubeColor = "lightgrey";
    var cubeHighlightColor = cfg.hoverColor || "rgba(0,0,0,0.4)";

    var height = 500;
    var width = height + (height / 3);
    var scale = width / 24;

    var facesZUp = [
        {boundary: [6, 6, 6, 6], color: cfg.frontColor || cfg.color || "#55FF55"},
        {boundary: [18, 6, 6, 6], color: cfg.backColor || cfg.color || "#55FF55"},
        {boundary: [12, 6, 6, 6], color: cfg.leftColor || cfg.color || "#FF5555"},
        {boundary: [0, 6, 6, 6], color: cfg.rightColor || cfg.color || "#FF5555"},
        {boundary: [6, 0, 6, 6], color: cfg.topColor || cfg.color || "#7777FF"},
        {boundary: [6, 12, 6, 6], color: cfg.bottomColor || cfg.color || "#7777FF"}
    ];

    var areasZUp = [
        {label: "NavCube.front", boundaries: [[7, 7, 4, 4]], dir: [0, 1, 0], up: [0, 0, 1]},
        {label: "NavCube.back", boundaries: [[19, 7, 4, 4]], dir: [0, -1, 0], up: [0, 0, 1]},
        {label: "NavCube.right", boundaries: [[13, 7, 4, 4]], dir: [-1, 0, 0], up: [0, 0, 1]},
        {label: "NavCube.left", boundaries: [[1, 7, 4, 4]], dir: [1, 0, 0], up: [0, 0, 1]},
        {label: "NavCube.top", boundaries: [[7, 1, 4, 4]], dir: [0, 0, -1], up: [0, 1, 0]},
        {label: "NavCube.bottom", boundaries: [[7, 13, 4, 4]], dir: [0, 0, 1], up: [0, -1, 0]},
        {boundaries: [[7, 5, 4, 2]], dir: [0, 1, -1], up: [0, 1, 1]},
        {boundaries: [[1, 6, 4, 1], [6, 1, 1, 4]], dir: [1, 0, -1], up: [1, 0, 1]},
        {boundaries: [[7, 0, 4, 1], [19, 6, 4, 1]], dir: [0, -1, -1], up: [0, -1, 1]},
        {boundaries: [[13, 6, 4, 1], [11, 1, 1, 4]], dir: [-1, 0, -1], up: [-1, 0, 1]},
        {boundaries: [[7, 11, 4, 2]], dir: [0, 1, 1], up: [0, -1, 1]},
        {boundaries: [[1, 11, 4, 1], [6, 13, 1, 4]], dir: [1, 0, 1], up: [-1, 0, 1]},
        {boundaries: [[7, 17, 4, 1], [19, 11, 4, 1]], dir: [0, -1, 1], up: [0, 1, 1]},
        {boundaries: [[13, 11, 4, 1], [11, 13, 1, 4]], dir: [-1, 0, 1], up: [1, 0, 1]},
        {boundaries: [[5, 7, 2, 4]], dir: [1, 1, 0], up: [0, 0, 1]},
        {boundaries: [[11, 7, 2, 4]], dir: [-1, 1, 0], up: [0, 0, 1]},
        {boundaries: [[17, 7, 2, 4]], dir: [-1, -1, 0], up: [0, 0, 1]},
        {boundaries: [[0, 7, 1, 4], [23, 7, 1, 4]], dir: [1, -1, 0], up: [0, 0, 1]},
        {boundaries: [[5, 11, 2, 2]], dir: [1, 1, 1], up: [-1, -1, 1]},
        {boundaries: [[23, 11, 1, 1], [6, 17, 1, 1], [0, 11, 1, 1]], dir: [1, -1, 1], up: [-1, 1, 1]},
        {boundaries: [[5, 5, 2, 2]], dir: [1, 1, -1], up: [1, 1, 1]},
        {boundaries: [[11, 17, 1, 1], [17, 11, 2, 1]], dir: [-1, -1, 1], up: [1, 1, 1]},
        {boundaries: [[17, 6, 2, 1], [11, 0, 1, 1]], dir: [-1, -1, -1], up: [-1, -1, 1]},
        {boundaries: [[11, 11, 2, 2]], dir: [-1, 1, 1], up: [1, -1, 1]},
        {boundaries: [[0, 6, 1, 1], [6, 0, 1, 1], [23, 6, 1, 1]], dir: [1, -1, -1], up: [1, -1, 1]},
        {boundaries: [[11, 5, 2, 2]], dir: [-1, 1, -1], up: [-1, 1, 1]}
    ];

    [
        {boundary: [6, 6, 6, 6], color: cfg.frontColor || cfg.color || "#55FF55"},
        {boundary: [18, 6, 6, 6], color: cfg.backColor || cfg.color || "#55FF55"},
        {boundary: [12, 6, 6, 6], color: cfg.leftColor || cfg.color || "#FF5555"},
        {boundary: [0, 6, 6, 6], color: cfg.rightColor || cfg.color || "#FF5555"},
        {boundary: [6, 0, 6, 6], color: cfg.topColor || cfg.color || "#7777FF"},
        {boundary: [6, 12, 6, 6], color: cfg.bottomColor || cfg.color || "#7777FF"}
    ];

    var areasYUp = [

        // Faces

        {yUp: "", label: "NavCube.front", boundaries: [[7, 7, 4, 4]], dir: [0, 0, -1], up: [0, 1, 0]},
        {label: "NavCube.back", boundaries: [[19, 7, 4, 4]], dir: [0, 0, 1], up: [0, 1, 0]},
        {label: "NavCube.right", boundaries: [[13, 7, 4, 4]], dir: [-1, 0, 0], up: [0, 1, 0]},
        {label: "NavCube.left", boundaries: [[1, 7, 4, 4]], dir: [1, 0, 0], up: [0, 1, 0]},
        {label: "NavCube.top", boundaries: [[7, 1, 4, 4]], dir: [0, -1, 0], up: [0, 0, -1]},
        {label: "NavCube.bottom", boundaries: [[7, 13, 4, 4]], dir: [0, 1, 0], up: [0, 0, 1]},
        {boundaries: [[7, 5, 4, 2]], dir: [0, -0.7071, -0.7071], up: [0, 0.7071, -0.7071]}, // Top-front edge
        {boundaries: [[1, 6, 4, 1], [6, 1, 1, 4]], dir: [1, -1, 0], up: [1, 1, 0]},  // Top-left edge
        {boundaries: [[7, 0, 4, 1], [19, 6, 4, 1]], dir: [0, -0.7071, 0.7071], up: [0, 0.7071, 0.7071]}, // Top-back edge
        {boundaries: [[13, 6, 4, 1], [11, 1, 1, 4]], dir: [-1, -1, 0], up: [-1, 1, 0]}, // Top-right edge
        {boundaries: [[7, 11, 4, 2]], dir: [0, 1, -1], up: [0, 1, 1]},  // Bottom-front edge
        {boundaries: [[1, 11, 4, 1], [6, 13, 1, 4]], dir: [1, 1, 0], up: [-1, 1, 0]}, // Bottom-left edge
        {boundaries: [[7, 17, 4, 1], [19, 11, 4, 1]], dir: [0, 1, 1], up: [0, 1, -1]}, // Bottom-back edge
        {boundaries: [[13, 11, 4, 1], [11, 13, 1, 4]], dir: [-1, 1, 0], up: [1, 1, 0]}, // Bottom-right edge
        {boundaries: [[5, 7, 2, 4]], dir: [1, 0, -1], up: [0, 1, 0]},// Front-left edge
        {boundaries: [[11, 7, 2, 4]], dir: [-1, 0, -1], up: [0, 1, 0]}, // Front-right edge
        {boundaries: [[17, 7, 2, 4]], dir: [-1, 0, 1], up: [0, 1, 0]},// Back-right edge
        {boundaries: [[0, 7, 1, 4], [23, 7, 1, 4]], dir: [1, 0, 1], up: [0, 1, 0]},// Back-left edge
        {boundaries: [[5, 11, 2, 2]], "dir": [0.5, 0.7071, -0.5], "up": [-0.5, 0.7071, 0.5]}, // Bottom-left-front corner
        {boundaries: [[23, 11, 1, 1], [6, 17, 1, 1], [0, 11, 1, 1]],"dir": [0.5, 0.7071, 0.5],"up": [-0.5, 0.7071, -0.5]},// Bottom-back-left corner
        {boundaries: [[5, 5, 2, 2]], "dir": [0.5, -0.7071, -0.5], "up": [0.5, 0.7071, -0.5]}, // Left-front-top corner
        {boundaries: [[11, 17, 1, 1], [17, 11, 2, 1]], "dir": [-0.5, 0.7071, 0.5], "up": [0.5, 0.7071, -0.5]}, // Bottom-back-right corner
        {boundaries: [[17, 6, 2, 1], [11, 0, 1, 1]], "dir": [-0.5, -0.7071, 0.5], "up": [-0.5, 0.7071, 0.5]}, // Top-back-right corner
        {boundaries: [[11, 11, 2, 2]], "dir": [-0.5, 0.7071, -0.5], "up": [0.5, 0.7071, 0.5]}, // Bottom-front-right corner
        {boundaries: [[0, 6, 1, 1], [6, 0, 1, 1], [23, 6, 1, 1]], "dir": [0.5, -0.7071, 0.5], "up": [0.5, 0.7071, 0.5]},// Top-back-left corner
        {boundaries: [[11, 5, 2, 2]], "dir": [-0.5, -0.7071, -0.5], "up": [-0.5, 0.7071, -0.5]}// Top-front-right corner
    ];

    for (var i = 0, len = areasZUp.length; i < len; i++) {
        math.normalizeVec3(areasZUp[i].dir, areasZUp[i].dir);
        math.normalizeVec3(areasZUp[i].up, areasZUp[i].up);
    }

    for (var i$1 = 0, len$1 = areasYUp.length; i$1 < len$1; i$1++) {
        math.normalizeVec3(areasYUp[i$1].dir, areasYUp[i$1].dir);
        math.normalizeVec3(areasYUp[i$1].up, areasYUp[i$1].up);
    }
    var areas = areasYUp;

    this._textureCanvas = document.createElement('canvas');
    this._textureCanvas.width = width;
    this._textureCanvas.height = height;
    this._textureCanvas.style.width = width + "px";
    this._textureCanvas.style.height = height + "px";
    this._textureCanvas.style.padding = "0";
    this._textureCanvas.style.margin = "0";
    this._textureCanvas.style.top = "0";
    this._textureCanvas.style.background = cubeColor;
    this._textureCanvas.style.position = "absolute";
    this._textureCanvas.style.opacity = "1.0";
    this._textureCanvas.style.visibility = "hidden";
    this._textureCanvas.style["z-index"] = 2000000;

    var body = document.getElementsByTagName("body")[0];
    body.appendChild(this._textureCanvas);

    var context = this._textureCanvas.getContext("2d");

    var zUp = false;

    function paint() {

        for (var i = 0, len = facesZUp.length; i < len; i++) {
            var face = facesZUp[i];
            var boundary = face.boundary;
            var xmin = Math.round(boundary[0] * scale);
            var ymin = Math.round(boundary[1] * scale);
            var width = Math.round(boundary[2] * scale);
            var height = Math.round(boundary[3] * scale);
            context.fillStyle = face.color;
            context.fillRect(xmin, ymin, width, height);
        }

        for (var i$1 = 0, len$1 = areas.length; i$1 < len$1; i$1++) {
            var xmin$1 = (void 0);
            var ymin$1 = (void 0);
            var width$1 = (void 0);
            var height$1 = (void 0);
            var area = areas[i$1];

            var boundaries = area.boundaries;
            for (var j = 0, lenj = boundaries.length; j < lenj; j++) {
                var boundary$1 = boundaries[j];
                xmin$1 = Math.round(boundary$1[0] * scale);
                ymin$1 = Math.round(boundary$1[1] * scale);
                width$1 = Math.round(boundary$1[2] * scale);
                height$1 = Math.round(boundary$1[3] * scale);
                if (area.highlighted) {
                    context.fillStyle = area.highlighted ? cubeHighlightColor : (area.color || cubeColor);
                    context.fillRect(xmin$1, ymin$1, width$1, height$1);
                }
            }
            if (area.label) {
                context.fillStyle = "black";
                context.font = '60px sans-serif';
                context.textAlign = "center";
                var xcenter = xmin$1 + (width$1 * 0.5);
                var ycenter = ymin$1 + (height$1 * 0.7);
                context.fillText(translateLabel(area.label), xcenter, ycenter, 80);
            }
        }

        viewer.scene.glRedraw();
    }

    var translateLabel = (function () {

        var swizzleYUp = {
            "NavCube.front": "NavCube.front",
            "NavCube.back": "NavCube.back",
            "NavCube.right": "NavCube.right",
            "NavCube.left": "NavCube.left",
            "NavCube.top": "NavCube.top",
            "NavCube.bottom": "NavCube.bottom"
        };

        var swizzleZUp = {
            "NavCube.front": "NavCube.front",
            "NavCube.back": "NavCube.back",
            "NavCube.right": "NavCube.right",
            "NavCube.left": "NavCube.left",
            "NavCube.top": "NavCube.top",
            "NavCube.bottom": "NavCube.bottom"
        };

        var defaultLabels = {
            "NavCube.front": "FRONT",
            "NavCube.back": "BACK",
            "NavCube.right": "RIGHT",
            "NavCube.left": "LEFT",
            "NavCube.top": "TOP",
            "NavCube.bottom": "BOTTOM"
        };

        return function (key) {
            var swizzle = zUp ? swizzleZUp : swizzleYUp;
            var swizzledKey = swizzle ? swizzle[key] : null;
            if (swizzledKey) {
                return viewer.localeService.translate(swizzledKey) || defaultLabels[swizzledKey] || swizzledKey;
            }
            return key;
        };
    })();

    this.setZUp = function () {
        zUp = true;
        areas = areasZUp;
        this.clear();
    };

    this.setYUp = function () {
        zUp = false;
        areas = areasYUp;
        this.clear();
    };

    this.clear = function () {
        context.fillStyle = cubeColor;
        context.fillRect(0, 0, width, height);
        for (var i = 0, len = areas.length; i < len; i++) {
            var area = areas[i];
            area.highlighted = false;
        }
        paint();
    };

    this.getArea = function (uv) {
        var s = uv[0] * width;
        var t = height - (uv[1] * height); // Correct for our texture Y-flipping
        for (var i = 0, len = areas.length; i < len; i++) {
            var area = areas[i];
            var boundaries = area.boundaries;
            for (var j = 0, lenj = boundaries.length; j < lenj; j++) {
                var boundary = boundaries[j];
                if (s >= (boundary[0] * scale) && s <= ((boundary[0] + boundary[2]) * scale) && t >= (boundary[1] * scale) && t <= ((boundary[1] + boundary[3]) * scale)) {
                    return i;
                }
            }
        }
        return -1;
    };

    this.setAreaHighlighted = function (areaId, highlighted) {
        var area = areas[areaId];
        if (!area) {
            throw "Area not found: " + areaId;
        }
        area.highlighted = !!highlighted;
        paint();
    };

    this.getAreaDir = function (areaId) {
        var area = areas[areaId];
        if (!area) {
            throw "Unknown area: " + areaId;
        }
        return area.dir;
    };

    this.getAreaUp = function (areaId) {
        var area = areas[areaId];
        if (!area) {
            throw "Unknown area: " + areaId;
        }
        return area.up;
    };

    this.getImage = function () {
        return this._textureCanvas;
    };

    this.destroy = function () {
        if (this._textureCanvas) {
            this._textureCanvas.parentNode.removeChild(this._textureCanvas);
            this._textureCanvas = null;
        }
    };
}

/**
 * {@link Viewer} plugin that lets us look at the entire {@link Scene} from along a chosen axis or diagonal.
 *
 *  [<img src="https://user-images.githubusercontent.com/83100/55674490-c93c2e00-58b5-11e9-8a28-eb08876947c0.gif">](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_NavCubePlugin)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_NavCubePlugin)]
 *
 * ## Overview
 *
 * * Rotating the NavCube causes the Viewer's {@link Camera} to orbit its current
 * point-of-interest. Conversely, orbiting the Camera causes the NavCube to rotate accordingly.
 * * The faces of the NavCube are aligned with the Viewer's {@link Scene}'s World-space coordinate axis. Clicking on a face moves
 * the Camera to look at the entire Scene along the corresponding axis. Clicking on an edge or a corner looks at
 * the entire Scene along a diagonal.
 * * The NavCube can be configured to either jump or fly the Camera to each new position. We can configure how tightly the
 * NavCube fits the Scene to view, and when flying, we can configure how fast it flies. We can also configure whether the
 * NavCube fits all objects to view, or just the currently visible objects. See below for a usage example.
 * * Clicking the NavCube also sets {@link CameraControl#pivotPos} to the center of the fitted objects.
 *
 * ## Usage
 *
 * In the example below, we'll create a Viewer and add a NavCubePlugin, which will create a NavCube gizmo in the canvas
 * with the given ID. Then we'll use the {@link XKTLoaderPlugin} to load a model into the Viewer's Scene. We can then
 * use the NavCube to look at the model along each axis or diagonal.
 *
 * ````JavaScript
 * import {Viewer, XKTLoaderPlugin, NavCubePlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.03];
 *
 * const navCube = new NavCubePlugin(viewer, {
 *
 *     canvasID: "myNavCubeCanvas",
 *
 *     visible: true,         // Initially visible (default)
 *
 *     cameraFly: true,       // Fly camera to each selected axis/diagonal
 *     cameraFitFOV: 45,      // How much field-of-view the scene takes once camera has fitted it to view
 *     cameraFlyDuration: 0.5,// How long (in seconds) camera takes to fly to each new axis/diagonal
 *
 *     fitVisible: false,     // Fit whole scene, including invisible objects (default)
 *
 *     synchProjection: false // Keep NavCube in perspective projection, even when camera switches to ortho (default)
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Duplex.ifc.xkt",
 *     edges: true
 * });
 * ````
 */
var NavCubePlugin = /*@__PURE__*/(function (Plugin) {
    function NavCubePlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "NavCube", viewer, cfg);

        viewer.navCube = this;

        var visible = true;

        try {
            this._navCubeScene = new Scene(viewer, {
                canvasId: cfg.canvasId,
                canvasElement: cfg.canvasElement,
                transparent: true
            });

            this._navCubeCanvas = this._navCubeScene.canvas.canvas;

            this._navCubeScene.input.keyboardEnabled = false; // Don't want keyboard input in the NavCube

        } catch (error) {
            this.error(error);
            return;
        }

        var navCubeScene = this._navCubeScene;

        navCubeScene.clearLights();

        new DirLight(navCubeScene, {dir: [0.4, -0.4, 0.8], color: [0.8, 1.0, 1.0], intensity: 1.0, space: "view"});
        new DirLight(navCubeScene, {dir: [-0.8, -0.3, -0.4], color: [0.8, 0.8, 0.8], intensity: 1.0, space: "view"});
        new DirLight(navCubeScene, {dir: [0.8, -0.6, -0.8], color: [1.0, 1.0, 1.0], intensity: 1.0, space: "view"});

        this._navCubeCamera = navCubeScene.camera;
        this._navCubeCamera.ortho.scale = 7.0;
        this._navCubeCamera.ortho.near = 0.1;
        this._navCubeCamera.ortho.far = 2000;

        navCubeScene.edgeMaterial.edgeColor = [0.2, 0.2, 0.2];
        navCubeScene.edgeMaterial.edgeAlpha = 0.6;

        this._zUp = Boolean(viewer.camera.zUp);

        var self = this;

        this._synchCamera = (function () {
            var matrix = math.rotationMat4c(-90 * math.DEGTORAD, 1, 0, 0);
            var eyeLookVec = math.vec3();
            var eyeLookVecCube = math.vec3();
            var upCube = math.vec3();
            return function () {
                var eye = viewer.camera.eye;
                var look = viewer.camera.look;
                var up = viewer.camera.up;
                eyeLookVec = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye, look, eyeLookVec)), 5);
                if (self._zUp) { // +Z up
                    math.transformVec3(matrix, eyeLookVec, eyeLookVecCube);
                    math.transformVec3(matrix, up, upCube);
                    self._navCubeCamera.look = [0, 0, 0];
                    self._navCubeCamera.eye = math.transformVec3(matrix, eyeLookVec, eyeLookVecCube);
                    self._navCubeCamera.up = math.transformPoint3(matrix, up, upCube);
                } else { // +Y up
                    self._navCubeCamera.look = [0, 0, 0];
                    self._navCubeCamera.eye = eyeLookVec;
                    self._navCubeCamera.up = up;
                }
            };
        }());

        this._cubeTextureCanvas = new CubeTextureCanvas(viewer, cfg);

        this._cubeSampler = new Texture(navCubeScene, {
            image: this._cubeTextureCanvas.getImage(),
            flipY: true,
            wrapS: "clampToEdge",
            wrapT: "clampToEdge"
        });

        this._cubeMesh = new Mesh(navCubeScene, {
            geometry: new ReadableGeometry(navCubeScene, {
                primitive: "triangles",
                normals: [
                    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
                    0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1,
                    0, 0, -1, 0, 0, -1, 0, 0, -1
                ],
                positions: [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1,
                    1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1,
                    1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1
                ],
                uv: [
                    0.5, 0.6666, 0.25, 0.6666, 0.25, 0.3333, 0.5, 0.3333, 0.5, 0.6666, 0.5, 0.3333, 0.75, 0.3333, 0.75, 0.6666,
                    0.5, 0.6666, 0.5, 1, 0.25, 1, 0.25, 0.6666, 0.25, 0.6666, 0.0, 0.6666, 0.0, 0.3333, 0.25, 0.3333,
                    0.25, 0, 0.50, 0, 0.50, 0.3333, 0.25, 0.3333, 0.75, 0.3333, 1.0, 0.3333, 1.0, 0.6666, 0.75, 0.6666
                ],
                indices: [
                    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16,
                    18, 19, 20, 21, 22, 20, 22, 23
                ]
            }),
            material: new PhongMaterial(navCubeScene, {
                diffuse: [0.4, 0.4, 0.4],
                specular: [0.4, 0.4, 0.4],
                emissive: [.6, .6, .6],
                diffuseMap: this._cubeSampler,
                emissiveMap: this._cubeSampler
            }),
            visible: !!visible,
            edges: true
        });

        this._shadow = new Mesh(navCubeScene, {
            geometry: new ReadableGeometry(navCubeScene, buildCylinderGeometry({
                center: [0, 0, 0],
                radiusTop: 0.001,
                radiusBottom: 1.4,
                height: 0.01,
                radialSegments: 20,
                heightSegments: 1,
                openEnded: true
            })),
            material: new PhongMaterial(navCubeScene, {
                diffuse: [0.0, 0.0, 0.0], specular: [0, 0, 0], emissive: [0.0, 0.0, 0.0], alpha: 0.5
            }),
            position: [0, -1.5, 0],
            visible: !!visible,
            pickable: false,
            backfaces: false
        });

        this._onCameraMatrix = viewer.camera.on("matrix", this._synchCamera);
        this._onCameraWorldAxis = viewer.camera.on("worldAxis", function () {
            if (viewer.camera.zUp) {
                this$1._zUp = true;
                this$1._cubeTextureCanvas.setZUp();
                this$1._repaint();
                this$1._synchCamera();
            } else if (viewer.camera.yUp) {
                this$1._zUp = false;
                this$1._cubeTextureCanvas.setYUp();
                this$1._repaint();
                this$1._synchCamera();
            }
        });
        this._onCameraFOV = viewer.camera.perspective.on("fov", function (fov) {
            if (this$1._synchProjection) {
                this$1._navCubeCamera.perspective.fov = fov;
            }
        });
        this._onCameraProjection = viewer.camera.on("projection", function (projection) {
            if (this$1._synchProjection) {
                this$1._navCubeCamera.projection = projection;
            }
        });

        var lastAreaId = -1;

        function actionMove(posX, posY) {
            var yawInc = (posX - lastX) * -sensitivity;
            var pitchInc = (posY - lastY) * -sensitivity;
            viewer.camera.orbitYaw(yawInc);
            viewer.camera.orbitPitch(-pitchInc);
            lastX = posX;
            lastY = posY;
        }

        function getCoordsWithinElement(event) {
            var coords = [0, 0];
            if (!event) {
                event = window.event;
                coords[0] = event.x;
                coords[1] = event.y;
            } else {
                var element = event.target;
                var totalOffsetLeft = 0;
                var totalOffsetTop = 0;
                while (element.offsetParent) {
                    totalOffsetLeft += element.offsetLeft;
                    totalOffsetTop += element.offsetTop;
                    element = element.offsetParent;
                }
                coords[0] = event.pageX - totalOffsetLeft;
                coords[1] = event.pageY - totalOffsetTop;
            }
            return coords;
        }

        {
            var downX = null;
            var downY = null;
            var down = false;
            var over = false;
            var sensitivity = 0.5;

            var lastX;
            var lastY;

            self._navCubeCanvas.addEventListener("mouseenter", self._onMouseEnter = function (e) {
                over = true;
            });


            self._navCubeCanvas.addEventListener("mouseleave", self._onMouseLeave = function (e) {
                over = false;
            });

            self._navCubeCanvas.addEventListener("mousedown", self._onMouseDown = function (e) {
                if (e.which !== 1) {
                    return;
                }
                downX = e.x;
                downY = e.y;
                lastX = e.clientX;
                lastY = e.clientY;
                var canvasPos = getCoordsWithinElement(e);
                var hit = navCubeScene.pick({
                    canvasPos: canvasPos
                });
                if (hit) {
                    down = true;

                } else {
                    down = false;
                }
            });

            document.addEventListener("mouseup", self._onMouseUp = function (e) {
                if (e.which !== 1) {// Left button
                    return;
                }
                down = false;
                if (downX === null) {
                    return;
                }
                var canvasPos = getCoordsWithinElement(e);
                var hit = navCubeScene.pick({
                    canvasPos: canvasPos,
                    pickSurface: true
                });
                if (hit) {
                    if (hit.uv) {
                        var areaId = self._cubeTextureCanvas.getArea(hit.uv);
                        if (areaId >= 0) {
                            document.body.style.cursor = "pointer";
                            if (lastAreaId >= 0) {
                                self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                                self._repaint();
                                lastAreaId = -1;
                            }
                            if (areaId >= 0) {
                                self._cubeTextureCanvas.setAreaHighlighted(areaId, true);
                                lastAreaId = areaId;
                                self._repaint();
                                if (e.x < (downX - 3) || e.x > (downX + 3) || e.y < (downY - 3) || e.y > (downY + 3)) {
                                    return;
                                }
                                var dir = self._cubeTextureCanvas.getAreaDir(areaId);
                                if (dir) {
                                    var up = self._cubeTextureCanvas.getAreaUp(areaId);
                                    flyTo(dir, up, function () {
                                        if (lastAreaId >= 0) {
                                            self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                                            self._repaint();
                                            lastAreaId = -1;
                                        }
                                        document.body.style.cursor = "pointer";
                                        if (lastAreaId >= 0) {
                                            self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                                            self._repaint();
                                            lastAreaId = -1;
                                        }
                                        if (areaId >= 0) {
                                            self._cubeTextureCanvas.setAreaHighlighted(areaId, false);
                                            lastAreaId = -1;
                                            self._repaint();
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            });

            document.addEventListener("mousemove", self._onMouseMove = function (e) {
                if (lastAreaId >= 0) {
                    self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                    self._repaint();
                    lastAreaId = -1;
                }
                if (e.buttons === 1 && !down) {
                    return;
                }
                if (down) {
                    var posX = e.clientX;
                    var posY = e.clientY;
                    document.body.style.cursor = "move";
                    actionMove(posX, posY);
                    return;
                }
                if (!over) {
                    return;
                }
                var canvasPos = getCoordsWithinElement(e);
                var hit = navCubeScene.pick({
                    canvasPos: canvasPos,
                    pickSurface: true
                });
                if (hit) {
                    if (hit.uv) {
                        document.body.style.cursor = "pointer";
                        var areaId = self._cubeTextureCanvas.getArea(hit.uv);
                        if (areaId === lastAreaId) {
                            return;
                        }
                        if (lastAreaId >= 0) {
                            self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                        }
                        if (areaId >= 0) {
                            self._cubeTextureCanvas.setAreaHighlighted(areaId, true);
                            self._repaint();
                            lastAreaId = areaId;
                        }
                    }
                } else {
                    document.body.style.cursor = "default";
                    if (lastAreaId >= 0) {
                        self._cubeTextureCanvas.setAreaHighlighted(lastAreaId, false);
                        self._repaint();
                        lastAreaId = -1;
                    }
                }
            });

            var flyTo = (function () {
                var center = math.vec3();
                return function (dir, up, ok) {
                    var aabb = self._fitVisible ? viewer.scene.getAABB(viewer.scene.visibleObjectIds) : viewer.scene.aabb;
                    var diag = math.getAABB3Diag(aabb);
                    math.getAABB3Center(aabb, center);
                    var dist = Math.abs(diag / Math.tan(self._cameraFitFOV * math.DEGTORAD));
                    viewer.cameraControl.pivotPos = center;
                    if (self._cameraFly) {
                        viewer.cameraFlight.flyTo({
                            look: center,
                            eye: [center[0] - (dist * dir[0]), center[1] - (dist * dir[1]), center[2] - (dist * dir[2])],
                            up: up || [0, 1, 0],
                            orthoScale: diag * 1.1,
                            fitFOV: self._cameraFitFOV,
                            duration: self._cameraFlyDuration
                        }, ok);
                    } else {
                        viewer.cameraFlight.jumpTo({
                            look: center,
                            eye: [center[0] - (dist * dir[0]), center[1] - (dist * dir[1]), center[2] - (dist * dir[2])],
                            up: up || [0, 1, 0],
                            orthoScale: diag * 1.1,
                            fitFOV: self._cameraFitFOV
                        }, ok);
                    }
                };
            })();
        }

        this._onUpdated = viewer.localeService.on("updated", function () {
            this$1._cubeTextureCanvas.clear();
            this$1._repaint();
        });

        this.setVisible(cfg.visible);
        this.setCameraFitFOV(cfg.cameraFitFOV);
        this.setCameraFly(cfg.cameraFly);
        this.setCameraFlyDuration(cfg.cameraFlyDuration);
        this.setFitVisible(cfg.fitVisible);
        this.setSynchProjection(cfg.synchProjection);
    }

    if ( Plugin ) NavCubePlugin.__proto__ = Plugin;
    NavCubePlugin.prototype = Object.create( Plugin && Plugin.prototype );
    NavCubePlugin.prototype.constructor = NavCubePlugin;

    NavCubePlugin.prototype.send = function send (name, value) {
        switch (name) {
            case "language":
                this._cubeTextureCanvas.clear();
                this._repaint(); // CubeTextureCanvas gets language from Viewer
                break;
        }
    };

    NavCubePlugin.prototype._repaint = function _repaint () {
        var image = this._cubeTextureCanvas.getImage();
        this._cubeMesh.material.diffuseMap.image = image;
        this._cubeMesh.material.emissiveMap.image = image;
    };

    /**
     * Sets if the NavCube is visible.
     *
     * @param {Boolean} visible Whether or not the NavCube is visible.
     */
    NavCubePlugin.prototype.setVisible = function setVisible (visible) {
        if ( visible === void 0 ) visible = true;

        if (!this._navCubeCanvas) {
            return;
        }
        this._cubeMesh.visible = visible;
        this._shadow.visible = visible;
        this._navCubeCanvas.style.visibility = visible ? "visible" : "hidden";
    };

    /**
     * Gets if the NavCube is visible.
     *
     * @return {Boolean} True when the NavCube is visible.
     */
    NavCubePlugin.prototype.getVisible = function getVisible () {
        if (!this._navCubeCanvas) {
            return false;
        }
        return this._cubeMesh.visible;
    };


    /**
     * Sets whether the axis, corner and edge-aligned views will fit the
     * view to the entire {@link Scene} or just to visible object-{@link Entity}s.
     *
     * Entitys are visible objects when {@link Entity#isObject} and {@link Entity#visible} are both ````true````.
     *
     * @param {Boolean} fitVisible Set ````true```` to fit only visible object-Entitys.
     */
    NavCubePlugin.prototype.setFitVisible = function setFitVisible (fitVisible) {
        if ( fitVisible === void 0 ) fitVisible = false;

        this._fitVisible = fitVisible;
    };

    /**
     * Gets whether the axis, corner and edge-aligned views will fit the
     * view to the entire {@link Scene} or just to visible object-{@link Entity}s.
     *
     * Entitys are visible objects when {@link Entity#isObject} and {@link Entity#visible} are both ````true````.
     *
     * @return {Boolean} True when fitting only visible object-Entitys.
     */
    NavCubePlugin.prototype.getFitVisible = function getFitVisible () {
        return this._fitVisible;
    };

    /**
     * Sets whether the {@link Camera} flies or jumps to each selected axis or diagonal.
     *
     * Default is ````true````, to fly.
     *
     * @param {Boolean} cameraFly Set ````true```` to fly, else ````false```` to jump.
     */
    NavCubePlugin.prototype.setCameraFly = function setCameraFly (cameraFly) {
        if ( cameraFly === void 0 ) cameraFly = true;

        this._cameraFly = cameraFly;
    };

    /**
     * Gets whether the {@link Camera} flies or jumps to each selected axis or diagonal.
     *
     * Default is ````true````, to fly.
     *
     * @returns {Boolean} Returns ````true```` to fly, else ````false```` to jump.
     */
    NavCubePlugin.prototype.getCameraFly = function getCameraFly () {
        return this._cameraFly;
    };

    /**
     * Sets how much of the field-of-view, in degrees, that the {@link Scene} should
     * fill the canvas when flying or jumping the {@link Camera} to each selected axis or diagonal.
     *
     * Default value is ````45````.
     *
     * @param {Number} cameraFitFOV New FOV value.
     */
    NavCubePlugin.prototype.setCameraFitFOV = function setCameraFitFOV (cameraFitFOV) {
        if ( cameraFitFOV === void 0 ) cameraFitFOV = 45;

        this._cameraFitFOV = cameraFitFOV;
    };

    /**
     * Gets how much of the field-of-view, in degrees, that the {@link Scene} should
     * fill the canvas when flying or jumping the {@link Camera} to each selected axis or diagonal.
     *
     * Default value is ````45````.
     *
     * @returns {Number} Current FOV value.
     */
    NavCubePlugin.prototype.getCameraFitFOV = function getCameraFitFOV () {
        return this._cameraFitFOV;
    };

    /**
     * When flying the {@link Camera} to each new axis or diagonal, sets how long, in seconds, that the Camera takes to get there.
     *
     * Default is ````0.5````.
     *
     * @param {Boolean} cameraFlyDuration Camera flight duration in seconds.
     */
    NavCubePlugin.prototype.setCameraFlyDuration = function setCameraFlyDuration (cameraFlyDuration) {
        if ( cameraFlyDuration === void 0 ) cameraFlyDuration = 0.5;

        this._cameraFlyDuration = cameraFlyDuration;
    };

    /**
     * When flying the {@link Camera} to each new axis or diagonal, gets how long, in seconds, that the Camera takes to get there.
     *
     * Default is ````0.5````.
     *
     * @returns {Boolean} Camera flight duration in seconds.
     */
    NavCubePlugin.prototype.getCameraFlyDuration = function getCameraFlyDuration () {
        return this._cameraFlyDuration;
    };

    /**
     * Sets whether the NavCube switches between perspective and orthographic projections in synchrony with
     * the {@link Camera}. When ````false````, the NavCube will always be rendered with perspective projection.
     *
     * @param {Boolean} synchProjection Set ````true```` to keep NavCube projection synchronized with {@link Camera#projection}.
     */
    NavCubePlugin.prototype.setSynchProjection = function setSynchProjection (synchProjection) {
        if ( synchProjection === void 0 ) synchProjection = false;

        this._synchProjection = synchProjection;
    };

    /**
     * Gets whether the NavCube switches between perspective and orthographic projections in synchrony with
     * the {@link Camera}. When ````false````, the NavCube will always be rendered with perspective projection.
     *
     * @return {Boolean} True when NavCube projection is synchronized with {@link Camera#projection}.
     */
    NavCubePlugin.prototype.getSynchProjection = function getSynchProjection () {
        return this._synchProjection;
    };

    /**
     * Destroys this NavCubePlugin.
     *
     * Does not destroy the canvas the NavCubePlugin was configured with.
     */
    NavCubePlugin.prototype.destroy = function destroy () {

        if (this._navCubeCanvas) {

            this.viewer.localeService.off(this._onUpdated);
            this.viewer.camera.off(this._onCameraMatrix);
            this.viewer.camera.off(this._onCameraWorldAxis);
            this.viewer.camera.perspective.off(this._onCameraFOV);
            this.viewer.camera.off(this._onCameraProjection);

            this._navCubeCanvas.removeEventListener("mouseenter", this._onMouseEnter);
            this._navCubeCanvas.removeEventListener("mouseleave", this._onMouseLeave);
            this._navCubeCanvas.removeEventListener("mousedown", this._onMouseDown);

            document.removeEventListener("mousemove", this._onMouseMove);
            document.removeEventListener("mouseup", this._onMouseUp);

            this._navCubeCanvas = null;
            this._cubeTextureCanvas.destroy();
            this._cubeTextureCanvas = null;

            this._onMouseEnter = null;
            this._onMouseLeave = null;
            this._onMouseDown = null;
            this._onMouseMove = null;
            this._onMouseUp = null;
        }

        this._navCubeScene.destroy();
        this._navCubeScene = null;
        this._cubeMesh = null;
        this._shadow = null;

        Plugin.prototype.destroy.call(this);
    };

    return NavCubePlugin;
}(Plugin));

var tempVec3a$7 = math.vec3();

/**
 * @private
 */
var OBJSceneGraphLoader = function OBJSceneGraphLoader () {};

OBJSceneGraphLoader.prototype.load = function load (modelNode, src, params) {


    var spinner = modelNode.scene.canvas.spinner;
    spinner.processes++;

    loadOBJ(modelNode, src, function (state) {
        loadMTLs(modelNode, state, function () {

            createMeshes(modelNode, state);

            spinner.processes--;

            core.scheduleTask(function () {
                modelNode.fire("loaded", true, false);
            });
        });
    });
};

/**
 * Parses OBJ and MTL text strings into a {@link Node}.
 *
 * @static
 * @param {Node} modelNode Node to load into.
 * @param {String} objText OBJ text string.
 * @param {String} [mtlText] MTL text string.
 * @param {String} [basePath] Base path for external resources.
 */
OBJSceneGraphLoader.prototype.parse = function parse (modelNode, objText, mtlText, basePath) {
    if (!objText) {
        this.warn("load() param expected: objText");
        return;
    }
    var state = parseOBJ(modelNode, objText, null);
    if (mtlText) {
        parseMTL(modelNode, mtlText, basePath);
    }
    createMeshes(modelNode, state);
    modelNode.src = null;
    modelNode.fire("loaded", true, false);
};

//--------------------------------------------------------------------------------------------
// Loads OBJ
//
// Parses OBJ into an intermediate state object. The object will contain geometry data
// and material IDs from which meshes can be created later. The object will also
// contain a list of filenames of the MTL files referenced by the OBJ, is any.
//
// Originally based on the THREE.js OBJ and MTL loaders:
//
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/MTLLoader.js
//--------------------------------------------------------------------------------------------

var loadOBJ = function (modelNode, url, ok) {
    loadFile(url, function (text) {
            var state = parseOBJ(modelNode, text, url);
            ok(state);
        },
        function (error) {
            modelNode.error(error);
        });
};

var parseOBJ = (function () {

    var regexp = {
        // v float float float
        vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vn float float float
        normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vt float float
        uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // f vertex vertex vertex
        face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        // f vertex/uv vertex/uv vertex/uv
        face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
        face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        // f vertex//normal vertex//normal vertex//normal
        face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        // o object_name | g group_name
        object_pattern: /^[og]\s*(.+)?/,
        // s boolean
        smoothing_pattern: /^s\s+(\d+|on|off)/,
        // mtllib file_reference
        material_library_pattern: /^mtllib /,
        // usemtl material_name
        material_use_pattern: /^usemtl /
    };

    return function (modelNode, text, url) {

        url = url || "";

        var state = {
            src: url,
            basePath: getBasePath(url),
            objects: [],
            object: {},
            positions: [],
            normals: [],
            uv: [],
            materialLibraries: {}
        };

        startObject(state, "", false);

        // Parts of this parser logic are derived from the THREE.js OBJ loader:
        // https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js

        if (text.indexOf('\r\n') !== -1) {
            // This is faster than String.split with regex that splits on both
            text = text.replace('\r\n', '\n');
        }

        var lines = text.split('\n');
        var line = '', lineFirstChar = '', lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = (typeof ''.trimLeft === 'function');

        for (var i = 0, l = lines.length; i < l; i++) {

            line = lines[i];

            line = trimLeft ? line.trimLeft() : line.trim();

            lineLength = line.length;

            if (lineLength === 0) {
                continue;
            }

            lineFirstChar = line.charAt(0);

            if (lineFirstChar === '#') {
                continue;
            }

            if (lineFirstChar === 'v') {

                lineSecondChar = line.charAt(1);

                if (lineSecondChar === ' ' && (result = regexp.vertex_pattern.exec(line)) !== null) {

                    // 0                  1      2      3
                    // ['v 1.0 2.0 3.0', '1.0', '2.0', '3.0']

                    state.positions.push(
                        parseFloat(result[1]),
                        parseFloat(result[2]),
                        parseFloat(result[3])
                    );

                } else if (lineSecondChar === 'n' && (result = regexp.normal_pattern.exec(line)) !== null) {

                    // 0                   1      2      3
                    // ['vn 1.0 2.0 3.0', '1.0', '2.0', '3.0']

                    state.normals.push(
                        parseFloat(result[1]),
                        parseFloat(result[2]),
                        parseFloat(result[3])
                    );

                } else if (lineSecondChar === 't' && (result = regexp.uv_pattern.exec(line)) !== null) {

                    // 0               1      2
                    // ['vt 0.1 0.2', '0.1', '0.2']

                    state.uv.push(
                        parseFloat(result[1]),
                        parseFloat(result[2])
                    );

                } else {

                    modelNode.error('Unexpected vertex/normal/uv line: \'' + line + '\'');
                    return;
                }

            } else if (lineFirstChar === 'f') {

                if ((result = regexp.face_vertex_uv_normal.exec(line)) !== null) {

                    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
                    // 0                        1    2    3    4    5    6    7    8    9   10         11         12
                    // ['f 1/1/1 2/2/2 3/3/3', '1', '1', '1', '2', '2', '2', '3', '3', '3', undefined, undefined, undefined]

                    addFace(state,
                        result[1], result[4], result[7], result[10],
                        result[2], result[5], result[8], result[11],
                        result[3], result[6], result[9], result[12]
                    );

                } else if ((result = regexp.face_vertex_uv.exec(line)) !== null) {

                    // f vertex/uv vertex/uv vertex/uv
                    // 0                  1    2    3    4    5    6   7          8
                    // ['f 1/1 2/2 3/3', '1', '1', '2', '2', '3', '3', undefined, undefined]

                    addFace(state,
                        result[1], result[3], result[5], result[7],
                        result[2], result[4], result[6], result[8]
                    );

                } else if ((result = regexp.face_vertex_normal.exec(line)) !== null) {

                    // f vertex//normal vertex//normal vertex//normal
                    // 0                     1    2    3    4    5    6   7          8
                    // ['f 1//1 2//2 3//3', '1', '1', '2', '2', '3', '3', undefined, undefined]

                    addFace(state,
                        result[1], result[3], result[5], result[7],
                        undefined, undefined, undefined, undefined,
                        result[2], result[4], result[6], result[8]
                    );

                } else if ((result = regexp.face_vertex.exec(line)) !== null) {

                    // f vertex vertex vertex
                    // 0            1    2    3   4
                    // ['f 1 2 3', '1', '2', '3', undefined]

                    addFace(state, result[1], result[2], result[3], result[4]);
                } else {
                    modelNode.error('Unexpected face line: \'' + line + '\'');
                    return;
                }

            } else if (lineFirstChar === 'l') {

                var lineParts = line.substring(1).trim().split(' ');
                var lineVertices = [], lineUVs = [];

                if (line.indexOf('/') === -1) {

                    lineVertices = lineParts;

                } else {
                    for (var li = 0, llen = lineParts.length; li < llen; li++) {
                        var parts = lineParts[li].split('/');
                        if (parts[0] !== '') {
                            lineVertices.push(parts[0]);
                        }
                        if (parts[1] !== '') {
                            lineUVs.push(parts[1]);
                        }
                    }
                }
                addLineGeometry(state, lineVertices, lineUVs);

            } else if ((result = regexp.object_pattern.exec(line)) !== null) {

                // o object_name
                // or
                // g group_name

                var id = result[0].substr(1).trim();
                startObject(state, id, true);

            } else if (regexp.material_use_pattern.test(line)) {

                // material

                var id = line.substring(7).trim();
                state.object.material.id = id;

            } else if (regexp.material_library_pattern.test(line)) {

                // mtl file

                state.materialLibraries[line.substring(7).trim()] = true;

            } else if ((result = regexp.smoothing_pattern.exec(line)) !== null) {

                // smooth shading

                var value = result[1].trim().toLowerCase();
                state.object.material.smooth = (value === '1' || value === 'on');

            } else {

                // Handle null terminated files without exception
                if (line === '\0') {
                    continue;
                }

                modelNode.error('Unexpected line: \'' + line + '\'');
                return;
            }
        }

        return state;
    };

    function getBasePath(src) {
        var n = src.lastIndexOf('/');
        return (n === -1) ? src : src.substring(0, n + 1);
    }

    function startObject(state, id, fromDeclaration) {
        if (state.object && state.object.fromDeclaration === false) {
            state.object.id = id;
            state.object.fromDeclaration = (fromDeclaration !== false);
            return;
        }
        state.object = {
            id: id || '',
            geometry: {
                positions: [],
                normals: [],
                uv: []
            },
            material: {
                id: '',
                smooth: true
            },
            fromDeclaration: (fromDeclaration !== false)
        };
        state.objects.push(state.object);
    }

    function parseVertexIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }

    function parseNormalIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }

    function parseUVIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 2) * 2;
    }

    function addVertex(state, a, b, c) {
        var src = state.positions;
        var dst = state.object.geometry.positions;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
        dst.push(src[b + 0]);
        dst.push(src[b + 1]);
        dst.push(src[b + 2]);
        dst.push(src[c + 0]);
        dst.push(src[c + 1]);
        dst.push(src[c + 2]);
    }

    function addVertexLine(state, a) {
        var src = state.positions;
        var dst = state.object.geometry.positions;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
    }

    function addNormal(state, a, b, c) {
        var src = state.normals;
        var dst = state.object.geometry.normals;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[a + 2]);
        dst.push(src[b + 0]);
        dst.push(src[b + 1]);
        dst.push(src[b + 2]);
        dst.push(src[c + 0]);
        dst.push(src[c + 1]);
        dst.push(src[c + 2]);
    }

    function addUV(state, a, b, c) {
        var src = state.uv;
        var dst = state.object.geometry.uv;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
        dst.push(src[b + 0]);
        dst.push(src[b + 1]);
        dst.push(src[c + 0]);
        dst.push(src[c + 1]);
    }

    function addUVLine(state, a) {
        var src = state.uv;
        var dst = state.object.geometry.uv;
        dst.push(src[a + 0]);
        dst.push(src[a + 1]);
    }

    function addFace(state, a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
        var vLen = state.positions.length;
        var ia = parseVertexIndex(a, vLen);
        var ib = parseVertexIndex(b, vLen);
        var ic = parseVertexIndex(c, vLen);
        var id;
        if (d === undefined) {
            addVertex(state, ia, ib, ic);

        } else {
            id = parseVertexIndex(d, vLen);
            addVertex(state, ia, ib, id);
            addVertex(state, ib, ic, id);
        }

        if (ua !== undefined) {

            var uvLen = state.uv.length;

            ia = parseUVIndex(ua, uvLen);
            ib = parseUVIndex(ub, uvLen);
            ic = parseUVIndex(uc, uvLen);

            if (d === undefined) {
                addUV(state, ia, ib, ic);

            } else {
                id = parseUVIndex(ud, uvLen);
                addUV(state, ia, ib, id);
                addUV(state, ib, ic, id);
            }
        }

        if (na !== undefined) {

            // Normals are many times the same. If so, skip function call and parseInt.

            var nLen = state.normals.length;

            ia = parseNormalIndex(na, nLen);
            ib = na === nb ? ia : parseNormalIndex(nb, nLen);
            ic = na === nc ? ia : parseNormalIndex(nc, nLen);

            if (d === undefined) {
                addNormal(state, ia, ib, ic);

            } else {

                id = parseNormalIndex(nd, nLen);
                addNormal(state, ia, ib, id);
                addNormal(state, ib, ic, id);
            }
        }
    }

    function addLineGeometry(state, positions, uv) {

        state.object.geometry.type = 'Line';

        var vLen = state.positions.length;
        var uvLen = state.uv.length;

        for (var vi = 0, l = positions.length; vi < l; vi++) {
            addVertexLine(state, parseVertexIndex(positions[vi], vLen));
        }

        for (var uvi = 0, uvl = uv.length; uvi < uvl; uvi++) {
            addUVLine(state, parseUVIndex(uv[uvi], uvLen));
        }
    }
})();

//--------------------------------------------------------------------------------------------
// Loads MTL files listed in parsed state
//--------------------------------------------------------------------------------------------

function loadMTLs(modelNode, state, ok) {
    var basePath = state.basePath;
    var srcList = Object.keys(state.materialLibraries);
    var numToLoad = srcList.length;
    for (var i = 0, len = numToLoad; i < len; i++) {
        loadMTL(modelNode, basePath, basePath + srcList[i], function () {
            if (--numToLoad === 0) {
                ok();
            }
        });
    }
}

//--------------------------------------------------------------------------------------------
// Loads an MTL file
//--------------------------------------------------------------------------------------------

var loadMTL = function (modelNode, basePath, src, ok) {
    loadFile(src, function (text) {
            parseMTL(modelNode, text, basePath);
            ok();
        },
        function (error) {
            modelNode.error(error);
            ok();
        });
};

var parseMTL = (function () {

    var delimiter_pattern = /\s+/;

    return function (modelNode, mtlText, basePath) {

        var lines = mtlText.split('\n');
        var materialCfg = {
            id: "Default"
        };
        var needCreate = false;
        var line;
        var pos;
        var key;
        var value;
        var alpha;

        basePath = basePath || "";

        for (var i = 0; i < lines.length; i++) {

            line = lines[i].trim();

            if (line.length === 0 || line.charAt(0) === '#') { // Blank line or comment ignore
                continue;
            }

            pos = line.indexOf(' ');

            key = (pos >= 0) ? line.substring(0, pos) : line;
            key = key.toLowerCase();

            value = (pos >= 0) ? line.substring(pos + 1) : '';
            value = value.trim();

            switch (key.toLowerCase()) {

                case "newmtl": // New material
                    //if (needCreate) {
                    createMaterial(modelNode, materialCfg);
                    //}
                    materialCfg = {
                        id: value
                    };
                    needCreate = true;
                    break;

                case 'ka':
                    materialCfg.ambient = parseRGB(value);
                    break;

                case 'kd':
                    materialCfg.diffuse = parseRGB(value);
                    break;

                case 'ks':
                    materialCfg.specular = parseRGB(value);
                    break;

                case 'map_kd':
                    if (!materialCfg.diffuseMap) {
                        materialCfg.diffuseMap = createTexture(modelNode, basePath, value, "sRGB");
                    }
                    break;

                case 'map_ks':
                    if (!materialCfg.specularMap) {
                        materialCfg.specularMap = createTexture(modelNode, basePath, value, "linear");
                    }
                    break;

                case 'map_bump':
                case 'bump':
                    if (!materialCfg.normalMap) {
                        materialCfg.normalMap = createTexture(modelNode, basePath, value);
                    }
                    break;

                case 'ns':
                    materialCfg.shininess = parseFloat(value);
                    break;

                case 'd':
                    alpha = parseFloat(value);
                    if (alpha < 1) {
                        materialCfg.alpha = alpha;
                        materialCfg.alphaMode = "blend";
                    }
                    break;

                case 'tr':
                    alpha = parseFloat(value);
                    if (alpha > 0) {
                        materialCfg.alpha = 1 - alpha;
                        materialCfg.alphaMode = "blend";
                    }
                    break;
                // modelNode.error("Unrecognized token: " + key);
            }
        }

        if (needCreate) {
            createMaterial(modelNode, materialCfg);
        }
    };

    function createTexture(modelNode, basePath, value, encoding) {
        var textureCfg = {};
        var items = value.split(/\s+/);
        var pos = items.indexOf('-bm');
        if (pos >= 0) {
            //matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
        }
        pos = items.indexOf('-s');
        if (pos >= 0) {
            textureCfg.scale = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        pos = items.indexOf('-o');
        if (pos >= 0) {
            textureCfg.translate = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        textureCfg.src = basePath + items.join(' ').trim();
        textureCfg.flipY = true;
        textureCfg.encoding = encoding || "linear";
        //textureCfg.wrapS = self.wrap;
        //textureCfg.wrapT = self.wrap;
        var texture = new Texture(modelNode, textureCfg);
        return texture.id;
    }

    function createMaterial(modelNode, materialCfg) {
        new PhongMaterial(modelNode, materialCfg);
    }

    function parseRGB(value) {
        var ss = value.split(delimiter_pattern, 3);
        return [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
    }

})();
//--------------------------------------------------------------------------------------------
// Creates meshes from parsed state
//--------------------------------------------------------------------------------------------


function createMeshes(modelNode, state) {

    for (var j = 0, k = state.objects.length; j < k; j++) {

        var object = state.objects[j];
        var geometry = object.geometry;
        (geometry.type === 'Line');

        if (geometry.positions.length === 0) {
            // Skip o/g line declarations that did not follow with any faces
            continue;
        }

        var geometryCfg = {
            primitive: "triangles",
            compressGeometry: false
        };

        geometryCfg.positions = geometry.positions;

        if (geometry.normals.length > 0) {
            geometryCfg.normals = geometry.normals;
        }

        if (geometry.uv.length > 0) {
            geometryCfg.uv = geometry.uv;
        }

        var indices = new Array(geometryCfg.positions.length / 3); // Triangle soup
        for (var idx = 0; idx < indices.length; idx++) {
            indices[idx] = idx;
        }
        geometryCfg.indices = indices;

        var rtcCenter = tempVec3a$7;

        worldToRTCPositions(geometry.positions, geometry.positions, rtcCenter);

        var readableGeometry = new ReadableGeometry(modelNode, geometryCfg);

        var materialId = object.material.id;
        var material;
        if (materialId && materialId !== "") {
            material = modelNode.scene.components[materialId];
            if (!material) {
                modelNode.error("Material not found: " + materialId);
            }
        } else {
            material = new PhongMaterial(modelNode, {
                //emissive: [0.6, 0.6, 0.0],
                diffuse: [0.6, 0.6, 0.6],
                backfaces: true
            });

        }

        // material.emissive = [Math.random(), Math.random(), Math.random()];

        var mesh = new Mesh(modelNode, {
            id: modelNode.id + "#" + object.id,
            rtcCenter: (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0) ? rtcCenter : null,
            isObject: true,
            geometry: readableGeometry,
            material: material,
            pickable: true
        });

        modelNode.addChild(mesh);
    }
}

function loadFile(url, ok, err) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.addEventListener('load', function (event) {
        var response = event.target.response;
        if (this.status === 200) {
            if (ok) {
                ok(response);
            }
        } else if (this.status === 0) {
            // Some browsers return HTTP Status 0 when using non-http protocol
            // e.g. 'file://' or 'data://'. Handle as success.
            console.warn('loadFile: HTTP Status 0 received.');
            if (ok) {
                ok(response);
            }
        } else {
            if (err) {
                err(event);
            }
        }
    }, false);

    request.addEventListener('error', function (event) {
        if (err) {
            err(event);
        }
    }, false);
    request.send(null);
}

/**
 * {@link Viewer} plugin that loads models from [OBJ](https://en.wikipedia.org/wiki/Wavefront_.obj_file) files.
 *
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 *
 * ## Metadata
 *
 * OBJLoaderPlugin can also load an accompanying JSON metadata file with each model, which creates a {@link MetaModel} corresponding
 * to the model {@link Entity} and a {@link MetaObject} corresponding to each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding {@link Entity}. When loading
 * metadata, we can also provide GLTFModelLoaderPlugin with a custom lookup table of initial values to set on the properties of each type of {@link Entity}. By default, OBJLoaderPlugin
 * uses its own map of standard default colors, visibilities and opacities for IFC element types.

 *
 * ## Usage
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#loading_OBJ_SportsCar)]
 *
 * ````javascript
 * import {Viewer, OBJLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a xeokit Viewer and arrange the camera
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.camera.orbitPitch(20);
 *
 * // Add an OBJLoaderPlugin to the Viewer
 * const objLoader = new OBJLoaderPlugin(viewer);
 *
 * // Load an OBJ model
 * var model = objLoader.load({ // Model is an Entity
 *      id: "myModel",
 *      src: "./models/obj/sportsCar/sportsCar.obj",
 *      edges: true
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", () => {
 *      viewer.cameraFlight.flyTo(model);
 * })
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Update properties of the model Entity
 * model.highlight = [1,0,0];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 * @class OBJLoaderPlugin
 */
var OBJLoaderPlugin = /*@__PURE__*/(function (Plugin) {
    function OBJLoaderPlugin(viewer, cfg) {

        Plugin.call(this, "OBJLoader", viewer, cfg);

        /**
         * @private
         */
        this._sceneGraphLoader = new OBJSceneGraphLoader();
    }

    if ( Plugin ) OBJLoaderPlugin.__proto__ = Plugin;
    OBJLoaderPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    OBJLoaderPlugin.prototype.constructor = OBJLoaderPlugin;

    /**
     * Loads an OBJ model from a file into this OBJLoader's {@link Viewer}.
     *
     * @param {*} params  Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} params.src Path to an OBJ file.
     * @param {String} [params.metaModelSrc] Path to an optional metadata file.
     * @param {Number[]} [params.position=[0,0,0]] The model World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */
    OBJLoaderPlugin.prototype.load = function load (params) {
        var this$1 = this;
        if ( params === void 0 ) params = {};


        if (params.id && this.viewer.scene.components[params.id]) {
            this.error("Component with this ID already exists in viewer: " + params.id + " - will autogenerate this ID");
            delete params.id;
        }

        var modelNode = new Node(this.viewer.scene, utils.apply(params, {
            isModel: true
        }));

        var modelId = modelNode.id;  // In case ID was auto-generated
        var src = params.src;

        if (!src) {
            this.error("load() param expected: src");
            return modelNode;
        }

        if (params.metaModelSrc) {
            var metaModelSrc = params.metaModelSrc;
            utils.loadJSON(metaModelSrc,
                function (modelMetadata) {
                    this$1.viewer.metaScene.createMetaModel(modelId, modelMetadata);
                    this$1._sceneGraphLoader.load(modelNode, src, params);
                },
                function (errMsg) {
                    this$1.error(("load(): Failed to load model modelMetadata for model '" + modelId + " from  '" + metaModelSrc + "' - " + errMsg));
                });
        } else {
            this._sceneGraphLoader.load(modelNode, src, params);
        }

        modelNode.once("destroyed", function () {
            this$1.viewer.metaScene.destroyMetaModel(modelId);
        });

        return modelNode;
    };

    /**
     * Destroys this OBJLoaderPlugin.
     */
    OBJLoaderPlugin.prototype.destroy = function destroy () {
        Plugin.prototype.destroy.call(this);
    };

    return OBJLoaderPlugin;
}(Plugin));

/**
 * @desc Creates a torus-shaped {@link Geometry}.
 *
 * ## Usage
 * Creating a {@link Mesh} with a torus-shaped {@link ReadableGeometry} :
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]
 * 
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0,0,0],
 *          radius: 1.0,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         diffuseMap: new Texture(viewer.scene, {
 *             src: "textures/diffuse/uvGrid2.jpg"
 *         })
 *      })
 * });
 * ````
 *
 * @function buildTorusGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center] 3D point indicating the center position.
 * @param {Number} [cfg.radius=1] The overall radius.
 * @param {Number} [cfg.tube=0.3] The tube radius.
 * @param {Number} [cfg.radialSegments=32] The number of radial segments.
 * @param {Number} [cfg.tubeSegments=24] The number of tubular segments.
 * @param {Number} [cfg.arc=Math.PI*0.5] The length of the arc in radians, where Math.PI*2 is a closed torus.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildTorusGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var radius = cfg.radius || 1;
    if (radius < 0) {
        console.error("negative radius not allowed - will invert");
        radius *= -1;
    }
    radius *= 0.5;

    var tube = cfg.tube || 0.3;
    if (tube < 0) {
        console.error("negative tube not allowed - will invert");
        tube *= -1;
    }

    var radialSegments = cfg.radialSegments || 32;
    if (radialSegments < 0) {
        console.error("negative radialSegments not allowed - will invert");
        radialSegments *= -1;
    }
    if (radialSegments < 4) {
        radialSegments = 4;
    }

    var tubeSegments = cfg.tubeSegments || 24;
    if (tubeSegments < 0) {
        console.error("negative tubeSegments not allowed - will invert");
        tubeSegments *= -1;
    }
    if (tubeSegments < 4) {
        tubeSegments = 4;
    }

    var arc = cfg.arc || Math.PI * 2;
    if (arc < 0) {
        console.warn("negative arc not allowed - will invert");
        arc *= -1;
    }
    if (arc > 360) {
        arc = 360;
    }

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;

    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    var u;
    var v;
    var x;
    var y;
    var z;
    var vec;

    var i;
    var j;

    for (j = 0; j <= tubeSegments; j++) {
        for (i = 0; i <= radialSegments; i++) {

            u = i / radialSegments * arc;
            v = 0.785398 + (j / tubeSegments * Math.PI * 2);

            centerX = radius * Math.cos(u);
            centerY = radius * Math.sin(u);

            x = (radius + tube * Math.cos(v)) * Math.cos(u);
            y = (radius + tube * Math.cos(v)) * Math.sin(u);
            z = tube * Math.sin(v);

            positions.push(x + centerX);
            positions.push(y + centerY);
            positions.push(z + centerZ);

            uvs.push(1 - (i / radialSegments));
            uvs.push((j / tubeSegments));

            vec = math.normalizeVec3(math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);

            normals.push(vec[0]);
            normals.push(vec[1]);
            normals.push(vec[2]);
        }
    }

    var a;
    var b;
    var c;
    var d;

    for (j = 1; j <= tubeSegments; j++) {
        for (i = 1; i <= radialSegments; i++) {

            a = (radialSegments + 1) * j + i - 1;
            b = (radialSegments + 1) * (j - 1) + i - 1;
            c = (radialSegments + 1) * (j - 1) + i;
            d = (radialSegments + 1) * j + i;

            indices.push(a);
            indices.push(b);
            indices.push(c);

            indices.push(c);
            indices.push(d);
            indices.push(a);
        }
    }

    return utils.apply(cfg, {
        positions: positions,
        normals: normals,
        uv: uvs,
        indices: indices
    });
}

var zeroVec$1 = new Float64Array([0, 0, 1]);
var quat = new Float64Array(4);

/**
 * Controls a {@link SectionPlane} with mouse and touch input.
 *
 * @private
 */
var Control = function Control(plugin) {

    /**
     * ID of this Control.
     *
     * SectionPlaneControls are mapped by this ID in {@link SectionPlanesPlugin#sectionPlaneControls}.
     *
     * @property id
     * @type {String|Number}
     */
    this.id = null;

    this._viewer = plugin.viewer;

    this._visible = false;
    this._pos = math.vec3(); // Full-precision position of the center of the Control
    this._rtcCenter = math.vec3();
    this._rtcPos = math.vec3();

    this._baseDir = math.vec3(); // Saves direction of clip plane when we start dragging an arrow or ring.
    this._rootNode = null; // Root of Node graph that represents this control in the 3D scene
    this._displayMeshes = null; // Meshes that are always visible
    this._affordanceMeshes = null; // Meshes displayed momentarily for affordance

    this._ignoreNextSectionPlaneDirUpdate = false;

    this._createNodes();
    this._bindEvents();
};

var prototypeAccessors$2 = { sectionPlane: { configurable: true } };

/**
 * Called by SectionPlanesPlugin to assign this Control to a SectionPlane.
 * SectionPlanesPlugin keeps SectionPlaneControls in a reuse pool.
 * Call with a null or undefined value to disconnect the Control ffrom whatever SectionPlane it was assigned to.
 * @private
 */
Control.prototype._setSectionPlane = function _setSectionPlane (sectionPlane) {
        var this$1 = this;

    if (this._sectionPlane) {
        this._sectionPlane.off(this._onSectionPlanePos);
        this._sectionPlane.off(this._onSectionPlaneDir);
        this._onSectionPlanePos = null;
        this._onSectionPlaneDir = null;
        this._sectionPlane = null;
    }
    if (sectionPlane) {
        this.id = sectionPlane.id;
        this._setPos(sectionPlane.pos);
        this._setDir(sectionPlane.dir);
        this._sectionPlane = sectionPlane;
        this._onSectionPlanePos = sectionPlane.on("pos", function () {
            this$1._setPos(this$1._sectionPlane.pos);
        });
        this._onSectionPlaneDir = sectionPlane.on("dir", function () {
            if (!this$1._ignoreNextSectionPlaneDirUpdate) {
                this$1._setDir(this$1._sectionPlane.dir);
            } else {
                this$1._ignoreNextSectionPlaneDirUpdate = false;
            }
        });
    }
};

/**
 * Gets the {@link SectionPlane} controlled by this Control.
 * @returns {SectionPlane} The SectionPlane.
 */
prototypeAccessors$2.sectionPlane.get = function () {
    return this._sectionPlane;
};

/** @private */
Control.prototype._setPos = function _setPos (xyz) {

    this._pos.set(xyz);

    worldToRTCPos(this._pos, this._rtcCenter, this._rtcPos);

    this._rootNode.rtcCenter = this._rtcCenter;
    this._rootNode.position = this._rtcPos;
};

/** @private */
Control.prototype._setDir = function _setDir (xyz) {
    this._baseDir.set(xyz);
    this._rootNode.quaternion = math.vec3PairToQuaternion(zeroVec$1, xyz, quat);
};

Control.prototype._setSectionPlaneDir = function _setSectionPlaneDir (dir) {
    if (this._sectionPlane) {
        this._ignoreNextSectionPlaneDirUpdate = true;
        this._sectionPlane.dir = dir;
    }
};

/**
 * Sets if this Control is visible.
 *
 * @type {Boolean}
 */
Control.prototype.setVisible = function setVisible (visible) {
        if ( visible === void 0 ) visible = true;

    if (this._visible === visible) {
        return;
    }
    this._visible = visible;
    var id;
    for (id in this._displayMeshes) {
        if (this._displayMeshes.hasOwnProperty(id)) {
            this._displayMeshes[id].visible = visible;
        }
    }
    if (!visible) {
        for (id in this._affordanceMeshes) {
            if (this._affordanceMeshes.hasOwnProperty(id)) {
                this._affordanceMeshes[id].visible = visible;
            }
        }
    }
};

/**
 * Gets if this Control is visible.
 *
 * @type {Boolean}
 */
Control.prototype.getVisible = function getVisible () {
    return this._visible;
};

/**
 * Sets if this Control is culled. This is called by SectionPlanesPlugin to
 * temporarily hide the Control while a snapshot is being taken by Viewer#getSnapshot().
 * @param culled
 */
Control.prototype.setCulled = function setCulled (culled) {
    var id;
    for (id in this._displayMeshes) {
        if (this._displayMeshes.hasOwnProperty(id)) {
            this._displayMeshes[id].culled = culled;
        }
    }
    if (!culled) {
        for (id in this._affordanceMeshes) {
            if (this._affordanceMeshes.hasOwnProperty(id)) {
                this._affordanceMeshes[id].culled = culled;
            }
        }
    }
};

/**
 * Builds the Entities that represent this Control.
 * @private
 */
Control.prototype._createNodes = function _createNodes () {

    var NO_STATE_INHERIT = false;
    var scene = this._viewer.scene;
    var radius = 1.0;
    var handleTubeRadius = 0.06;
    var hoopRadius = radius - 0.2;
    var tubeRadius = 0.01;
    var arrowRadius = 0.07;

    this._rootNode = new Node(scene, {
        position: [0, 0, 0],
        scale: [5, 5, 5]
    });

    var rootNode = this._rootNode;

    var shapes = {// Reusable geometries

        arrowHead: new ReadableGeometry(rootNode, buildCylinderGeometry({
            radiusTop: 0.001,
            radiusBottom: arrowRadius,
            radialSegments: 32,
            heightSegments: 1,
            height: 0.2,
            openEnded: false
        })),

        arrowHeadBig: new ReadableGeometry(rootNode, buildCylinderGeometry({
            radiusTop: 0.001,
            radiusBottom: 0.09,
            radialSegments: 32,
            heightSegments: 1,
            height: 0.25,
            openEnded: false
        })),

        arrowHeadHandle: new ReadableGeometry(rootNode, buildCylinderGeometry({
            radiusTop: 0.09,
            radiusBottom: 0.09,
            radialSegments: 8,
            heightSegments: 1,
            height: 0.37,
            openEnded: false
        })),

        curve: new ReadableGeometry(rootNode, buildTorusGeometry({
            radius: hoopRadius,
            tube: tubeRadius,
            radialSegments: 64,
            tubeSegments: 14,
            arc: (Math.PI * 2.0) / 4.0
        })),

        curveHandle: new ReadableGeometry(rootNode, buildTorusGeometry({
            radius: hoopRadius,
            tube: handleTubeRadius,
            radialSegments: 64,
            tubeSegments: 14,
            arc: (Math.PI * 2.0) / 4.0
        })),

        hoop: new ReadableGeometry(rootNode, buildTorusGeometry({
            radius: hoopRadius,
            tube: tubeRadius,
            radialSegments: 64,
            tubeSegments: 8,
            arc: (Math.PI * 2.0)
        })),

        axis: new ReadableGeometry(rootNode, buildCylinderGeometry({
            radiusTop: tubeRadius,
            radiusBottom: tubeRadius,
            radialSegments: 20,
            heightSegments: 1,
            height: radius,
            openEnded: false
        })),

        axisHandle: new ReadableGeometry(rootNode, buildCylinderGeometry({
            radiusTop: 0.08,
            radiusBottom: 0.08,
            radialSegments: 20,
            heightSegments: 1,
            height: radius,
            openEnded: false
        }))
    };

    var materials = { // Reusable materials

        pickable: new PhongMaterial(rootNode, { // Invisible material for pickable handles, which define a pickable 3D area
            diffuse: [1, 1, 0],
            alpha: 0, // Invisible
            alphaMode: "blend"
        }),

        red: new PhongMaterial(rootNode, {
            diffuse: [1, 0.0, 0.0],
            emissive: [1, 0.0, 0.0],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        }),

        highlightRed: new EmphasisMaterial(rootNode, { // Emphasis for red rotation affordance hoop
            edges: false,
            fill: true,
            fillColor: [1, 0, 0],
            fillAlpha: 0.6
        }),

        green: new PhongMaterial(rootNode, {
            diffuse: [0.0, 1, 0.0],
            emissive: [0.0, 1, 0.0],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        }),

        highlightGreen: new EmphasisMaterial(rootNode, { // Emphasis for green rotation affordance hoop
            edges: false,
            fill: true,
            fillColor: [0, 1, 0],
            fillAlpha: 0.6
        }),

        blue: new PhongMaterial(rootNode, {
            diffuse: [0.0, 0.0, 1],
            emissive: [0.0, 0.0, 1],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80,
            lineWidth: 2
        }),

        highlightBlue: new EmphasisMaterial(rootNode, { // Emphasis for blue rotation affordance hoop
            edges: false,
            fill: true,
            fillColor: [0, 0, 1],
            fillAlpha: 0.2
        }),

        center: new PhongMaterial(rootNode, {
            diffuse: [0.0, 0.0, 0.0],
            emissive: [0, 0, 0],
            ambient: [0.0, 0.0, 0.0],
            specular: [.6, .6, .3],
            shininess: 80
        }),

        highlightBall: new EmphasisMaterial(rootNode, {
            edges: false,
            fill: true,
            fillColor: [0.5, 0.5, 0.5],
            fillAlpha: 0.5,
            vertices: false
        }),

        highlightPlane: new EmphasisMaterial(rootNode, {
            edges: true,
            edgeWidth: 3,
            fill: false,
            fillColor: [0.5, 0.5, .5],
            fillAlpha: 0.5,
            vertices: false
        })
    };

    this._displayMeshes = {

        plane: rootNode.addChild(new Mesh(rootNode, {
            geometry: new ReadableGeometry(rootNode, {
                primitive: "triangles",
                positions: [
                    0.5, 0.5, 0.0, 0.5, -0.5, 0.0, // 0
                    -0.5, -0.5, 0.0, -0.5, 0.5, 0.0, // 1
                    0.5, 0.5, -0.0, 0.5, -0.5, -0.0, // 2
                    -0.5, -0.5, -0.0, -0.5, 0.5, -0.0 // 3
                ],
                indices: [0, 1, 2, 2, 3, 0]
            }),
            material: new PhongMaterial(rootNode, {
                emissive: [0, 0.0, 0],
                diffuse: [0, 0, 0],
                backfaces: true
            }),
            opacity: 0.6,
            ghosted: true,
            ghostMaterial: new EmphasisMaterial(rootNode, {
                edges: false,
                filled: true,
                fillColor: [1, 1, 0],
                edgeColor: [0, 0, 0],
                fillAlpha: 0.1,
                backfaces: true
            }),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false,
            scale: [2.4, 2.4, 1]
        }), NO_STATE_INHERIT),

        planeFrame: rootNode.addChild(new Mesh(rootNode, { // Visible frame
            geometry: new ReadableGeometry(rootNode, buildTorusGeometry({
                center: [0, 0, 0],
                radius: 1.7,
                tube: tubeRadius * 2,
                radialSegments: 4,
                tubeSegments: 4,
                arc: Math.PI * 2.0
            })),
            material: new PhongMaterial(rootNode, {
                emissive: [0, 0, 0],
                diffuse: [0, 0, 0],
                specular: [0, 0, 0],
                shininess: 0
            }),
            //highlighted: true,
            highlightMaterial: new EmphasisMaterial(rootNode, {
                edges: false,
                edgeColor: [0.0, 0.0, 0.0],
                filled: true,
                fillColor: [0.8, 0.8, 0.8],
                fillAlpha: 1.0
            }),
            pickable: false,
            collidable: false,
            clippable: false,
            visible: false,
            scale: [1, 1, .1],
            rotation: [0, 0, 45]
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        xCurve: rootNode.addChild(new Mesh(rootNode, { // Red hoop about Y-axis
            geometry: shapes.curve,
            material: materials.red,
            matrix: (function () {
                var rotate2 = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4());
                var rotate1 = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate1, rotate2, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            backfaces: true,
            visible: false
        }), NO_STATE_INHERIT),

        xCurveHandle: rootNode.addChild(new Mesh(rootNode, { // Red hoop about Y-axis
            geometry: shapes.curveHandle,
            material: materials.pickable,
            matrix: (function () {
                var rotate2 = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4());
                var rotate1 = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate1, rotate2, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            backfaces: true,
            visible: false
        }), NO_STATE_INHERIT),

        xCurveArrow1: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.red,
            matrix: (function () {
                var translate = math.translateMat4c(0., -0.07, -0.8, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                var rotate = math.rotationMat4v(0 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(math.mulMat4(translate, scale, math.identityMat4()), rotate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        xCurveArrow2: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.red,
            matrix: (function () {
                var translate = math.translateMat4c(0.0, -0.8, -0.07, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                var rotate = math.rotationMat4v(90 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(math.mulMat4(translate, scale, math.identityMat4()), rotate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        yCurve: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.curve,
            material: materials.green,
            rotation: [-90, 0, 0],
            pickable: false,
            collidable: true,
            clippable: false,
            backfaces: true,
            visible: false
        }), NO_STATE_INHERIT),

        yCurveHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.curveHandle,
            material: materials.pickable,
            rotation: [-90, 0, 0],
            pickable: true,
            collidable: true,
            clippable: false,
            backfaces: true,
            visible: false
        }), NO_STATE_INHERIT),

        yCurveArrow1: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.green,
            matrix: (function () {
                var translate = math.translateMat4c(0.07, 0, -0.8, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                var rotate = math.rotationMat4v(90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(math.mulMat4(translate, scale, math.identityMat4()), rotate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        yCurveArrow2: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.green,
            matrix: (function () {
                var translate = math.translateMat4c(0.8, 0.0, -0.07, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                var rotate = math.rotationMat4v(90 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(math.mulMat4(translate, scale, math.identityMat4()), rotate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        zCurve: rootNode.addChild(new Mesh(rootNode, { // Blue hoop about Z-axis
            geometry: shapes.curve,
            material: materials.blue,
            matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zCurveHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.curveHandle,
            material: materials.pickable,
            matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zCurveCurveArrow1: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.blue,
            matrix: (function () {
                var translate = math.translateMat4c(.8, -0.07, 0, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                return math.mulMat4(translate, scale, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zCurveArrow2: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.blue,
            matrix: (function () {
                var translate = math.translateMat4c(.05, -0.8, 0, math.identityMat4());
                var scale = math.scaleMat4v([0.6, 0.6, 0.6], math.identityMat4());
                var rotate = math.rotationMat4v(90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(math.mulMat4(translate, scale, math.identityMat4()), rotate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        center: rootNode.addChild(new Mesh(rootNode, {
            geometry: new ReadableGeometry(rootNode, buildSphereGeometry({
                radius: 0.05
            })),
            material: materials.center,
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        xAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.red,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        xAxisArrowHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadHandle,
            material: materials.pickable,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        xAxis: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axis,
            material: materials.red,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius / 2, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        xAxisHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axisHandle,
            material: materials.pickable,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius / 2, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        yAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.green,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        yAxisArrowHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadHandle,
            material: materials.pickable,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false,
            opacity: 0.2
        }), NO_STATE_INHERIT),

        yShaft: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axis,
            material: materials.green,
            position: [0, -radius / 2, 0],
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        yShaftHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axisHandle,
            material: materials.pickable,
            position: [0, -radius / 2, 0],
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        //----------------------------------------------------------------------------------------------------------
        //
        //----------------------------------------------------------------------------------------------------------

        zAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHead,
            material: materials.blue,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0.8, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zAxisArrowHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadHandle,
            material: materials.pickable,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0.8, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: true,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),


        zShaft: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axis,
            material: materials.blue,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius / 2, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            clippable: false,
            pickable: false,
            collidable: true,
            visible: false
        }), NO_STATE_INHERIT),

        zAxisHandle: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.axisHandle,
            material: materials.pickable,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius / 2, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            clippable: false,
            pickable: true,
            collidable: true,
            visible: false
        }), NO_STATE_INHERIT)
    };

    this._affordanceMeshes = {

        planeFrame: rootNode.addChild(new Mesh(rootNode, {
            geometry: new ReadableGeometry(rootNode, buildTorusGeometry({
                center: [0, 0, 0],
                radius: 2,
                tube: tubeRadius,
                radialSegments: 4,
                tubeSegments: 4,
                arc: Math.PI * 2.0
            })),
            material: new PhongMaterial(rootNode, {
                ambient: [1, 1, 1],
                diffuse: [0, 0, 0],
                emissive: [1, 1, 0]
            }),
            highlighted: true,
            highlightMaterial: new EmphasisMaterial(rootNode, {
                edges: false,
                filled: true,
                fillColor: [1, 1, 0],
                fillAlpha: 1.0
            }),
            pickable: false,
            collidable: false,
            clippable: false,
            visible: false,
            scale: [1, 1, 1],
            rotation: [0, 0, 45]
        }), NO_STATE_INHERIT),

        xHoop: rootNode.addChild(new Mesh(rootNode, { // Full
            geometry: shapes.hoop,
            material: materials.red,
            highlighted: true,
            highlightMaterial: materials.highlightRed,
            matrix: (function () {
                var rotate2 = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4());
                var rotate1 = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate1, rotate2, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        yHoop: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.hoop,
            material: materials.green,
            highlighted: true,
            highlightMaterial: materials.highlightGreen,
            rotation: [-90, 0, 0],
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zHoop: rootNode.addChild(new Mesh(rootNode, { // Blue hoop about Z-axis
            geometry: shapes.hoop,
            material: materials.blue,
            highlighted: true,
            highlightMaterial: materials.highlightBlue,
            matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()),
            pickable: false,
            collidable: true,
            clippable: false,
            backfaces: true,
            visible: false
        }), NO_STATE_INHERIT),

        xAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadBig,
            material: materials.red,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        yAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadBig,
            material: materials.green,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT),

        zAxisArrow: rootNode.addChild(new Mesh(rootNode, {
            geometry: shapes.arrowHeadBig,
            material: materials.blue,
            matrix: (function () {
                var translate = math.translateMat4c(0, radius + .1, 0, math.identityMat4());
                var rotate = math.rotationMat4v(-90 * math.DEGTORAD, [0.8, 0, 0], math.identityMat4());
                return math.mulMat4(rotate, translate, math.identityMat4());
            })(),
            pickable: false,
            collidable: true,
            clippable: false,
            visible: false
        }), NO_STATE_INHERIT)
    };
};

Control.prototype._bindEvents = function _bindEvents () {
        var this$1 = this;


    var self = this;

    var grabbed = false;

    var DRAG_ACTIONS = {
        none: -1,
        xTranslate: 0,
        yTranslate: 1,
        zTranslate: 2,
        xRotate: 3,
        yRotate: 4,
        zRotate: 5
    };

    var rootNode = this._rootNode;

    var nextDragAction = null; // As we hover grabbed an arrow or hoop, self is the action we would do if we then dragged it.
    var dragAction = null; // Action we're doing while we drag an arrow or hoop.
    var lastCanvasPos = math.vec2();

    var xBaseAxis = math.vec3([1, 0, 0]);
    var yBaseAxis = math.vec3([0, 1, 0]);
    var zBaseAxis = math.vec3([0, 0, 1]);

    var canvas = this._viewer.scene.canvas.canvas;
    var camera = this._viewer.camera;
    var scene = this._viewer.scene;

    { // Keep gizmo screen size constant

        var tempVec3a = math.vec3([0, 0, 0]);
        var lastDist = -1;

        this._onCameraViewMatrix = scene.camera.on("viewMatrix", function () {
        });

        this._onCameraProjMatrix = scene.camera.on("projMatrix", function () {
        });

        this._onSceneTick = scene.on("tick", function () {

            var dist = Math.abs(math.lenVec3(math.subVec3(scene.camera.eye, this$1._pos, tempVec3a)));

            if (dist !== lastDist) {
                if (camera.projection === "perspective") {
                    var worldSize = (Math.tan(camera.perspective.fov * math.DEGTORAD)) * dist;
                    var size = 0.07 * worldSize;
                    rootNode.scale = [size, size, size];
                    lastDist = dist;
                }
            }

            if (camera.projection === "ortho") {
                var worldSize$1 = camera.ortho.scale / 10;
                var size$1 = worldSize$1;
                rootNode.scale = [size$1, size$1, size$1];
                lastDist = dist;
            }
        });
    }

    var getClickCoordsWithinElement = (function () {
        var canvasPos = new Float64Array(2);
        return function (event) {
            if (!event) {
                event = window.event;
                canvasPos[0] = event.x;
                canvasPos[1] = event.y;
            } else {
                var element = event.target;
                var totalOffsetLeft = 0;
                var totalOffsetTop = 0;

                while (element.offsetParent) {
                    totalOffsetLeft += element.offsetLeft;
                    totalOffsetTop += element.offsetTop;
                    element = element.offsetParent;
                }
                canvasPos[0] = event.pageX - totalOffsetLeft;
                canvasPos[1] = event.pageY - totalOffsetTop;
            }
            return canvasPos;
        };
    })();

    var localToWorldVec = (function () {
        var mat = math.mat4();
        return function (localVec, worldVec) {
            math.quaternionToMat4(self._rootNode.quaternion, mat);
            math.transformVec3(mat, localVec, worldVec);
            math.normalizeVec3(worldVec);
            return worldVec;
        };
    })();

    var getTranslationPlane = (function () {
        var planeNormal = math.vec3();
        return function (worldAxis) {
            var absX = Math.abs(worldAxis[0]);
            if (absX > Math.abs(worldAxis[1]) && absX > Math.abs(worldAxis[2])) {
                math.cross3Vec3(worldAxis, [0, 1, 0], planeNormal);
            } else {
                math.cross3Vec3(worldAxis, [1, 0, 0], planeNormal);
            }
            math.cross3Vec3(planeNormal, worldAxis, planeNormal);
            math.normalizeVec3(planeNormal);
            return planeNormal;
        }
    })();

    var dragTranslateSectionPlane = (function () {
        var p1 = math.vec3();
        var p2 = math.vec3();
        var worldAxis = math.vec4();
        return function (baseAxis, fromMouse, toMouse) {
            localToWorldVec(baseAxis, worldAxis);
            var planeNormal = getTranslationPlane(worldAxis, fromMouse, toMouse);
            getPointerPlaneIntersect(fromMouse, planeNormal, p1);
            getPointerPlaneIntersect(toMouse, planeNormal, p2);
            math.subVec3(p2, p1);
            var dot = math.dotVec3(p2, worldAxis);
            self._pos[0] += worldAxis[0] * dot;
            self._pos[1] += worldAxis[1] * dot;
            self._pos[2] += worldAxis[2] * dot;
            self._rootNode.position = self._pos;
            if (self._sectionPlane) {
                self._sectionPlane.pos = self._pos;
            }
        }
    })();

    var dragRotateSectionPlane = (function () {
        var p1 = math.vec4();
        var p2 = math.vec4();
        var c = math.vec4();
        var worldAxis = math.vec4();
        return function (baseAxis, fromMouse, toMouse) {
            localToWorldVec(baseAxis, worldAxis);
            var hasData = getPointerPlaneIntersect(fromMouse, worldAxis, p1) && getPointerPlaneIntersect(toMouse, worldAxis, p2);
            if (!hasData) { // Find intersections with view plane and project down to origin
                var planeNormal = getTranslationPlane(worldAxis, fromMouse, toMouse);
                getPointerPlaneIntersect(fromMouse, planeNormal, p1, 1); // Ensure plane moves closer to camera so angles become workable
                getPointerPlaneIntersect(toMouse, planeNormal, p2, 1);
                var dot = math.dotVec3(p1, worldAxis);
                p1[0] -= dot * worldAxis[0];
                p1[1] -= dot * worldAxis[1];
                p1[2] -= dot * worldAxis[2];
                dot = math.dotVec3(p2, worldAxis);
                p2[0] -= dot * worldAxis[0];
                p2[1] -= dot * worldAxis[1];
                p2[2] -= dot * worldAxis[2];
            }
            math.normalizeVec3(p1);
            math.normalizeVec3(p2);
            dot = math.dotVec3(p1, p2);
            dot = math.clamp(dot, -1.0, 1.0); // Rounding errors cause dot to exceed allowed range
            var incDegrees = Math.acos(dot) * math.RADTODEG;
            math.cross3Vec3(p1, p2, c);
            if (math.dotVec3(c, worldAxis) < 0.0) {
                incDegrees = -incDegrees;
            }
            self._rootNode.rotate(baseAxis, incDegrees);
            rotateSectionPlane();
        }
    })();

    var getPointerPlaneIntersect = (function () {
        var dir = math.vec4([0, 0, 0, 1]);
        var matrix = math.mat4();
        return function (mouse, axis, dest, offset) {
            offset = offset || 0;
            dir[0] = mouse[0] / canvas.width * 2.0 - 1.0;
            dir[1] = -(mouse[1] / canvas.height * 2.0 - 1.0);
            dir[2] = 0.0;
            dir[3] = 1.0;
            math.mulMat4(camera.projMatrix, camera.viewMatrix, matrix); // Unproject norm device coords to view coords
            math.inverseMat4(matrix);
            math.transformVec4(matrix, dir, dir);
            math.mulVec4Scalar(dir, 1.0 / dir[3]); // This is now point A on the ray in world space
            var rayO = camera.eye; // The direction
            math.subVec4(dir, rayO, dir);
            var origin = self._sectionPlane.pos; // Plane origin:
            var d = -math.dotVec3(origin, axis) - offset;
            var dot = math.dotVec3(axis, dir);
            if (Math.abs(dot) > 0.005) {
                var t = -(math.dotVec3(axis, rayO) + d) / dot;
                math.mulVec3Scalar(dir, t, dest);
                math.addVec3(dest, rayO);
                math.subVec3(dest, origin, dest);
                return true;
            }
            return false;
        }
    })();

    var rotateSectionPlane = (function () {
        var dir = math.vec3();
        var mat = math.mat4();
        return function () {
            if (self.sectionPlane) {
                math.quaternionToMat4(rootNode.quaternion, mat);  // << ---
                math.transformVec3(mat, [0, 0, 1], dir);
                self._setSectionPlaneDir(dir);
            }
        };
    })();

    {
        var down = false;
        var lastAffordanceMesh;

        this._onCameraControlHover = this._viewer.cameraControl.on("hoverEnter", function (hit) {
            if (!this$1._visible) {
                return;
            }
            if (down) {
                return;
            }
            grabbed = false;
            if (lastAffordanceMesh) {
                lastAffordanceMesh.visible = false;
            }
            var affordanceMesh;
            var meshId = hit.entity.id;
            switch (meshId) {

                case this$1._displayMeshes.xAxisArrowHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.xAxisArrow;
                    nextDragAction = DRAG_ACTIONS.xTranslate;
                    break;

                case this$1._displayMeshes.xAxisHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.xAxisArrow;
                    nextDragAction = DRAG_ACTIONS.xTranslate;
                    break;

                case this$1._displayMeshes.yAxisArrowHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.yAxisArrow;
                    nextDragAction = DRAG_ACTIONS.yTranslate;
                    break;

                case this$1._displayMeshes.yShaftHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.yAxisArrow;
                    nextDragAction = DRAG_ACTIONS.yTranslate;
                    break;

                case this$1._displayMeshes.zAxisArrowHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.zAxisArrow;
                    nextDragAction = DRAG_ACTIONS.zTranslate;
                    break;

                case this$1._displayMeshes.zAxisHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.zAxisArrow;
                    nextDragAction = DRAG_ACTIONS.zTranslate;
                    break;

                case this$1._displayMeshes.xCurveHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.xHoop;
                    nextDragAction = DRAG_ACTIONS.xRotate;
                    break;

                case this$1._displayMeshes.yCurveHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.yHoop;
                    nextDragAction = DRAG_ACTIONS.yRotate;
                    break;

                case this$1._displayMeshes.zCurveHandle.id:
                    affordanceMesh = this$1._affordanceMeshes.zHoop;
                    nextDragAction = DRAG_ACTIONS.zRotate;
                    break;

                default:
                    nextDragAction = DRAG_ACTIONS.none;
                    return; // Not clicked an arrow or hoop
            }
            if (affordanceMesh) {
                affordanceMesh.visible = true;
            }
            lastAffordanceMesh = affordanceMesh;
            grabbed = true;
        });

        this._onCameraControlHoverLeave = this._viewer.cameraControl.on("hoverOut", function (hit) {
            if (!this$1._visible) {
                return;
            }
            if (lastAffordanceMesh) {
                lastAffordanceMesh.visible = false;
            }
            lastAffordanceMesh = null;
            nextDragAction = DRAG_ACTIONS.none;
        });

        canvas.addEventListener("mousedown", this._canvasMouseDownListener = function (e) {
            e.preventDefault();
            if (!this$1._visible) {
                return;
            }
            if (!grabbed) {
                return;
            }
            this$1._viewer.cameraControl.pointerEnabled = false;
            switch (e.which) {
                case 1: // Left button
                    down = true;
                    var canvasPos = getClickCoordsWithinElement(e);
                    dragAction = nextDragAction;
                    lastCanvasPos[0] = canvasPos[0];
                    lastCanvasPos[1] = canvasPos[1];
                    break;
            }
        });

        canvas.addEventListener("mousemove", this._canvasMouseMoveListener = function (e) {
            if (!this$1._visible) {
                return;
            }
            if (!down) {
                return;
            }
            var canvasPos = getClickCoordsWithinElement(e);
            var x = canvasPos[0];
            var y = canvasPos[1];

            switch (dragAction) {
                case DRAG_ACTIONS.xTranslate:
                    dragTranslateSectionPlane(xBaseAxis, lastCanvasPos, canvasPos);
                    break;
                case DRAG_ACTIONS.yTranslate:
                    dragTranslateSectionPlane(yBaseAxis, lastCanvasPos, canvasPos);
                    break;
                case DRAG_ACTIONS.zTranslate:
                    dragTranslateSectionPlane(zBaseAxis, lastCanvasPos, canvasPos);
                    break;
                case DRAG_ACTIONS.xRotate:
                    dragRotateSectionPlane(xBaseAxis, lastCanvasPos, canvasPos);
                    break;
                case DRAG_ACTIONS.yRotate:
                    dragRotateSectionPlane(yBaseAxis, lastCanvasPos, canvasPos);
                    break;
                case DRAG_ACTIONS.zRotate:
                    dragRotateSectionPlane(zBaseAxis, lastCanvasPos, canvasPos);
                    break;
            }

            lastCanvasPos[0] = x;
            lastCanvasPos[1] = y;
        });

        canvas.addEventListener("mouseup", this._canvasMouseUpListener = function (e) {
            if (!this$1._visible) {
                return;
            }
            this$1._viewer.cameraControl.pointerEnabled = true;
            if (!down) {
                return;
            }
            switch (e.which) {
                            }
            down = false;
            grabbed = false;
        });

        canvas.addEventListener("wheel", this._canvasWheelListener = function (e) {
            if (!this$1._visible) {
                return;
            }
            var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
            if (delta === 0) {
                return;
            }
        });
    }
};

Control.prototype._destroy = function _destroy () {
    this._unbindEvents();
    this._destroyNodes();
};

Control.prototype._unbindEvents = function _unbindEvents () {

    var viewer = this._viewer;
    var scene = viewer.scene;
    var canvas = scene.canvas.canvas;
    var camera = viewer.camera;
    var cameraControl = viewer.cameraControl;

    scene.off(this._onSceneTick);

    canvas.removeEventListener("mousedown", this._canvasMouseDownListener);
    canvas.removeEventListener("mousemove", this._canvasMouseMoveListener);
    canvas.removeEventListener("mouseup", this._canvasMouseUpListener);
    canvas.removeEventListener("wheel", this._canvasWheelListener);

    camera.off(this._onCameraViewMatrix);
    camera.off(this._onCameraProjMatrix);

    cameraControl.off(this._onCameraControlHover);
    cameraControl.off(this._onCameraControlHoverLeave);
};

Control.prototype._destroyNodes = function _destroyNodes () {
    this._setSectionPlane(null);
    this._rootNode.destroy();
    this._displayMeshes = {};
    this._affordanceMeshes = {};
};

Object.defineProperties( Control.prototype, prototypeAccessors$2 );

/**
 * Renders a 3D plane within an {@link Overview} to indicate its {@link SectionPlane}'s current position and orientation.
 *
 * @private
 */
var Plane = function Plane(overview, overviewScene, sectionPlane) {
    var this$1 = this;


    /**
     * The ID of this SectionPlanesOverviewPlane.
     *
     * @type {String}
     */
    this.id = sectionPlane.id;

    /**
     * The {@link SectionPlane} represented by this SectionPlanesOverviewPlane.
     *
     * @type {SectionPlane}
     */
    this._sectionPlane = sectionPlane;

    this._mesh = new Mesh(overviewScene, {
        id: sectionPlane.id,
        geometry: new ReadableGeometry(overviewScene, buildBoxGeometry({
            xSize: .5,
            ySize: .5,
            zSize: .001
        })),
        material: new PhongMaterial(overviewScene, {
            emissive: [1, 1, 1],
            diffuse: [0, 0, 0],
            backfaces: false
        }),
        edgeMaterial: new EdgeMaterial(overviewScene, {
            edgeColor: [0.0, 0.0, 0.0],
            edgeAlpha: 1.0,
            edgeWidth: 1
        }),
        highlightMaterial: new EmphasisMaterial(overviewScene, {
            fill: true,
            fillColor: [0.5, 1, 0.5],
            fillAlpha: 0.7,
            edges: true,
            edgeColor: [0.0, 0.0, 0.0],
            edgeAlpha: 1.0,
            edgeWidth: 1
        }),
        selectedMaterial: new EmphasisMaterial(overviewScene, {
            fill: true,
            fillColor: [0, 0, 1],
            fillAlpha: 0.7,
            edges: true,
            edgeColor: [1.0, 0.0, 0.0],
            edgeAlpha: 1.0,
            edgeWidth: 1
        }),
        highlighted: true,
        scale: [3, 3, 3],
        position: [0, 0, 0],
        rotation: [0, 0, 0],
        opacity: 0.3,
        edges: true
    });


    {
        var vec = math.vec3([0, 0, 0]);
        var pos2 = math.vec3();
        var zeroVec = math.vec3([0, 0, 1]);
        var quat = math.vec4(4);
        var pos3 = math.vec3();

        var update = function () {

            var origin = this$1._sectionPlane.scene.center;

            var negDir = [-this$1._sectionPlane.dir[0], -this$1._sectionPlane.dir[1], -this$1._sectionPlane.dir[2]];
            math.subVec3(origin, this$1._sectionPlane.pos, vec);
            var dist = -math.dotVec3(negDir, vec);

            math.normalizeVec3(negDir);
            math.mulVec3Scalar(negDir, dist, pos2);
            var quaternion = math.vec3PairToQuaternion(zeroVec, this$1._sectionPlane.dir, quat);

            pos3[0] = pos2[0] * 0.1;
            pos3[1] = pos2[1] * 0.1;
            pos3[2] = pos2[2] * 0.1;

            this$1._mesh.quaternion = quaternion;
            this$1._mesh.position = pos3;
        };

        this._onSectionPlanePos = this._sectionPlane.on("pos", update);
        this._onSectionPlaneDir = this._sectionPlane.on("dir", update);

        // update();
    }

    this._highlighted = false;
    this._selected = false;
};

/**
 * Sets if this SectionPlanesOverviewPlane is highlighted.
 *
 * @type {Boolean}
 * @private
 */
Plane.prototype.setHighlighted = function setHighlighted (highlighted) {
    this._highlighted = !!highlighted;
    this._mesh.highlighted = this._highlighted;
    this._mesh.highlightMaterial.fillColor = highlighted ? [0, 0.7, 0] : [0, 0, 0];
    // this._selectedMesh.highlighted = true;
};

/**
 * Gets if this SectionPlanesOverviewPlane is highlighted.
 *
 * @type {Boolean}
 * @private
 */
Plane.prototype.getHighlighted = function getHighlighted () {
    return this._highlighted;
};

/**
 * Sets if this SectionPlanesOverviewPlane is selected.
 *
 * @type {Boolean}
 * @private
 */
Plane.prototype.setSelected = function setSelected (selected) {
    this._selected = !!selected;
    this._mesh.edgeMaterial.edgeWidth = selected ? 3 : 1;
    this._mesh.highlightMaterial.edgeWidth = selected ? 3 : 1;

};

/**
 * Gets if this SectionPlanesOverviewPlane is selected.
 *
 * @type {Boolean}
 * @private
 */
Plane.prototype.getSelected = function getSelected () {
    return this._selected;
};

/** @private */
Plane.prototype.destroy = function destroy () {
    this._sectionPlane.off(this._onSectionPlanePos);
    this._sectionPlane.off(this._onSectionPlaneDir);
    this._mesh.destroy();
};

/**
 * @desc An interactive 3D overview for navigating the {@link SectionPlane}s created by its {@link SectionPlanesPlugin}.
 *
 * * Located at {@link SectionPlanesPlugin#overview}.
 * * Renders the overview on a separate canvas at a corner of the {@link Viewer}'s {@link Scene} {@link Canvas}.
 * * The overview shows a 3D plane object for each {@link SectionPlane} in the {@link Scene}.
 * * Click a plane object in the overview to toggle the visibility of a 3D gizmo to edit the position and orientation of its {@link SectionPlane}.
 *
 * @private
 */
var Overview = function Overview(plugin, cfg) {
    var this$1 = this;


    if (!cfg.onHoverEnterPlane || !cfg.onHoverLeavePlane || !cfg.onClickedNothing || !cfg.onClickedPlane) {
        throw "Missing config(s): onHoverEnterPlane, onHoverLeavePlane, onClickedNothing || onClickedPlane";
    }

    /**
     * The {@link SectionPlanesPlugin} that owns this SectionPlanesOverview.
     *
     * @type {SectionPlanesPlugin}
     */
    this.plugin = plugin;

    this._viewer = plugin.viewer;

    this._onHoverEnterPlane = cfg.onHoverEnterPlane;
    this._onHoverLeavePlane = cfg.onHoverLeavePlane;
    this._onClickedNothing = cfg.onClickedNothing;
    this._onClickedPlane = cfg.onClickedPlane;
    this._visible = true;

    this._planes = {};

    //--------------------------------------------------------------------------------------------------------------
    // Init canvas
    //--------------------------------------------------------------------------------------------------------------

    this._canvas = cfg.overviewCanvas;

    //--------------------------------------------------------------------------------------------------------------
    // Init scene
    //--------------------------------------------------------------------------------------------------------------

    this._scene = new Scene(this._viewer, {
        canvasId: this._canvas.id,
        transparent: true
    });
    this._scene.clearLights();
    new DirLight(this._scene, {
        dir: [0.4, -0.4, 0.8],
        color: [0.8, 1.0, 1.0],
        intensity: 1.0,
        space: "view"
    });
    new DirLight(this._scene, {
        dir: [-0.8, -0.3, -0.4],
        color: [0.8, 0.8, 0.8],
        intensity: 1.0,
        space: "view"
    });
    new DirLight(this._scene, {
        dir: [0.8, -0.6, -0.8],
        color: [1.0, 1.0, 1.0],
        intensity: 1.0,
        space: "view"
    });

    this._scene.camera;
    this._scene.camera.perspective.fov = 70;

    this._zUp = false;

    //--------------------------------------------------------------------------------------------------------------
    // Synchronize overview scene camera with viewer camera
    //--------------------------------------------------------------------------------------------------------------

    {
        var camera = this._scene.camera;
        var matrix = math.rotationMat4c(-90 * math.DEGTORAD, 1, 0, 0);
        var eyeLookVec = math.vec3();
        var eyeLookVecOverview = math.vec3();
        var upOverview = math.vec3();

        this._synchCamera = function () {
            var eye = this$1._viewer.camera.eye;
            var look = this$1._viewer.camera.look;
            var up = this$1._viewer.camera.up;
            math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye, look, eyeLookVec)), 7);
            if (this$1._zUp) { // +Z up
                math.transformVec3(matrix, eyeLookVec, eyeLookVecOverview);
                math.transformVec3(matrix, up, upOverview);
                camera.look = [0, 0, 0];
                camera.eye = math.transformVec3(matrix, eyeLookVec, eyeLookVecOverview);
                camera.up = math.transformPoint3(matrix, up, upOverview);
            } else { // +Y up
                camera.look = [0, 0, 0];
                camera.eye = eyeLookVec;
                camera.up = up;
            }
        };
    }

    this._onViewerCameraMatrix = this._viewer.camera.on("matrix", this._synchCamera);

    this._onViewerCameraWorldAxis = this._viewer.camera.on("worldAxis", this._synchCamera);

    this._onViewerCameraFOV = this._viewer.camera.perspective.on("fov", function (fov) {
        this$1._scene.camera.perspective.fov = fov;
    });

    //--------------------------------------------------------------------------------------------------------------
    // Bind overview canvas events
    //--------------------------------------------------------------------------------------------------------------

    {
        var hoveredEntity = null;

        this._onInputMouseMove = this._scene.input.on("mousemove", function (coords) {
            var hit = this$1._scene.pick({
                canvasPos: coords
            });
            if (hit) {
                if (!hoveredEntity || hit.entity.id !== hoveredEntity.id) {
                    if (hoveredEntity) {
                        var plane = this$1._planes[hoveredEntity.id];
                        if (plane) {
                            this$1._onHoverLeavePlane(hoveredEntity.id);
                        }
                    }
                    hoveredEntity = hit.entity;
                    var plane$1 = this$1._planes[hoveredEntity.id];
                    if (plane$1) {
                        this$1._onHoverEnterPlane(hoveredEntity.id);
                    }
                }
            } else {
                if (hoveredEntity) {
                    this$1._onHoverLeavePlane(hoveredEntity.id);
                    hoveredEntity = null;
                }
            }
        });

        this._scene.canvas.canvas.addEventListener("mouseup", this._onCanvasMouseUp = function () {
            if (hoveredEntity) {
                var plane = this$1._planes[hoveredEntity.id];
                if (plane) {
                    this$1._onClickedPlane(hoveredEntity.id);
                }
            } else {
                this$1._onClickedNothing();
            }
        });

        this._scene.canvas.canvas.addEventListener("mouseout", this._onCanvasMouseOut = function () {
            if (hoveredEntity) {
                this$1._onHoverLeavePlane(hoveredEntity.id);
                hoveredEntity = null;
            }
        });
    }

    //--------------------------------------------------------------------------------------------------------------
    // Configure overview
    //--------------------------------------------------------------------------------------------------------------

    this.setVisible(cfg.overviewVisible);
};

/** Called by SectionPlanesPlugin#createSectionPlane()
 * @private
 */
Overview.prototype.addSectionPlane = function addSectionPlane (sectionPlane) {
    this._planes[sectionPlane.id] = new Plane(this, this._scene, sectionPlane);
};

/**  @private
 */
Overview.prototype.setPlaneHighlighted = function setPlaneHighlighted (id, highlighted) {
    var plane = this._planes[id];
    if (plane) {
        plane.setHighlighted(highlighted);
    }
};

/**  @private
 */
Overview.prototype.setPlaneSelected = function setPlaneSelected (id, selected) {
    var plane = this._planes[id];
    if (plane) {
        plane.setSelected(selected);
    }
};

/** @private
 */
Overview.prototype.removeSectionPlane = function removeSectionPlane (sectionPlane) {
    var plane = this._planes[sectionPlane.id];
    if (plane) {
        plane.destroy();
        delete this._planes[sectionPlane.id];
    }
};

/**
 * Sets if this SectionPlanesOverview is visible.
 *
 * @param {Boolean} visible Whether or not this SectionPlanesOverview is visible.
 */
Overview.prototype.setVisible = function setVisible (visible) {
        if ( visible === void 0 ) visible = true;

    this._visible = visible;
    this._canvas.style.visibility = visible ? "visible" : "hidden";
};

/**
 * Gets if this SectionPlanesOverview is visible.
 *
 * @return {Boolean} True when this SectionPlanesOverview is visible.
 */
Overview.prototype.getVisible = function getVisible () {
    return this._visible;
};

/**  @private
 */
Overview.prototype.destroy = function destroy () {
    this._viewer.camera.off(this._onViewerCameraMatrix);
    this._viewer.camera.off(this._onViewerCameraWorldAxis);
    this._viewer.camera.perspective.off(this._onViewerCameraFOV);

    this._scene.input.off(this._onInputMouseMove);
    this._scene.canvas.canvas.removeEventListener("mouseup", this._onCanvasMouseUp);
    this._scene.canvas.canvas.removeEventListener("mouseout", this._onCanvasMouseOut);
    this._scene.destroy();
};

var tempAABB = math.AABB3();
var tempVec3$3 = math.vec3();

/**
 * SectionPlanesPlugin is a {@link Viewer} plugin that manages {@link SectionPlane}s.
 *
 * [<img src="https://user-images.githubusercontent.com/83100/57724962-406e9a00-768c-11e9-9f1f-3d178a3ec11f.gif">](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_SectionPlanesPlugin)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#gizmos_SectionPlanesPlugin)]
 *
 * ## Overview
 *
 * * Use the SectionPlanesPlugin to
 * create and edit {@link SectionPlane}s to slice portions off your models and reveal internal structures.
 * * As shown in the screen capture above, SectionPlanesPlugin shows an overview of all your SectionPlanes (on the right, in
 * this example).
 * * Click a plane in the overview to activate a 3D control with which you can interactively
 * reposition its SectionPlane in the main canvas.
 *
 * ## Usage
 *
 * In the example below, we'll use a {@link GLTFLoaderPlugin} to load a model, and a SectionPlanesPlugin
 * to slice it open with two {@link SectionPlane}s. We'll show the overview in the bottom right of the Viewer
 * canvas. Finally, we'll programmatically activate the 3D editing control, so that we can use it to interactively
 * reposition our second SectionPlane.
 *
 * ````JavaScript
 * import {Viewer, GLTFLoaderPlugin, SectionPlanesPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange its Camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [-5.02, 2.22, 15.09];
 * viewer.camera.look = [4.97, 2.79, 9.89];
 * viewer.camera.up = [-0.05, 0.99, 0.02];
 *
 *
 * // Add a GLTFLoaderPlugin
 *
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * // Add a SectionPlanesPlugin, with overview visible
 *
 * const sectionPlanes = new SectionPlanesPlugin(viewer, {
 *     overviewCanvasID: "myOverviewCanvas",
 *     overviewVisible: true
 * });
 *
 * // Load a model
 *
 * const model = gltfLoader.load({
 *     id: "myModel",
 *     src: "./models/gltf/schependomlaan/scene.gltf"
 * });
 *
 * // Create a couple of section planes
 * // These will be shown in the overview
 *
 * sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane",
 *     pos: [1.04, 1.95, 9.74],
 *     dir: [1.0, 0.0, 0.0]
 * });
 *
 * sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane2",
 *     pos: [2.30, 4.46, 14.93],
 *     dir: [0.0, -0.09, -0.79]
 * });
 *
 * // Show the SectionPlanePlugin's 3D editing gizmo,
 * // to interactively reposition one of our SectionPlanes
 *
 * sectionPlanes.showControl("mySectionPlane2");
 *
 * const mySectionPlane2 = sectionPlanes.sectionPlanes["mySectionPlane2"];
 *
 * // Programmatically reposition one of our SectionPlanes
 * // This also updates its position as shown in the overview gizmo
 *
 * mySectionPlane2.pos = [11.0, 6.-, -12];
 * mySectionPlane2.dir = [0.4, 0.0, 0.5];
 * ````
 */
var SectionPlanesPlugin = /*@__PURE__*/(function (Plugin) {
    function SectionPlanesPlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "SectionPlanes", viewer);

        this._freeControls = [];
        this._sectionPlanes = viewer.scene.sectionPlanes;
        this._controls = {};
        this._shownControlId = null;

        if (cfg.overviewCanvasId !== null && cfg.overviewCanvasId !== undefined) {

            var overviewCanvas = document.getElementById(cfg.overviewCanvasId);

            if (!overviewCanvas) {
                this.warn("Can't find overview canvas: '" + cfg.overviewCanvasId + "' - will create plugin without overview");

            } else {

                this._overview = new Overview(this, {
                    overviewCanvas: overviewCanvas,
                    visible: cfg.overviewVisible,

                    onHoverEnterPlane: (function (id) {
                        this$1._overview.setPlaneHighlighted(id, true);
                    }),

                    onHoverLeavePlane: (function (id) {
                        this$1._overview.setPlaneHighlighted(id, false);
                    }),

                    onClickedPlane: (function (id) {
                        if (this$1.getShownControl() === id) {
                            this$1.hideControl();
                            return;
                        }
                        this$1.showControl(id);
                        var sectionPlane = this$1.sectionPlanes[id];
                        var sectionPlanePos = sectionPlane.pos;
                        tempAABB.set(this$1.viewer.scene.aabb);
                        math.getAABB3Center(tempAABB, tempVec3$3);
                        tempAABB[0] += sectionPlanePos[0] - tempVec3$3[0];
                        tempAABB[1] += sectionPlanePos[1] - tempVec3$3[1];
                        tempAABB[2] += sectionPlanePos[2] - tempVec3$3[2];
                        tempAABB[3] += sectionPlanePos[0] - tempVec3$3[0];
                        tempAABB[4] += sectionPlanePos[1] - tempVec3$3[1];
                        tempAABB[5] += sectionPlanePos[2] - tempVec3$3[2];
                        this$1.viewer.cameraFlight.flyTo({
                            aabb: tempAABB,
                            fitFOV: 65
                        });
                    }),

                    onClickedNothing: (function () {
                        this$1.hideControl();
                    })
                });
            }
        }

        this._onSceneSectionPlaneCreated = viewer.scene.on("sectionPlaneCreated", function (sectionPlane) {

            // SectionPlane created, either via SectionPlanesPlugin#createSectionPlane(), or by directly
            // instantiating a SectionPlane independently of SectionPlanesPlugin, which can be done
            // by BCFViewpointsPlugin#loadViewpoint().

            this$1._sectionPlaneCreated(sectionPlane);
        });
    }

    if ( Plugin ) SectionPlanesPlugin.__proto__ = Plugin;
    SectionPlanesPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    SectionPlanesPlugin.prototype.constructor = SectionPlanesPlugin;

    var prototypeAccessors = { sectionPlanes: { configurable: true } };

    /**
     * Sets if the overview canvas is visible.
     *
     * @param {Boolean} visible Whether or not the overview canvas is visible.
     */
    SectionPlanesPlugin.prototype.setOverviewVisible = function setOverviewVisible (visible) {
        if (this._overview) {
            this._overview.setVisible(visible);
        }
    };

    /**
     * Gets if the overview canvas is visible.
     *
     * @return {Boolean} True when the overview canvas is visible.
     */
    SectionPlanesPlugin.prototype.getOverviewVisible = function getOverviewVisible () {
        if (this._overview) {
            return this._overview.getVisible();
        }
    };

    /**
     * Returns a map of the {@link SectionPlane}s created by this SectionPlanesPlugin.
     *
     * @returns {{String:SectionPlane}} A map containing the {@link SectionPlane}s, each mapped to its {@link SectionPlane#id}.
     */
    prototypeAccessors.sectionPlanes.get = function () {
        return this._sectionPlanes;
    };

    /**
     * Creates a {@link SectionPlane}.
     *
     * The {@link SectionPlane} will be registered by {@link SectionPlane#id} in {@link SectionPlanesPlugin#sectionPlanes}.
     *
     * @param {Object} params {@link SectionPlane} configuration.
     * @param {String} [params.id] Unique ID to assign to the {@link SectionPlane}. Must be unique among all components in the {@link Viewer}'s {@link Scene}. Auto-generated when omitted.
     * @param {Number[]} [params.pos=[0,0,0]] World-space position of the {@link SectionPlane}.
     * @param {Number[]} [params.dir=[0,0,-1]] World-space vector indicating the orientation of the {@link SectionPlane}.
     * @param {Boolean} [params.active=true] Whether the {@link SectionPlane} is initially active. Only clips while this is true.
     * @returns {SectionPlane} The new {@link SectionPlane}.
     */
    SectionPlanesPlugin.prototype.createSectionPlane = function createSectionPlane (params) {
        if ( params === void 0 ) params = {};


        if (params.id !== undefined && params.id !== null && this.viewer.scene.components[params.id]) {
            this.error("Viewer component with this ID already exists: " + params.id);
            delete params.id;
        }

        // Note that SectionPlane constructor fires "sectionPlaneCreated" on the Scene,
        // which SectionPlanesPlugin handles and calls #_sectionPlaneCreated to create gizmo and add to overview canvas.

        var sectionPlane = new SectionPlane(this.viewer.scene, {
            id: params.id,
            pos: params.pos,
            dir: params.dir,
            active: true 
        });
        return sectionPlane;
    };

    SectionPlanesPlugin.prototype._sectionPlaneCreated = function _sectionPlaneCreated (sectionPlane) {
        var this$1 = this;

        var control = (this._freeControls.length > 0) ? this._freeControls.pop() : new Control(this);
        control._setSectionPlane(sectionPlane);
        control.setVisible(false);
        this._controls[sectionPlane.id] = control;
        if (this._overview) {
            this._overview.addSectionPlane(sectionPlane);
        }
        sectionPlane.once("destroyed", function () {
            this$1._sectionPlaneDestroyed(sectionPlane);
        });
    };

    /**
     * Inverts the direction of {@link SectionPlane#dir} on every existing SectionPlane.
     *
     * Inverts all SectionPlanes, including those that were not created with SectionPlanesPlugin.
     */
    SectionPlanesPlugin.prototype.flipSectionPlanes = function flipSectionPlanes () {
        var sectionPlanes = this.viewer.scene.sectionPlanes;
        for (var id in sectionPlanes) {
            var sectionPlane = sectionPlanes[id];
            sectionPlane.flipDir();
        }
    };

    /**
     * Shows the 3D editing gizmo for a {@link SectionPlane}.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */
    SectionPlanesPlugin.prototype.showControl = function showControl (id) {
        var control = this._controls[id];
        if (!control) {
            this.error("Control not found: " + id);
            return;
        }
        this.hideControl();
        control.setVisible(true);
        if (this._overview) {
            this._overview.setPlaneSelected(id, true);
        }
        this._shownControlId = id;
    };

    /**
     * Gets the ID of the {@link SectionPlane} that the 3D editing gizmo is shown for.
     *
     * Returns ````null```` when the editing gizmo is not shown.
     *
     * @returns {String} ID of the the {@link SectionPlane} that the 3D editing gizmo is shown for, if shown, else ````null````.
     */
    SectionPlanesPlugin.prototype.getShownControl = function getShownControl () {
        return this._shownControlId;
    };

    /**
     * Hides the 3D {@link SectionPlane} editing gizmo if shown.
     */
    SectionPlanesPlugin.prototype.hideControl = function hideControl () {
        for (var id in this._controls) {
            if (this._controls.hasOwnProperty(id)) {
                this._controls[id].setVisible(false);
                if (this._overview) {
                    this._overview.setPlaneSelected(id, false);
                }
            }
        }
        this._shownControlId = null;
    };

    /**
     * Destroys a {@link SectionPlane} created by this SectionPlanesPlugin.
     *
     * @param {String} id ID of the {@link SectionPlane}.
     */
    SectionPlanesPlugin.prototype.destroySectionPlane = function destroySectionPlane (id) {
        var sectionPlane = this.viewer.scene.sectionPlanes[id];
        if (!sectionPlane) {
            this.error("SectionPlane not found: " + id);
            return;
        }
        this._sectionPlaneDestroyed(sectionPlane);
        sectionPlane.destroy();

        if (id === this._shownControlId) {
            this._shownControlId = null;
        }
    };

    SectionPlanesPlugin.prototype._sectionPlaneDestroyed = function _sectionPlaneDestroyed (sectionPlane) {
        if (this._overview) {
            this._overview.removeSectionPlane(sectionPlane);
        }
        var control = this._controls[sectionPlane.id];
        if (!control) {
            return;
        }
        control.setVisible(false);
        control._setSectionPlane(null);
        delete this._controls[sectionPlane.id];
        this._freeControls.push(control);
    };

    /**
     * Destroys all {@link SectionPlane}s created by this SectionPlanesPlugin.
     */
    SectionPlanesPlugin.prototype.clear = function clear () {
        var ids = Object.keys(this._sectionPlanes);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroySectionPlane(ids[i]);
        }
    };

    /**
     * @private
     */
    SectionPlanesPlugin.prototype.send = function send (name, value) {
        switch (name) {

            case "snapshotStarting": // Viewer#getSnapshot() about to take snapshot - hide controls
                for (var id in this._controls) {
                    if (this._controls.hasOwnProperty(id)) {
                        this._controls[id].setCulled(true);
                    }
                }
                break;

            case "snapshotFinished": // Viewer#getSnapshot() finished taking snapshot - show controls again
                for (var id$1 in this._controls) {
                    if (this._controls.hasOwnProperty(id$1)) {
                        this._controls[id$1].setCulled(false);
                    }
                }
                break;

            case "clearSectionPlanes":
                this.clear();
                break;
        }
    };

    /**
     * Destroys this SectionPlanesPlugin.
     *
     * Also destroys each {@link SectionPlane} created by this SectionPlanesPlugin.
     *
     * Does not destroy the canvas the SectionPlanesPlugin was configured with.
     */
    SectionPlanesPlugin.prototype.destroy = function destroy () {
        this.clear();
        if (this._overview) {
            this._overview.destroy();
        }
        this._destroyFreeControls();
        Plugin.prototype.destroy.call(this);
    };

    SectionPlanesPlugin.prototype._destroyFreeControls = function _destroyFreeControls () {
        var control = this._freeControls.pop();
        while (control) {
            control._destroy();
            control = this._freeControls.pop();
        }
        this.viewer.scene.off(this._onSceneSectionPlaneCreated);
    };

    Object.defineProperties( SectionPlanesPlugin.prototype, prototypeAccessors );

    return SectionPlanesPlugin;
}(Plugin));

/**
 * @desc A Skybox.
 */
var Skybox = /*@__PURE__*/(function (Component) {
    function Skybox(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._skyboxMesh = new Mesh(this, {

            geometry: new ReadableGeometry(this, { // Box-shaped geometry
                primitive: "triangles",
                positions: [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
                    1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v5 right
                    1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v5-v6-v1 top
                    -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
                    -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
                    1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v5 back
                ],
                uv: [
                    0.5, 0.6666, 0.25, 0.6666, 0.25, 0.3333, 0.5, 0.3333, 0.5, 0.6666, 0.5, 0.3333, 0.75, 0.3333, 0.75, 0.6666,
                    0.5, 0.6666, 0.5, 1, 0.25, 1, 0.25, 0.6666, 0.25, 0.6666, 0.0, 0.6666, 0.0, 0.3333, 0.25, 0.3333,
                    0.25, 0, 0.50, 0, 0.50, 0.3333, 0.25, 0.3333, 0.75, 0.3333, 1.0, 0.3333, 1.0, 0.6666, 0.75, 0.6666
                ],
                indices: [
                    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11,
                    12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
                ]
            }),
            scale: [2000, 2000, 2000], // Overridden when we initialize the 'size' property, below
            rotation: [0, -90, 0],
            material: new PhongMaterial(this, {
                ambient: [0, 0, 0],
                diffuse: [0, 0, 0],
                specular: [0, 0, 0],
                emissive: [1, 1, 1],
                emissiveMap: new Texture(this, {
                    src: cfg.src,
                    flipY: true,
                    encoding: cfg.encoding || "sRGB"
                }),
                backfaces: true // Show interior faces of our skybox geometry
            }),
            // stationary: true,
            visible: false,
            pickable: false,
            collidable: false
        });

        this.size = cfg.size; // Sets 'xyz' property on the Mesh's Scale transform
        this.active = cfg.active;
    }

    if ( Component ) Skybox.__proto__ = Component;
    Skybox.prototype = Object.create( Component && Component.prototype );
    Skybox.prototype.constructor = Skybox;

    var prototypeAccessors = { size: { configurable: true },active: { configurable: true } };


    /**
     * Sets the size of this Skybox, given as the distance from the center at [0,0,0] to each face.
     *
     * Default value is ````1000````.
     *
     * @param {Number} value The size.
     */
    prototypeAccessors.size.set = function (value) {
        this._size = value || 1000;
        this._skyboxMesh.scale = [this._size, this._size, this._size];
    };

    /**
     * Gets the size of this Skybox, given as the distance from the center at [0,0,0] to each face.
     *
     * Default value is ````1000````.
     *
     * @returns {Number} The size.
     */
    prototypeAccessors.size.get = function () {
        return this._size;
    };

    /**
     * Sets whether this Skybox is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} active Whether to make active or not.
     */
    prototypeAccessors.active.set = function (active) {
        this._skyboxMesh.visible = active;
    };

    /**
     * Gets if this Skybox is visible or not.
     *
     * Default active is ````true````.
     *
     * @returns {Boolean} ````true```` if the Skybox is active.
     */
    prototypeAccessors.active.get = function () {
        return this._skyboxMesh.visible;
    };

    Object.defineProperties( Skybox.prototype, prototypeAccessors );

    return Skybox;
}(Component));

/**
 * {@link Viewer} plugin that manages skyboxes
 *
 * @example
 *
 * // Create a Viewer
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Add a GLTFModelsPlugin
 * var gltfLoaderPlugin = new GLTFModelsPlugin(viewer, {
 *     id: "GLTFModels"  // Default value
 * });
 *
 * // Add a SkyboxesPlugin
 * var skyboxesPlugin = new SkyboxesPlugin(viewer, {
 *     id: "Skyboxes" // Default value
 * });
 *
 * // Load a glTF model
 * const model = gltfLoaderPlugin.load({
 *     id: "myModel",
 *     src: "./models/gltf/mygltfmodel.gltf"
 * });
 *
 * // Create three directional World-space lights. "World" means that they will appear as if part
 * // of the world, instead of "View", where they move with the user's head.
 *
 * skyboxesPlugin.createLight({
 *     id: "keyLight",
 *     dir: [0.8, -0.6, -0.8],
 *     color: [1.0, 0.3, 0.3],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * skyboxesPlugin.createLight({
 *     id: "fillLight",
 *     dir: [-0.8, -0.4, -0.4],
 *     color: [0.3, 1.0, 0.3],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * skyboxesPlugin.createDirLight({
 *     id: "rimLight",
 *     dir: [0.2, -0.8, 0.8],
 *     color: [0.6, 0.6, 0.6],
 *     intensity: 1.0,
 *     space: "world"
 * });
 *
 * @class SkyboxesPlugin
 */
var SkyboxesPlugin = /*@__PURE__*/(function (Plugin) {
    function SkyboxesPlugin(viewer) {
        Plugin.call(this, "skyboxes", viewer);
        this.skyboxes = {};
    }

    if ( Plugin ) SkyboxesPlugin.__proto__ = Plugin;
    SkyboxesPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    SkyboxesPlugin.prototype.constructor = SkyboxesPlugin;

    /**
     * @private
     */
    SkyboxesPlugin.prototype.send = function send (name, value) {
        switch (name) {
            case "clear":
                this.clear();
                break;
        }
    };

    /**
     Creates a skybox.

     @param {String} id Unique ID to assign to the skybox.
     @param {Object} params Skybox configuration.
     @param {Boolean} [params.active=true] Whether the skybox plane is initially active. Only skyboxes while this is true.
     @returns {Skybox} The new skybox.
     */
    SkyboxesPlugin.prototype.createSkybox = function createSkybox (id, params) {
        if (this.viewer.scene.components[id]) {
            this.error("Component with this ID already exists: " + id);
            return this;
        }
        var skybox = new Skybox(this.viewer.scene, {
            id: id,
            pos: params.pos,
            dir: params.dir,
            active: true 
        });
        this.skyboxes[id] = skybox;
        return skybox;
    };

    /**
     Destroys a skybox.
     @param id
     */
    SkyboxesPlugin.prototype.destroySkybox = function destroySkybox (id) {
        var skybox = this.skyboxes[id];
        if (!skybox) {
            this.error("Skybox not found: " + id);
            return;
        }
        skybox.destroy();
    };

    /**
     Destroys all skyboxes.
     */
    SkyboxesPlugin.prototype.clear = function clear () {
        var ids = Object.keys(this.viewer.scene.skyboxes);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroySkybox(ids[i]);
        }
    };

    /**
     * Destroys this plugin.
     *
     * Clears skyboxes from the Viewer first.
     */
    SkyboxesPlugin.prototype.destroy = function destroy () {
        this.clear();
        Plugin.prototype.clear.call(this);
    };

    return SkyboxesPlugin;
}(Plugin));

/**
 * Default data access strategy for {@link STLLoaderPlugin}.
 *
 * This implementation simply loads STL files using XMLHttpRequest.
 */
var STLDefaultDataSource = function STLDefaultDataSource () {};

STLDefaultDataSource.prototype.getSTL = function getSTL (src, ok, error) {
    var request = new XMLHttpRequest();
    request.overrideMimeType("application/json");
    request.open('GET', src, true);
    request.responseType = 'arraybuffer';
    request.onreadystatechange = function () {
        if (request.readyState === 4) {
            if (request.status === 200) {
                ok(request.response);
            } else {
                error(request.statusText);
            }
        }
    };
    request.send(null);
};

var tempVec3a$6 = math.vec3();

/**
 * @private
 */
var STLSceneGraphLoader = function STLSceneGraphLoader () {};

STLSceneGraphLoader.prototype.load = function load (plugin, modelNode, src, options, ok, error) {

    options = options || {};

    var spinner = plugin.viewer.scene.canvas.spinner;
    spinner.processes++;

    plugin.dataSource.getSTL(src, function (data) { // OK
            parse(plugin, modelNode, data, options);
            try {
                var binData = ensureBinary(data);
                if (isBinary(binData)) {
                    parseBinary(plugin, binData, modelNode, options);
                } else {
                    parseASCII(plugin, ensureString(data), modelNode, options);
                }
                spinner.processes--;
                core.scheduleTask(function () {
                    modelNode.fire("loaded", true, false);
                });
                if (ok) {
                    ok();
                }
            } catch (e) {
                spinner.processes--;
                plugin.error(e);
                if (error) {
                    error(e);
                }
                modelNode.fire("error", e);
            }
        },
        function (msg) {
            spinner.processes--;
            plugin.error(msg);
            if (error) {
                error(msg);
            }
            modelNode.fire("error", msg);
        });
};

STLSceneGraphLoader.prototype.parse = function parse (plugin, modelNode, data, options) {
    var spinner = plugin.viewer.scene.canvas.spinner;
    spinner.processes++;
    try {
        var binData = ensureBinary(data);
        if (isBinary(binData)) {
            parseBinary(plugin, binData, modelNode, options);
        } else {
            parseASCII(plugin, ensureString(data), modelNode, options);
        }
        spinner.processes--;
        core.scheduleTask(function () {
            modelNode.fire("loaded", true, false);
        });
    } catch (e) {
        spinner.processes--;
        modelNode.fire("error", e);
    }
};

function parse(plugin, modelNode, data, options) {
    try {
        var binData = ensureBinary(data);
        if (isBinary(binData)) {
            parseBinary(plugin, binData, modelNode, options);
        } else {
            parseASCII(plugin, ensureString(data), modelNode, options);
        }
    } catch (e) {
        modelNode.fire("error", e);
    }
}

function isBinary(data) {
    var reader = new DataView(data);
    var numFaces = reader.getUint32(80, true);
    var faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);
    var numExpectedBytes = 80 + (32 / 8) + (numFaces * faceSize);
    if (numExpectedBytes === reader.byteLength) {
        return true;
    }
    var solid = [115, 111, 108, 105, 100];
    for (var i = 0; i < 5; i++) {
        if (solid[i] !== reader.getUint8(i, false)) {
            return true;
        }
    }
    return false;
}

function parseBinary(plugin, data, modelNode, options) {
    var reader = new DataView(data);
    var faces = reader.getUint32(80, true);
    var r;
    var g;
    var b;
    var hasColors = false;
    var colors;
    var defaultR;
    var defaultG;
    var defaultB;
    var lastR = null;
    var lastG = null;
    var lastB = null;
    var newMesh = false;
    for (var index = 0; index < 80 - 10; index++) {
        if ((reader.getUint32(index, false) === 0x434F4C4F /*COLO*/) &&
            (reader.getUint8(index + 4) === 0x52 /*'R'*/) &&
            (reader.getUint8(index + 5) === 0x3D /*'='*/)) {
            hasColors = true;
            colors = [];
            defaultR = reader.getUint8(index + 6) / 255;
            defaultG = reader.getUint8(index + 7) / 255;
            defaultB = reader.getUint8(index + 8) / 255;
            reader.getUint8(index + 9) / 255;
        }
    }
    var material = new MetallicMaterial(modelNode, { // Share material with all meshes
        roughness: 0.5
    });
    // var material = new PhongMaterial(modelNode, { // Share material with all meshes
    //     diffuse: [0.4, 0.4, 0.4],
    //     reflectivity: 1,
    //     specular: [0.5, 0.5, 1.0]
    // });
    var dataOffset = 84;
    var faceLength = 12 * 4 + 2;
    var positions = [];
    var normals = [];
    var splitMeshes = options.splitMeshes;
    for (var face = 0; face < faces; face++) {
        var start = dataOffset + face * faceLength;
        var normalX = reader.getFloat32(start, true);
        var normalY = reader.getFloat32(start + 4, true);
        var normalZ = reader.getFloat32(start + 8, true);
        if (hasColors) {
            var packedColor = reader.getUint16(start + 48, true);
            if ((packedColor & 0x8000) === 0) {
                r = (packedColor & 0x1F) / 31;
                g = ((packedColor >> 5) & 0x1F) / 31;
                b = ((packedColor >> 10) & 0x1F) / 31;
            } else {
                r = defaultR;
                g = defaultG;
                b = defaultB;
            }
            if (splitMeshes && r !== lastR || g !== lastG || b !== lastB) {
                if (lastR !== null) {
                    newMesh = true;
                }
                lastR = r;
                lastG = g;
                lastB = b;
            }
        }
        for (var i = 1; i <= 3; i++) {
            var vertexstart = start + i * 12;
            positions.push(reader.getFloat32(vertexstart, true));
            positions.push(reader.getFloat32(vertexstart + 4, true));
            positions.push(reader.getFloat32(vertexstart + 8, true));
            normals.push(normalX, normalY, normalZ);
            if (hasColors) {
                colors.push(r, g, b, 1); // TODO: handle alpha
            }
        }
        if (splitMeshes && newMesh) {
            addMesh(modelNode, positions, normals, colors, material, options);
            positions = [];
            normals = [];
            colors = colors ? [] : null;
            newMesh = false;
        }
    }
    if (positions.length > 0) {
        addMesh(modelNode, positions, normals, colors, material, options);
    }
}

function parseASCII(plugin, data, modelNode, options) {
    var faceRegex = /facet([\s\S]*?)endfacet/g;
    var faceCounter = 0;
    var floatRegex = /[\s]+([+-]?(?:\d+.\d+|\d+.|\d+|.\d+)(?:[eE][+-]?\d+)?)/.source;
    var vertexRegex = new RegExp('vertex' + floatRegex + floatRegex + floatRegex, 'g');
    var normalRegex = new RegExp('normal' + floatRegex + floatRegex + floatRegex, 'g');
    var positions = [];
    var normals = [];
    var colors = null;
    var normalx;
    var normaly;
    var normalz;
    var result;
    var verticesPerFace;
    var normalsPerFace;
    var text;
    while ((result = faceRegex.exec(data)) !== null) {
        verticesPerFace = 0;
        normalsPerFace = 0;
        text = result[0];
        while ((result = normalRegex.exec(text)) !== null) {
            normalx = parseFloat(result[1]);
            normaly = parseFloat(result[2]);
            normalz = parseFloat(result[3]);
            normalsPerFace++;
        }
        while ((result = vertexRegex.exec(text)) !== null) {
            positions.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
            normals.push(normalx, normaly, normalz);
            verticesPerFace++;
        }
        if (normalsPerFace !== 1) {
            plugin.error("Error in normal of face " + faceCounter);
        }
        if (verticesPerFace !== 3) {
            plugin.error("Error in positions of face " + faceCounter);
        }
        faceCounter++;
    }
    var material = new MetallicMaterial(modelNode, {
        roughness: 0.5
    });
    // var material = new PhongMaterial(modelNode, {
    //     diffuse: [0.4, 0.4, 0.4],
    //     reflectivity: 1,
    //     specular: [0.5, 0.5, 1.0]
    // });
    addMesh(modelNode, positions, normals, colors, material, options);
}

function addMesh(modelNode, positions, normals, colors, material, options) {

    var indices = new Int32Array(positions.length / 3);
    for (var ni = 0, len = indices.length; ni < len; ni++) {
        indices[ni] = ni;
    }

    normals = normals && normals.length > 0 ? normals : null;
    colors = colors && colors.length > 0 ? colors : null;

    if (options.smoothNormals) {
        math.faceToVertexNormals(positions, normals, options);
    }

    var rtcCenter = tempVec3a$6;

    worldToRTCPositions(positions, positions, rtcCenter);

    var geometry = new ReadableGeometry(modelNode, {
        primitive: "triangles",
        positions: positions,
        normals: normals,
        colors: colors,
        indices: indices
    });

    var mesh = new Mesh(modelNode, {
        rtcCenter: (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0) ? rtcCenter : null,
        geometry: geometry,
        material: material,
        edges: options.edges
    });

    modelNode.addChild(mesh);
}

function ensureString(buffer) {
    if (typeof buffer !== 'string') {
        return decodeText(new Uint8Array(buffer));
    }
    return buffer;
}

function ensureBinary(buffer) {
    if (typeof buffer === 'string') {
        var arrayBuffer = new Uint8Array(buffer.length);
        for (var i = 0; i < buffer.length; i++) {
            arrayBuffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian
        }
        return arrayBuffer.buffer || arrayBuffer;
    } else {
        return buffer;
    }
}

function decodeText(array) {
    if (typeof TextDecoder !== 'undefined') {
        return new TextDecoder().decode(array);
    }
    var s = '';
    for (var i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]); // Implicitly assumes little-endian.
    }
    return decodeURIComponent(escape(s));
}

/**
 * {@link Viewer} plugin that loads models from <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> files.
 *
 * ## Overview
 *
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 * * Supports both binary and ASCII formats.
 * * Supports double-precision vertex positions.
 * * Supports custom data source configuration.
 *
 * ## Smoothing STL Normals
 *
 * STL models are normally flat-shaded, however providing a ````smoothNormals```` parameter when loading gives a smooth
 * appearance. Triangles in STL are disjoint, where each triangle has its own separate vertex positions, normals and
 * (optionally) colors. This means that you can have gaps between triangles in an STL model. Normals for each triangle
 * are perpendicular to the triangle's surface, which gives the model a faceted appearance by default.
 *
 * The ```smoothNormals``` parameter causes the plugin to recalculate the STL normals, so that each normal's direction is
 * the average of the orientations of the triangles adjacent to its vertex. When smoothing, each vertex normal is set to
 * the average of the orientations of all other triangles that have a vertex at the same position, excluding those triangles
 * whose direction deviates from the direction of the vertice's triangle by a threshold given in
 * the ````smoothNormalsAngleThreshold```` loading parameter. This makes smoothing robust for hard edges.
 *
 * ## Creating Entities for Objects
 *
 * An STL model is normally a single mesh, however providing a ````splitMeshes```` parameter when loading
 * will create a separate object {@link Entity} for each group of faces that share the same vertex colors. This option
 * only works with binary STL files.
 *
 * See the {@link STLLoaderPlugin#load} method for more info on loading options.
 *
 * ## Usage
 *
 * In the example below, we'll use an STLLoaderPlugin to load an STL model of a spur gear. When the model has loaded,
 * we'll use the {@link CameraFlightAnimation} to fly the {@link Camera} to look at boundary of the model. We'll
 * then get the model's {@link Entity} from the {@link Scene} and highlight the whole model.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_SpurGear)]
 *
 * ````javascript
 * // Create a xeokit Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * // Add an STLLoaderPlugin to the Viewer
 * var plugin = new STLLoaderPlugin(viewer);
 *
 * // Load the STL model
 * var model = plugin.load({ // Model is an Entity
 *      id: "myModel",
 *      src: "./models/stl/binary/spurGear.stl",
 *      scale: [0.1, 0.1, 0.1],
 *      rotate: [90, 0, 0],
 *      translate: [100,0,0],
 *      edges: true,
 *      smoothNormals: true,                // Default
 *      smoothNormalsAngleThreshold: 20,    // Default
 *      splitMeshes: true                   // Default
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", function() { // Model is an Entity
 *      viewer.cameraFlight.flyTo(model);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Update properties of the model Entity
 * model.highlight = [1,0,0];
 *
 * // Destroy the model Entity
 * model.destroy();
 * ````
 *
 * ## Loading from a Pre-Loaded STL File
 *
 * If we already have our STL file in memory (perhaps pre-loaded, or even generated in-client), then we can just pass that
 * file data straight into the {@link STLLoaderPlugin#load} method. In the example below, to show how it's done, we'll pre-load
 * our STL file data, then pass it straight into that method.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_dataAsParam)]
 *
 * ````javascript
 * loadSTL("./models/stl/binary/spurGear.stl", (stlData) =>{
 *
 *      const model = stlLoader.load({
 *          id: "myModel",
 *          stl: stlData,
 *          smoothNormals: true
 *      });
 *
 *      model.on("loaded", () => {
 *          viewer.cameraFlight.jumpTo(model);
 *          viewer.scene.on("tick", () => {
 *              viewer.camera.orbitYaw(0.4);
 *          })
 *      });
 *  })
 *
 * function loadSTL(src, ok, error) {
 *     const request = new XMLHttpRequest();
 *     request.overrideMimeType("application/json");
 *     request.open('GET', src, true);
 *     request.responseType = 'arraybuffer';
 *     request.onreadystatechange = function () {
 *         if (request.readyState === 4) {
 *             if (request.status === 200) {
 *                 ok(request.response);
 *             } else if (error) {
 *                     error(request.statusText);
 *             }
 *         }
 *     };
 *     request.send(null);
 * }
 *````
 *
 * ## Configuring a Custom Data Source
 *
 * In the example below, we'll create the STLLoaderPlugin again, this time configuring it with a
 * custom data source object, through which it can load STL files. For this example, our data source just loads
 * them via HTTP, for simplicity. Once we've created the STLLoaderPlugin, we'll load our STL file as before.
 *
 *  * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_STL_dataSource)]
 *
 * ````javascript
 * // Our custom STL data access strategy - implementation happens to be the same as STLDefaultDataSource
 *
 * class MyDataSource {
 *      getSTL(src, ok, error) {
 *          const request = new XMLHttpRequest();
 *          request.overrideMimeType("application/json");
 *          request.open('GET', src, true);
 *          request.responseType = 'arraybuffer';
 *          request.onreadystatechange = function () {
 *              if (request.readyState === 4) {
 *                  if (request.status === 200) {
 *                      ok(request.response);
 *                  } else {
 *                      error(request.statusText);
 *                  }
 *              }
 *          };
 *          request.send(null);
 *      }
 *  }
 *
 * const stlLoader = new STLLoaderPlugin(viewer, {
 *      dataSource: new MyDataSource()
 *  });
 *
 * // Load the STL model as before
 * var model = plugin.load({
 *      id: "myModel",
 *      src: "./models/stl/binary/spurGear.stl",
 *      scale: [0.1, 0.1, 0.1],
 *      rotate: [90, 0, 0],
 *      translate: [100,0,0],
 *      edges: true,
 *      smoothNormals: true,                // Default
 *      smoothNormalsAngleThreshold: 20,    // Default
 *      splitMeshes: true                   // Default
 * });
 *
 * //...
 *````
 *
 * @class STLLoaderPlugin
 */
var STLLoaderPlugin = /*@__PURE__*/(function (Plugin) {
    function STLLoaderPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "STLLoader", viewer, cfg);

        /**
         * @private
         */
        this._sceneGraphLoader = new STLSceneGraphLoader();

        this.dataSource = cfg.dataSource;
    }

    if ( Plugin ) STLLoaderPlugin.__proto__ = Plugin;
    STLLoaderPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    STLLoaderPlugin.prototype.constructor = STLLoaderPlugin;

    var prototypeAccessors = { dataSource: { configurable: true } };

    /**
     * Sets a custom data source through which the STLLoaderPlugin can load STL files.
     *
     * Default value is {@link STLDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.set = function (value) {
        this._dataSource = value || new STLDefaultDataSource();
    };

    /**
     * Gets the custom data source through which the STLLoaderPlugin can load STL files.
     *
     * Default value is {@link STLDefaultDataSource}, which loads via an XMLHttpRequest.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.get = function () {
        return this._dataSource;
    };

    /**
     * Loads an STL model from a file into this STLLoaderPlugin's {@link Viewer}.
     *
     * @param {*} params Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} [params.src] Path to an STL file. Overrides the ````stl```` parameter.
     * @param {String} [params.stl] Contents of an STL file, either binary of ASCII. Overridden by the ````src```` parameter.
     * @param {Boolean} [params.edges=false] Whether or not to renders the model with edges emphasized.
     * @param {Number[]} [params.position=[0,0,0]] The model World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the STL.  When false, ignores backfaces.
     * @param {Boolean} [params.smoothNormals=true] When true, automatically converts face-oriented normals to vertex normals for a smooth appearance.
     * @param {Number} [params.smoothNormalsAngleThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {Boolean} [params.splitMeshes=true] When true, creates a separate {@link Mesh} for each group of faces that share the same vertex colors. Only works with binary STL.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */
    STLLoaderPlugin.prototype.load = function load (params) {

        if (params.id && this.viewer.scene.components[params.id]) {
            this.error("Component with this ID already exists in viewer: " + params.id + " - will autogenerate this ID");
            delete params.id;
        }

        var modelNode = new Node(this.viewer.scene, utils.apply(params, {
            isModel: true
        }));

        var src = params.src;
        var stl = params.stl;

        if (!src && !stl) {
            this.error("load() param expected: either 'src' or 'stl'");
            return modelNode;
        }

        if (src) {
            this._sceneGraphLoader.load(this, modelNode, src, params);
        } else {
            this._sceneGraphLoader.parse(this, modelNode, stl, params);
        }

        return modelNode;
    };

    Object.defineProperties( STLLoaderPlugin.prototype, prototypeAccessors );

    return STLLoaderPlugin;
}(Plugin));

/**
 * @desc Information about an ````IfcBuildingStorey````.
 *
 * These are provided by a {@link StoreyViewsPlugin}.
 */
var Storey = function Storey(plugin, aabb, modelId, storeyId, numObjects) {

    /**
     * The {@link StoreyViewsPlugin} this Storey belongs to.
     *
     * @property plugin
     * @type {StoreyViewsPlugin}
     */
    this.plugin = plugin;

    /**
     * ID of the IfcBuildingStorey.
     *
     * This matches IDs of the IfcBuildingStorey's {@link MetaObject} and {@link Entity}.
     *
     * @property storeyId
     * @type {String}
     */
    this.storeyId = storeyId;

    /**
     * ID of the model.
     *
     * This matches the ID of the {@link MetaModel} that contains the IfcBuildingStorey's {@link MetaObject}.
     *
     * @property modelId
     * @type {String|Number}
     */
    this.modelId = modelId;

    /**
     * Axis-aligned World-space boundary of the {@link Entity}s that represent the IfcBuildingStorey.
     *
     * The boundary is a six-element Float32Array containing the min/max extents of the
     * axis-aligned boundary, ie. ````[xmin, ymin, zmin, xmax, ymax, zmax]````
     *
     * @property aabb
     * @type {Number[]}
     */
    this.aabb = aabb.slice();

    /** Number of {@link Entity}s within the IfcBuildingStorey.
     *
     * @property numObjects
     * @type {Number}
     */
    this.numObjects = numObjects;
};

/**
 * @desc Property states for {@link Entity}s in {@link Storey}s capture by a {@link StoreyViewsPlugin}.
 *
 * @type {{String:Object}}
 */
var IFCStoreyPlanObjectStates = {
    IfcSlab: {
        visible: true,
        edges: false,
        colorize: [1.0, 1.0, 1.0, 1.0]
    },
    IfcWall: {
        visible: true,
        edges: false,
        colorize: [0.1, 0.1, 0.1, 1.0]
    },
    IfcWallStandardCase: {
        visible: true,
        edges: false,
        colorize: [0.1, 0.1, 0.1, 1.0]
    },
    IfcDoor: {
        visible: true,
        edges: false,
        colorize: [0.5, 0.5, 0.5, 1.0]
    },
    IfcWindow: {
        visible: true,
        edges: false,
        colorize: [0.5, 0.5, 0.5, 1.0]
    },
    IfcColumn: {
        visible: true,
        edges: false,
        colorize: [0.5, 0.5, 0.5, 1.0]
    },
    IfcCurtainWall: {
        visible: true,
        edges: false,
        colorize: [0.5, 0.5, 0.5, 1.0]
    },
    IfcStair: {
        visible: true,
        edges: false,
        colorize: [0.7, 0.7, 0.7, 1.0]
    },
    IfcStairFlight: {
        visible: true,
        edges: false,
        colorize: [0.7, 0.7, 0.7, 1.0]
    },
    IfcRamp: {
        visible: true,
        edges: false,
        colorize: [0.7, 0.7, 0.7, 1.0]
    },
    IfcFurniture: {
        visible: true,
        edges: false,
        colorize: [0.7, 0.7, 0.7, 1.0]
    },
    IfcFooting: {
        visible: true,
        edges: false,
        colorize: [0.7, 0.7, 0.7, 1.0]
    },
    IfcFloor: {
        visible: true,
        edges: false,
        colorize: [1.0, 1.0, 1.0, 1.0]
    },
    DEFAULT: {
        visible: false
    }
};

var color$1 = math.vec3();

/**
 * @desc Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * * An Entity represents an object when {@link Entity#isObject} is ````true````.
 * * Each object-Entity is registered by {@link Entity#id} in {@link Scene#objects}.
 *
 * ## See Also
 *
 * * {@link CameraMemento} - Saves and restores the state of a {@link Scene}'s {@link Camera}.
 * * {@link ModelMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll hide a couple of {@link Entity}s and save a snapshot of the visual states of all the Entitys in an ObjectsMemento. Then we'll show all the Entitys
 * again, and then we'll restore the visual states of all the Entitys again from the ObjectsMemento, which will hide those two Entitys again.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, ObjectsMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Hide a couple of objects
 *      viewer.scene.objects["0u4wgLe6n0ABVaiXyikbkA"].visible = false;
 *      viewer.scene.objects["3u4wgLe3n0AXVaiXyikbYO"].visible = false;
 *
 *      // Save memento of all object states, which includes those two hidden objects
 *      const objectsMemento = new ObjectsMemento();
 *
 *      objectsMemento.saveObjects(viewer.scene);
 *
 *      // Show all objects
 *      viewer.scene.setObjectsVisible(viewer.scene.objectIds, true);
 *
 *      // Restore the objects states again, which involves hiding those two objects again
 *      objectsMemento.restoreObjects(viewer.scene);
 * });
 * `````
 *
 * ## Masking Saved State
 *
 * We can optionally supply a mask to focus what state we save and restore.
 *
 * For example, to save and restore only the {@link Entity#visible} and {@link Entity#clippable} states:
 *
 * ````javascript
 * objectsMemento.saveObjects(viewer.scene, {
 *     visible: true,
 *     clippable: true
 * });
 *
 * //...
 *
 * // Restore the objects states again
 * objectsMemento.restoreObjects(viewer.scene);
 * ````
 */
var ObjectsMemento = function ObjectsMemento() {

    /** @private */
    this.objectsVisible = [];

    /** @private */
    this.objectsEdges = [];

    /** @private */
    this.objectsXrayed = [];

    /** @private */
    this.objectsHighlighted = [];

    /** @private */
    this.objectsSelected = [];

    /** @private */
    this.objectsClippable = [];

    /** @private */
    this.objectsPickable = [];

    /** @private */
    this.objectsColorize = [];

    /** @private */
    this.objectsHasColorize = [];

    /** @private */
    this.objectsOpacity = [];

    /** @private */
    this.numObjects = 0;
};

/**
 * Saves a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * @param {Scene} scene The scene.
 * @param {Object} [mask] Masks what state gets saved. Saves all state when not supplied.
 * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
 * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
 * @param {boolean} [mask.edges] Saves {@link Entity#edges} values when ````true````.
 * @param {boolean} [mask.xrayed] Saves {@link Entity#xrayed} values when ````true````.
 * @param {boolean} [mask.highlighted] Saves {@link Entity#highlighted} values when ````true````.
 * @param {boolean} [mask.selected] Saves {@link Entity#selected} values when ````true````.
 * @param {boolean} [mask.clippable] Saves {@link Entity#clippable} values when ````true````.
 * @param {boolean} [mask.pickable] Saves {@link Entity#pickable} values when ````true````.
 * @param {boolean} [mask.colorize] Saves {@link Entity#colorize} values when ````true````.
 * @param {boolean} [mask.opacity] Saves {@link Entity#opacity} values when ````true````.
 */
ObjectsMemento.prototype.saveObjects = function saveObjects (scene, mask) {

    this.numObjects = 0;

    this._mask = mask ? utils.apply(mask, {}) : null;

    var objects = scene.objects;
    var visible = (!mask || mask.visible);
    var edges = (!mask || mask.edges);
    var xrayed = (!mask || mask.xrayed);
    var highlighted = (!mask || mask.highlighted);
    var selected = (!mask || mask.selected);
    var clippable = (!mask || mask.clippable);
    var pickable = (!mask || mask.pickable);
    var colorize = (!mask || mask.colorize);
    var opacity = (!mask || mask.opacity);

    for (var objectId in objects) {
        if (objects.hasOwnProperty(objectId)) {
            var object = objects[objectId];
            var i = this.numObjects;
            if (visible) {
                this.objectsVisible[i] = object.visible;
            }
            if (edges) {
                this.objectsEdges[i] = object.edges;
            }
            if (xrayed) {
                this.objectsXrayed[i] = object.xrayed;
            }
            if (highlighted) {
                this.objectsHighlighted[i] = object.highlighted;
            }
            if (selected) {
                this.objectsSelected[i] = object.selected;
            }
            if (clippable) {
                this.objectsClippable[i] = object.clippable;
            }
            if (pickable) {
                this.objectsPickable[i] = object.pickable;
            }
            if (colorize) {
                var objectColor = object.colorize;
                if (objectColor) {
                    this.objectsColorize[i * 3 + 0] = objectColor[0];
                    this.objectsColorize[i * 3 + 1] = objectColor[1];
                    this.objectsColorize[i * 3 + 2] = objectColor[2];
                    this.objectsHasColorize[i] = true;
                } else {
                    this.objectsHasColorize[i] = false;
                }
            }
            if (opacity) {
                this.objectsOpacity[i] = object.opacity;
            }
            this.numObjects++;
        }
    }
};

/**
 * Restores a {@link Scene}'s {@link Entity}'s to their state previously captured with {@link ObjectsMemento#saveObjects}.
 * @param {Scene} scene The scene.
 */
ObjectsMemento.prototype.restoreObjects = function restoreObjects (scene) {

    var mask = this._mask;

    var visible = (!mask || mask.visible);
    var edges = (!mask || mask.edges);
    var xrayed = (!mask || mask.xrayed);
    var highlighted = (!mask || mask.highlighted);
    var selected = (!mask || mask.selected);
    var clippable = (!mask || mask.clippable);
    var pickable = (!mask || mask.pickable);
    var colorize = (!mask || mask.colorize);
    var opacity = (!mask || mask.opacity);

    var i = 0;

    var objects = scene.objects;

    for (var objectId in objects) {
        if (objects.hasOwnProperty(objectId)) {
            var object = objects[objectId];
            if (visible) {
                object.visible = this.objectsVisible[i];
            }
            if (edges) {
                object.edges = this.objectsEdges[i];
            }
            if (xrayed) {
                object.xrayed = this.objectsXrayed[i];
            }
            if (highlighted) {
                object.highlighted = this.objectsHighlighted[i];
            }
            if (selected) {
                object.selected = this.objectsSelected[i];
            }
            if (clippable) {
                object.clippable = this.objectsClippable[i];
            }
            if (pickable) {
                object.pickable = this.objectsPickable[i];
            }
            if (colorize ) {
                if (this.objectsHasColorize[i]) {
                    color$1[0] = this.objectsColorize[i * 3 + 0];
                    color$1[1] = this.objectsColorize[i * 3 + 1];
                    color$1[2] = this.objectsColorize[i * 3 + 2];
                    object.colorize = color$1;
                } else {
                    object.colorize = null;
                }
            }
            if (opacity) {
                object.opacity = this.objectsOpacity[i];
            }
            i++;
        }
    }
};

/**
 * @desc Saves and restores the state of a {@link Scene}'s {@link Camera}.
 *
 * ## See Also
 *
 * * {@link ModelMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 * * {@link ObjectsMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll save a snapshot of the {@link Camera} state in an CameraMemento. Then we'll move the Camera, and then we'll restore its original state again from the CameraMemento.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, CameraMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * // Set camera
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Save memento of camera state
 *      const cameraMemento = new CameraMemento();
 *
 *      cameraMemento.saveCamera(viewer.scene);
 *
 *      // Move the camera
 *      viewer.camera.eye = [45.3, 2.00, 5.13];
 *      viewer.camera.look = [0.0, 5.5, 10.0];
 *      viewer.camera.up = [0.10, 0.98, -0.14];
 *
 *      // Restore the camera state again
 *      objectsMemento.restoreCamera(viewer.scene);
 * });
 * ````
 */
var CameraMemento = function CameraMemento(scene) {

    /** @private */
    this._eye = math.vec3();

    /** @private */
    this._look = math.vec3();

    /** @private */
    this._up = math.vec3();

    /** @private */
    this._projection = {};

    if (scene) {
        this.saveCamera(scene);
    }
};

/**
 * Saves the state of the given {@link Scene}'s {@link Camera}.
 *
 * @param {Scene} scene The scene that contains the {@link Camera}.
 */
CameraMemento.prototype.saveCamera = function saveCamera (scene) {

    var camera = scene.camera;
    var project = camera.project;

    this._eye.set(camera.eye);
    this._look.set(camera.look);
    this._up.set(camera.up);

    switch (camera.projection) {

        case "perspective":
            this._projection = {
                projection: "perspective",
                fov: project.fov,
                fovAxis: project.fovAxis,
                near: project.near,
                far: project.far
            };
            break;

        case "ortho":
            this._projection = {
                projection: "ortho",
                scale: project.scale,
                near: project.near,
                far: project.far
            };
            break;

        case "frustum":
            this._projection = {
                projection: "frustum",
                left: project.left,
                right: project.right,
                top: project.top,
                bottom: project.bottom,
                near: project.near,
                far: project.far
            };
            break;

        case "custom":
            this._projection = {
                projection: "custom",
                matrix: project.matrix.slice()
            };
            break;
    }
};

/**
 * Restores a {@link Scene}'s {@link Camera} to the state previously captured with {@link CameraMemento#saveCamera}.
 *
 * @param {Scene} scene The scene.
 * @param {Function} [done] When this callback is given, will fly the {@link Camera} to the saved state then fire the callback. Otherwise will just jump the Camera to the saved state.
 */
CameraMemento.prototype.restoreCamera = function restoreCamera (scene, done) {

    var camera = scene.camera;
    var savedProjection = this._projection;

    function restoreProjection() {

        switch (savedProjection.type) {

            case "perspective":
                camera.perspective.fov = savedProjection.fov;
                camera.perspective.fovAxis = savedProjection.fovAxis;
                camera.perspective.near = savedProjection.near;
                camera.perspective.far = savedProjection.far;
                break;

            case "ortho":
                camera.ortho.scale = savedProjection.scale;
                camera.ortho.near = savedProjection.near;
                camera.ortho.far = savedProjection.far;
                break;

            case "frustum":
                camera.frustum.left = savedProjection.left;
                camera.frustum.right = savedProjection.right;
                camera.frustum.top = savedProjection.top;
                camera.frustum.bottom = savedProjection.bottom;
                camera.frustum.near = savedProjection.near;
                camera.frustum.far = savedProjection.far;
                break;

            case "custom":
                camera.customProjection.matrix = savedProjection.matrix;
                break;
        }
    }

    if (done) {
        scene.viewer.cameraFlight.flyTo({
            eye: this._eye,
            look: this._look,
            up: this._up,
            orthoScale: savedProjection.scale,
            projection: savedProjection.projection
        }, function () {
            restoreProjection();
            done();
        });
    } else {
        camera.eye = this._eye;
        camera.look = this._look;
        camera.up = this._up;
        restoreProjection();
        camera.projection = savedProjection.projection;
    }
};

/**
 * @desc A 2D plan view image of an ````IfcBuildingStorey````.
 *
 * These are created by a {@link StoreyViewsPlugin}.
 */
var StoreyMap = function StoreyMap(storeyId, imageData, format, width, height, padding) {

    /**
     * ID of the IfcBuildingStorey.
     *
     * This matches IDs of the IfcBuildingStorey's {@link MetaObject} and {@link Entity}.
     *
     * @property storeyId
     * @type {String}
     */
    this.storeyId = storeyId;

    /**
     * Base64-encoded plan view image.
     *
     * @property imageData
     * @type {String}
     */
    this.imageData = imageData;

    /**
     * The image format - "png" or "jpeg".
     *
     * @property format
     * @type {String}
     */
    this.format = format;

    /**
     * Width of the image, in pixels.
     *
     * @property width
     * @type {Number}
     */
    this.width = width;

    /**
     * Height of the image, in pixels.
     *
     * @property height
     * @type {Number}
     */
    this.height = height;
};

var tempVec3a$5 = math.vec3();
var tempMat4 = math.mat4();

var EMPTY_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==";


/**
 * @desc A {@link Viewer} plugin that provides methods for visualizing IfcBuildingStoreys.
 *
 *  <a href="https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_recipe2"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/minimap.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_recipe2)]
 *
 * ## Overview
 *
 * StoreyViewsPlugin provides a flexible set of methods for visualizing building storeys in 3D and 2D.
 *
 * Use the first two methods to set up 3D views of storeys:
 *
 * * [showStoreyObjects](#instance-method-showStoreyObjects) - shows the {@link Entity}s within a storey, and
 * * [gotoStoreyCamera](#instance-method-gotoStoreyCamera) - positions the {@link Camera} for a plan view of the Entitys within a storey.
 * <br> <br>
 *
 * Use the second two methods to create 2D plan view mini-map images:
 *
 * * [createStoreyMap](#instance-method-createStoreyMap) - creates a 2D plan view image of a storey, and
 * * [pickStoreyMap](#instance-method-pickStoreyMap) - picks the {@link Entity} at the given 2D pixel coordinates within a plan view image.
 *
 * ## Usage
 *
 * Let's start by creating a {@link Viewer} with a StoreyViewsPlugin and an {@link XKTLoaderPlugin}.
 *
 * Then we'll load a BIM building model from an  ```.xkt``` file.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, StoreyViewsPlugin} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer, arrange the camera
 *
 * const viewer = new Viewer({
 *        canvasId: "myCanvas",
 *        transparent: true
 *    });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * // Add an XKTLoaderPlugin
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // Add a StoreyViewsPlugin
 *
 * const storeyViewsPlugin = new StoreyViewsPlugin(viewer);
 *
 * // Load a BIM model from .xkt format
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true
 * });
 * ````
 *
 * ## Finding Storeys
 *
 * Getting information on a storey in our model:
 *
 * ````javascript
 * const storey = storeyViewsPlugin.storeys["2SWZMQPyD9pfT9q87pgXa1"]; // ID of the IfcBuildingStorey
 *
 * const modelId  = storey.modelId;  // "myModel"
 * const storeyId = storey.storeyId; // "2SWZMQPyD9pfT9q87pgXa1"
 * const aabb     = storey.aabb;     // Axis-aligned 3D World-space boundary of the IfcBuildingStorey
 * ````
 *
 * We can also get a "storeys" event every time the set of storeys changes, ie. every time a storey is created or destroyed:
 *
 * ````javascript
 * storeyViewsPlugin.on("storeys", ()=> {
 *      const storey = storeyViewsPlugin.storeys["2SWZMQPyD9pfT9q87pgXa1"];
 *      //...
 * });
 * ````
 *
 * ## Showing Entitys within Storeys
 *
 * Showing the {@link Entity}s within a storey:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1");
 * ````
 *
 * Showing **only** the Entitys in a storey, hiding all others:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1", {
 *     hideOthers: true
 * });
 * ````
 * Showing only the storey Entitys, applying custom appearances configured on {@link StoreyViewsPlugin#objectStates}:
 *
 * ````javascript
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1", {
 *     hideOthers: true,
 *     useObjectStates: true
 * });
 * ````
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_showStoreyObjects"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/showStoreyObjects.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_showStoreyObjects)]
 *
 * When using this option, at some point later you'll probably want to restore all Entitys to their original visibilities and
 * appearances.
 *
 * To do that, save their visibility and appearance states in an {@link ObjectsMemento} beforehand, from
 * which you can restore them later:
 *
 * ````javascript
 * const objectsMemento = new ObjectsMemento();
 *
 * // Save all Entity visibility and appearance states
 *
 * objectsMemento.saveObjects(viewer.scene);
 *
 * // Show storey view Entitys, with custom appearances as configured for IFC types
 *
 * storeyViewsPlugin.showStoreyObjects("2SWZMQPyD9pfT9q87pgXa1", {
 *     useObjectStates: true // <<--------- Apply custom appearances
 * });
 *
 * //...
 *
 * // Later, restore all Entitys to their saved visibility and appearance states
 * objectsMemento.restoreObjects(viewer.scene);
 * ````
 *
 * ## Arranging the Camera for Storey Plan Views
 *
 * The {@link StoreyViewsPlugin#gotoStoreyCamera} method positions the {@link Camera} for a plan view of
 * the {@link Entity}s within the given storey.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_gotoStoreyCamera"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/gotoStoreyCamera.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_gotoStoreyCamera)]
 *
 * Let's fly the {@link Camera} to a downward-looking orthographic view of the Entitys within our storey.
 *
 * ````javascript
 * storeyViewsPlugin.gotoStoreyCamera("2SWZMQPyD9pfT9q87pgXa1", {
 *     projection: "ortho", // Orthographic projection
 *     duration: 2.5,       // 2.5 second transition
 *     done: () => {
 *         viewer.cameraControl.planView = true; // Disable rotation
 *     }
 * });
 * ````
 *
 * Note that we also set {@link CameraControl#planView} ````true````, which prevents the CameraControl from rotating
 * or orbiting. In orthographic mode, this effectively makes the {@link Viewer} behave as if it were a 2D viewer, with
 * picking, panning and zooming still enabled.
 *
 * If you need to be able to restore the Camera to its previous state, you can save it to a {@link CameraMemento}
 * beforehand, from which you can restore it later:
 *
 * ````javascript
 * const cameraMemento = new CameraMemento();
 *
 * // Save camera state
 *
 * cameraMemento.saveCamera(viewer.scene);
 *
 * // Position camera for a downward-looking orthographic view of our storey
 *
 * storeyViewsPlugin.gotoStoreyCamera("2SWZMQPyD9pfT9q87pgXa1", {
 *     projection: "ortho",
 *     duration: 2.5,
 *     done: () => {
 *         viewer.cameraControl.planView = true; // Disable rotation
 *     }
 * });
 *
 * //...
 *
 * // Later, restore the Camera to its saved state
 * cameraMemento.restoreCamera(viewer.scene);
 * ````
 *
 * ## Creating StoreyMaps
 *
 * The {@link StoreyViewsPlugin#createStoreyMap} method creates a 2D orthographic plan image of the given storey.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_createStoreyMap"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/createStoreyMap.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_createStoreyMap)]
 *
 * This method creates a {@link StoreyMap}, which provides the plan image as a Base64-encoded string.
 *
 * Let's create a 2D plan image of our building storey:
 *
 * ````javascript
 * const storeyMap = storeyViewsPlugin.createStoreyMap("2SWZMQPyD9pfT9q87pgXa1", {
 *     width: 300,
 *     format: "png"
 * });
 *
 * const imageData = storeyMap.imageData; // Base64-encoded image data string
 * const width     = storeyMap.width; // 300
 * const height    = storeyMap.height; // Automatically derived from width
 * const format    = storeyMap.format; // "png"
 * ````
 *
 * As with ````showStoreyEntitys````,  We also have the option to customize the appearance of the Entitys in our plan
 * images according to their IFC types, using the lookup table configured on {@link StoreyViewsPlugin#objectStates}.
 *
 * For example, we usually want to show only element types like ````IfcWall````,  ````IfcDoor```` and
 * ````IfcFloor```` in our plan images.
 *
 * Let's create another StoreyMap, this time applying the custom appearances:
 *
 * ````javascript
 * const storeyMap = storeyViewsPlugin.createStoreyMap("2SWZMQPyD9pfT9q87pgXa1", {
 *     width: 300,
 *     format: "png",
 *     useObjectStates: true // <<--------- Apply custom appearances
 * });
 *````
 *
 * We can also specify a ````height```` for the plan image, as an alternative to ````width````:
 *
 *  ````javascript
 *  const storeyMap = storeyViewsPlugin.createStoreyMap("2SWZMQPyD9pfT9q87pgXa1", {
 *      height: 200,
 *      format: "png",
 *      useObjectStates: true
 * });
 * ````
 *
 * ## Picking Entities in StoreyMaps
 *
 * We can use {@link StoreyViewsPlugin#pickStoreyMap} to pick Entities in our building storey, using 2D coordinates from mouse or touch events on our {@link StoreyMap}'s 2D plan image.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_recipe2"><img src="http://xeokit.io/img/docs/StoreyViewsPlugin/recipe2.gif"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#storeyViews_StoreyViewsPlugin_recipe2)]
 *
 * Let's programmatically pick the Entity at the given 2D pixel coordinates within our image:
 *
 * ````javascript
 * const mouseCoords = [65, 120]; // Mouse coords within the image extents
 *
 * const pickResult = storeyViewsPlugin.pickStoreyMap(storeyMap, mouseCoords);
 *
 * if (pickResult && pickResult.entity) {
 *     pickResult.entity.highlighted = true;
 * }
 * ````
 */
var StoreyViewsPlugin = /*@__PURE__*/(function (Plugin) {
    function StoreyViewsPlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "StoreyViews", viewer);

        this._objectsMemento = new ObjectsMemento();
        this._cameraMemento = new CameraMemento();

        /**
         * A {@link Storey} for each ````IfcBuildingStorey```.
         *
         * There will be a {@link Storey} for every existing {@link MetaObject} whose {@link MetaObject#type} equals "IfcBuildingStorey".
         *
         * These are created and destroyed automatically as models are loaded and destroyed.
         *
         * @type {{String:Storey}}
         */
        this.storeys = {};

        /**
         * A set of {@link Storey}s for each {@link MetaModel}.
         *
         * These are created and destroyed automatically as models are loaded and destroyed.
         *
         * @type {{String: {String:Storey}}}
         */
        this.modelStoreys = {};

        this.objectStates = cfg.objectStates;

        this._onModelLoaded = this.viewer.scene.on("modelLoaded", function (modelId) {
            this$1._registerModelStoreys(modelId);
            this$1.fire("storeys", this$1.storeys);
        });
    }

    if ( Plugin ) StoreyViewsPlugin.__proto__ = Plugin;
    StoreyViewsPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    StoreyViewsPlugin.prototype.constructor = StoreyViewsPlugin;

    var prototypeAccessors = { objectStates: { configurable: true } };

    StoreyViewsPlugin.prototype._registerModelStoreys = function _registerModelStoreys (modelId) {
        var this$1 = this;

        var viewer = this.viewer;
        var scene = viewer.scene;
        var metaScene = viewer.metaScene;
        var metaModel = metaScene.metaModels[modelId];
        var model = scene.models[modelId];
        if (!metaModel || !metaModel.rootMetaObject) {
            return;
        }
        var storeyIds = metaModel.rootMetaObject.getObjectIDsInSubtreeByType(["IfcBuildingStorey"]);
        for (var i = 0, len = storeyIds.length; i < len; i++) {
            var storeyId = storeyIds[i];
            var metaObject = metaScene.metaObjects[storeyId];
            var childObjectIds = metaObject.getObjectIDsInSubtree();
            var aabb = scene.getAABB(childObjectIds);
            var numObjects = (Math.random() > 0.5) ? childObjectIds.length : 0;
            var storey = new Storey(this, aabb, modelId, storeyId, numObjects);
            storey._onModelDestroyed = model.once("destroyed", function () {
                this$1._deregisterModelStoreys(modelId);
                this$1.fire("storeys", this$1.storeys);
            });
            this.storeys[storeyId] = storey;
            if (!this.modelStoreys[modelId]) {
                this.modelStoreys[modelId] = {};
            }
            this.modelStoreys[modelId][storeyId] = storey;
        }
    };

    StoreyViewsPlugin.prototype._deregisterModelStoreys = function _deregisterModelStoreys (modelId) {
        var storeys = this.modelStoreys[modelId];
        if (storeys) {
            var scene = this.viewer.scene;
            for (var storyObjectId in storeys) {
                if (storeys.hasOwnProperty(storyObjectId)) {
                    var storey = storeys[storyObjectId];
                    var model = scene.models[storey.modelId];
                    if (model) {
                        model.off(storey._onModelDestroyed);
                    }
                    delete this.storeys[storyObjectId];
                }
            }
            delete this.modelStoreys[modelId];
        }
    };

    /**
     * Sets map of visual states for the {@link Entity}s as rendered within each {@link Storey}.
     *
     * Default value is {@link IFCStoreyPlanObjectStates}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectStates.set = function (value) {
        this._objectStates = value || IFCStoreyPlanObjectStates;
    };

    /**
     * Gets map of visual states for the {@link Entity}s as rendered within each {@link Storey}.
     *
     * Default value is {@link IFCStoreyPlanObjectStates}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectStates.get = function () {
        return this._objectStates;
    };

    /**
     * Arranges the {@link Camera} for a 3D orthographic view of the {@link Entity}s within the given storey.
     *
     * See also: {@link CameraMemento}, which saves and restores the state of the {@link Scene}'s {@link Camera}
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for arranging the Camera.
     * @param {String} [options.projection] Projection type to transition the Camera to. Accepted values are "perspective" and "ortho".
     * @param {Function} [options.done] Callback to fire when the Camera has arrived. When provided, causes an animated flight to the saved state. Otherwise jumps to the saved state.
     */
    StoreyViewsPlugin.prototype.gotoStoreyCamera = function gotoStoreyCamera (storeyId, options) {
        if ( options === void 0 ) options = {};


        var storey = this.storeys[storeyId];

        if (!storey) {
            this.error("IfcBuildingStorey not found with this ID: " + storeyId);
            if (options.done) {
                options.done();
            }
            return;
        }

        var viewer = this.viewer;
        var scene = viewer.scene;
        var camera = scene.camera;
        var aabb = storey.aabb;

        if (aabb[3] < aabb[0] || aabb[4] < aabb[1] || aabb[5] < aabb[2]) { // Don't fly to an inverted boundary
            if (options.done) {
                options.done();
            }
            return;
        }
        if (aabb[3] === aabb[0] && aabb[4] === aabb[1] && aabb[5] === aabb[2]) { // Don't fly to an empty boundary
            if (options.done) {
                options.done();
            }
            return;
        }
        var look2 = math.getAABB3Center(aabb);
        var diag = math.getAABB3Diag(aabb);
        var fitFOV = 45; // fitFOV;
        var sca = Math.abs(diag / Math.tan(fitFOV * math.DEGTORAD));

        var orthoScale2 = diag * 1.3;

        var eye2 = tempVec3a$5;

        eye2[0] = look2[0] + (camera.worldUp[0] * sca);
        eye2[1] = look2[1] + (camera.worldUp[1] * sca);
        eye2[2] = look2[2] + (camera.worldUp[2] * sca);

        var up2 = camera.worldForward;

        if (options.done) {

            viewer.cameraFlight.flyTo(utils.apply(options, {
                eye: eye2,
                look: look2,
                up: up2,
                orthoScale: orthoScale2
            }), function () {
                options.done();
            });

        } else {

            viewer.cameraFlight.jumpTo(utils.apply(options, {
                eye: eye2,
                look: look2,
                up: up2,
                orthoScale: orthoScale2
            }));

            viewer.camera.ortho.scale = orthoScale2;
        }
    };

    /**
     * Shows the {@link Entity}s within the given storey.
     *
     * Optionally hides all other Entitys.
     *
     * Optionally sets the visual appearance of each of the Entitys according to its IFC type. The appearance of
     * IFC types in plan views is configured by {@link StoreyViewsPlugin#objectStates}.
     *
     * See also: {@link ObjectsMemento}, which saves and restores a memento of the visual state
     * of the {@link Entity}'s that represent objects within a {@link Scene}.
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for showing the Entitys within the storey.
     * @param {Boolean} [options.hideOthers=false] When ````true````, hide all other {@link Entity}s.
     * @param {Boolean} [options.useObjectStates=false] When ````true````, apply the custom visibilities and appearances configured for IFC types in {@link StoreyViewsPlugin#objectStates}.
     */
    StoreyViewsPlugin.prototype.showStoreyObjects = function showStoreyObjects (storeyId, options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};


        var storey = this.storeys[storeyId];

        if (!storey) {
            this.error("IfcBuildingStorey not found with this ID: " + storeyId);
            return;
        }

        var viewer = this.viewer;
        var scene = viewer.scene;
        var metaScene = viewer.metaScene;
        var storeyMetaObject = metaScene.metaObjects[storeyId];

        if (!storeyMetaObject) {
            return;
        }

        if (options.hideOthers) {
            scene.setObjectsVisible(viewer.scene.visibleObjectIds, false);
        }

        this.withStoreyObjects(storeyId, function (entity, metaObject) {
            if (entity) {
                if (options.useObjectStates) {
                    var props = this$1._objectStates[metaObject.type] || this$1._objectStates["DEFAULT"];
                    if (props) {
                        entity.visible = props.visible;
                        entity.edges = props.edges;
                        // entity.xrayed = props.xrayed; // FIXME: Buggy
                        // entity.highlighted = props.highlighted;
                        // entity.selected = props.selected;
                        if (props.colorize) {
                            entity.colorize = props.colorize;
                        }
                        if (props.opacity !== null && props.opacity !== undefined) {
                            entity.opacity = props.opacity;
                        }
                    }
                } else {
                    entity.visible = true;
                }
            }
        });
    };

    /**
     * Executes a callback on each of the objects within the given storey.
     *
     * ## Usage
     *
     * In the example below, we'll show all the {@link Entity}s, within the given ````IfcBuildingStorey````,
     * that have {@link MetaObject}s with type ````IfcSpace````. Note that the callback will only be given
     * an {@link Entity} when one exists for the given {@link MetaObject}.
     *
     * ````JavaScript
     * myStoreyViewsPlugin.withStoreyObjects(storeyId, (entity, metaObject) => {
     *      if (entity && metaObject && metaObject.type === "IfcSpace") {
     *          entity.visible = true;
     *      }
     * });
     * ````
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {Function} callback The callback.
     */
    StoreyViewsPlugin.prototype.withStoreyObjects = function withStoreyObjects (storeyId, callback) {
        var viewer = this.viewer;
        var scene = viewer.scene;
        var metaScene = viewer.metaScene;
        var rootMetaObject = metaScene.metaObjects[storeyId];
        if (!rootMetaObject) {
            return;
        }
        var storeySubObjects = rootMetaObject.getObjectIDsInSubtree();
        for (var i = 0, len = storeySubObjects.length; i < len; i++) {
            var objectId = storeySubObjects[i];
            var metaObject = metaScene.metaObjects[objectId];
            var entity = scene.objects[objectId];
            if (entity) {
                callback(entity, metaObject);
            }
        }
    };

    /**
     * Creates a 2D map of the given storey.
     *
     * @param {String} storeyId ID of the ````IfcBuildingStorey```` object.
     * @param {*} [options] Options for creating the image.
     * @param {Number} [options.width=300] Image width in pixels. Height will be automatically determined from this, if not given.
     * @param {Number} [options.height=300] Image height in pixels, as an alternative to width. Width will be automatically determined from this, if not given.
     * @param {String} [options.format="png"] Image format. Accepted values are "png" and "jpeg".
     * @returns {StoreyMap} The StoreyMap.
     */
    StoreyViewsPlugin.prototype.createStoreyMap = function createStoreyMap (storeyId, options) {
        if ( options === void 0 ) options = {};


        var storey = this.storeys[storeyId];
        if (!storey) {
            this.error("IfcBuildingStorey not found with this ID: " + storeyId);
            return EMPTY_IMAGE;
        }

        var viewer = this.viewer;
        var scene = viewer.scene;
        var format = options.format || "png";
        var aabb = storey.aabb;
        var aspect = (aabb[5] - aabb[2]) / (aabb[3] - aabb[0]);
        var padding = options.padding || 0;

        var width;
        var height;

        if (options.width && options.height) {
            width = options.width;
            height = options.height;

        } else if (options.height) {
            height = options.height;
            width = height / aspect;

        } else if (options.width) {
            width = options.width;
            height = width * aspect;

        } else {
            width = 300;
            height = width * aspect;
        }

        this._objectsMemento.saveObjects(scene);
        this._cameraMemento.saveCamera(scene);

        viewer.beginSnapshot();

        this.showStoreyObjects(storeyId, utils.apply(options, {
            useObjectStates: true,
            hideOthers: true
        }));

        this._arrangeStoreyMapCamera(storey);

        var src = viewer.getSnapshot({
            width: width,
            height: height,
            format: format,
        });

        this._objectsMemento.restoreObjects(scene);
        this._cameraMemento.restoreCamera(scene);

        viewer.endSnapshot();

        return new StoreyMap(storeyId, src, format, width, height, padding);
    };

    StoreyViewsPlugin.prototype._arrangeStoreyMapCamera = function _arrangeStoreyMapCamera (storey) {
        var viewer = this.viewer;
        var scene = viewer.scene;
        var camera = scene.camera;
        var aabb = storey.aabb;
        var look = math.getAABB3Center(aabb);
        var sca = 0.5;
        var eye = tempVec3a$5;
        eye[0] = look[0] + (camera.worldUp[0] * sca);
        eye[1] = look[1] + (camera.worldUp[1] * sca);
        eye[2] = look[2] + (camera.worldUp[2] * sca);
        var up = camera.worldForward;
        viewer.cameraFlight.jumpTo({eye: eye, look: look, up: up});
        var xHalfSize = (aabb[3] - aabb[0]) / 2;
        var yHalfSize = (aabb[4] - aabb[1]) / 2;
        var zHalfSize = (aabb[5] - aabb[2]) / 2;
        var xmin = -xHalfSize;
        var xmax = +xHalfSize;
        var ymin = -yHalfSize;
        var ymax = +yHalfSize;
        var zmin = -zHalfSize;
        var zmax = +zHalfSize;
        viewer.camera.customProjection.matrix = math.orthoMat4c(xmin, xmax, zmin, zmax, ymin, ymax, tempMat4);
        viewer.camera.projection = "customProjection";
    };

    /**
     * Attempts to pick an {@link Entity} at the given pixel coordinates within a StoreyMap image.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} imagePos 2D pixel coordinates within the bounds of {@link StoreyMap#imageData}.
     * @param {*} [options] Picking options.
     * @param {Boolean} [options.pickSurface=false] Whether to return the picked position on the surface of the Entity.
     * @returns {PickResult} The pick result, if an Entity was successfully picked, else null.
     */
    StoreyViewsPlugin.prototype.pickStoreyMap = function pickStoreyMap (storeyMap, imagePos, options) {
        if ( options === void 0 ) options = {};


        var storeyId = storeyMap.storeyId;
        var storey = this.storeys[storeyId];

        if (!storey) {
            this.error("IfcBuildingStorey not found with this ID: " + storeyId);
            return null
        }

        var normX = 1.0 - (imagePos[0] / storeyMap.width);
        var normZ = 1.0 - (imagePos[1] / storeyMap.height);

        var aabb = storey.aabb;

        var xmin = aabb[0];
        var ymin = aabb[1];
        var zmin = aabb[2];
        var xmax = aabb[3];
        var ymax = aabb[4];
        var zmax = aabb[5];

        var xWorldSize = xmax - xmin;
        var yWorldSize = ymax - ymin;
        var zWorldSize = zmax - zmin;

        var origin = math.vec3([xmin + (xWorldSize * normX), ymin + (yWorldSize * 0.5), zmin + (zWorldSize * normZ)]);
        var direction = math.vec3([0, -1, 0]);
        var look = math.addVec3(origin, direction, tempVec3a$5);
        var worldForward = this.viewer.camera.worldForward;
        var matrix = math.lookAtMat4v(origin, look, worldForward, tempMat4);

        var pickResult = this.viewer.scene.pick({  // Picking with arbitrarily-positioned ray
            pickSurface: options.pickSurface,
            pickInvisible: true,
            matrix: matrix
        });

        if (pickResult) {
            var metaObject = this.viewer.metaScene.metaObjects[pickResult.entity.id];
            var objectState = this.objectStates[metaObject.type];
            if (!objectState || !objectState.visible) {
                return null;
            }
        }

        return pickResult;
    };

    /**
     * Gets the ID of the storey that contains the given 3D World-space position.
     *.
     * @param {Number[]} worldPos 3D World-space position.
     * @returns {String} ID of the storey containing the position, or null if the position falls outside all the storeys.
     */
    StoreyViewsPlugin.prototype.getStoreyContainingWorldPos = function getStoreyContainingWorldPos (worldPos) {
        for (var storeyId in this.storeys) {
            var storey = this.storeys[storeyId];
            if (math.point3AABB3Intersect(storey.aabb, worldPos)) {
                return storeyId;
            }
        }
        return null;
    };

    /**
     * Converts a 3D World-space position to a 2D position within a StoreyMap image.
     *
     * Use {@link StoreyViewsPlugin#pickStoreyMap} to convert 2D image positions to 3D world-space.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} worldPos 3D World-space position within the storey.
     * @param {Number[]} imagePos 2D pixel position within the {@link StoreyMap#imageData}.
     * @returns {Boolean} True if ````imagePos```` is within the bounds of the {@link StoreyMap#imageData}, else ````false```` if it falls outside.
     */
    StoreyViewsPlugin.prototype.worldPosToStoreyMap = function worldPosToStoreyMap (storeyMap, worldPos, imagePos) {

        var storeyId = storeyMap.storeyId;
        var storey = this.storeys[storeyId];

        if (!storey) {
            this.error("IfcBuildingStorey not found with this ID: " + storeyId);
            return false
        }

        var aabb = storey.aabb;

        var xmin = aabb[0];
        var ymin = aabb[1];
        var zmin = aabb[2];

        var xmax = aabb[3];
        var ymax = aabb[4];
        var zmax = aabb[5];

        var xWorldSize = xmax - xmin;
        var yWorldSize = ymax - ymin;
        var zWorldSize = zmax - zmin;

        var camera = this.viewer.camera;
        var worldUp = camera.worldUp;

        var xUp = worldUp[0] > worldUp[1] && worldUp[0] > worldUp[2];
        var yUp = !xUp && worldUp[1] > worldUp[0] && worldUp[1] > worldUp[2];
        !xUp && !yUp && worldUp[2] > worldUp[0] && worldUp[2] > worldUp[1];

        var ratioX = (storeyMap.width / xWorldSize);
        var ratioY = yUp ? (storeyMap.height / zWorldSize) : (storeyMap.height / yWorldSize); // Assuming either Y or Z is "up", but never X

        imagePos[0] = Math.floor(storeyMap.width - ((worldPos[0] - xmin) * ratioX));
        imagePos[1] = Math.floor(storeyMap.height - ((worldPos[2] - zmin) * ratioY));

        return (imagePos[0] >= 0 && imagePos[0] < storeyMap.width && imagePos[1] >= 0 && imagePos[1] <= storeyMap.height);
    };

    /**
     * Converts a 3D World-space direction vector to a 2D vector within a StoreyMap image.
     *
     * @param {StoreyMap} storeyMap The StoreyMap.
     * @param {Number[]} worldDir 3D World-space direction vector.
     * @param {Number[]} imageDir Normalized 2D direction vector.
     */
    StoreyViewsPlugin.prototype.worldDirToStoreyMap = function worldDirToStoreyMap (storeyMap, worldDir, imageDir) {
        var camera = this.viewer.camera;
        var eye = camera.eye;
        var look = camera.look;
        var eyeLookDir = math.subVec3(look, eye, tempVec3a$5);
        var worldUp = camera.worldUp;
        var xUp = worldUp[0] > worldUp[1] && worldUp[0] > worldUp[2];
        var yUp = !xUp && worldUp[1] > worldUp[0] && worldUp[1] > worldUp[2];
        !xUp && !yUp && worldUp[2] > worldUp[0] && worldUp[2] > worldUp[1];
        if (xUp) {
            imageDir[0] = eyeLookDir[1];
            imageDir[1] = eyeLookDir[2];
        } else if (yUp) {
            imageDir[0] = eyeLookDir[0];
            imageDir[1] = eyeLookDir[2];
        } else {
            imageDir[0] = eyeLookDir[0];
            imageDir[1] = eyeLookDir[1];
        }
        math.normalizeVec2(imageDir);
    };

    /**
     * Destroys this StoreyViewsPlugin.
     */
    StoreyViewsPlugin.prototype.destroy = function destroy () {
        this.viewer.scene.off(this._onModelLoaded);
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( StoreyViewsPlugin.prototype, prototypeAccessors );

    return StoreyViewsPlugin;
}(Plugin));

/**
 * Tests if {@link TreeViewPlugin} would be able to create a "types" hierarchy for the given {@link MetaModel}.
 *
 * @param {MetaModel} metaModel The MetaModel.
 * @param {String[]} errors Accumulates messages for validation errors.
 * @return {boolean} Returns ````true```` if no errors found, else ````false````.
 */
function validateMetaModelForTreeViewTypesHierarchy(metaModel, errors) {
    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        errors.push("Can't build types hierarchy: model is empty");
        return false;
    }
    return true;
}

/**
 * Tests if {@link TreeViewPlugin} would be able to create a "storeys" hierarchy for the given {@link MetaModel}.
 *
 * @param {MetaModel} metaModel The MetaModel.
 * @param {String[]} errors Accumulates messages for validation errors.
 * @return {boolean} Returns ````true```` if no errors found, else ````false````.
 */
function validateMetaModelForTreeViewStoreysHierarchy(metaModel, errors) {
    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        errors.push("Can't build storeys hierarchy: model is empty");
        return false;
    }
    return _validateMetaModelForStoreysHierarchy(rootMetaObject, errors);
}

/**
 * Tests if {@link TreeViewPlugin} would be able to create a "containment" hierarchy for the given {@link MetaModel}.
 *
 * @param {MetaModel} metaModel The MetaModel.
 * @param {String[]} errors Accumulates messages for validation errors.
 * @return {boolean} Returns ````true```` if no errors found, else ````false````.
 */
function validateMetaModelForTreeViewContainmentHierarchy(metaModel, errors) {
    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        errors.push("Can't build containment hierarchy: model is empty");
        return false;
    }
    return true;
}

/**
 * @private
 */
function _validateMetaModelForStoreysHierarchy(metaObject, errors, level, ctx, buildingNode) {
    if ( level === void 0 ) level = 0;

    ctx = ctx || {
        foundIFCBuildingStoreys: false
    };
    var metaObjectType = metaObject.type;
    var children = metaObject.children;
    if (metaObjectType === "IfcBuilding") {
        buildingNode = true;
    } else if (metaObjectType === "IfcBuildingStorey") {
        if (!buildingNode) {
            errors.push("Can't build storeys hierarchy: IfcBuildingStorey found without parent IfcBuilding");
            return false;
        }
        ctx.foundIFCBuildingStoreys = true;
    }
    if (children) {
        for (var i = 0, len = children.length; i < len; i++) {
            var childMetaObject = children[i];
            if (!_validateMetaModelForStoreysHierarchy(childMetaObject, errors, level + 1, ctx, buildingNode)) {
                return false;
            }
        }
    }
    if (level === 0) {
        if (!ctx.foundIFCBuildingStoreys) ;
    }
    return true;
}

var idMap = new Map();

/**
 * @desc Represents a model tree view within a {@link TreeViewPlugin}.
 *
 * * Stored in {@link treeViewPlugin#modelTreeViews}, mapped to the model ID.
 * * Created by each call to {@link TreeViewPlugin#addModel}.
 */
var ModelTreeView = function ModelTreeView(viewer, treeViewPlugin, model, metaModel, cfg) {
    var this$1 = this;


    if (!cfg.containerElement) {
        throw "Config expected: containerElement";
    }

    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        return;
    }

    /**
     * Contains messages for any errors found in the MetaModel for this ModelTreeView.
     * @type {String[]}
     */
    this.errors = [];

    /**
     * True if errors were found in the MetaModel for this ModelTreeView.
     * @type {boolean}
     */
    this.valid = true;

    /**
     * The MetaModel corresponding to this ModelTreeView.
     * @type {MetaModel}
     */
    this.metaModel = metaModel;

    this._id = idMap.addItem();
    this._baseId = "" + this._id;
    this._viewer = viewer;
    this._treeViewPlugin = treeViewPlugin;
    this._rootMetaObject = rootMetaObject;
    this._containerElement = cfg.containerElement;
    this._rootElement = null;
    this._muteSceneEvents = false;
    this._muteTreeEvents = false;
    this._rootNodes = [];
    this._objectNodes = {};
    this._rootName = cfg.rootName;
    this._sortNodes = cfg.sortNodes;
    this._pruneEmptyNodes = cfg.pruneEmptyNodes;

    this._showListItemElementId = null;

    this._containerElement.oncontextmenu = function (e) {
        e.preventDefault();
    };

    this._onObjectVisibility = this._viewer.scene.on("objectVisibility", function (entity) {
        if (this$1._muteSceneEvents) {
            return;
        }
        var objectId = entity.id;
        var node = this$1._objectNodes[objectId];
        if (!node) {
            return; // Not in this tree
        }
        var visible = entity.visible;
        var updated = (visible !== node.checked);
        if (!updated) {
            return;
        }
        this$1._muteTreeEvents = true;
        node.checked = visible;
        if (visible) {
            node.numVisibleEntities++;
        } else {
            node.numVisibleEntities--;
        }
        var checkbox = document.getElementById(node.nodeId);
        if (checkbox) {
            checkbox.checked = visible;
        }
        var parent = node.parent;
        while (parent) {
            parent.checked = visible;
            if (visible) {
                parent.numVisibleEntities++;
            } else {
                parent.numVisibleEntities--;
            }
            var parentCheckbox = document.getElementById(parent.nodeId);
            if (parentCheckbox) {
                var newChecked = (parent.numVisibleEntities > 0);
                if (newChecked !== parentCheckbox.checked) {
                    parentCheckbox.checked = newChecked;
                }
            }
            parent = parent.parent;
        }
        this$1._muteTreeEvents = false;
    });

    this.switchExpandHandler = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var switchElement = event.target;
        this$1._expandSwitchElement(switchElement);
    };

    this.switchCollapseHandler = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var switchElement = event.target;
        this$1._collapseSwitchElement(switchElement);
    };

    this._checkboxChangeHandler = function (event) {
        if (this$1._muteTreeEvents) {
            return;
        }
        this$1._muteSceneEvents = true;
        var checkbox = event.target;
        var visible = checkbox.checked;
        var nodeId = checkbox.id;
        var checkedObjectId = this$1._nodeToObjectID(nodeId);
        var checkedNode = this$1._objectNodes[checkedObjectId];
        var objects = this$1._viewer.scene.objects;
        var numUpdated = 0;
        this$1._withNodeTree(checkedNode, function (node) {
            var objectId = node.objectId;
            var checkBoxId = node.nodeId;
            var entity = objects[objectId];
            var isLeaf = (node.children.length === 0);
            node.numVisibleEntities = visible ? node.numEntities : 0;
            if (isLeaf && (visible !== node.checked)) {
                numUpdated++;
            }
            node.checked = visible;
            var checkbox2 = document.getElementById(checkBoxId);
            if (checkbox2) {
                checkbox2.checked = visible;
            }
            if (entity) {
                entity.visible = visible;
            }
        });
        var parent = checkedNode.parent;
        while (parent) {
            parent.checked = visible;
            var checkbox2 = document.getElementById(parent.nodeId); // Parent checkboxes are always in DOM
            if (visible) {
                parent.numVisibleEntities += numUpdated;
            } else {
                parent.numVisibleEntities -= numUpdated;
            }
            var newChecked = (parent.numVisibleEntities > 0);
            if (newChecked !== checkbox2.checked) {
                checkbox2.checked = newChecked;
            }
            parent = parent.parent;
        }
        this$1._muteSceneEvents = false;
    };

    this._hierarchy = cfg.hierarchy || "containment";
    this._autoExpandDepth = cfg.autoExpandDepth || 0;

    this._createNodes();
};

ModelTreeView.prototype._nodeToObjectID = function _nodeToObjectID (nodeId) {
    return nodeId.substring(this._baseId.length);
};

ModelTreeView.prototype._objectToNodeID = function _objectToNodeID (objectId) {
    return this._baseId + objectId;
};

/**
 * @private
 * @param depth
 */
ModelTreeView.prototype.setAutoExpandDepth = function setAutoExpandDepth (depth) {
        if ( depth === void 0 ) depth = 0;

    this._autoExpandDepth = depth;
};

/**
 * @private
 * @param hierarchy
 */
ModelTreeView.prototype.setHierarchy = function setHierarchy (hierarchy) {
    if (this._hierarchy === hierarchy) {
        return;
    }
    this._hierarchy = hierarchy;
    this._createNodes();
};

ModelTreeView.prototype._createNodes = function _createNodes () {
    if (this._rootElement) {
        this._rootElement.parentNode.removeChild(this._rootElement);
        this._rootElement = null;
    }
    this._rootNodes = [];
    this._objectNodes = {};
    this._validate();
    if (this.valid || (this._hierarchy !== "storeys")) {
        this._createEnabledNodes();
    } else {
        this._createDisabledNodes();
    }
};

ModelTreeView.prototype._validate = function _validate () {
    this.errors = [];
    switch (this._hierarchy) {
        case "storeys":
            this.valid = validateMetaModelForTreeViewStoreysHierarchy(this.metaModel, this.errors);
            break;
        case "types":
            this.valid = validateMetaModelForTreeViewTypesHierarchy(this.metaModel, this.errors);
            break;
        case "containment":
        default:
            this.valid = validateMetaModelForTreeViewContainmentHierarchy(this.metaModel, this.errors);
            break;
    }
    return this.valid;
};

ModelTreeView.prototype._createEnabledNodes = function _createEnabledNodes () {
    if (this._pruneEmptyNodes) {
        this._findEmptyNodes();
    }
    switch (this._hierarchy) {
        case "storeys":
            this._createStoreysNodes();
            if (this._rootNodes.length === 0) {
                this._treeViewPlugin.error("Failed to build storeys hierarchy for model '" + this.metaModel.id + "' - perhaps this model is not an IFC model?");
            }
            break;
        case "types":
            this._createTypesNodes();
            break;
        case "containment":
        default:
            this._createContainmentNodes();
    }
    if (this._sortNodes) {
        this._doSortNodes();
    }
    this._synchNodesToEntities();
    this._createTrees();
    this.expandToDepth(this._autoExpandDepth);
};

ModelTreeView.prototype._createDisabledNodes = function _createDisabledNodes () {

    var metaObject = this._rootMetaObject;
    var metaObjectType = metaObject.type;
    var metaObjectName = metaObject.name;

    var rootName = ((metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType);

    var ul = document.createElement('ul');
    var li = document.createElement('li');
    ul.appendChild(li);
    this._containerElement.appendChild(ul);
    this._rootElement = ul;

    var switchElement = document.createElement('a');
    switchElement.href = '#';
    switchElement.textContent = '!';
    switchElement.classList.add('warn');
    switchElement.classList.add('warning');
    li.appendChild(switchElement);

    var span = document.createElement('span');
    span.textContent = rootName;
    li.appendChild(span);
};

ModelTreeView.prototype._findEmptyNodes = function _findEmptyNodes (metaObject, countEntities) {
        if ( metaObject === void 0 ) metaObject = this._rootMetaObject;

    var viewer = this._treeViewPlugin.viewer;
    var scene = viewer.scene;
    var children = metaObject.children;
    var objectId = metaObject.id;
    var entity = scene.objects[objectId];
    metaObject._countEntities = 0;
    if (entity) {
        metaObject._countEntities++;
    }
    if (children) {
        for (var i = 0, len = children.length; i < len; i++) {
            var childMetaObject = children[i];
            childMetaObject._countEntities = this._findEmptyNodes(childMetaObject);
            metaObject._countEntities += childMetaObject._countEntities;
        }
    }
    return metaObject._countEntities;
};

ModelTreeView.prototype._createStoreysNodes = function _createStoreysNodes (
    metaObject,
    buildingNode,
    storeyNode,
    typeNodes) {
        if ( metaObject === void 0 ) metaObject = this._rootMetaObject;

    if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {
        return;
    }
    var metaObjectType = metaObject.type;
    var metaObjectName = metaObject.name;
    var children = metaObject.children;
    var objectId = metaObject.id;
    if (metaObjectType === "IfcBuilding") {
        buildingNode = {
            nodeId: this._objectToNodeID(objectId),
            objectId: objectId,
            title: this._rootName || ((metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType),
            type: metaObjectType,
            parent: null,
            numEntities: 0,
            numVisibleEntities: 0,
            checked: false,
            children: []
        };
        this._rootNodes.push(buildingNode);
        this._objectNodes[buildingNode.objectId] = buildingNode;
    } else if (metaObjectType === "IfcBuildingStorey") {
        if (!buildingNode) {
            this._treeViewPlugin.error("Failed to build storeys hierarchy for model '" + this.metaModel.id + "' - model does not have an IfcBuilding object, or is not an IFC model");
            return;
        }
        storeyNode = {
            nodeId: this._objectToNodeID(objectId),
            objectId: objectId,
            title: (metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType,
            type: metaObjectType,
            parent: buildingNode,
            numEntities: 0,
            numVisibleEntities: 0,
            checked: false,
            children: []
        };
        buildingNode.children.push(storeyNode);
        this._objectNodes[storeyNode.objectId] = storeyNode;
        typeNodes = {};
    } else {
        if (storeyNode) {
            var objects = this._viewer.scene.objects;
            var object = objects[objectId];
            if (object) {
                typeNodes = typeNodes || {};
                var typeNode = typeNodes[metaObjectType];
                if (!typeNode) {
                    var typeNodeObjectId = storeyNode.objectId + "." + metaObjectType;
                    var typeNodeNodeId = this._objectToNodeID(typeNodeObjectId);
                    typeNode = {
                        nodeId: typeNodeNodeId,
                        objectId: typeNodeObjectId,
                        title: metaObjectType,
                        type: metaObjectType,
                        parent: storeyNode,
                        numEntities: 0,
                        numVisibleEntities: 0,
                        checked: false,
                        children: []
                    };
                    storeyNode.children.push(typeNode);
                    this._objectNodes[typeNodeObjectId] = typeNode;
                    typeNodes[metaObjectType] = typeNode;
                }
                var node = {
                    nodeId: this._objectToNodeID(objectId),
                    objectId: objectId,
                    title: (metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType,
                    type: metaObjectType,
                    parent: typeNode,
                    numEntities: 0,
                    numVisibleEntities: 0,
                    checked: false,
                    children: []
                };
                typeNode.children.push(node);
                this._objectNodes[node.objectId] = node;
            }
        }
    }
    if (children) {
        for (var i = 0, len = children.length; i < len; i++) {
            var childMetaObject = children[i];
            this._createStoreysNodes(childMetaObject, buildingNode, storeyNode, typeNodes);
        }
    }
};

ModelTreeView.prototype._createTypesNodes = function _createTypesNodes (metaObject, rootNode, typeNodes) {
        if ( metaObject === void 0 ) metaObject = this._rootMetaObject;

    if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {
        return;
    }
    var metaObjectType = metaObject.type;
    var metaObjectName = metaObject.name;
    var children = metaObject.children;
    var objectId = metaObject.id;
    if (metaObject.id === this._rootMetaObject.id) {
        rootNode = {
            nodeId: this._objectToNodeID(objectId),
            objectId: objectId,
            title: this._rootName || ((metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType),
            type: metaObjectType,
            parent: null,
            numEntities: 0,
            numVisibleEntities: 0,
            checked: false,
            children: []
        };
        this._rootNodes.push(rootNode);
        this._objectNodes[rootNode.objectId] = rootNode;
        typeNodes = {};
    } else {
        if (rootNode) {
            var objects = this._viewer.scene.objects;
            var object = objects[objectId];
            if (object) {
                var typeNode = typeNodes[metaObjectType];
                if (!typeNode) {
                    typeNode = {
                        nodeId: this._objectToNodeID(rootNode.objectId + "." + metaObjectType),
                        objectId: rootNode.objectId + "." + metaObjectType,
                        title: metaObjectType,
                        type: metaObjectType,
                        parent: rootNode,
                        numEntities: 0,
                        numVisibleEntities: 0,
                        checked: false,
                        children: []
                    };
                    rootNode.children.push(typeNode);
                    this._objectNodes[typeNode.objectId] = typeNode;
                    typeNodes[metaObjectType] = typeNode;
                }
                var node = {
                    nodeId: this._objectToNodeID(objectId),
                    objectId: objectId,
                    title: (metaObjectName && metaObjectName !== "" && metaObjectName !== "Default") ? metaObjectName : metaObjectType,
                    type: metaObjectType,
                    parent: typeNode,
                    numEntities: 0,
                    numVisibleEntities: 0,
                    checked: false,
                    children: []
                };
                typeNode.children.push(node);
                this._objectNodes[node.objectId] = node;
            }
        }
    }
    if (children) {
        for (var i = 0, len = children.length; i < len; i++) {
            var childMetaObject = children[i];
            this._createTypesNodes(childMetaObject, rootNode, typeNodes);
        }
    }
};

ModelTreeView.prototype._createContainmentNodes = function _createContainmentNodes (metaObject, parent) {
        if ( metaObject === void 0 ) metaObject = this._rootMetaObject;

    if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {
        return;
    }
    var metaObjectType = metaObject.type;
    var metaObjectName = metaObject.name || metaObjectType;
    var children = metaObject.children;
    var objectId = metaObject.id;
    var node = {
        nodeId: this._objectToNodeID(objectId),
        objectId: objectId,
        title: (!parent) ? (this._rootName || metaObjectName) : (metaObjectName && metaObjectName !== "" && metaObjectName !== "Undefined" && metaObjectName !== "Default") ? metaObjectName : metaObjectType,
        type: metaObjectType,
        parent: parent,
        numEntities: 0,
        numVisibleEntities: 0,
        checked: false,
        children: []
    };
    if (parent) {
        parent.children.push(node);
    } else {
        this._rootNodes.push(node);
    }
    this._objectNodes[node.objectId] = node;

    if (children) {
        for (var i = 0, len = children.length; i < len; i++) {
            var childMetaObject = children[i];
            this._createContainmentNodes(childMetaObject, node);
        }
    }
};

ModelTreeView.prototype._doSortNodes = function _doSortNodes () {
    for (var i = 0, len = this._rootNodes.length; i < len; i++) {
        var rootNode = this._rootNodes[i];
        this._sortChildren(rootNode);
    }
};

ModelTreeView.prototype._sortChildren = function _sortChildren (node) {
    var children = node.children;
    if (!children || children.length === 0) {
        return;
    }
    if (this._hierarchy === "storeys" && node.type === "IfcBuilding") {
        // Assumes that children of an IfcBuilding will always be IfcBuildingStoreys
        children.sort(this._getSpatialSortFunc());
    } else {
        children.sort(this._alphaSortFunc);
    }
    for (var i = 0, len = children.length; i < len; i++) {
        var node$1 = children[i];
        this._sortChildren(node$1);
    }
};

ModelTreeView.prototype._getSpatialSortFunc = function _getSpatialSortFunc () { // Creates cached sort func with Viewer in scope
    var viewer = this._treeViewPlugin.viewer;
    var scene = viewer.scene;
    var camera = scene.camera;
    var metaScene = viewer.metaScene;
    return this._spatialSortFunc || (this._spatialSortFunc = function (node1, node2) {
        if (!node1.aabb || !node2.aabb) {
            // Sorting on lowest point of the AABB is likely more more robust when objects could overlap storeys
            if (!node1.aabb) {
                node1.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node1.objectId));
            }
            if (!node2.aabb) {
                node2.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node2.objectId));
            }
        }
        var idx = 0;
        if (camera.xUp) {
            idx = 0;
        } else if (camera.yUp) {
            idx = 1;
        } else {
            idx = 2;
        }
        if (node1.aabb[idx] > node2.aabb[idx]) {
            return -1;
        }
        if (node1.aabb[idx] < node2.aabb[idx]) {
            return 1;
        }
        return 0;
    });
};

ModelTreeView.prototype._alphaSortFunc = function _alphaSortFunc (node1, node2) {
    var title1 = node1.title.toUpperCase(); // FIXME: Should be case sensitive?
    var title2 = node2.title.toUpperCase();
    if (title1 < title2) {
        return -1;
    }
    if (title1 > title2) {
        return 1;
    }
    return 0;
};

ModelTreeView.prototype._synchNodesToEntities = function _synchNodesToEntities () {
    var rootMetaObject = this._rootMetaObject;
    var objectIds = rootMetaObject.getObjectIDsInSubtree();
    var metaObjects = this._viewer.metaScene.metaObjects;
    var objects = this._viewer.scene.objects;
    for (var i = 0, len = objectIds.length; i < len; i++) {
        var objectId = objectIds[i];
        var metaObject = metaObjects[objectId];
        if (metaObject) {
            var node = this._objectNodes[objectId];
            if (node) {
                var entity = objects[objectId];
                if (entity) {
                    var visible = entity.visible;
                    node.numEntities = 1;
                    if (visible) {
                        node.numVisibleEntities = 1;
                        node.checked = true;
                    } else {
                        node.numVisibleEntities = 0;
                        node.checked = false;
                    }
                    var parent = node.parent; // Synch parents
                    while (parent) {
                        parent.numEntities++;
                        if (visible) {
                            parent.numVisibleEntities++;
                            parent.checked = true;
                        }
                        parent = parent.parent;
                    }
                }
            }
        }
    }
};

ModelTreeView.prototype._withNodeTree = function _withNodeTree (node, callback) {
    callback(node);
    var children = node.children;
    if (!children) {
        return;
    }
    for (var i = 0, len = children.length; i < len; i++) {
        this._withNodeTree(children[i], callback);
    }
};

ModelTreeView.prototype._createTrees = function _createTrees () {
        var this$1 = this;

    if (this._rootNodes.length === 0) {
        return;
    }
    var rootNodeElements = this._rootNodes.map(function (rootNode) {
        return this$1._createNodeElement(rootNode);
    });
    var ul = document.createElement('ul');
    rootNodeElements.forEach(function (nodeElement) {
        ul.appendChild(nodeElement);
    });
    this._containerElement.appendChild(ul);
    this._rootElement = ul;
};

ModelTreeView.prototype._createNodeElement = function _createNodeElement (node) {
        var this$1 = this;

    var nodeElement = document.createElement('li');
    //const nodeId = this._objectToNodeID(node.objectId);
    var nodeId = node.nodeId;
    nodeElement.id = 'node-' + nodeId;
    if (node.children.length > 0) {
        var switchElementId = "switch-" + nodeId;
        var switchElement = document.createElement('a');
        switchElement.href = '#';
        switchElement.id = switchElementId;
        switchElement.textContent = '+';
        switchElement.classList.add('plus');
        switchElement.addEventListener('click', this.switchExpandHandler);
        nodeElement.appendChild(switchElement);
    }
    var checkbox = document.createElement('input');
    checkbox.id = nodeId;
    checkbox.type = "checkbox";
    checkbox.checked = node.checked;
    checkbox.style["pointer-events"] = "all";
    checkbox.addEventListener("change", this._checkboxChangeHandler);
    nodeElement.appendChild(checkbox);
    var span = document.createElement('span');
    span.textContent = node.title;
    nodeElement.appendChild(span);
    span.oncontextmenu = function (e) {
        this$1._treeViewPlugin.fire("contextmenu", {
            event: e,
            viewer: this$1._viewer,
            treeViewPlugin: this$1._treeViewPlugin,
            treeViewNode: node
        });
        e.preventDefault();
    };
    span.onclick = function (e) {
        this$1._treeViewPlugin.fire("nodeTitleClicked", {
            event: e,
            viewer: this$1._viewer,
            treeViewPlugin: this$1._treeViewPlugin,
            treeViewNode: node
        });
        e.preventDefault();
    };
    return nodeElement;
};

/**
 * @private
 * @param depth
 */
ModelTreeView.prototype.expandToDepth = function expandToDepth (depth) {
        var this$1 = this;

    var expand = function (node, countDepth) {
        if (countDepth === depth) {
            return;
        }
        var nodeId = node.nodeId;
        var switchElementId = "switch-" + nodeId;
        var switchElement = document.getElementById(switchElementId);
        if (switchElement) {
            this$1._expandSwitchElement(switchElement);
            var childNodes = node.children;
            for (var i = 0, len = childNodes.length; i < len; i++) {
                var childNode = childNodes[i];
                expand(childNode, countDepth + 1);
            }
        }
    };
    for (var i = 0, len = this._rootNodes.length; i < len; i++) {
        var rootNode = this._rootNodes[i];
        expand(rootNode, 0);
    }
};

/**
 * @private
 */
ModelTreeView.prototype.collapse = function collapse () {
    for (var i = 0, len = this._rootNodes.length; i < len; i++) {
        var rootNode = this._rootNodes[i];
        var objectId = rootNode.objectId;
        this._collapseNode(objectId);
    }
};

/**
 * @private
 * @param objectId
 */
ModelTreeView.prototype.showNode = function showNode (objectId) {
    if (this._showListItemElementId) {
        this.unShowNode();
    }
    var node = this._objectNodes[objectId];
    if (!node) {
        return; // Node may not exist for the given object if (this._pruneEmptyNodes == true)
    }
    var nodeId = node.nodeId;
    var switchElementId = "switch-" + nodeId;
    var switchElement = document.getElementById(switchElementId);
    if (switchElement) {
        this._expandSwitchElement(switchElement);
        switchElement.scrollIntoView();
        return;
    }
    var path = [];
    path.unshift(node);
    var parent = node.parent;
    while (parent) {
        path.unshift(parent);
        parent = parent.parent;
    }
    for (var i = 0, len = path.length; i < len; i++) {
        var node$1 = path[i];
        var nodeId$1 = node$1.nodeId;
        var switchElementId$1 = "switch-" + nodeId$1;
        var switchElement$1 = document.getElementById(switchElementId$1);
        if (switchElement$1) {
            this._expandSwitchElement(switchElement$1);
        }
    }
    var listItemElementId = 'node-' + nodeId;
    var listItemElement = document.getElementById(listItemElementId);
    listItemElement.scrollIntoView({block: "center"});
    listItemElement.classList.add("highlighted-node");
    this._showListItemElementId = listItemElementId;
};

/**
 * @private
 */
ModelTreeView.prototype.unShowNode = function unShowNode () {
    if (!this._showListItemElementId) {
        return;
    }
    var listItemElement = document.getElementById(this._showListItemElementId);
    if (!listItemElement) {
        this._showListItemElementId = null;
        return;
    }
    listItemElement.classList.remove("highlighted-node");
    this._showListItemElementId = null;
};

ModelTreeView.prototype._expandSwitchElement = function _expandSwitchElement (switchElement) {
        var this$1 = this;

    var parentElement = switchElement.parentElement;
    var expanded = parentElement.getElementsByTagName('li')[0];
    if (expanded) {
        return;
    }
    var nodeId = parentElement.id.replace('node-', '');
    var objectId = this._nodeToObjectID(nodeId);
    var switchNode = this._objectNodes[objectId];
    var childNodes = switchNode.children;
    var nodeElements = childNodes.map(function (node) {
        return this$1._createNodeElement(node);
    });
    var ul = document.createElement('ul');
    nodeElements.forEach(function (nodeElement) {
        ul.appendChild(nodeElement);
    });
    parentElement.appendChild(ul);
    switchElement.classList.remove('plus');
    switchElement.classList.add('minus');
    switchElement.textContent = '-';
    switchElement.removeEventListener('click', this.switchExpandHandler);
    switchElement.addEventListener('click', this.switchCollapseHandler);
};

ModelTreeView.prototype._collapseNode = function _collapseNode (objectId) {
    var nodeId = this._objectToNodeID(objectId);
    var switchElementId = "switch-" + nodeId;
    var switchElement = document.getElementById(switchElementId);
    this._collapseSwitchElement(switchElement);
};

ModelTreeView.prototype._collapseSwitchElement = function _collapseSwitchElement (switchElement) {
    if (!switchElement) {
        return;
    }
    var parent = switchElement.parentElement;
    if (!parent) {
        return;
    }
    var ul = parent.querySelector('ul');
    if (!ul) {
        return;
    }
    parent.removeChild(ul);
    switchElement.classList.remove('minus');
    switchElement.classList.add('plus');
    switchElement.textContent = '+';
    switchElement.removeEventListener('click', this.switchCollapseHandler);
    switchElement.addEventListener('click', this.switchExpandHandler);
};

/**
 * Destroys this ModelTreeView.
 * @private
 */
ModelTreeView.prototype.destroy = function destroy () {
    if (this._rootElement && !this._destroyed) {
        this._rootElement.parentNode.removeChild(this._rootElement);
        this._viewer.scene.off(this._onObjectVisibility);
        this._destroyed = true;
        idMap.removeItem(this._id);
    }
};

/**
 * @desc A {@link Viewer} plugin that provides an HTML tree view to navigate the IFC elements in models.
 * <br>
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital" style="border: 1px solid black;"><img src="http://xeokit.io/img/docs/TreeViewPlugin/TreeViewPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital)]
 *
 * ## Overview
 *
 * * A fast HTML tree view, with zero external dependencies, that works with huge numbers of objects.
 * * Each tree node has a checkbox to control the visibility of its object.
 * * Has three hierarchy modes: "containment", "types" and "storeys".
 * * Automatically contains all models (that have metadata) that are currently in the {@link Scene}.
 * * Sorts tree nodes by default - spatially, from top-to-bottom for ````IfcBuildingStorey```` nodes, and alphanumerically for other nodes.
 * * Allows custom CSS styling.
 * * Use {@link ContextMenu} to create a context menu for the tree nodes.
 *
 * ## Credits
 *
 * TreeViewPlugin is based on techniques described in [*Super Fast Tree View in JavaScript*](https://chrissmith.xyz/super-fast-tree-view-in-javascript/) by [Chris Smith](https://twitter.com/chris22smith).
 *
 * ## Usage
 *
 * In the example below, we'll add a TreeViewPlugin which, by default, will automatically show the structural
 * hierarchy of the IFC elements in each model we load.
 *
 * Then we'll use an {@link XKTLoaderPlugin} to load the Schependomlaan model from an
 * [.xkt file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/models/xkt/schependomlaan), along
 * with an accompanying JSON [IFC metadata file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/metaModels/schependomlaan).
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_Schependomlaan)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, TreeViewPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *     containerElement: document.getElementById("myTreeViewContainer")
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 * ````
 *
 * ## Manually Adding Models
 *
 * Instead of adding models automatically, we can control which models appear in our TreeViewPlugin by adding them manually.
 *
 * In the next example, we'll configure the TreeViewPlugin to not add models automatically. Then, once the model
 * has loaded, we'll add it manually using {@link TreeViewPlugin#addModel}.
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      autoAddModels: false  // <<---------------- Don't auto-add models
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 *
 * model.on("loaded", () => {
 *      treeView.addModel(model.id);
 * });
 * ````
 *
 * Adding models manually also allows us to set some options for the model. For example, the ````rootName```` option allows us to provide a custom name for
 * the root node, which is sometimes desirable when the model's "IfcProject" element's name is not suitable:
 *
 * ````javascript
 * model.on("loaded", () => {
 *      treeView.addModel(model.id, {
 *          rootName: "Schependomlaan Model"
 *      });
 * });
 * ````
 *
 * ## Initially Expanding the Hierarchy
 *
 * We can also configure TreeViewPlugin to initially expand each model's nodes to a given depth.
 *
 * Let's automatically expand the first three nodes from the root, for every model added:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      autoExpandDepth: 3
 * });
 * ````
 *
 * ## Showing a Node by ID
 *
 * We can show a given node using its ID. This causes the TreeViewPlugin to collapse, then expand and scroll the node into view, then highlight the node.
 *
 * See the documentation for the {@link TreeViewPlugin#showNode} method for more information, including how to define a custom highlighted appearance for the node using CSS.
 *
 * Let's make the TreeViewPlugin show the node corresponding to whatever object {@link Entity} that we pick:
 *
 * ````javascript
 * viewer.cameraControl.on("picked", function (e) {
 *     var objectId = e.entity.id;
 *     treeView.showNode(objectId);
 * });
 * ````
 *
 * This will de-highlight any node that was previously shown by this method.
 *
 * Note that this method only works if the picked {@link Entity} is an object that belongs to a model that's represented in the TreeViewPlugin.
 *
 * ## Customizing Appearance
 *
 * We can customize the appearance of our TreeViewPlugin by defining custom CSS for its HTML
 * elements. See our example's [source code](https://github.com/xeokit/xeokit-sdk/blob/master/examples/BIMOffline_XKT_Schependomlaan.html)
 * for an example of custom CSS rules.
 *
 * ## Model Hierarchies
 *
 * TreeViewPlugin has three hierarchies for organizing its nodes:
 *
 * * "containment" - organizes the tree nodes to indicate the containment hierarchy of the {@link MetaObject}s.
 * * "types" - groups nodes by their IFC types.
 * * "storeys" - groups nodes within their ````IfcBuildingStoreys````, and sub-groups them by their IFC types.
 *
 * <br>
 * The table below shows what the hierarchies look like:
 * <br>
 *
 * | 1. Containment Hierarchy | 2. Types Hierarchy | 3. Storeys Hierarchy |
 * |---|---|---|
 * | <img src="http://xeokit.io/img/docs/TreeViewPlugin/structureMode.png"> | <img src="http://xeokit.io/img/docs/TreeViewPlugin/typesMode.png"> | <img src="http://xeokit.io/img/docs/TreeViewPlugin/storeysMode.png"> |
 * <br>
 *
 * Let's create a TreeViewPlugin that groups nodes by their building stories and IFC types:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories"
 * });
 * ````
 *
 * ## Sorting Nodes
 *
 * TreeViewPlugin sorts its tree nodes by default. For a "storeys" hierarchy, it orders ````IfcBuildingStorey```` nodes
 * spatially, with the node for the highest story at the top, down to the lowest at the bottom.
 *
 * For all the hierarchy types ("containment", "classes" and "storeys"), TreeViewPlugin sorts the other node types
 * alphanumerically on their titles.
 *
 * If for some reason you need to prevent sorting, create your TreeViewPlugin with the option disabled, like so:
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories",
 *      sortNodes: false // <<------ Disable node sorting
 * });
 * ````
 *
 * Note that, for all hierarchy modes, node sorting is only done for each model at the time that it is added to the TreeViewPlugin, and will not
 * update dynamically if we later transform the {@link Entity}s corresponding to the nodes.
 *
 * ## Pruning empty nodes
 *
 * Sometimes a model contains subtrees of objects that don't have any geometry. These are models whose
 * {@link MetaModel} contains trees of {@link MetaObject}s that don't have any {@link Entity}s in the {@link Scene}.
 *
 * For these models, the tree view would contain nodes that don't do anything in the Scene when we interact with them,
 * which is undesirable.
 *
 * By default, TreeViewPlugin will not create nodes for those objects. However, we can override that behaviour if we want
 * to have nodes for those objects (perhaps for debugging the model):
 *
 * ````javascript
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("myTreeViewContainer"),
 *      hierarchy: "stories",
 *      pruneEmptyNodes: false // <<------ Create nodes for object subtrees without geometry
 * });
 * ````
 *
 * ## Context Menu
 *
 * TreeViewPlugin fires a "contextmenu" event whenever we right-click on a tree node.
 *
 * The event contains:
 *
 * * ````event```` - the original [contextmenu](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)
 * * ````viewer```` - the {@link Viewer}
 * * ````treeViewPlugin```` - the TreeViewPlugin
 * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node
 *<br><br>
 *
 * Let's use {@link ContextMenu} to show a simple context menu for the node we clicked.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ````javascript
 * import {ContextMenu} from "../src/extras/ContextMenu/ContextMenu.js";
 *
 * const treeViewContextMenu = new ContextMenu({
 *     items: [
 *         [
 *             [
 *                 {
 *                     title: "Hide",
 *                     doAction: function (context) {
 *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {
 *                             if (treeViewNode.objectId) {
 *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];
 *                                 if (entity) {
 *                                     entity.visible = false;
 *                                 }
 *                             }
 *                         });
 *                     }
 *                 },
 *                 {
 *                     title: "Hide all",
 *                     doAction: function (context) {
 *                         context.viewer.scene.setObjectsVisible(context.viewer.scene.visibleObjectIds, false);
 *                     }
 *                 }
 *             ],
 *             [
 *                 {
 *                     title: "Show",
 *                     doAction: function (context) {
 *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {
 *                             if (treeViewNode.objectId) {
 *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];
 *                                 if (entity) {
 *                                     entity.visible = true;
 *                                     entity.xrayed = false;
 *                                     entity.selected = false;
 *                                 }
 *                             }
 *                         });
 *                     }
 *                 },
 *                 {
 *                     title: "Show all",
 *                     doAction: function (context) {
 *                         const scene = context.viewer.scene;
 *                         scene.setObjectsVisible(scene.objectIds, true);
 *                         scene.setObjectsXRayed(scene.xrayedObjectIds, false);
 *                         scene.setObjectsSelected(scene.selectedObjectIds, false);
 *                     }
 *                 }
 *             ]
 *         ]
 *     ]
 * });
 *
 * treeView.on("contextmenu", (e) => {
 *
 *     const event = e.event;                           // MouseEvent
 *     const viewer = e.viewer;                         // Viewer
 *     const treeViewPlugin = e.treeViewPlugin;         // TreeViewPlugin
 *     const treeViewNode = e.treeViewNode;             // TreeViewNode
 *
 *     treeViewContextMenu.show(e.event.pageX, e.event.pageY);
 *
 *     treeViewContextMenu.context = {
 *         viewer: e.viewer,
 *         treeViewPlugin: e.treeViewPlugin,
 *         treeViewNode: e.treeViewNode
 *     };
 * });
 * ````
 *
 * ## Clicking Node Titles
 *
 * TreeViewPlugin fires a "nodeTitleClicked" event whenever we left-click on a tree node.
 *
 * Like the "contextmenu" event, this event contains:
 *
 * * ````event```` - the original [click](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)
 * * ````viewer```` - the {@link Viewer}
 * * ````treeViewPlugin```` - the TreeViewPlugin
 * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node
 *<br><br>
 *
 * Let's register a callback to isolate and fit-to-view the {@link Entity}(s) represented by the node. This callback is
 * going to X-ray all the other Entitys, fly the camera to fit the Entity(s) for the clicked node, then hide the other Entitys.
 *
 * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]
 *
 * ````javascript
 * treeView.on("nodeTitleClicked", (e) => {
 *     const scene = viewer.scene;
 *     const objectIds = [];
 *     e.treeViewPlugin.withNodeTree(e.treeViewNode, (treeViewNode) => {
 *         if (treeViewNode.objectId) {
 *             objectIds.push(treeViewNode.objectId);
 *         }
 *     });
 *     scene.setObjectsXRayed(scene.objectIds, true);
 *     scene.setObjectsVisible(scene.objectIds, true);
 *     scene.setObjectsXRayed(objectIds, false);
 *     viewer.cameraFlight.flyTo({
 *         aabb: scene.getAABB(objectIds),
 *         duration: 0.5
 *     }, () => {
 *         setTimeout(function () {
 *             scene.setObjectsVisible(scene.xrayedObjectIds, false);
 *             scene.setObjectsXRayed(scene.xrayedObjectIds, false);
 *         }, 500);
 *     });
 * });
 * ````
 *
 * To make the cursor change to a pointer when we hover over the node titles, and also to make the titles change to blue, we'll also define this CSS for the ````<span>```` elements
 * that represent the titles of our TreeViewPlugin nodes:
 *
 * ````css
 * #treeViewContainer ul li span:hover {
 *      color: blue;
 *      cursor: pointer;
 * }
 * ````
 *
 * @class TreeViewPlugin
 */
var TreeViewPlugin = /*@__PURE__*/(function (Plugin) {
    function TreeViewPlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "TreeViewPlugin", viewer);

        if (!cfg.containerElement) {
            this.error("Config expected: containerElement");
            return;
        }

        this._containerElement = cfg.containerElement;
        this._modelTreeViews = {};
        this._autoAddModels = (cfg.autoAddModels !== false);
        this._autoExpandDepth = (cfg.autoExpandDepth || 0);
        this._sortNodes = (cfg.sortNodes !== false);
        this._pruneEmptyNodes = (cfg.pruneEmptyNodes !== false);

        if (this._autoAddModels) {
            var modelIds = Object.keys(this.viewer.metaScene.metaModels);
            for (var i = 0, len = modelIds.length; i < len; i++) {
                var modelId = modelIds[i];
                this.addModel(modelId);
            }
            this.viewer.scene.on("modelLoaded", function (modelId) {
                if (this$1.viewer.metaScene.metaModels[modelId]) {
                    this$1.addModel(modelId);
                }
            });
        }

        this.hierarchy = cfg.hierarchy;
    }

    if ( Plugin ) TreeViewPlugin.__proto__ = Plugin;
    TreeViewPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    TreeViewPlugin.prototype.constructor = TreeViewPlugin;

    var prototypeAccessors = { modelTreeViews: { configurable: true },hierarchy: { configurable: true } };

    /**
     * Returns the map of {@link ModelTreeView}s.
     *
     * Each ModelTreeView is mapped to the ID of its model.
     *
     * @return {*|{}}
     */
    prototypeAccessors.modelTreeViews.get = function () {
        return this._modelTreeViews;
    };

    /**
     * Sets how the nodes are organized within this tree view.
     *
     * Accepted values are:
     *
     * * "containment" - organizes the nodes to indicate the containment hierarchy of the IFC objects.
     * * "types" - groups the nodes within their IFC types.
     * * "storeys" - groups the nodes within ````IfcBuildingStoreys```` and sub-groups them by their IFC types.
     *
     * <br>
     * This can be updated dynamically.
     *
     * Default value is "containment".
     *
     * @type {String}
     */
    prototypeAccessors.hierarchy.set = function (hierarchy) {
        hierarchy = hierarchy || "containment";
        if (hierarchy !== "containment" && hierarchy !== "storeys" && hierarchy !== "types") {
            this.error("Unsupported value for `hierarchy' - defaulting to 'containment'");
            hierarchy = "containment";
        }
        this._hierarchy = hierarchy;
        for (var modelId in this._modelTreeViews) {
            if (this._modelTreeViews.hasOwnProperty(modelId)) {
                this._modelTreeViews[modelId].setHierarchy(this._hierarchy);
            }
        }
    };

    /**
     * Gets how the nodes are organized within this tree view.
     *
     * @type {String}
     */
    prototypeAccessors.hierarchy.get = function () {
        return this._hierarchy;
    };

    /**
     * Adds a model to this tree view.
     *
     * The model will be automatically removed when destroyed.
     *
     * To automatically add each model as it's created, instead of manually calling this method each time,
     * provide a ````autoAddModels: true```` to the TreeViewPlugin constructor.
     *
     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.
     * @param {Object} [options] Options for model in the tree view.
     * @param {String} [options.rootName] Optional display name for the root node. Ordinary, for "containment"
     * and "storeys" hierarchy types, the tree would derive the root node name from the model's "IfcProject" element
     * name. This option allows to override that name when it is not suitable as a display name.
     * @returns {ModelTreeView} ModelTreeView for the newly-added model. If this method succeeded in adding the model,
     * then {@link ModelTreeView#valid} will equal ````true````. Otherwise, that property will be ````false````
     * and {@link ModelTreeView#errors} will contain error messages.
     */
    TreeViewPlugin.prototype.addModel = function addModel (modelId, options) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

        if (!this._containerElement) {
            return;
        }
        var model = this.viewer.scene.models[modelId];
        if (!model) {
            throw "Model not found: " + modelId;
        }
        var metaModel = this.viewer.metaScene.metaModels[modelId];
        if (!metaModel) {
            this.error("MetaModel not found: " + modelId);
            return;
        }
        if (this._modelTreeViews[modelId]) {
            this.warn("Model already added: " + modelId);
            return;
        }
        var modelTreeView = new ModelTreeView(this.viewer, this, model, metaModel, {
            containerElement: this._containerElement,
            autoExpandDepth: this._autoExpandDepth,
            hierarchy: this._hierarchy,
            sortNodes: this._sortNodes,
            pruneEmptyNodes: this._pruneEmptyNodes,
            rootName: options.rootName
        });
        this._modelTreeViews[modelId] = modelTreeView;
        model.on("destroyed", function () {
            this$1.removeModel(model.id);
        });
        return modelTreeView;
    };

    /**
     * Removes a model from this tree view.
     *
     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.
     */
    TreeViewPlugin.prototype.removeModel = function removeModel (modelId) {
        if (!this._containerElement) {
            return;
        }
        var modelTreeView = this._modelTreeViews[modelId];
        if (!modelTreeView) {
            this.warn("Model not added: " + modelId);
            return;
        }
        modelTreeView.destroy();
        delete this._modelTreeViews[modelId];
    };

    /**
     * Collapses all trees within this tree view.
     */
    TreeViewPlugin.prototype.collapse = function collapse () {
        for (var modelId in this._modelTreeViews) {
            if (this._modelTreeViews.hasOwnProperty(modelId)) {
                var modelTreeView = this._modelTreeViews[modelId];
                modelTreeView.collapse();
            }
        }
    };

    /**
     * Highlights the tree view node that represents the given object {@link Entity}.
     *
     * This causes the tree view to collapse, then expand to reveal the node, then highlight the node.
     *
     * If a node is previously highlighted, de-highlights that node and collapses the tree first.
     *
     * Note that if the TreeViewPlugin was configured with ````pruneEmptyNodes: true```` (default configuration), then the
     * node won't exist in the tree if it has no Entitys in the {@link Scene}. in that case, nothing will happen.
     *
     * Within the DOM, the node is represented by an ````<li>```` element. This method will add a ````.highlighted-node```` class to
     * the element to make it appear highlighted, removing that class when de-highlighting it again. See the CSS rules
     * in the TreeViewPlugin examples for an example of that class.
     *
     * @param {String} objectId ID of the {@link Entity}.
     */
    TreeViewPlugin.prototype.showNode = function showNode (objectId) {
        this.unShowNode();
        var metaObject = this.viewer.metaScene.metaObjects[objectId];
        if (!metaObject) {
            this.error("MetaObject not found: " + objectId);
            return;
        }
        var metaModel = metaObject.metaModel;
        var modelId = metaModel.id;
        var modelTreeView = this._modelTreeViews[modelId];
        if (!modelTreeView) {
            this.error("Object not in this TreeView: " + objectId);
            return;
        }
        modelTreeView.showNode(objectId);
    };

    /**
     * De-highlights the node previously shown with {@link TreeViewPlugin#showNode}.
     *
     * Does nothing if no node is currently shown.
     *
     * If the node is currently scrolled into view, keeps the node in view.
     */
    TreeViewPlugin.prototype.unShowNode = function unShowNode () {
        for (var modelId in this._modelTreeViews) {
            if (this._modelTreeViews.hasOwnProperty(modelId)) {
                var modelTreeView = this._modelTreeViews[modelId];
                modelTreeView.unShowNode();
            }
        }
    };

    /**
     * Expands the tree to the given depth.
     *
     * Collapses the tree first.
     *
     * @param {Number} depth Depth to expand to.
     */
    TreeViewPlugin.prototype.expandToDepth = function expandToDepth (depth) {
        for (var modelId in this._modelTreeViews) {
            if (this._modelTreeViews.hasOwnProperty(modelId)) {
                var modelTreeView = this._modelTreeViews[modelId];
                modelTreeView.collapse();
                modelTreeView.expandToDepth(depth);
            }
        }
    };

    /**
     * Iterates over a subtree of the tree view's {@link TreeViewNode}s, calling the given callback for each
     * node in depth-first pre-order.
     *
     * @param {TreeViewNode} node Root of the subtree.
     * @param {Function} callback Callback called at each {@link TreeViewNode}, with the TreeViewNode given as the argument.
     */
    TreeViewPlugin.prototype.withNodeTree = function withNodeTree (node, callback) {
        callback(node);
        var children = node.children;
        if (!children) {
            return;
        }
        for (var i = 0, len = children.length; i < len; i++) {
            this.withNodeTree(children[i], callback);
        }
    };

    /**
     * Destroys this TreeViewPlugin.
     */
    TreeViewPlugin.prototype.destroy = function destroy () {
        if (!this._containerElement) {
            return;
        }
        for (var modelId in this._modelTreeViews) {
            if (this._modelTreeViews.hasOwnProperty(modelId)) {
                this._modelTreeViews[modelId].destroy();
            }
        }
        this._modelTreeViews = {};
        Plugin.prototype.destroy.call(this);
    };

    Object.defineProperties( TreeViewPlugin.prototype, prototypeAccessors );

    return TreeViewPlugin;
}(Plugin));

var tempVec3a$4 = math.vec3();
var tempVec3b$4 = math.vec3();
var tempMat4a = math.mat4();

/**
 * @private
 */
var FrustumPlane = function FrustumPlane() {
    this.normal = math.vec3();
    this.offset = 0;
    this.testVertex = math.vec3();
};

FrustumPlane.prototype.set = function set (nx, ny, nz, offset) {
    var s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    this.normal[0] = nx * s;
    this.normal[1] = ny * s;
    this.normal[2] = nz * s;
    this.offset = offset * s;
    this.testVertex[0] = (this.normal[0] >= 0.0) ? 1 : 0;
    this.testVertex[1] = (this.normal[1] >= 0.0) ? 1 : 0;
    this.testVertex[2] = (this.normal[2] >= 0.0) ? 1 : 0;
};

/**
 * @private
 */
var Frustum = function Frustum() {
    this.planes = [
        new FrustumPlane(), new FrustumPlane(), new FrustumPlane(),
        new FrustumPlane(), new FrustumPlane(), new FrustumPlane()
    ];
};

Frustum.INSIDE = 0;
Frustum.INTERSECT = 1;
Frustum.OUTSIDE = 2;

/** @private */
function setFrustum(frustum, viewMat, projMat) {

    var m = math.mulMat4(projMat, viewMat, tempMat4a);

    var m0 = m[0];
    var m1 = m[1];
    var m2 = m[2];
    var m3 = m[3];
    var m4 = m[4];
    var m5 = m[5];
    var m6 = m[6];
    var m7 = m[7];
    var m8 = m[8];
    var m9 = m[9];
    var m10 = m[10];
    var m11 = m[11];
    var m12 = m[12];
    var m13 = m[13];
    var m14 = m[14];
    var m15 = m[15];

    frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);
    frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);
    frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);
    frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);
    frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);
    frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);
}

/** @private */
function frustumIntersectsAABB3(frustum, aabb) {

    var ret = Frustum.INSIDE;

    var min = tempVec3a$4;
    var max = tempVec3b$4;

    min[0] = aabb[0];
    min[1] = aabb[1];
    min[2] = aabb[2];
    max[0] = aabb[3];
    max[1] = aabb[4];
    max[2] = aabb[5];

    var bminmax = [min, max];

    for (var i = 0; i < 6; ++i) {
        var plane = frustum.planes[i];
        if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +
            (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +
            (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +
            (plane.offset)) < 0.0) {
            return Frustum.OUTSIDE;
        }

        if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +
            (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +
            (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +
            (plane.offset)) < 0.0) {
            ret = Frustum.INTERSECT;
        }
    }

    return ret;
}

/**
 * For each Entity in its Scene, efficiently combines updates from multiple culling systems into a single "culled" state.
 *
 * Two culling systems are supported:
 *
 * * View culling - culls Entities when they fall outside the current view frustum, and
 * * Detail culling - momentarily culls less visually-significant Entities while we are moving the camera.
 *
 * @private
 */
var ObjectCullStates = function ObjectCullStates(scene) {
    var this$1 = this;


    this._scene = scene;

    this._objects = []; // Array of all Entity instances that represent objects
    this._objectsViewCulled = []; // A flag for each object to indicate its view-cull status
    this._objectsDetailCulled = []; // A flag for each object to indicate its detail-cull status
    this._objectsChanged = []; // A flag for each object, set whenever its cull status has changed since last _applyChanges()
    this._objectsChangedList = []; // A list of objects whose cull status has changed, applied and cleared by _applyChanges()

    this._modelInfos = {};

    this._numObjects = 0;
    this._lenObjectsChangedList = 0;

    this._dirty = true;

    this._onModelLoaded = scene.on("modelLoaded", function (modelId) {
        var model = scene.models[modelId];
        if (model) {
            this$1._addModel(model);
        }
    });

    this._onTick = scene.on("tick", function () {
        if (this$1._dirty) {
            this$1._build();
        }
        this$1._applyChanges();
    });
};

var prototypeAccessors$1 = { objects: { configurable: true },numObjects: { configurable: true } };

ObjectCullStates.prototype._addModel = function _addModel (model) {
        var this$1 = this;

    var modelInfo = {
        model: model,
        onDestroyed: model.on("destroyed", function () {
            this$1._removeModel(model);
        })
    };
    this._modelInfos[model.id] = modelInfo;
    this._dirty = true;
};

ObjectCullStates.prototype._removeModel = function _removeModel (model) {
    var modelInfo = this._modelInfos[model.id];
    if (modelInfo) {
        modelInfo.model.off(modelInfo.onDestroyed);
        delete this._modelInfos[model.id];
        this._dirty = true;
    }
};

ObjectCullStates.prototype._build = function _build () {
    if (!this._dirty) {
        return;
    }
    this._applyChanges();
    var objects = this._scene.objects;
    for (var i = 0; i < this._numObjects; i++) {
        this._objects[i] = null;
    }
    this._numObjects = 0;
    for (var objectId in objects) {
        var entity = objects[objectId];
        this._objects[this._numObjects++] = entity;
    }
    this._lenObjectsChangedList = 0;
    this._dirty = false;
};

ObjectCullStates.prototype._applyChanges = function _applyChanges () {
    if (this._lenObjectsChangedList > 0) {
        for (var i = 0; i < this._lenObjectsChangedList; i++) {
            var objectIdx = this._objectsChangedList[i];
            var object = this._objects[objectIdx];
            var viewCulled = this._objectsViewCulled[objectIdx];
            var detailCulled = this._objectsDetailCulled[objectIdx];
            var culled = (viewCulled || detailCulled);
            object.culled = culled;
            this._objectsChanged[objectIdx] = false;
        }
        this._lenObjectsChangedList = 0;
    }
};

/**
 * Array of {@link Entity} instances that represent objects in the {@link Scene}.
 *
 * ObjectCullStates rebuilds this from {@link Scene#objects} whenever ````Scene```` fires a ````modelLoaded```` event.
 *
 * @returns {Entity[]}
 */
prototypeAccessors$1.objects.get = function () {
    if (this._dirty) {
        this._build();
    }
    return this._objects;
};

/**
 * Number of objects in {@link ObjectCullStates#objects},
 *
 * Updated whenever ````Scene```` fires a ````modelLoaded```` event.
 *
 * @returns {Number}
 */
prototypeAccessors$1.numObjects.get = function () {
    if (this._dirty) {
        this._build();
    }
    return this._numObjects;
};

/**
 * Updates an object's view-cull status.
 *
 * @param {Number} objectIdx Index of the object in {@link ObjectCullStates#objects}
 * @param {boolean} culled Whether to view-cull or not.
 */
ObjectCullStates.prototype.setObjectViewCulled = function setObjectViewCulled (objectIdx, culled) {
    if (this._dirty) {
        this._build();
    }
    if (this._objectsViewCulled[objectIdx] === culled) {
        return;
    }
    this._objectsViewCulled[objectIdx] = culled;
    if (!this._objectsChanged[objectIdx]) {
        this._objectsChanged[objectIdx] = true;
        this._objectsChangedList[this._lenObjectsChangedList++] = objectIdx;
    }
};

/**
 * Updates an object's detail-cull status.
 *
 * @param {Number} objectIdx Index of the object in {@link ObjectCullStates#objects}
 * @param {boolean} culled Whether to detail-cull or not.
 */
ObjectCullStates.prototype.setObjectDetailCulled = function setObjectDetailCulled (objectIdx, culled) {
    if (this._dirty) {
        this._build();
    }
    if (this._objectsDetailCulled[objectIdx] === culled) {
        return;
    }
    this._objectsDetailCulled[objectIdx] = culled;
    if (!this._objectsChanged[objectIdx]) {
        this._objectsChanged[objectIdx] = true;
        this._objectsChangedList[this._lenObjectsChangedList++] = objectIdx;
    }
};

/**
 * Destroys this ObjectCullStAtes.
 */
ObjectCullStates.prototype._destroy = function _destroy () {
    this._clear();
    this._scene.off(this._onModelLoaded);
    this._scene.off(this._onTick);
};

ObjectCullStates.prototype._clear = function _clear () {
    for (var modelId in this._modelInfos) {
        var modelInfo = this._modelInfos[modelId];
        modelInfo.model.off(modelInfo.onDestroyed);
    }
    this._modelInfos = {};
    this._dirty = true;
};

Object.defineProperties( ObjectCullStates.prototype, prototypeAccessors$1 );

var sceneObjectCullStates = {};

/**
 * @private
 */
function getObjectCullStates(scene) {
    var sceneId = scene.id;
    var objectCullStates = sceneObjectCullStates[sceneId];
    if (!objectCullStates) {
        objectCullStates = new ObjectCullStates(scene);
        sceneObjectCullStates[sceneId] = objectCullStates;
        scene.on("destroyed", function () {
            delete sceneObjectCullStates[sceneId];
            objectCullStates._destroy();
        });
    }
    return objectCullStates;
}

var MAX_KD_TREE_DEPTH = 8; // Increase if greater precision needed

var kdTreeDimLength = new Float32Array(3);

/**
 * {@link Viewer} plugin that performs view frustum culling to accelerate rendering performance.
 *
 * For each {@link Entity} that represents an object, ````ViewCullPlugin```` will automatically
 * set {@link Entity#culled}````false```` whenever it falls outside our field of view.
 *
 * When culled, an ````Entity```` is not processed by xeokit's renderer.
 *
 * Internally, ````ViewCullPlugin```` organizes {@link Entity}s in
 * a [bounding volume hierarchy](https://en.wikipedia.org/wiki/Bounding_volume_hierarchy), implemented as
 * a [kd-tree](https://en.wikipedia.org/wiki/K-d_tree).
 *
 * On each {@link Scene} "tick" event, ````ViewCullPlugin```` searches the kd-tree using a frustum generated from
 * the {@link Camera}, marking each ````Entity```` **culled** if it falls outside the frustum.
 *
 * Use ````ViewCullPlugin```` by simply adding it to your ````Viewer````:
 *
 * ````javascript
 * const viewer = new Viewer({
 *    canvasId: "myCanvas",
 *    transparent: true
 * });
 *
 * const viewCullPlugin = new ViewCullPlugin(viewer, {
 *    maxTreeDepth: 20
 * });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *      id: "myModel",
 *      src: "./models/xkt/OTCConferenceCenter.xkt"
 * });
 * ````
 */
var ViewCullPlugin = /*@__PURE__*/(function (Plugin) {
    function ViewCullPlugin(viewer, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "ViewCull", viewer);

        this._objectCullStates = getObjectCullStates(viewer.scene); // Combines updates from multiple culling systems for its Scene's Entities

        this._maxTreeDepth = cfg.maxTreeDepth || MAX_KD_TREE_DEPTH;
        this._modelInfos = {};
        this._frustum = new Frustum();
        this._kdRoot = null;

        this._frustumDirty = false;
        this._kdTreeDirty = false;

        this._onViewMatrix = viewer.scene.camera.on("viewMatrix", function () {
            this$1._frustumDirty = true;
        });

        this._onProjMatrix = viewer.scene.camera.on("projMatMatrix", function () {
            this$1._frustumDirty = true;
        });

        this._onModelLoaded = viewer.scene.on("modelLoaded", function (modelId) {
            var model = this$1.viewer.scene.models[modelId];
            if (model) {
                this$1._addModel(model);
            }
        });

        this._onSceneTick = viewer.scene.on("tick", function () {
            this$1._doCull();
        });
    }

    if ( Plugin ) ViewCullPlugin.__proto__ = Plugin;
    ViewCullPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    ViewCullPlugin.prototype.constructor = ViewCullPlugin;

    var prototypeAccessors = { enabled: { configurable: true } };

    /**
     * Sets whether view culling is enabled.
     *
     * @param {Boolean} enabled Whether to enable view culling.
     */
    prototypeAccessors.enabled.set = function (enabled) {
        this._enabled = enabled;
    };

    /**
     * Gets whether view culling is enabled.
     *
     * @retutns {Boolean} Whether view culling is enabled.
     */
    prototypeAccessors.enabled.get = function () {
        return this._enabled;
    };

    ViewCullPlugin.prototype._addModel = function _addModel (model) {
        var this$1 = this;

        var modelInfo = {
            model: model,
            onDestroyed: model.on("destroyed", function () {
                this$1._removeModel(model);
            })
        };
        this._modelInfos[model.id] = modelInfo;
        this._kdTreeDirty = true;
    };

    ViewCullPlugin.prototype._removeModel = function _removeModel (model) {
        var modelInfo = this._modelInfos[model.id];
        if (modelInfo) {
            modelInfo.model.off(modelInfo.onDestroyed);
            delete this._modelInfos[model.id];
            this._kdTreeDirty = true;
        }
    };

    ViewCullPlugin.prototype._doCull = function _doCull () {
        var cullDirty = (this._frustumDirty || this._kdTreeDirty);
        if (this._frustumDirty) {
            this._buildFrustum();
        }
        if (this._kdTreeDirty) {
            this._buildKDTree();
        }
        if (cullDirty) {
            var kdNode = this._kdRoot;
            if (kdNode) {
                this._visitKDNode(kdNode);
            }
        }
    };

    ViewCullPlugin.prototype._buildFrustum = function _buildFrustum () {
        var camera = this.viewer.scene.camera;
        setFrustum(this._frustum, camera.viewMatrix, camera.projMatrix);
        this._frustumDirty = false;
    };

    ViewCullPlugin.prototype._buildKDTree = function _buildKDTree () {
        var viewer = this.viewer;
        var scene = viewer.scene;
        var depth = 0;
        if (this._kdRoot) ;
        this._kdRoot = {
            aabb: scene.getAABB(),
            intersection: Frustum.INTERSECT
        };
        for (var objectIdx = 0, len = this._objectCullStates.numObjects; objectIdx < len; objectIdx++) {
            var entity = this._objectCullStates.objects[objectIdx];
            this._insertEntityIntoKDTree(this._kdRoot, entity, objectIdx, depth + 1);
        }
        this._kdTreeDirty = false;
    };

    ViewCullPlugin.prototype._insertEntityIntoKDTree = function _insertEntityIntoKDTree (kdNode, entity, objectIdx, depth) {

        var entityAABB = entity.aabb;

        if (depth >= this._maxTreeDepth) {
            kdNode.objects = kdNode.objects || [];
            kdNode.objects.push(objectIdx);
            math.expandAABB3(kdNode.aabb, entityAABB);
            return;
        }

        if (kdNode.left) {
            if (math.containsAABB3(kdNode.left.aabb, entityAABB)) {
                this._insertEntityIntoKDTree(kdNode.left, entity, objectIdx, depth + 1);
                return;
            }
        }

        if (kdNode.right) {
            if (math.containsAABB3(kdNode.right.aabb, entityAABB)) {
                this._insertEntityIntoKDTree(kdNode.right, entity, objectIdx, depth + 1);
                return;
            }
        }

        var nodeAABB = kdNode.aabb;

        kdTreeDimLength[0] = nodeAABB[3] - nodeAABB[0];
        kdTreeDimLength[1] = nodeAABB[4] - nodeAABB[1];
        kdTreeDimLength[2] = nodeAABB[5] - nodeAABB[2];

        var dim = 0;

        if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {
            dim = 1;
        }

        if (kdTreeDimLength[2] > kdTreeDimLength[dim]) {
            dim = 2;
        }

        if (!kdNode.left) {
            var aabbLeft = nodeAABB.slice();
            aabbLeft[dim + 3] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);
            kdNode.left = {
                aabb: aabbLeft,
                intersection: Frustum.INTERSECT
            };
            if (math.containsAABB3(aabbLeft, entityAABB)) {
                this._insertEntityIntoKDTree(kdNode.left, entity, objectIdx, depth + 1);
                return;
            }
        }

        if (!kdNode.right) {
            var aabbRight = nodeAABB.slice();
            aabbRight[dim] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);
            kdNode.right = {
                aabb: aabbRight,
                intersection: Frustum.INTERSECT
            };
            if (math.containsAABB3(aabbRight, entityAABB)) {
                this._insertEntityIntoKDTree(kdNode.right, entity, objectIdx, depth + 1);
                return;
            }
        }

        kdNode.objects = kdNode.objects || [];
        kdNode.objects.push(objectIdx);

        math.expandAABB3(kdNode.aabb, entityAABB);
    };

    ViewCullPlugin.prototype._visitKDNode = function _visitKDNode (kdNode, intersects) {
        if ( intersects === void 0 ) intersects = Frustum.INTERSECT;

        if (intersects !== Frustum.INTERSECT && kdNode.intersects === intersects) {
            return;
        }
        if (intersects === Frustum.INTERSECT) {
            intersects = frustumIntersectsAABB3(this._frustum, kdNode.aabb);
            kdNode.intersects = intersects;
        }
        var culled = (intersects === Frustum.OUTSIDE);
        var objects = kdNode.objects;
        if (objects && objects.length > 0) {
            for (var i = 0, len = objects.length; i < len; i++) {
                var objectIdx = objects[i];
                this._objectCullStates.setObjectViewCulled(objectIdx, culled);
            }
        }
        if (kdNode.left) {
            this._visitKDNode(kdNode.left, intersects);
        }
        if (kdNode.right) {
            this._visitKDNode(kdNode.right, intersects);
        }
    };

    /**
     * @private
     */
    ViewCullPlugin.prototype.send = function send (name, value) {
    };

    /**
     * Destroys this ViewCullPlugin.
     */
    ViewCullPlugin.prototype.destroy = function destroy () {
        Plugin.prototype.destroy.call(this);
        this._clear();
        var scene = this.viewer.scene;
        var camera = scene.camera;
        scene.off(this._onModelLoaded);
        scene.off(this._onSceneTick);
        camera.off(this._onViewMatrix);
        camera.off(this._onProjMatrix);
    };

    ViewCullPlugin.prototype._clear = function _clear () {
        for (var modelId in this._modelInfos) {
            var modelInfo = this._modelInfos[modelId];
            modelInfo.model.off(modelInfo.onDestroyed);
        }
        this._modelInfos = {};
        this._kdRoot = null;
        this._kdTreeDirty = true;
    };

    Object.defineProperties( ViewCullPlugin.prototype, prototypeAccessors );

    return ViewCullPlugin;
}(Plugin));

/**
 * Default data access strategy for {@link XKTLoaderPlugin}.
 */
var XKTDefaultDataSource = function XKTDefaultDataSource() {
};

/**
 * Gets metamodel JSON.
 *
 * @param {String|Number} metaModelSrc Identifies the metamodel JSON asset.
 * @param {{Function(*)}} ok Fired on successful loading of the metamodel JSON asset.
 * @param {{Function(*)}} error Fired on error while loading the metamodel JSON asset.
 */
XKTDefaultDataSource.prototype.getMetaModel = function getMetaModel (metaModelSrc, ok, error) {
    utils.loadJSON(metaModelSrc,
        function (json) {
            ok(json);
        },
        function (errMsg) {
            error(errMsg);
        });
};

/**
 * Gets the contents of the given ````.xkt```` file in an arraybuffer.
 *
 * @param {String|Number} src Path or ID of an ````.xkt```` file.
 * @param {Function} ok Callback fired on success, argument is the ````.xkt```` file in an arraybuffer.
 * @param {Function} error Callback fired on error.
 */
XKTDefaultDataSource.prototype.getXKT = function getXKT (src, ok, error) {
    var defaultCallback = function () {
    };
    ok = ok || defaultCallback;
    error = error || defaultCallback;
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = src.match(dataUriRegex);
    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest
        var isBase64 = !!dataUriRegexResult[2];
        var data = dataUriRegexResult[3];
        data = window.decodeURIComponent(data);
        if (isBase64) {
            data = window.atob(data);
        }
        try {
            var buffer = new ArrayBuffer(data.length);
            var view = new Uint8Array(buffer);
            for (var i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
            }
            ok(buffer);
        } catch (errMsg) {
            error(errMsg);
        }
    } else {
        var request = new XMLHttpRequest();
        request.open('GET', src, true);
        request.responseType = 'arraybuffer';
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    ok(request.response);
                } else {
                    error('getXKT error : ' + request.response);
                }
            }
        };
        request.send(null);
    }
};

/* pako 1.0.10 nodeca/pako */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f();}else if(typeof define==="function"&&define.amd){define([],f);}else {var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else {g=this;}g.pako = f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c){ return c(i,!0); }if(u){ return u(i,!0); }var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++){ o(t[i]); }return o}return r})()({1:[function(require,module,exports){


        var zlib_deflate = require('./zlib/deflate');
        var utils        = require('./utils/common');
        var strings      = require('./utils/strings');
        var msg          = require('./zlib/messages');
        var ZStream      = require('./zlib/zstream');

        var toString = Object.prototype.toString;

        /* Public constants ==========================================================*/
        /* ===========================================================================*/

        var Z_NO_FLUSH      = 0;
        var Z_FINISH        = 4;

        var Z_OK            = 0;
        var Z_STREAM_END    = 1;
        var Z_SYNC_FLUSH    = 2;

        var Z_DEFAULT_COMPRESSION = -1;

        var Z_DEFAULT_STRATEGY    = 0;

        var Z_DEFLATED  = 8;

        /* ===========================================================================*/


        /**
         * class Deflate
         *
         * Generic JS-style wrapper for zlib calls. If you don't need
         * streaming behaviour - use more simple functions: [[deflate]],
         * [[deflateRaw]] and [[gzip]].
         **/

        /* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

        /**
         * Deflate.result -> Uint8Array|Array
         *
         * Compressed result, generated by default [[Deflate#onData]]
         * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
         * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
         * push a chunk with explicit flush (call [[Deflate#push]] with
         * `Z_SYNC_FLUSH` param).
         **/

        /**
         * Deflate.err -> Number
         *
         * Error code after deflate finished. 0 (Z_OK) on success.
         * You will not need it in real life, because deflate errors
         * are possible only on wrong options or bad `onData` / `onEnd`
         * custom handlers.
         **/

        /**
         * Deflate.msg -> String
         *
         * Error message, if [[Deflate.err]] != 0
         **/


        /**
         * new Deflate(options)
         * - options (Object): zlib deflate options.
         *
         * Creates new deflator instance with specified params. Throws exception
         * on bad params. Supported options:
         *
         * - `level`
         * - `windowBits`
         * - `memLevel`
         * - `strategy`
         * - `dictionary`
         *
         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
         * for more information on these.
         *
         * Additional options, for internal needs:
         *
         * - `chunkSize` - size of generated data chunks (16K by default)
         * - `raw` (Boolean) - do raw deflate
         * - `gzip` (Boolean) - create gzip wrapper
         * - `to` (String) - if equal to 'string', then result will be "binary string"
         *    (each char code [0..255])
         * - `header` (Object) - custom header for gzip
         *   - `text` (Boolean) - true if compressed data believed to be text
         *   - `time` (Number) - modification time, unix timestamp
         *   - `os` (Number) - operation system code
         *   - `extra` (Array) - array of bytes with extra data (max 65536)
         *   - `name` (String) - file name (binary string)
         *   - `comment` (String) - comment (binary string)
         *   - `hcrc` (Boolean) - true if header crc should be added
         *
         * ##### Example:
         *
         * ```javascript
         * var pako = require('pako')
         *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
         *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
         *
         * var deflate = new pako.Deflate({ level: 3});
         *
         * deflate.push(chunk1, false);
         * deflate.push(chunk2, true);  // true -> last chunk
         *
         * if (deflate.err) { throw new Error(deflate.err); }
         *
         * console.log(deflate.result);
         * ```
         **/
        function Deflate(options) {
            if (!(this instanceof Deflate)) { return new Deflate(options); }

            this.options = utils.assign({
                level: Z_DEFAULT_COMPRESSION,
                method: Z_DEFLATED,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Z_DEFAULT_STRATEGY,
                to: ''
            }, options || {});

            var opt = this.options;

            if (opt.raw && (opt.windowBits > 0)) {
                opt.windowBits = -opt.windowBits;
            }

            else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
                opt.windowBits += 16;
            }

            this.err    = 0;      // error code, if happens (0 = Z_OK)
            this.msg    = '';     // error message
            this.ended  = false;  // used to avoid multiple onEnd() calls
            this.chunks = [];     // chunks of compressed data

            this.strm = new ZStream();
            this.strm.avail_out = 0;

            var status = zlib_deflate.deflateInit2(
                this.strm,
                opt.level,
                opt.method,
                opt.windowBits,
                opt.memLevel,
                opt.strategy
            );

            if (status !== Z_OK) {
                throw new Error(msg[status]);
            }

            if (opt.header) {
                zlib_deflate.deflateSetHeader(this.strm, opt.header);
            }

            if (opt.dictionary) {
                var dict;
                // Convert data if needed
                if (typeof opt.dictionary === 'string') {
                    // If we need to compress text, change encoding to utf8.
                    dict = strings.string2buf(opt.dictionary);
                } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                    dict = new Uint8Array(opt.dictionary);
                } else {
                    dict = opt.dictionary;
                }

                status = zlib_deflate.deflateSetDictionary(this.strm, dict);

                if (status !== Z_OK) {
                    throw new Error(msg[status]);
                }

                this._dict_set = true;
            }
        }

        /**
         * Deflate#push(data[, mode]) -> Boolean
         * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
         *   converted to utf8 byte sequence.
         * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
         *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
         *
         * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
         * new compressed chunks. Returns `true` on success. The last data block must have
         * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
         * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
         * can use mode Z_SYNC_FLUSH, keeping the compression context.
         *
         * On fail call [[Deflate#onEnd]] with error code and return false.
         *
         * We strongly recommend to use `Uint8Array` on input for best speed (output
         * array format is detected automatically). Also, don't skip last param and always
         * use the same type in your code (boolean or number). That will improve JS speed.
         *
         * For regular `Array`-s make sure all elements are [0..255].
         *
         * ##### Example
         *
         * ```javascript
         * push(chunk, false); // push one of data chunks
         * ...
         * push(chunk, true);  // push last chunk
         * ```
         **/
        Deflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var status, _mode;

            if (this.ended) { return false; }

            _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

            // Convert data if needed
            if (typeof data === 'string') {
                // If we need to compress text, change encoding to utf8.
                strm.input = strings.string2buf(data);
            } else if (toString.call(data) === '[object ArrayBuffer]') {
                strm.input = new Uint8Array(data);
            } else {
                strm.input = data;
            }

            strm.next_in = 0;
            strm.avail_in = strm.input.length;

            do {
                if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                }
                status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

                if (status !== Z_STREAM_END && status !== Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                }
                if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
                    if (this.options.to === 'string') {
                        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                    } else {
                        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                    }
                }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

            // Finalize on the last chunk.
            if (_mode === Z_FINISH) {
                status = zlib_deflate.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK;
            }

            // callback interim results if Z_SYNC_FLUSH.
            if (_mode === Z_SYNC_FLUSH) {
                this.onEnd(Z_OK);
                strm.avail_out = 0;
                return true;
            }

            return true;
        };


        /**
         * Deflate#onData(chunk) -> Void
         * - chunk (Uint8Array|Array|String): output data. Type of array depends
         *   on js engine support. When string output requested, each chunk
         *   will be string.
         *
         * By default, stores data blocks in `chunks[]` property and glue
         * those in `onEnd`. Override this handler, if you need another behaviour.
         **/
        Deflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
        };


        /**
         * Deflate#onEnd(status) -> Void
         * - status (Number): deflate status. 0 (Z_OK) on success,
         *   other if not.
         *
         * Called once after you tell deflate that the input stream is
         * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
         * or if an error happened. By default - join collected chunks,
         * free memory and fill `results` / `err` properties.
         **/
        Deflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === Z_OK) {
                if (this.options.to === 'string') {
                    this.result = this.chunks.join('');
                } else {
                    this.result = utils.flattenChunks(this.chunks);
                }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
        };


        /**
         * deflate(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to compress.
         * - options (Object): zlib deflate options.
         *
         * Compress `data` with deflate algorithm and `options`.
         *
         * Supported options are:
         *
         * - level
         * - windowBits
         * - memLevel
         * - strategy
         * - dictionary
         *
         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
         * for more information on these.
         *
         * Sugar (options):
         *
         * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
         *   negative windowBits implicitly.
         * - `to` (String) - if equal to 'string', then result will be "binary string"
         *    (each char code [0..255])
         *
         * ##### Example:
         *
         * ```javascript
         * var pako = require('pako')
         *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
         *
         * console.log(pako.deflate(data));
         * ```
         **/
        function deflate(input, options) {
            var deflator = new Deflate(options);

            deflator.push(input, true);

            // That will never happens, if you don't cheat with options :)
            if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

            return deflator.result;
        }


        /**
         * deflateRaw(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to compress.
         * - options (Object): zlib deflate options.
         *
         * The same as [[deflate]], but creates raw data, without wrapper
         * (header and adler32 crc).
         **/
        function deflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return deflate(input, options);
        }


        /**
         * gzip(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to compress.
         * - options (Object): zlib deflate options.
         *
         * The same as [[deflate]], but create gzip wrapper instead of
         * deflate one.
         **/
        function gzip(input, options) {
            options = options || {};
            options.gzip = true;
            return deflate(input, options);
        }


        exports.Deflate = Deflate;
        exports.deflate = deflate;
        exports.deflateRaw = deflateRaw;
        exports.gzip = gzip;

    },{"./utils/common":3,"./utils/strings":4,"./zlib/deflate":8,"./zlib/messages":13,"./zlib/zstream":15}],2:[function(require,module,exports){


        var zlib_inflate = require('./zlib/inflate');
        var utils        = require('./utils/common');
        var strings      = require('./utils/strings');
        var c            = require('./zlib/constants');
        var msg          = require('./zlib/messages');
        var ZStream      = require('./zlib/zstream');
        var GZheader     = require('./zlib/gzheader');

        var toString = Object.prototype.toString;

        /**
         * class Inflate
         *
         * Generic JS-style wrapper for zlib calls. If you don't need
         * streaming behaviour - use more simple functions: [[inflate]]
         * and [[inflateRaw]].
         **/

        /* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

        /**
         * Inflate.result -> Uint8Array|Array|String
         *
         * Uncompressed result, generated by default [[Inflate#onData]]
         * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
         * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
         * push a chunk with explicit flush (call [[Inflate#push]] with
         * `Z_SYNC_FLUSH` param).
         **/

        /**
         * Inflate.err -> Number
         *
         * Error code after inflate finished. 0 (Z_OK) on success.
         * Should be checked if broken data possible.
         **/

        /**
         * Inflate.msg -> String
         *
         * Error message, if [[Inflate.err]] != 0
         **/


        /**
         * new Inflate(options)
         * - options (Object): zlib inflate options.
         *
         * Creates new inflator instance with specified params. Throws exception
         * on bad params. Supported options:
         *
         * - `windowBits`
         * - `dictionary`
         *
         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
         * for more information on these.
         *
         * Additional options, for internal needs:
         *
         * - `chunkSize` - size of generated data chunks (16K by default)
         * - `raw` (Boolean) - do raw inflate
         * - `to` (String) - if equal to 'string', then result will be converted
         *   from utf8 to utf16 (javascript) string. When string output requested,
         *   chunk length can differ from `chunkSize`, depending on content.
         *
         * By default, when no options set, autodetect deflate/gzip data format via
         * wrapper header.
         *
         * ##### Example:
         *
         * ```javascript
         * var pako = require('pako')
         *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
         *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
         *
         * var inflate = new pako.Inflate({ level: 3});
         *
         * inflate.push(chunk1, false);
         * inflate.push(chunk2, true);  // true -> last chunk
         *
         * if (inflate.err) { throw new Error(inflate.err); }
         *
         * console.log(inflate.result);
         * ```
         **/
        function Inflate(options) {
            if (!(this instanceof Inflate)) { return new Inflate(options); }

            this.options = utils.assign({
                chunkSize: 16384,
                windowBits: 0,
                to: ''
            }, options || {});

            var opt = this.options;

            // Force window size for `raw` data, if not set directly,
            // because we have no header for autodetect.
            if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
                opt.windowBits = -opt.windowBits;
                if (opt.windowBits === 0) { opt.windowBits = -15; }
            }

            // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
            if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
                !(options && options.windowBits)) {
                opt.windowBits += 32;
            }

            // Gzip header has no info about windows size, we can do autodetect only
            // for deflate. So, if window size not set, force it to max when gzip possible
            if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
                // bit 3 (16) -> gzipped data
                // bit 4 (32) -> autodetect gzip/deflate
                if ((opt.windowBits & 15) === 0) {
                    opt.windowBits |= 15;
                }
            }

            this.err    = 0;      // error code, if happens (0 = Z_OK)
            this.msg    = '';     // error message
            this.ended  = false;  // used to avoid multiple onEnd() calls
            this.chunks = [];     // chunks of compressed data

            this.strm   = new ZStream();
            this.strm.avail_out = 0;

            var status  = zlib_inflate.inflateInit2(
                this.strm,
                opt.windowBits
            );

            if (status !== c.Z_OK) {
                throw new Error(msg[status]);
            }

            this.header = new GZheader();

            zlib_inflate.inflateGetHeader(this.strm, this.header);

            // Setup dictionary
            if (opt.dictionary) {
                // Convert data if needed
                if (typeof opt.dictionary === 'string') {
                    opt.dictionary = strings.string2buf(opt.dictionary);
                } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                    opt.dictionary = new Uint8Array(opt.dictionary);
                }
                if (opt.raw) { //In raw mode we need to set the dictionary early
                    status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
                    if (status !== c.Z_OK) {
                        throw new Error(msg[status]);
                    }
                }
            }
        }

        /**
         * Inflate#push(data[, mode]) -> Boolean
         * - data (Uint8Array|Array|ArrayBuffer|String): input data
         * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
         *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
         *
         * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
         * new output chunks. Returns `true` on success. The last data block must have
         * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
         * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
         * can use mode Z_SYNC_FLUSH, keeping the decompression context.
         *
         * On fail call [[Inflate#onEnd]] with error code and return false.
         *
         * We strongly recommend to use `Uint8Array` on input for best speed (output
         * format is detected automatically). Also, don't skip last param and always
         * use the same type in your code (boolean or number). That will improve JS speed.
         *
         * For regular `Array`-s make sure all elements are [0..255].
         *
         * ##### Example
         *
         * ```javascript
         * push(chunk, false); // push one of data chunks
         * ...
         * push(chunk, true);  // push last chunk
         * ```
         **/
        Inflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var dictionary = this.options.dictionary;
            var status, _mode;
            var next_out_utf8, tail, utf8str;

            // Flag to properly process Z_BUF_ERROR on testing inflate call
            // when we check that all output data was flushed.
            var allowBufError = false;

            if (this.ended) { return false; }
            _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

            // Convert data if needed
            if (typeof data === 'string') {
                // Only binary strings can be decompressed on practice
                strm.input = strings.binstring2buf(data);
            } else if (toString.call(data) === '[object ArrayBuffer]') {
                strm.input = new Uint8Array(data);
            } else {
                strm.input = data;
            }

            strm.next_in = 0;
            strm.avail_in = strm.input.length;

            do {
                if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                }

                status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

                if (status === c.Z_NEED_DICT && dictionary) {
                    status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
                }

                if (status === c.Z_BUF_ERROR && allowBufError === true) {
                    status = c.Z_OK;
                    allowBufError = false;
                }

                if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                }

                if (strm.next_out) {
                    if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

                        if (this.options.to === 'string') {

                            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

                            tail = strm.next_out - next_out_utf8;
                            utf8str = strings.buf2string(strm.output, next_out_utf8);

                            // move tail
                            strm.next_out = tail;
                            strm.avail_out = chunkSize - tail;
                            if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

                            this.onData(utf8str);

                        } else {
                            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                        }
                    }
                }

                // When no more input data, we should check that internal inflate buffers
                // are flushed. The only way to do it when avail_out = 0 - run one more
                // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
                // Here we set flag to process this error properly.
                //
                // NOTE. Deflate does not return error in this case and does not needs such
                // logic.
                if (strm.avail_in === 0 && strm.avail_out === 0) {
                    allowBufError = true;
                }

            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

            if (status === c.Z_STREAM_END) {
                _mode = c.Z_FINISH;
            }

            // Finalize on the last chunk.
            if (_mode === c.Z_FINISH) {
                status = zlib_inflate.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === c.Z_OK;
            }

            // callback interim results if Z_SYNC_FLUSH.
            if (_mode === c.Z_SYNC_FLUSH) {
                this.onEnd(c.Z_OK);
                strm.avail_out = 0;
                return true;
            }

            return true;
        };


        /**
         * Inflate#onData(chunk) -> Void
         * - chunk (Uint8Array|Array|String): output data. Type of array depends
         *   on js engine support. When string output requested, each chunk
         *   will be string.
         *
         * By default, stores data blocks in `chunks[]` property and glue
         * those in `onEnd`. Override this handler, if you need another behaviour.
         **/
        Inflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
        };


        /**
         * Inflate#onEnd(status) -> Void
         * - status (Number): inflate status. 0 (Z_OK) on success,
         *   other if not.
         *
         * Called either after you tell inflate that the input stream is
         * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
         * or if an error happened. By default - join collected chunks,
         * free memory and fill `results` / `err` properties.
         **/
        Inflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === c.Z_OK) {
                if (this.options.to === 'string') {
                    // Glue & convert here, until we teach pako to send
                    // utf8 aligned strings to onData
                    this.result = this.chunks.join('');
                } else {
                    this.result = utils.flattenChunks(this.chunks);
                }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
        };


        /**
         * inflate(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to decompress.
         * - options (Object): zlib inflate options.
         *
         * Decompress `data` with inflate/ungzip and `options`. Autodetect
         * format via wrapper header by default. That's why we don't provide
         * separate `ungzip` method.
         *
         * Supported options are:
         *
         * - windowBits
         *
         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
         * for more information.
         *
         * Sugar (options):
         *
         * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
         *   negative windowBits implicitly.
         * - `to` (String) - if equal to 'string', then result will be converted
         *   from utf8 to utf16 (javascript) string. When string output requested,
         *   chunk length can differ from `chunkSize`, depending on content.
         *
         *
         * ##### Example:
         *
         * ```javascript
         * var pako = require('pako')
         *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
         *   , output;
         *
         * try {
         *   output = pako.inflate(input);
         * } catch (err)
         *   console.log(err);
         * }
         * ```
         **/
        function inflate(input, options) {
            var inflator = new Inflate(options);

            inflator.push(input, true);

            // That will never happens, if you don't cheat with options :)
            if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

            return inflator.result;
        }


        /**
         * inflateRaw(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to decompress.
         * - options (Object): zlib inflate options.
         *
         * The same as [[inflate]], but creates raw data, without wrapper
         * (header and adler32 crc).
         **/
        function inflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return inflate(input, options);
        }


        /**
         * ungzip(data[, options]) -> Uint8Array|Array|String
         * - data (Uint8Array|Array|String): input data to decompress.
         * - options (Object): zlib inflate options.
         *
         * Just shortcut to [[inflate]], because it autodetects format
         * by header.content. Done for convenience.
         **/


        exports.Inflate = Inflate;
        exports.inflate = inflate;
        exports.inflateRaw = inflateRaw;
        exports.ungzip  = inflate;

    },{"./utils/common":3,"./utils/strings":4,"./zlib/constants":6,"./zlib/gzheader":9,"./zlib/inflate":11,"./zlib/messages":13,"./zlib/zstream":15}],3:[function(require,module,exports){


        var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
            (typeof Uint16Array !== 'undefined') &&
            (typeof Int32Array !== 'undefined');

        function _has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
        }

        exports.assign = function (obj /*from1, from2, from3, ...*/) {
            var sources = Array.prototype.slice.call(arguments, 1);
            while (sources.length) {
                var source = sources.shift();
                if (!source) { continue; }

                if (typeof source !== 'object') {
                    throw new TypeError(source + 'must be non-object');
                }

                for (var p in source) {
                    if (_has(source, p)) {
                        obj[p] = source[p];
                    }
                }
            }

            return obj;
        };


// reduce buffer size, avoiding mem copy
        exports.shrinkBuf = function (buf, size) {
            if (buf.length === size) { return buf; }
            if (buf.subarray) { return buf.subarray(0, size); }
            buf.length = size;
            return buf;
        };


        var fnTyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
                if (src.subarray && dest.subarray) {
                    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                    return;
                }
                // Fallback to ordinary array
                for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                }
            },
            // Join array of chunks to single array.
            flattenChunks: function (chunks) {
                var i, l, len, pos, chunk, result;

                // calculate data length
                len = 0;
                for (i = 0, l = chunks.length; i < l; i++) {
                    len += chunks[i].length;
                }

                // join chunks
                result = new Uint8Array(len);
                pos = 0;
                for (i = 0, l = chunks.length; i < l; i++) {
                    chunk = chunks[i];
                    result.set(chunk, pos);
                    pos += chunk.length;
                }

                return result;
            }
        };

        var fnUntyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
                for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                }
            },
            // Join array of chunks to single array.
            flattenChunks: function (chunks) {
                return [].concat.apply([], chunks);
            }
        };


// Enable/Disable typed arrays use, for testing
//
        exports.setTyped = function (on) {
            if (on) {
                exports.Buf8  = Uint8Array;
                exports.Buf16 = Uint16Array;
                exports.Buf32 = Int32Array;
                exports.assign(exports, fnTyped);
            } else {
                exports.Buf8  = Array;
                exports.Buf16 = Array;
                exports.Buf32 = Array;
                exports.assign(exports, fnUntyped);
            }
        };

        exports.setTyped(TYPED_OK);

    },{}],4:[function(require,module,exports){


        var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;

        try { String.fromCharCode.apply(null, [ 0 ]); } catch (_) { STR_APPLY_OK = false; }
        try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (_$1) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
            _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
        }
        _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
        exports.string2buf = function (str) {
            var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

            // count binary size
            for (m_pos = 0; m_pos < str_len; m_pos++) {
                c = str.charCodeAt(m_pos);
                if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 0xfc00) === 0xdc00) {
                        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                        m_pos++;
                    }
                }
                buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
            }

            // allocate buffer
            buf = new utils.Buf8(buf_len);

            // convert
            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                c = str.charCodeAt(m_pos);
                if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 0xfc00) === 0xdc00) {
                        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                        m_pos++;
                    }
                }
                if (c < 0x80) {
                    /* one byte */
                    buf[i++] = c;
                } else if (c < 0x800) {
                    /* two bytes */
                    buf[i++] = 0xC0 | (c >>> 6);
                    buf[i++] = 0x80 | (c & 0x3f);
                } else if (c < 0x10000) {
                    /* three bytes */
                    buf[i++] = 0xE0 | (c >>> 12);
                    buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                    buf[i++] = 0x80 | (c & 0x3f);
                } else {
                    /* four bytes */
                    buf[i++] = 0xf0 | (c >>> 18);
                    buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                    buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                    buf[i++] = 0x80 | (c & 0x3f);
                }
            }

            return buf;
        };

// Helper (used in 2 places)
        function buf2binstring(buf, len) {
            // On Chrome, the arguments in a function call that are allowed is `65534`.
            // If the length of the buffer is smaller than that, we can use this optimization,
            // otherwise we will take a slower path.
            if (len < 65534) {
                if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
                    return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                }
            }

            var result = '';
            for (var i = 0; i < len; i++) {
                result += String.fromCharCode(buf[i]);
            }
            return result;
        }


// Convert byte array to binary string
        exports.buf2binstring = function (buf) {
            return buf2binstring(buf, buf.length);
        };


// Convert binary string (typed, when possible)
        exports.binstring2buf = function (str) {
            var buf = new utils.Buf8(str.length);
            for (var i = 0, len = buf.length; i < len; i++) {
                buf[i] = str.charCodeAt(i);
            }
            return buf;
        };


// convert array to string
        exports.buf2string = function (buf, max) {
            var i, out, c, c_len;
            var len = max || buf.length;

            // Reserve max possible length (2 words per char)
            // NB: by unknown reasons, Array is significantly faster for
            //     String.fromCharCode.apply than Uint16Array.
            var utf16buf = new Array(len * 2);

            for (out = 0, i = 0; i < len;) {
                c = buf[i++];
                // quick process ascii
                if (c < 0x80) { utf16buf[out++] = c; continue; }

                c_len = _utf8len[c];
                // skip 5 & 6 byte codes
                if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

                // apply mask on first byte
                c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
                // join the rest
                while (c_len > 1 && i < len) {
                    c = (c << 6) | (buf[i++] & 0x3f);
                    c_len--;
                }

                // terminated by end of string?
                if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

                if (c < 0x10000) {
                    utf16buf[out++] = c;
                } else {
                    c -= 0x10000;
                    utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                    utf16buf[out++] = 0xdc00 | (c & 0x3ff);
                }
            }

            return buf2binstring(utf16buf, out);
        };


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
        exports.utf8border = function (buf, max) {
            var pos;

            max = max || buf.length;
            if (max > buf.length) { max = buf.length; }

            // go back from last position, until start of sequence found
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

            // Very small and broken sequence,
            // return max, because we should return something anyway.
            if (pos < 0) { return max; }

            // If we came to start of buffer - that means buffer is too small,
            // return max too.
            if (pos === 0) { return max; }

            return (pos + _utf8len[buf[pos]] > max) ? pos : max;
        };

    },{"./common":3}],5:[function(require,module,exports){

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        function adler32(adler, buf, len, pos) {
            var s1 = (adler & 0xffff) |0,
                s2 = ((adler >>> 16) & 0xffff) |0,
                n = 0;

            while (len !== 0) {
                // Set limit ~ twice less than 5552, to keep
                // s2 in 31-bits, because we force signed ints.
                // in other case %= will fail.
                n = len > 2000 ? 2000 : len;
                len -= n;

                do {
                    s1 = (s1 + buf[pos++]) |0;
                    s2 = (s2 + s1) |0;
                } while (--n);

                s1 %= 65521;
                s2 %= 65521;
            }

            return (s1 | (s2 << 16)) |0;
        }


        module.exports = adler32;

    },{}],6:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        module.exports = {

            /* Allowed flush values; see deflate() and inflate() below for details */
            Z_NO_FLUSH:         0,
            Z_PARTIAL_FLUSH:    1,
            Z_SYNC_FLUSH:       2,
            Z_FULL_FLUSH:       3,
            Z_FINISH:           4,
            Z_BLOCK:            5,
            Z_TREES:            6,

            /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
            Z_OK:               0,
            Z_STREAM_END:       1,
            Z_NEED_DICT:        2,
            Z_ERRNO:           -1,
            Z_STREAM_ERROR:    -2,
            Z_DATA_ERROR:      -3,
            //Z_MEM_ERROR:     -4,
            Z_BUF_ERROR:       -5,
            //Z_VERSION_ERROR: -6,

            /* compression levels */
            Z_NO_COMPRESSION:         0,
            Z_BEST_SPEED:             1,
            Z_BEST_COMPRESSION:       9,
            Z_DEFAULT_COMPRESSION:   -1,


            Z_FILTERED:               1,
            Z_HUFFMAN_ONLY:           2,
            Z_RLE:                    3,
            Z_FIXED:                  4,
            Z_DEFAULT_STRATEGY:       0,

            /* Possible values of the data_type field (though see inflate()) */
            Z_BINARY:                 0,
            Z_TEXT:                   1,
            //Z_ASCII:                1, // = Z_TEXT (deprecated)
            Z_UNKNOWN:                2,

            /* The deflate compression method */
            Z_DEFLATED:               8
            //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };

    },{}],7:[function(require,module,exports){

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
        function makeTable() {
            var c, table = [];

            for (var n = 0; n < 256; n++) {
                c = n;
                for (var k = 0; k < 8; k++) {
                    c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                }
                table[n] = c;
            }

            return table;
        }

// Create table on load. Just 255 signed longs. Not a problem.
        var crcTable = makeTable();


        function crc32(crc, buf, len, pos) {
            var t = crcTable,
                end = pos + len;

            crc ^= -1;

            for (var i = pos; i < end; i++) {
                crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
            }

            return (crc ^ (-1)); // >>> 0;
        }


        module.exports = crc32;

    },{}],8:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        var utils   = require('../utils/common');
        var trees   = require('./trees');
        var adler32 = require('./adler32');
        var crc32   = require('./crc32');
        var msg     = require('./messages');

        /* Public constants ==========================================================*/
        /* ===========================================================================*/


        /* Allowed flush values; see deflate() and inflate() below for details */
        var Z_NO_FLUSH      = 0;
        var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
        var Z_FULL_FLUSH    = 3;
        var Z_FINISH        = 4;
        var Z_BLOCK         = 5;
//var Z_TREES         = 6;


        /* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
        var Z_OK            = 0;
        var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
        var Z_STREAM_ERROR  = -2;
        var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
        var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


        /* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
        var Z_DEFAULT_COMPRESSION = -1;


        var Z_FILTERED            = 1;
        var Z_HUFFMAN_ONLY        = 2;
        var Z_RLE                 = 3;
        var Z_FIXED               = 4;
        var Z_DEFAULT_STRATEGY    = 0;

        /* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
        var Z_UNKNOWN             = 2;


        /* The deflate compression method */
        var Z_DEFLATED  = 8;

        /*============================================================================*/


        var MAX_MEM_LEVEL = 9;
        /* Maximum value for memLevel in deflateInit2 */
        var MAX_WBITS = 15;
        /* 32K LZ77 window */
        var DEF_MEM_LEVEL = 8;


        var LENGTH_CODES  = 29;
        /* number of length codes, not counting the special END_BLOCK code */
        var LITERALS      = 256;
        /* number of literal bytes 0..255 */
        var L_CODES       = LITERALS + 1 + LENGTH_CODES;
        /* number of Literal or Length codes, including the END_BLOCK code */
        var D_CODES       = 30;
        /* number of distance codes */
        var BL_CODES      = 19;
        /* number of codes used to transfer the bit lengths */
        var HEAP_SIZE     = 2 * L_CODES + 1;
        /* maximum heap size */
        var MAX_BITS  = 15;
        /* All codes must not exceed MAX_BITS bits */

        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

        var PRESET_DICT = 0x20;

        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;

        var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
        var BS_BLOCK_DONE     = 2; /* block flush performed */
        var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
        var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

        var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

        function err(strm, errorCode) {
            strm.msg = msg[errorCode];
            return errorCode;
        }

        function rank(f) {
            return ((f) << 1) - ((f) > 4 ? 9 : 0);
        }

        function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


        /* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
        function flush_pending(strm) {
            var s = strm.state;

            //_tr_flush_bits(s);
            var len = s.pending;
            if (len > strm.avail_out) {
                len = strm.avail_out;
            }
            if (len === 0) { return; }

            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
            strm.next_out += len;
            s.pending_out += len;
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;
            if (s.pending === 0) {
                s.pending_out = 0;
            }
        }


        function flush_block_only(s, last) {
            trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
            s.block_start = s.strstart;
            flush_pending(s.strm);
        }


        function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
        }


        /* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
        function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
            s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
            s.pending_buf[s.pending++] = b & 0xff;
        }


        /* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
        function read_buf(strm, buf, start, size) {
            var len = strm.avail_in;

            if (len > size) { len = size; }
            if (len === 0) { return 0; }

            strm.avail_in -= len;

            // zmemcpy(buf, strm->next_in, len);
            utils.arraySet(buf, strm.input, strm.next_in, len, start);
            if (strm.state.wrap === 1) {
                strm.adler = adler32(strm.adler, buf, len, start);
            }

            else if (strm.state.wrap === 2) {
                strm.adler = crc32(strm.adler, buf, len, start);
            }

            strm.next_in += len;
            strm.total_in += len;

            return len;
        }


        /* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
        function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length;      /* max hash chain length */
            var scan = s.strstart; /* current string */
            var match;                       /* matched string */
            var len;                           /* length of current match */
            var best_len = s.prev_length;              /* best match length so far */
            var nice_match = s.nice_match;             /* stop if match long enough */
            var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
                s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

            var _win = s.window; // shortcut

            var wmask = s.w_mask;
            var prev  = s.prev;

            /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

            var strend = s.strstart + MAX_MATCH;
            var scan_end1  = _win[scan + best_len - 1];
            var scan_end   = _win[scan + best_len];

            /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
            // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

            /* Do not waste too much time if we already have a good match: */
            if (s.prev_length >= s.good_match) {
                chain_length >>= 2;
            }
            /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
            if (nice_match > s.lookahead) { nice_match = s.lookahead; }

            // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

            do {
                // Assert(cur_match < s->strstart, "no future");
                match = cur_match;

                /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

                if (_win[match + best_len]     !== scan_end  ||
                    _win[match + best_len - 1] !== scan_end1 ||
                    _win[match]                !== _win[scan] ||
                    _win[++match]              !== _win[scan + 1]) {
                    continue;
                }

                /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
                scan += 2;
                match++;
                // Assert(*scan == *match, "match[2]?");

                /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
                do {
                    /*jshint noempty:false*/
                } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                scan < strend);

                // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

                len = MAX_MATCH - (strend - scan);
                scan = strend - MAX_MATCH;

                if (len > best_len) {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match) {
                        break;
                    }
                    scan_end1  = _win[scan + best_len - 1];
                    scan_end   = _win[scan + best_len];
                }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

            if (best_len <= s.lookahead) {
                return best_len;
            }
            return s.lookahead;
        }


        /* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
        function fill_window(s) {
            var _w_size = s.w_size;
            var p, n, m, more, str;

            //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

            do {
                more = s.window_size - s.lookahead - s.strstart;

                // JS ints have 32 bit, block below not needed
                /* Deal with !@#$% 64K limit: */
                //if (sizeof(int) <= 2) {
                //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                //        more = wsize;
                //
                //  } else if (more == (unsigned)(-1)) {
                //        /* Very unlikely, but possible on 16 bit machine if
                //         * strstart == 0 && lookahead == 1 (input done a byte at time)
                //         */
                //        more--;
                //    }
                //}


                /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
                if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

                    utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                    s.match_start -= _w_size;
                    s.strstart -= _w_size;
                    /* we now have strstart >= MAX_DIST */
                    s.block_start -= _w_size;

                    /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

                    n = s.hash_size;
                    p = n;
                    do {
                        m = s.head[--p];
                        s.head[p] = (m >= _w_size ? m - _w_size : 0);
                    } while (--n);

                    n = _w_size;
                    p = n;
                    do {
                        m = s.prev[--p];
                        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
                        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
                    } while (--n);

                    more += _w_size;
                }
                if (s.strm.avail_in === 0) {
                    break;
                }

                /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
                //Assert(more >= 2, "more < 2");
                n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                s.lookahead += n;

                /* Initialize the hash value now that we have some input: */
                if (s.lookahead + s.insert >= MIN_MATCH) {
                    str = s.strstart - s.insert;
                    s.ins_h = s.window[str];

                    /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
                    while (s.insert) {
                        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

                        s.prev[str & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = str;
                        str++;
                        s.insert--;
                        if (s.lookahead + s.insert < MIN_MATCH) {
                            break;
                        }
                    }
                }
                /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

            /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
        }

        /* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
        function deflate_stored(s, flush) {
            /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
            var max_block_size = 0xffff;

            if (max_block_size > s.pending_buf_size - 5) {
                max_block_size = s.pending_buf_size - 5;
            }

            /* Copy as much as possible from input to output: */
            for (;;) {
                /* Fill the window as much as possible: */
                if (s.lookahead <= 1) {

                    //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                    //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

                    fill_window(s);
                    if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }

                    if (s.lookahead === 0) {
                        break;
                    }
                    /* flush the current block */
                }
                //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

                s.strstart += s.lookahead;
                s.lookahead = 0;

                /* Emit a stored block if pending_buf will be full: */
                var max_start = s.block_start + max_block_size;

                if (s.strstart === 0 || s.strstart >= max_start) {
                    /* strstart == 0 is possible when wraparound on 16-bit machine */
                    s.lookahead = s.strstart - max_start;
                    s.strstart = max_start;
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/


                }
                /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
                if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
            }

            s.insert = 0;

            if (flush === Z_FINISH) {
                /*** FLUSH_BLOCK(s, 1); ***/
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                /***/
                return BS_FINISH_DONE;
            }

            if (s.strstart > s.block_start) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }

            return BS_NEED_MORE;
        }

        /* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
        function deflate_fast(s, flush) {
            var hash_head;        /* head of the hash chain */
            var bflush;           /* set if current block must be flushed */

            for (;;) {
                /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
                if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                        break; /* flush the current block */
                    }
                }

                /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
                hash_head = 0/*NIL*/;
                if (s.lookahead >= MIN_MATCH) {
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                    /***/
                }

                /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
                if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                    /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
                    s.match_length = longest_match(s, hash_head);
                    /* longest_match() sets match_start */
                }
                if (s.match_length >= MIN_MATCH) {
                    // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                    /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
                    bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

                    s.lookahead -= s.match_length;

                    /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
                    if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
                        s.match_length--; /* string at strstart already in table */
                        do {
                            s.strstart++;
                            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                            /***/
                            /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
                        } while (--s.match_length !== 0);
                        s.strstart++;
                    } else
                    {
                        s.strstart += s.match_length;
                        s.match_length = 0;
                        s.ins_h = s.window[s.strstart];
                        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
                        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
                    }
                } else {
                    /* No match, output a literal byte */
                    //Tracevv((stderr,"%c", s.window[s.strstart]));
                    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
            }
            s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
            if (flush === Z_FINISH) {
                /*** FLUSH_BLOCK(s, 1); ***/
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                /***/
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
            return BS_BLOCK_DONE;
        }

        /* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
        function deflate_slow(s, flush) {
            var hash_head;          /* head of hash chain */
            var bflush;              /* set if current block must be flushed */

            var max_insert;

            /* Process the input block. */
            for (;;) {
                /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
                if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) { break; } /* flush the current block */
                }

                /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
                hash_head = 0/*NIL*/;
                if (s.lookahead >= MIN_MATCH) {
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                    /***/
                }

                /* Find the longest match, discarding those <= prev_length.
     */
                s.prev_length = s.match_length;
                s.prev_match = s.match_start;
                s.match_length = MIN_MATCH - 1;

                if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
                    s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
                    /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
                    s.match_length = longest_match(s, hash_head);
                    /* longest_match() sets match_start */

                    if (s.match_length <= 5 &&
                        (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

                        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
                        s.match_length = MIN_MATCH - 1;
                    }
                }
                /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
                if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    max_insert = s.strstart + s.lookahead - MIN_MATCH;
                    /* Do not insert strings in hash table beyond this. */

                    //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                    /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
                    bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                    /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do {
                        if (++s.strstart <= max_insert) {
                            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                            /***/
                        }
                    } while (--s.prev_length !== 0);
                    s.match_available = 0;
                    s.match_length = MIN_MATCH - 1;
                    s.strstart++;

                    if (bflush) {
                        /*** FLUSH_BLOCK(s, 0); ***/
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                        /***/
                    }

                } else if (s.match_available) {
                    /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
                    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

                    if (bflush) {
                        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                        flush_block_only(s, false);
                        /***/
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                } else {
                    /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                }
            }
            //Assert (flush != Z_NO_FLUSH, "no flush?");
            if (s.match_available) {
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

                s.match_available = 0;
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
                /*** FLUSH_BLOCK(s, 1); ***/
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                /***/
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }

            return BS_BLOCK_DONE;
        }


        /* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
        function deflate_rle(s, flush) {
            var bflush;            /* set if current block must be flushed */
            var prev;              /* byte at distance one to match */
            var scan, strend;      /* scan goes up to strend for length of run */

            var _win = s.window;

            for (;;) {
                /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
                if (s.lookahead <= MAX_MATCH) {
                    fill_window(s);
                    if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) { break; } /* flush the current block */
                }

                /* See how many times the previous byte repeats */
                s.match_length = 0;
                if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                    scan = s.strstart - 1;
                    prev = _win[scan];
                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                        strend = s.strstart + MAX_MATCH;
                        do {
                            /*jshint noempty:false*/
                        } while (prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        scan < strend);
                        s.match_length = MAX_MATCH - (strend - scan);
                        if (s.match_length > s.lookahead) {
                            s.match_length = s.lookahead;
                        }
                    }
                    //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
                }

                /* Emit match if have run of MIN_MATCH or longer, else emit literal */
                if (s.match_length >= MIN_MATCH) {
                    //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                    /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                    bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                } else {
                    /* No match, output a literal byte */
                    //Tracevv((stderr,"%c", s->window[s->strstart]));
                    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
                /*** FLUSH_BLOCK(s, 1); ***/
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                /***/
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
            return BS_BLOCK_DONE;
        }

        /* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
        function deflate_huff(s, flush) {
            var bflush;             /* set if current block must be flushed */

            for (;;) {
                /* Make sure that we have a literal to write. */
                if (s.lookahead === 0) {
                    fill_window(s);
                    if (s.lookahead === 0) {
                        if (flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        break;      /* flush the current block */
                    }
                }

                /* Output a literal byte */
                s.match_length = 0;
                //Tracevv((stderr,"%c", s->window[s->strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
                /*** FLUSH_BLOCK(s, 1); ***/
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                /***/
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
            return BS_BLOCK_DONE;
        }

        /* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length;
            this.max_lazy = max_lazy;
            this.nice_length = nice_length;
            this.max_chain = max_chain;
            this.func = func;
        }

        var configuration_table;

        configuration_table = [
            /*      good lazy nice chain */
            new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
            new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
            new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
            new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

            new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
            new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
            new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
            new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
            new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
            new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
        ];


        /* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
        function lm_init(s) {
            s.window_size = 2 * s.w_size;

            /*** CLEAR_HASH(s); ***/
            zero(s.head); // Fill with NIL (= 0);

            /* Set the default configuration parameters:
   */
            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;

            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            s.ins_h = 0;
        }


        function DeflateState() {
            this.strm = null;            /* pointer back to this zlib stream */
            this.status = 0;            /* as the name implies */
            this.pending_buf = null;      /* output still pending */
            this.pending_buf_size = 0;  /* size of pending_buf */
            this.pending_out = 0;       /* next pending byte to output to the stream */
            this.pending = 0;           /* nb of bytes in the pending buffer */
            this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
            this.gzhead = null;         /* gzip header information to write */
            this.gzindex = 0;           /* where in extra, name, or comment */
            this.method = Z_DEFLATED; /* can only be DEFLATED */
            this.last_flush = -1;   /* value of flush param for previous deflate call */

            this.w_size = 0;  /* LZ77 window size (32K by default) */
            this.w_bits = 0;  /* log2(w_size)  (8..16) */
            this.w_mask = 0;  /* w_size - 1 */

            this.window = null;
            /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

            this.window_size = 0;
            /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

            this.prev = null;
            /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

            this.head = null;   /* Heads of the hash chains or NIL. */

            this.ins_h = 0;       /* hash index of string to be inserted */
            this.hash_size = 0;   /* number of elements in hash table */
            this.hash_bits = 0;   /* log2(hash_size) */
            this.hash_mask = 0;   /* hash_size-1 */

            this.hash_shift = 0;
            /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

            this.block_start = 0;
            /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

            this.match_length = 0;      /* length of best match */
            this.prev_match = 0;        /* previous match */
            this.match_available = 0;   /* set if previous match exists */
            this.strstart = 0;          /* start of string to insert */
            this.match_start = 0;       /* start of matching string */
            this.lookahead = 0;         /* number of valid bytes ahead in window */

            this.prev_length = 0;
            /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

            this.max_chain_length = 0;
            /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

            this.max_lazy_match = 0;
            /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
            // That's alias to max_lazy_match, don't use directly
            //this.max_insert_length = 0;
            /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

            this.level = 0;     /* compression level (1..9) */
            this.strategy = 0;  /* favor or force Huffman coding*/

            this.good_match = 0;
            /* Use a faster search when the previous match is longer than this */

            this.nice_match = 0; /* Stop searching when current match exceeds this */

            /* used by trees.c: */

            /* Didn't use ct_data typedef below to suppress compiler warning */

            // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
            // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
            // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

            // Use flat array of DOUBLE size, with interleaved fata,
            // because JS does not support effective
            this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
            this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
            this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
            zero(this.dyn_ltree);
            zero(this.dyn_dtree);
            zero(this.bl_tree);

            this.l_desc   = null;         /* desc. for literal tree */
            this.d_desc   = null;         /* desc. for distance tree */
            this.bl_desc  = null;         /* desc. for bit length tree */

            //ush bl_count[MAX_BITS+1];
            this.bl_count = new utils.Buf16(MAX_BITS + 1);
            /* number of codes at each bit length for an optimal tree */

            //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
            this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
            zero(this.heap);

            this.heap_len = 0;               /* number of elements in the heap */
            this.heap_max = 0;               /* element of largest frequency */
            /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

            this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
            zero(this.depth);
            /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

            this.l_buf = 0;          /* buffer index for literals or lengths */

            this.lit_bufsize = 0;
            /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

            this.last_lit = 0;      /* running index in l_buf */

            this.d_buf = 0;
            /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

            this.opt_len = 0;       /* bit length of current block with optimal trees */
            this.static_len = 0;    /* bit length of current block with static trees */
            this.matches = 0;       /* number of string matches in current block */
            this.insert = 0;        /* bytes at end of window left to insert */


            this.bi_buf = 0;
            /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
            this.bi_valid = 0;
            /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

            // Used for window memory init. We safely ignore it for JS. That makes
            // sense only for pointers and memory check tools.
            //this.high_water = 0;
            /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
        }


        function deflateResetKeep(strm) {
            var s;

            if (!strm || !strm.state) {
                return err(strm, Z_STREAM_ERROR);
            }

            strm.total_in = strm.total_out = 0;
            strm.data_type = Z_UNKNOWN;

            s = strm.state;
            s.pending = 0;
            s.pending_out = 0;

            if (s.wrap < 0) {
                s.wrap = -s.wrap;
                /* was made negative by deflate(..., Z_FINISH); */
            }
            s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
            strm.adler = (s.wrap === 2) ?
                0  // crc32(0, Z_NULL, 0)
                :
                1; // adler32(0, Z_NULL, 0)
            s.last_flush = Z_NO_FLUSH;
            trees._tr_init(s);
            return Z_OK;
        }


        function deflateReset(strm) {
            var ret = deflateResetKeep(strm);
            if (ret === Z_OK) {
                lm_init(strm.state);
            }
            return ret;
        }


        function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) { return Z_STREAM_ERROR; }
            if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
            strm.state.gzhead = head;
            return Z_OK;
        }


        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) { // === Z_NULL
                return Z_STREAM_ERROR;
            }
            var wrap = 1;

            if (level === Z_DEFAULT_COMPRESSION) {
                level = 6;
            }

            if (windowBits < 0) { /* suppress zlib wrapper */
                wrap = 0;
                windowBits = -windowBits;
            }

            else if (windowBits > 15) {
                wrap = 2;           /* write gzip wrapper instead */
                windowBits -= 16;
            }


            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
                windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
                strategy < 0 || strategy > Z_FIXED) {
                return err(strm, Z_STREAM_ERROR);
            }


            if (windowBits === 8) {
                windowBits = 9;
            }
            /* until 256-byte window bug fixed */

            var s = new DeflateState();

            strm.state = s;
            s.strm = strm;

            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;

            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = s.hash_size - 1;
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

            s.window = new utils.Buf8(s.w_size * 2);
            s.head = new utils.Buf16(s.hash_size);
            s.prev = new utils.Buf16(s.w_size);

            // Don't need mem init magic for JS.
            //s.high_water = 0;  /* nothing written to s->window yet */

            s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

            s.pending_buf_size = s.lit_bufsize * 4;

            //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
            //s->pending_buf = (uchf *) overlay;
            s.pending_buf = new utils.Buf8(s.pending_buf_size);

            // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
            //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
            s.d_buf = 1 * s.lit_bufsize;

            //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
            s.l_buf = (1 + 2) * s.lit_bufsize;

            s.level = level;
            s.strategy = strategy;
            s.method = method;

            return deflateReset(strm);
        }

        function deflateInit(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }


        function deflate(strm, flush) {
            var old_flush, s;
            var beg, val; // for gzip header write only

            if (!strm || !strm.state ||
                flush > Z_BLOCK || flush < 0) {
                return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            }

            s = strm.state;

            if (!strm.output ||
                (!strm.input && strm.avail_in !== 0) ||
                (s.status === FINISH_STATE && flush !== Z_FINISH)) {
                return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
            }

            s.strm = strm; /* just in case */
            old_flush = s.last_flush;
            s.last_flush = flush;

            /* Write the header */
            if (s.status === INIT_STATE) {

                if (s.wrap === 2) { // GZIP header
                    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
                    put_byte(s, 31);
                    put_byte(s, 139);
                    put_byte(s, 8);
                    if (!s.gzhead) { // s->gzhead == Z_NULL
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, s.level === 9 ? 2 :
                            (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                4 : 0));
                        put_byte(s, OS_CODE);
                        s.status = BUSY_STATE;
                    }
                    else {
                        put_byte(s, (s.gzhead.text ? 1 : 0) +
                            (s.gzhead.hcrc ? 2 : 0) +
                            (!s.gzhead.extra ? 0 : 4) +
                            (!s.gzhead.name ? 0 : 8) +
                            (!s.gzhead.comment ? 0 : 16)
                        );
                        put_byte(s, s.gzhead.time & 0xff);
                        put_byte(s, (s.gzhead.time >> 8) & 0xff);
                        put_byte(s, (s.gzhead.time >> 16) & 0xff);
                        put_byte(s, (s.gzhead.time >> 24) & 0xff);
                        put_byte(s, s.level === 9 ? 2 :
                            (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                4 : 0));
                        put_byte(s, s.gzhead.os & 0xff);
                        if (s.gzhead.extra && s.gzhead.extra.length) {
                            put_byte(s, s.gzhead.extra.length & 0xff);
                            put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                        }
                        if (s.gzhead.hcrc) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                        }
                        s.gzindex = 0;
                        s.status = EXTRA_STATE;
                    }
                }
                else // DEFLATE header
                {
                    var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                    var level_flags = -1;

                    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                        level_flags = 0;
                    } else if (s.level < 6) {
                        level_flags = 1;
                    } else if (s.level === 6) {
                        level_flags = 2;
                    } else {
                        level_flags = 3;
                    }
                    header |= (level_flags << 6);
                    if (s.strstart !== 0) { header |= PRESET_DICT; }
                    header += 31 - (header % 31);

                    s.status = BUSY_STATE;
                    putShortMSB(s, header);

                    /* Save the adler32 of the preset dictionary: */
                    if (s.strstart !== 0) {
                        putShortMSB(s, strm.adler >>> 16);
                        putShortMSB(s, strm.adler & 0xffff);
                    }
                    strm.adler = 1; // adler32(0L, Z_NULL, 0);
                }
            }

//#ifdef GZIP
            if (s.status === EXTRA_STATE) {
                if (s.gzhead.extra/* != Z_NULL*/) {
                    beg = s.pending;  /* start of bytes to update crc */

                    while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                break;
                            }
                        }
                        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                        s.gzindex++;
                    }
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (s.gzindex === s.gzhead.extra.length) {
                        s.gzindex = 0;
                        s.status = NAME_STATE;
                    }
                }
                else {
                    s.status = NAME_STATE;
                }
            }
            if (s.status === NAME_STATE) {
                if (s.gzhead.name/* != Z_NULL*/) {
                    beg = s.pending;  /* start of bytes to update crc */
                    //int val;

                    do {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                val = 1;
                                break;
                            }
                        }
                        // JS specific: little magic to add zero terminator to end of string
                        if (s.gzindex < s.gzhead.name.length) {
                            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                        } else {
                            val = 0;
                        }
                        put_byte(s, val);
                    } while (val !== 0);

                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                        s.gzindex = 0;
                        s.status = COMMENT_STATE;
                    }
                }
                else {
                    s.status = COMMENT_STATE;
                }
            }
            if (s.status === COMMENT_STATE) {
                if (s.gzhead.comment/* != Z_NULL*/) {
                    beg = s.pending;  /* start of bytes to update crc */
                    //int val;

                    do {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                val = 1;
                                break;
                            }
                        }
                        // JS specific: little magic to add zero terminator to end of string
                        if (s.gzindex < s.gzhead.comment.length) {
                            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                        } else {
                            val = 0;
                        }
                        put_byte(s, val);
                    } while (val !== 0);

                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                        s.status = HCRC_STATE;
                    }
                }
                else {
                    s.status = HCRC_STATE;
                }
            }
            if (s.status === HCRC_STATE) {
                if (s.gzhead.hcrc) {
                    if (s.pending + 2 > s.pending_buf_size) {
                        flush_pending(strm);
                    }
                    if (s.pending + 2 <= s.pending_buf_size) {
                        put_byte(s, strm.adler & 0xff);
                        put_byte(s, (strm.adler >> 8) & 0xff);
                        strm.adler = 0; //crc32(0L, Z_NULL, 0);
                        s.status = BUSY_STATE;
                    }
                }
                else {
                    s.status = BUSY_STATE;
                }
            }
//#endif

            /* Flush as much pending output as possible */
            if (s.pending !== 0) {
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
                    s.last_flush = -1;
                    return Z_OK;
                }

                /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
            } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
                flush !== Z_FINISH) {
                return err(strm, Z_BUF_ERROR);
            }

            /* User must not provide more input after the first FINISH: */
            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                return err(strm, Z_BUF_ERROR);
            }

            /* Start a new block or continue the current one.
   */
            if (strm.avail_in !== 0 || s.lookahead !== 0 ||
                (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
                var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
                    (s.strategy === Z_RLE ? deflate_rle(s, flush) :
                        configuration_table[s.level].func(s, flush));

                if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                    s.status = FINISH_STATE;
                }
                if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                    if (strm.avail_out === 0) {
                        s.last_flush = -1;
                        /* avoid BUF_ERROR next call, see above */
                    }
                    return Z_OK;
                    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
                }
                if (bstate === BS_BLOCK_DONE) {
                    if (flush === Z_PARTIAL_FLUSH) {
                        trees._tr_align(s);
                    }
                    else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

                        trees._tr_stored_block(s, 0, 0, false);
                        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
                        if (flush === Z_FULL_FLUSH) {
                            /*** CLEAR_HASH(s); ***/             /* forget history */
                            zero(s.head); // Fill with NIL (= 0);

                            if (s.lookahead === 0) {
                                s.strstart = 0;
                                s.block_start = 0;
                                s.insert = 0;
                            }
                        }
                    }
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                        return Z_OK;
                    }
                }
            }
            //Assert(strm->avail_out > 0, "bug2");
            //if (strm.avail_out <= 0) { throw new Error("bug2");}

            if (flush !== Z_FINISH) { return Z_OK; }
            if (s.wrap <= 0) { return Z_STREAM_END; }

            /* Write the trailer */
            if (s.wrap === 2) {
                put_byte(s, strm.adler & 0xff);
                put_byte(s, (strm.adler >> 8) & 0xff);
                put_byte(s, (strm.adler >> 16) & 0xff);
                put_byte(s, (strm.adler >> 24) & 0xff);
                put_byte(s, strm.total_in & 0xff);
                put_byte(s, (strm.total_in >> 8) & 0xff);
                put_byte(s, (strm.total_in >> 16) & 0xff);
                put_byte(s, (strm.total_in >> 24) & 0xff);
            }
            else
            {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 0xffff);
            }

            flush_pending(strm);
            /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
            if (s.wrap > 0) { s.wrap = -s.wrap; }
            /* write the trailer only once! */
            return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }

        function deflateEnd(strm) {
            var status;

            if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
                return Z_STREAM_ERROR;
            }

            status = strm.state.status;
            if (status !== INIT_STATE &&
                status !== EXTRA_STATE &&
                status !== NAME_STATE &&
                status !== COMMENT_STATE &&
                status !== HCRC_STATE &&
                status !== BUSY_STATE &&
                status !== FINISH_STATE
            ) {
                return err(strm, Z_STREAM_ERROR);
            }

            strm.state = null;

            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }


        /* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
        function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;

            var s;
            var str, n;
            var wrap;
            var avail;
            var next;
            var input;
            var tmpDict;

            if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
                return Z_STREAM_ERROR;
            }

            s = strm.state;
            wrap = s.wrap;

            if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
                return Z_STREAM_ERROR;
            }

            /* when using zlib wrappers, compute Adler-32 for provided dictionary */
            if (wrap === 1) {
                /* adler32(strm->adler, dictionary, dictLength); */
                strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
            }

            s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

            /* if dictionary would fill window, just replace the history */
            if (dictLength >= s.w_size) {
                if (wrap === 0) {            /* already empty otherwise */
                    /*** CLEAR_HASH(s); ***/
                    zero(s.head); // Fill with NIL (= 0);
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                }
                /* use the tail */
                // dictionary = dictionary.slice(dictLength - s.w_size);
                tmpDict = new utils.Buf8(s.w_size);
                utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                dictionary = tmpDict;
                dictLength = s.w_size;
            }
            /* insert dictionary into window and hash */
            avail = strm.avail_in;
            next = strm.next_in;
            input = strm.input;
            strm.avail_in = dictLength;
            strm.next_in = 0;
            strm.input = dictionary;
            fill_window(s);
            while (s.lookahead >= MIN_MATCH) {
                str = s.strstart;
                n = s.lookahead - (MIN_MATCH - 1);
                do {
                    /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

                    s.prev[str & s.w_mask] = s.head[s.ins_h];

                    s.head[s.ins_h] = str;
                    str++;
                } while (--n);
                s.strstart = str;
                s.lookahead = MIN_MATCH - 1;
                fill_window(s);
            }
            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.input = input;
            strm.avail_in = avail;
            s.wrap = wrap;
            return Z_OK;
        }


        exports.deflateInit = deflateInit;
        exports.deflateInit2 = deflateInit2;
        exports.deflateReset = deflateReset;
        exports.deflateResetKeep = deflateResetKeep;
        exports.deflateSetHeader = deflateSetHeader;
        exports.deflate = deflate;
        exports.deflateEnd = deflateEnd;
        exports.deflateSetDictionary = deflateSetDictionary;
        exports.deflateInfo = 'pako deflate (from Nodeca project)';

        /* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

    },{"../utils/common":3,"./adler32":5,"./crc32":7,"./messages":13,"./trees":14}],9:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        function GZheader() {
            /* true if compressed data believed to be text */
            this.text       = 0;
            /* modification time */
            this.time       = 0;
            /* extra flags (not used when writing a gzip file) */
            this.xflags     = 0;
            /* operating system */
            this.os         = 0;
            /* pointer to extra field or Z_NULL if none */
            this.extra      = null;
            /* extra field length (valid if extra != Z_NULL) */
            this.extra_len  = 0; // Actually, we don't need it in JS,
                                 // but leave for few code modifications

            //
            // Setup limits is not necessary because in js we should not preallocate memory
            // for inflate use constant limit in 65536 bytes
            //

            /* space at extra (only when reading header) */
            // this.extra_max  = 0;
            /* pointer to zero-terminated file name or Z_NULL */
            this.name       = '';
            /* space at name (only when reading header) */
            // this.name_max   = 0;
            /* pointer to zero-terminated comment or Z_NULL */
            this.comment    = '';
            /* space at comment (only when reading header) */
            // this.comm_max   = 0;
            /* true if there was or will be a header crc */
            this.hcrc       = 0;
            /* true when done reading gzip header (not used when writing a gzip file) */
            this.done       = false;
        }

        module.exports = GZheader;

    },{}],10:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
        var BAD = 30;       /* got a data error -- remain here until reset */
        var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

        /*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
        module.exports = function inflate_fast(strm, start) {
            var state;
            var _in;                    /* local strm.input */
            var last;                   /* have enough input while in < last */
            var _out;                   /* local strm.output */
            var beg;                    /* inflate()'s initial strm.output */
            var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
            var dmax;                   /* maximum distance from zlib header */
//#endif
            var wsize;                  /* window size or zero if not using window */
            var whave;                  /* valid bytes in the window */
            var wnext;                  /* window write index */
            // Use `s_window` instead `window`, avoid conflict with instrumentation tools
            var s_window;               /* allocated sliding window, if wsize != 0 */
            var hold;                   /* local strm.hold */
            var bits;                   /* local strm.bits */
            var lcode;                  /* local strm.lencode */
            var dcode;                  /* local strm.distcode */
            var lmask;                  /* mask for first level of length codes */
            var dmask;                  /* mask for first level of distance codes */
            var here;                   /* retrieved table entry */
            var op;                     /* code bits, operation, extra bits, or */
            /*  window position, window bytes to copy */
            var len;                    /* match length, unused bytes */
            var dist;                   /* match distance */
            var from;                   /* where to copy match from */
            var from_source;


            var input, output; // JS specific, because we have no pointers

            /* copy state to local variables */
            state = strm.state;
            //here = state.here;
            _in = strm.next_in;
            input = strm.input;
            last = _in + (strm.avail_in - 5);
            _out = strm.next_out;
            output = strm.output;
            beg = _out - (start - strm.avail_out);
            end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
            dmax = state.dmax;
//#endif
            wsize = state.wsize;
            whave = state.whave;
            wnext = state.wnext;
            s_window = state.window;
            hold = state.hold;
            bits = state.bits;
            lcode = state.lencode;
            dcode = state.distcode;
            lmask = (1 << state.lenbits) - 1;
            dmask = (1 << state.distbits) - 1;


            /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

            top:
                do {
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }

                    here = lcode[hold & lmask];

                    dolen:
                        for (;;) { // Goto emulation
                            op = here >>> 24/*here.bits*/;
                            hold >>>= op;
                            bits -= op;
                            op = (here >>> 16) & 0xff/*here.op*/;
                            if (op === 0) {                          /* literal */
                                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                //        "inflate:         literal '%c'\n" :
                                //        "inflate:         literal 0x%02x\n", here.val));
                                output[_out++] = here & 0xffff/*here.val*/;
                            }
                            else if (op & 16) {                     /* length base */
                                len = here & 0xffff/*here.val*/;
                                op &= 15;                           /* number of extra bits */
                                if (op) {
                                    if (bits < op) {
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                    }
                                    len += hold & ((1 << op) - 1);
                                    hold >>>= op;
                                    bits -= op;
                                }
                                //Tracevv((stderr, "inflate:         length %u\n", len));
                                if (bits < 15) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                                here = dcode[hold & dmask];

                                dodist:
                                    for (;;) { // goto emulation
                                        op = here >>> 24/*here.bits*/;
                                        hold >>>= op;
                                        bits -= op;
                                        op = (here >>> 16) & 0xff/*here.op*/;

                                        if (op & 16) {                      /* distance base */
                                            dist = here & 0xffff/*here.val*/;
                                            op &= 15;                       /* number of extra bits */
                                            if (bits < op) {
                                                hold += input[_in++] << bits;
                                                bits += 8;
                                                if (bits < op) {
                                                    hold += input[_in++] << bits;
                                                    bits += 8;
                                                }
                                            }
                                            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
                                            if (dist > dmax) {
                                                strm.msg = 'invalid distance too far back';
                                                state.mode = BAD;
                                                break top;
                                            }
//#endif
                                            hold >>>= op;
                                            bits -= op;
                                            //Tracevv((stderr, "inflate:         distance %u\n", dist));
                                            op = _out - beg;                /* max distance in output */
                                            if (dist > op) {                /* see if copy from window */
                                                op = dist - op;               /* distance back in window */
                                                if (op > whave) {
                                                    if (state.sane) {
                                                        strm.msg = 'invalid distance too far back';
                                                        state.mode = BAD;
                                                        break top;
                                                    }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
                                                }
                                                from = 0; // window index
                                                from_source = s_window;
                                                if (wnext === 0) {           /* very common case */
                                                    from += wsize - op;
                                                    if (op < len) {         /* some from window */
                                                        len -= op;
                                                        do {
                                                            output[_out++] = s_window[from++];
                                                        } while (--op);
                                                        from = _out - dist;  /* rest from output */
                                                        from_source = output;
                                                    }
                                                }
                                                else if (wnext < op) {      /* wrap around window */
                                                    from += wsize + wnext - op;
                                                    op -= wnext;
                                                    if (op < len) {         /* some from end of window */
                                                        len -= op;
                                                        do {
                                                            output[_out++] = s_window[from++];
                                                        } while (--op);
                                                        from = 0;
                                                        if (wnext < len) {  /* some from start of window */
                                                            op = wnext;
                                                            len -= op;
                                                            do {
                                                                output[_out++] = s_window[from++];
                                                            } while (--op);
                                                            from = _out - dist;      /* rest from output */
                                                            from_source = output;
                                                        }
                                                    }
                                                }
                                                else {                      /* contiguous in window */
                                                    from += wnext - op;
                                                    if (op < len) {         /* some from window */
                                                        len -= op;
                                                        do {
                                                            output[_out++] = s_window[from++];
                                                        } while (--op);
                                                        from = _out - dist;  /* rest from output */
                                                        from_source = output;
                                                    }
                                                }
                                                while (len > 2) {
                                                    output[_out++] = from_source[from++];
                                                    output[_out++] = from_source[from++];
                                                    output[_out++] = from_source[from++];
                                                    len -= 3;
                                                }
                                                if (len) {
                                                    output[_out++] = from_source[from++];
                                                    if (len > 1) {
                                                        output[_out++] = from_source[from++];
                                                    }
                                                }
                                            }
                                            else {
                                                from = _out - dist;          /* copy direct from output */
                                                do {                        /* minimum length is three */
                                                    output[_out++] = output[from++];
                                                    output[_out++] = output[from++];
                                                    output[_out++] = output[from++];
                                                    len -= 3;
                                                } while (len > 2);
                                                if (len) {
                                                    output[_out++] = output[from++];
                                                    if (len > 1) {
                                                        output[_out++] = output[from++];
                                                    }
                                                }
                                            }
                                        }
                                        else if ((op & 64) === 0) {          /* 2nd level distance code */
                                            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                                            continue dodist;
                                        }
                                        else {
                                            strm.msg = 'invalid distance code';
                                            state.mode = BAD;
                                            break top;
                                        }

                                        break; // need to emulate goto via "continue"
                                    }
                            }
                            else if ((op & 64) === 0) {              /* 2nd level length code */
                                here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                                continue dolen;
                            }
                            else if (op & 32) {                     /* end-of-block */
                                //Tracevv((stderr, "inflate:         end of block\n"));
                                state.mode = TYPE;
                                break top;
                            }
                            else {
                                strm.msg = 'invalid literal/length code';
                                state.mode = BAD;
                                break top;
                            }

                            break; // need to emulate goto via "continue"
                        }
                } while (_in < last && _out < end);

            /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
            len = bits >> 3;
            _in -= len;
            bits -= len << 3;
            hold &= (1 << bits) - 1;

            /* update state and return */
            strm.next_in = _in;
            strm.next_out = _out;
            strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
            strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
            state.hold = hold;
            state.bits = bits;
            return;
        };

    },{}],11:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        var utils         = require('../utils/common');
        var adler32       = require('./adler32');
        var crc32         = require('./crc32');
        var inflate_fast  = require('./inffast');
        var inflate_table = require('./inftrees');

        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;

        /* Public constants ==========================================================*/
        /* ===========================================================================*/


        /* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
        var Z_FINISH        = 4;
        var Z_BLOCK         = 5;
        var Z_TREES         = 6;


        /* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
        var Z_OK            = 0;
        var Z_STREAM_END    = 1;
        var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
        var Z_STREAM_ERROR  = -2;
        var Z_DATA_ERROR    = -3;
        var Z_MEM_ERROR     = -4;
        var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

        /* The deflate compression method */
        var Z_DEFLATED  = 8;


        /* STATES ====================================================================*/
        /* ===========================================================================*/


        var    HEAD = 1;       /* i: waiting for magic header */
        var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
        var    TIME = 3;       /* i: waiting for modification time (gzip) */
        var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
        var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
        var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
        var    NAME = 7;       /* i: waiting for end of file name (gzip) */
        var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
        var    HCRC = 9;       /* i: waiting for header crc (gzip) */
        var    DICTID = 10;    /* i: waiting for dictionary check value */
        var    DICT = 11;      /* waiting for inflateSetDictionary() call */
        var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
        var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
        var        STORED = 14;    /* i: waiting for stored size (length and complement) */
        var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
        var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
        var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
        var        LENLENS = 18;   /* i: waiting for code length code lengths */
        var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
        var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
        var            LEN = 21;       /* i: waiting for length/lit/eob code */
        var            LENEXT = 22;    /* i: waiting for length extra bits */
        var            DIST = 23;      /* i: waiting for distance code */
        var            DISTEXT = 24;   /* i: waiting for distance extra bits */
        var            MATCH = 25;     /* o: waiting for output space to copy string */
        var            LIT = 26;       /* o: waiting for output space to write literal */
        var    CHECK = 27;     /* i: waiting for 32-bit check value */
        var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
        var    DONE = 29;      /* finished check, done -- remain here until reset */
        var    BAD = 30;       /* got a data error -- remain here until reset */
        var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
        var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

        /* ===========================================================================*/



        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

        var MAX_WBITS = 15;
        /* 32K LZ77 window */
        var DEF_WBITS = MAX_WBITS;


        function zswap32(q) {
            return  (((q >>> 24) & 0xff) +
                ((q >>> 8) & 0xff00) +
                ((q & 0xff00) << 8) +
                ((q & 0xff) << 24));
        }


        function InflateState() {
            this.mode = 0;             /* current inflate mode */
            this.last = false;          /* true if processing last block */
            this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
            this.havedict = false;      /* true if dictionary provided */
            this.flags = 0;             /* gzip header method and flags (0 if zlib) */
            this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
            this.check = 0;             /* protected copy of check value */
            this.total = 0;             /* protected copy of output count */
            // TODO: may be {}
            this.head = null;           /* where to save gzip header information */

            /* sliding window */
            this.wbits = 0;             /* log base 2 of requested window size */
            this.wsize = 0;             /* window size or zero if not using window */
            this.whave = 0;             /* valid bytes in the window */
            this.wnext = 0;             /* window write index */
            this.window = null;         /* allocated sliding window, if needed */

            /* bit accumulator */
            this.hold = 0;              /* input bit accumulator */
            this.bits = 0;              /* number of bits in "in" */

            /* for string and stored block copying */
            this.length = 0;            /* literal or length of data to copy */
            this.offset = 0;            /* distance back to copy string from */

            /* for table and code decoding */
            this.extra = 0;             /* extra bits needed */

            /* fixed and dynamic code tables */
            this.lencode = null;          /* starting table for length/literal codes */
            this.distcode = null;         /* starting table for distance codes */
            this.lenbits = 0;           /* index bits for lencode */
            this.distbits = 0;          /* index bits for distcode */

            /* dynamic table building */
            this.ncode = 0;             /* number of code length code lengths */
            this.nlen = 0;              /* number of length code lengths */
            this.ndist = 0;             /* number of distance code lengths */
            this.have = 0;              /* number of code lengths in lens[] */
            this.next = null;              /* next available space in codes[] */

            this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
            this.work = new utils.Buf16(288); /* work area for code table building */

            /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
            //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
            this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
            this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
            this.sane = 0;                   /* if false, allow invalid distance too far */
            this.back = 0;                   /* bits back of last unprocessed length/lit */
            this.was = 0;                    /* initial length of match */
        }

        function inflateResetKeep(strm) {
            var state;

            if (!strm || !strm.state) { return Z_STREAM_ERROR; }
            state = strm.state;
            strm.total_in = strm.total_out = state.total = 0;
            strm.msg = ''; /*Z_NULL*/
            if (state.wrap) {       /* to support ill-conceived Java test suite */
                strm.adler = state.wrap & 1;
            }
            state.mode = HEAD;
            state.last = 0;
            state.havedict = 0;
            state.dmax = 32768;
            state.head = null/*Z_NULL*/;
            state.hold = 0;
            state.bits = 0;
            //state.lencode = state.distcode = state.next = state.codes;
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

            state.sane = 1;
            state.back = -1;
            //Tracev((stderr, "inflate: reset\n"));
            return Z_OK;
        }

        function inflateReset(strm) {
            var state;

            if (!strm || !strm.state) { return Z_STREAM_ERROR; }
            state = strm.state;
            state.wsize = 0;
            state.whave = 0;
            state.wnext = 0;
            return inflateResetKeep(strm);

        }

        function inflateReset2(strm, windowBits) {
            var wrap;
            var state;

            /* get the state */
            if (!strm || !strm.state) { return Z_STREAM_ERROR; }
            state = strm.state;

            /* extract wrap request from windowBits parameter */
            if (windowBits < 0) {
                wrap = 0;
                windowBits = -windowBits;
            }
            else {
                wrap = (windowBits >> 4) + 1;
                if (windowBits < 48) {
                    windowBits &= 15;
                }
            }

            /* set number of window bits, free window if different */
            if (windowBits && (windowBits < 8 || windowBits > 15)) {
                return Z_STREAM_ERROR;
            }
            if (state.window !== null && state.wbits !== windowBits) {
                state.window = null;
            }

            /* update state and reset the rest of it */
            state.wrap = wrap;
            state.wbits = windowBits;
            return inflateReset(strm);
        }

        function inflateInit2(strm, windowBits) {
            var ret;
            var state;

            if (!strm) { return Z_STREAM_ERROR; }
            //strm.msg = Z_NULL;                 /* in case we return an error */

            state = new InflateState();

            //if (state === Z_NULL) return Z_MEM_ERROR;
            //Tracev((stderr, "inflate: allocated\n"));
            strm.state = state;
            state.window = null/*Z_NULL*/;
            ret = inflateReset2(strm, windowBits);
            if (ret !== Z_OK) {
                strm.state = null/*Z_NULL*/;
            }
            return ret;
        }

        function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
        }


        /*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
        var virgin = true;

        var lenfix, distfix; // We have no pointers in JS, so keep tables separate

        function fixedtables(state) {
            /* build fixed huffman tables if first call (may not be thread safe) */
            if (virgin) {
                var sym;

                lenfix = new utils.Buf32(512);
                distfix = new utils.Buf32(32);

                /* literal/length table */
                sym = 0;
                while (sym < 144) { state.lens[sym++] = 8; }
                while (sym < 256) { state.lens[sym++] = 9; }
                while (sym < 280) { state.lens[sym++] = 7; }
                while (sym < 288) { state.lens[sym++] = 8; }

                inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

                /* distance table */
                sym = 0;
                while (sym < 32) { state.lens[sym++] = 5; }

                inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

                /* do this just once */
                virgin = false;
            }

            state.lencode = lenfix;
            state.lenbits = 9;
            state.distcode = distfix;
            state.distbits = 5;
        }


        /*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
        function updatewindow(strm, src, end, copy) {
            var dist;
            var state = strm.state;

            /* if it hasn't been done already, allocate space for the window */
            if (state.window === null) {
                state.wsize = 1 << state.wbits;
                state.wnext = 0;
                state.whave = 0;

                state.window = new utils.Buf8(state.wsize);
            }

            /* copy state->wsize or less output bytes into the circular window */
            if (copy >= state.wsize) {
                utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                state.wnext = 0;
                state.whave = state.wsize;
            }
            else {
                dist = state.wsize - state.wnext;
                if (dist > copy) {
                    dist = copy;
                }
                //zmemcpy(state->window + state->wnext, end - copy, dist);
                utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                copy -= dist;
                if (copy) {
                    //zmemcpy(state->window, end - copy, copy);
                    utils.arraySet(state.window, src, end - copy, copy, 0);
                    state.wnext = copy;
                    state.whave = state.wsize;
                }
                else {
                    state.wnext += dist;
                    if (state.wnext === state.wsize) { state.wnext = 0; }
                    if (state.whave < state.wsize) { state.whave += dist; }
                }
            }
            return 0;
        }

        function inflate(strm, flush) {
            var state;
            var input, output;          // input/output buffers
            var next;                   /* next input INDEX */
            var put;                    /* next output INDEX */
            var have, left;             /* available input and output */
            var hold;                   /* bit buffer */
            var bits;                   /* bits in bit buffer */
            var _in, _out;              /* save starting available input and output */
            var copy;                   /* number of stored or match bytes to copy */
            var from;                   /* where to copy match bytes from */
            var from_source;
            var here = 0;               /* current decoding table entry */
            var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
            //var last;                   /* parent table entry */
            var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
            var len;                    /* length to copy for repeats, bits to drop */
            var ret;                    /* return code */
            var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
            var opts;

            var n; // temporary var for NEED_BITS

            var order = /* permutation of code lengths */
                [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


            if (!strm || !strm.state || !strm.output ||
                (!strm.input && strm.avail_in !== 0)) {
                return Z_STREAM_ERROR;
            }

            state = strm.state;
            if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


            //--- LOAD() ---
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            //---

            _in = have;
            _out = left;
            ret = Z_OK;

            inf_leave: // goto emulation
                for (;;) {
                    switch (state.mode) {
                        case HEAD:
                            if (state.wrap === 0) {
                                state.mode = TYPEDO;
                                break;
                            }
                            //=== NEEDBITS(16);
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
                                state.check = 0/*crc32(0L, Z_NULL, 0)*/;
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//

                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = FLAGS;
                                break;
                            }
                            state.flags = 0;           /* expect zlib header */
                            if (state.head) {
                                state.head.done = false;
                            }
                            if (!(state.wrap & 1) ||   /* check if zlib header allowed */
                                (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                                strm.msg = 'incorrect header check';
                                state.mode = BAD;
                                break;
                            }
                            if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
                                strm.msg = 'unknown compression method';
                                state.mode = BAD;
                                break;
                            }
                            //--- DROPBITS(4) ---//
                            hold >>>= 4;
                            bits -= 4;
                            //---//
                            len = (hold & 0x0f)/*BITS(4)*/ + 8;
                            if (state.wbits === 0) {
                                state.wbits = len;
                            }
                            else if (len > state.wbits) {
                                strm.msg = 'invalid window size';
                                state.mode = BAD;
                                break;
                            }
                            state.dmax = 1 << len;
                            //Tracev((stderr, "inflate:   zlib header ok\n"));
                            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                            state.mode = hold & 0x200 ? DICTID : TYPE;
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            break;
                        case FLAGS:
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.flags = hold;
                            if ((state.flags & 0xff) !== Z_DEFLATED) {
                                strm.msg = 'unknown compression method';
                                state.mode = BAD;
                                break;
                            }
                            if (state.flags & 0xe000) {
                                strm.msg = 'unknown header flags set';
                                state.mode = BAD;
                                break;
                            }
                            if (state.head) {
                                state.head.text = ((hold >> 8) & 1);
                            }
                            if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = TIME;
                        /* falls through */
                        case TIME:
                            //=== NEEDBITS(32); */
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (state.head) {
                                state.head.time = hold;
                            }
                            if (state.flags & 0x0200) {
                                //=== CRC4(state.check, hold)
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                hbuf[2] = (hold >>> 16) & 0xff;
                                hbuf[3] = (hold >>> 24) & 0xff;
                                state.check = crc32(state.check, hbuf, 4, 0);
                                //===
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = OS;
                        /* falls through */
                        case OS:
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (state.head) {
                                state.head.xflags = (hold & 0xff);
                                state.head.os = (hold >> 8);
                            }
                            if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = EXLEN;
                        /* falls through */
                        case EXLEN:
                            if (state.flags & 0x0400) {
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.length = hold;
                                if (state.head) {
                                    state.head.extra_len = hold;
                                }
                                if (state.flags & 0x0200) {
                                    //=== CRC2(state.check, hold);
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                    //===//
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                            }
                            else if (state.head) {
                                state.head.extra = null/*Z_NULL*/;
                            }
                            state.mode = EXTRA;
                        /* falls through */
                        case EXTRA:
                            if (state.flags & 0x0400) {
                                copy = state.length;
                                if (copy > have) { copy = have; }
                                if (copy) {
                                    if (state.head) {
                                        len = state.head.extra_len - state.length;
                                        if (!state.head.extra) {
                                            // Use untyped array for more convenient processing later
                                            state.head.extra = new Array(state.head.extra_len);
                                        }
                                        utils.arraySet(
                                            state.head.extra,
                                            input,
                                            next,
                                            // extra field is limited to 65536 bytes
                                            // - no need for additional size check
                                            copy,
                                            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                            len
                                        );
                                        //zmemcpy(state.head.extra + len, next,
                                        //        len + copy > state.head.extra_max ?
                                        //        state.head.extra_max - len : copy);
                                    }
                                    if (state.flags & 0x0200) {
                                        state.check = crc32(state.check, input, copy, next);
                                    }
                                    have -= copy;
                                    next += copy;
                                    state.length -= copy;
                                }
                                if (state.length) { break inf_leave; }
                            }
                            state.length = 0;
                            state.mode = NAME;
                        /* falls through */
                        case NAME:
                            if (state.flags & 0x0800) {
                                if (have === 0) { break inf_leave; }
                                copy = 0;
                                do {
                                    // TODO: 2 or 1 bytes?
                                    len = input[next + copy++];
                                    /* use constant limit because in js we should not preallocate memory */
                                    if (state.head && len &&
                                        (state.length < 65536 /*state.head.name_max*/)) {
                                        state.head.name += String.fromCharCode(len);
                                    }
                                } while (len && copy < have);

                                if (state.flags & 0x0200) {
                                    state.check = crc32(state.check, input, copy, next);
                                }
                                have -= copy;
                                next += copy;
                                if (len) { break inf_leave; }
                            }
                            else if (state.head) {
                                state.head.name = null;
                            }
                            state.length = 0;
                            state.mode = COMMENT;
                        /* falls through */
                        case COMMENT:
                            if (state.flags & 0x1000) {
                                if (have === 0) { break inf_leave; }
                                copy = 0;
                                do {
                                    len = input[next + copy++];
                                    /* use constant limit because in js we should not preallocate memory */
                                    if (state.head && len &&
                                        (state.length < 65536 /*state.head.comm_max*/)) {
                                        state.head.comment += String.fromCharCode(len);
                                    }
                                } while (len && copy < have);
                                if (state.flags & 0x0200) {
                                    state.check = crc32(state.check, input, copy, next);
                                }
                                have -= copy;
                                next += copy;
                                if (len) { break inf_leave; }
                            }
                            else if (state.head) {
                                state.head.comment = null;
                            }
                            state.mode = HCRC;
                        /* falls through */
                        case HCRC:
                            if (state.flags & 0x0200) {
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if (hold !== (state.check & 0xffff)) {
                                    strm.msg = 'header crc mismatch';
                                    state.mode = BAD;
                                    break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                            }
                            if (state.head) {
                                state.head.hcrc = ((state.flags >> 9) & 1);
                                state.head.done = true;
                            }
                            strm.adler = state.check = 0;
                            state.mode = TYPE;
                            break;
                        case DICTID:
                            //=== NEEDBITS(32); */
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            strm.adler = state.check = zswap32(hold);
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = DICT;
                        /* falls through */
                        case DICT:
                            if (state.havedict === 0) {
                                //--- RESTORE() ---
                                strm.next_out = put;
                                strm.avail_out = left;
                                strm.next_in = next;
                                strm.avail_in = have;
                                state.hold = hold;
                                state.bits = bits;
                                //---
                                return Z_NEED_DICT;
                            }
                            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                            state.mode = TYPE;
                        /* falls through */
                        case TYPE:
                            if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
                        /* falls through */
                        case TYPEDO:
                            if (state.last) {
                                //--- BYTEBITS() ---//
                                hold >>>= bits & 7;
                                bits -= bits & 7;
                                //---//
                                state.mode = CHECK;
                                break;
                            }
                            //=== NEEDBITS(3); */
                            while (bits < 3) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.last = (hold & 0x01)/*BITS(1)*/;
                            //--- DROPBITS(1) ---//
                            hold >>>= 1;
                            bits -= 1;
                            //---//

                            switch ((hold & 0x03)/*BITS(2)*/) {
                                case 0:                             /* stored block */
                                    //Tracev((stderr, "inflate:     stored block%s\n",
                                    //        state.last ? " (last)" : ""));
                                    state.mode = STORED;
                                    break;
                                case 1:                             /* fixed block */
                                    fixedtables(state);
                                    //Tracev((stderr, "inflate:     fixed codes block%s\n",
                                    //        state.last ? " (last)" : ""));
                                    state.mode = LEN_;             /* decode codes */
                                    if (flush === Z_TREES) {
                                        //--- DROPBITS(2) ---//
                                        hold >>>= 2;
                                        bits -= 2;
                                        //---//
                                        break inf_leave;
                                    }
                                    break;
                                case 2:                             /* dynamic block */
                                    //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                    //        state.last ? " (last)" : ""));
                                    state.mode = TABLE;
                                    break;
                                case 3:
                                    strm.msg = 'invalid block type';
                                    state.mode = BAD;
                            }
                            //--- DROPBITS(2) ---//
                            hold >>>= 2;
                            bits -= 2;
                            //---//
                            break;
                        case STORED:
                            //--- BYTEBITS() ---// /* go to byte boundary */
                            hold >>>= bits & 7;
                            bits -= bits & 7;
                            //---//
                            //=== NEEDBITS(32); */
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                                strm.msg = 'invalid stored block lengths';
                                state.mode = BAD;
                                break;
                            }
                            state.length = hold & 0xffff;
                            //Tracev((stderr, "inflate:       stored length %u\n",
                            //        state.length));
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = COPY_;
                            if (flush === Z_TREES) { break inf_leave; }
                        /* falls through */
                        case COPY_:
                            state.mode = COPY;
                        /* falls through */
                        case COPY:
                            copy = state.length;
                            if (copy) {
                                if (copy > have) { copy = have; }
                                if (copy > left) { copy = left; }
                                if (copy === 0) { break inf_leave; }
                                //--- zmemcpy(put, next, copy); ---
                                utils.arraySet(output, input, next, copy, put);
                                //---//
                                have -= copy;
                                next += copy;
                                left -= copy;
                                put += copy;
                                state.length -= copy;
                                break;
                            }
                            //Tracev((stderr, "inflate:       stored end\n"));
                            state.mode = TYPE;
                            break;
                        case TABLE:
                            //=== NEEDBITS(14); */
                            while (bits < 14) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
                            //--- DROPBITS(5) ---//
                            hold >>>= 5;
                            bits -= 5;
                            //---//
                            state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
                            //--- DROPBITS(5) ---//
                            hold >>>= 5;
                            bits -= 5;
                            //---//
                            state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
                            //--- DROPBITS(4) ---//
                            hold >>>= 4;
                            bits -= 4;
                            //---//
//#ifndef PKZIP_BUG_WORKAROUND
                            if (state.nlen > 286 || state.ndist > 30) {
                                strm.msg = 'too many length or distance symbols';
                                state.mode = BAD;
                                break;
                            }
//#endif
                            //Tracev((stderr, "inflate:       table sizes ok\n"));
                            state.have = 0;
                            state.mode = LENLENS;
                        /* falls through */
                        case LENLENS:
                            while (state.have < state.ncode) {
                                //=== NEEDBITS(3);
                                while (bits < 3) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
                                //--- DROPBITS(3) ---//
                                hold >>>= 3;
                                bits -= 3;
                                //---//
                            }
                            while (state.have < 19) {
                                state.lens[order[state.have++]] = 0;
                            }
                            // We have separate tables & no pointers. 2 commented lines below not needed.
                            //state.next = state.codes;
                            //state.lencode = state.next;
                            // Switch to use dynamic table
                            state.lencode = state.lendyn;
                            state.lenbits = 7;

                            opts = { bits: state.lenbits };
                            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                            state.lenbits = opts.bits;

                            if (ret) {
                                strm.msg = 'invalid code lengths set';
                                state.mode = BAD;
                                break;
                            }
                            //Tracev((stderr, "inflate:       code lengths ok\n"));
                            state.have = 0;
                            state.mode = CODELENS;
                        /* falls through */
                        case CODELENS:
                            while (state.have < state.nlen + state.ndist) {
                                for (;;) {
                                    here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;

                                    if ((here_bits) <= bits) { break; }
                                    //--- PULLBYTE() ---//
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                    //---//
                                }
                                if (here_val < 16) {
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    state.lens[state.have++] = here_val;
                                }
                                else {
                                    if (here_val === 16) {
                                        //=== NEEDBITS(here.bits + 2);
                                        n = here_bits + 2;
                                        while (bits < n) {
                                            if (have === 0) { break inf_leave; }
                                            have--;
                                            hold += input[next++] << bits;
                                            bits += 8;
                                        }
                                        //===//
                                        //--- DROPBITS(here.bits) ---//
                                        hold >>>= here_bits;
                                        bits -= here_bits;
                                        //---//
                                        if (state.have === 0) {
                                            strm.msg = 'invalid bit length repeat';
                                            state.mode = BAD;
                                            break;
                                        }
                                        len = state.lens[state.have - 1];
                                        copy = 3 + (hold & 0x03);//BITS(2);
                                        //--- DROPBITS(2) ---//
                                        hold >>>= 2;
                                        bits -= 2;
                                        //---//
                                    }
                                    else if (here_val === 17) {
                                        //=== NEEDBITS(here.bits + 3);
                                        n = here_bits + 3;
                                        while (bits < n) {
                                            if (have === 0) { break inf_leave; }
                                            have--;
                                            hold += input[next++] << bits;
                                            bits += 8;
                                        }
                                        //===//
                                        //--- DROPBITS(here.bits) ---//
                                        hold >>>= here_bits;
                                        bits -= here_bits;
                                        //---//
                                        len = 0;
                                        copy = 3 + (hold & 0x07);//BITS(3);
                                        //--- DROPBITS(3) ---//
                                        hold >>>= 3;
                                        bits -= 3;
                                        //---//
                                    }
                                    else {
                                        //=== NEEDBITS(here.bits + 7);
                                        n = here_bits + 7;
                                        while (bits < n) {
                                            if (have === 0) { break inf_leave; }
                                            have--;
                                            hold += input[next++] << bits;
                                            bits += 8;
                                        }
                                        //===//
                                        //--- DROPBITS(here.bits) ---//
                                        hold >>>= here_bits;
                                        bits -= here_bits;
                                        //---//
                                        len = 0;
                                        copy = 11 + (hold & 0x7f);//BITS(7);
                                        //--- DROPBITS(7) ---//
                                        hold >>>= 7;
                                        bits -= 7;
                                        //---//
                                    }
                                    if (state.have + copy > state.nlen + state.ndist) {
                                        strm.msg = 'invalid bit length repeat';
                                        state.mode = BAD;
                                        break;
                                    }
                                    while (copy--) {
                                        state.lens[state.have++] = len;
                                    }
                                }
                            }

                            /* handle error breaks in while */
                            if (state.mode === BAD) { break; }

                            /* check for end-of-block code (better have one) */
                            if (state.lens[256] === 0) {
                                strm.msg = 'invalid code -- missing end-of-block';
                                state.mode = BAD;
                                break;
                            }

                            /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
                            state.lenbits = 9;

                            opts = { bits: state.lenbits };
                            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                            // We have separate tables & no pointers. 2 commented lines below not needed.
                            // state.next_index = opts.table_index;
                            state.lenbits = opts.bits;
                            // state.lencode = state.next;

                            if (ret) {
                                strm.msg = 'invalid literal/lengths set';
                                state.mode = BAD;
                                break;
                            }

                            state.distbits = 6;
                            //state.distcode.copy(state.codes);
                            // Switch to use dynamic table
                            state.distcode = state.distdyn;
                            opts = { bits: state.distbits };
                            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                            // We have separate tables & no pointers. 2 commented lines below not needed.
                            // state.next_index = opts.table_index;
                            state.distbits = opts.bits;
                            // state.distcode = state.next;

                            if (ret) {
                                strm.msg = 'invalid distances set';
                                state.mode = BAD;
                                break;
                            }
                            //Tracev((stderr, 'inflate:       codes ok\n'));
                            state.mode = LEN_;
                            if (flush === Z_TREES) { break inf_leave; }
                        /* falls through */
                        case LEN_:
                            state.mode = LEN;
                        /* falls through */
                        case LEN:
                            if (have >= 6 && left >= 258) {
                                //--- RESTORE() ---
                                strm.next_out = put;
                                strm.avail_out = left;
                                strm.next_in = next;
                                strm.avail_in = have;
                                state.hold = hold;
                                state.bits = bits;
                                //---
                                inflate_fast(strm, _out);
                                //--- LOAD() ---
                                put = strm.next_out;
                                output = strm.output;
                                left = strm.avail_out;
                                next = strm.next_in;
                                input = strm.input;
                                have = strm.avail_in;
                                hold = state.hold;
                                bits = state.bits;
                                //---

                                if (state.mode === TYPE) {
                                    state.back = -1;
                                }
                                break;
                            }
                            state.back = 0;
                            for (;;) {
                                here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if (here_bits <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            if (here_op && (here_op & 0xf0) === 0) {
                                last_bits = here_bits;
                                last_op = here_op;
                                last_val = here_val;
                                for (;;) {
                                    here = state.lencode[last_val +
                                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;

                                    if ((last_bits + here_bits) <= bits) { break; }
                                    //--- PULLBYTE() ---//
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                    //---//
                                }
                                //--- DROPBITS(last.bits) ---//
                                hold >>>= last_bits;
                                bits -= last_bits;
                                //---//
                                state.back += last_bits;
                            }
                            //--- DROPBITS(here.bits) ---//
                            hold >>>= here_bits;
                            bits -= here_bits;
                            //---//
                            state.back += here_bits;
                            state.length = here_val;
                            if (here_op === 0) {
                                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                //        "inflate:         literal '%c'\n" :
                                //        "inflate:         literal 0x%02x\n", here.val));
                                state.mode = LIT;
                                break;
                            }
                            if (here_op & 32) {
                                //Tracevv((stderr, "inflate:         end of block\n"));
                                state.back = -1;
                                state.mode = TYPE;
                                break;
                            }
                            if (here_op & 64) {
                                strm.msg = 'invalid literal/length code';
                                state.mode = BAD;
                                break;
                            }
                            state.extra = here_op & 15;
                            state.mode = LENEXT;
                        /* falls through */
                        case LENEXT:
                            if (state.extra) {
                                //=== NEEDBITS(state.extra);
                                n = state.extra;
                                while (bits < n) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
                                //--- DROPBITS(state.extra) ---//
                                hold >>>= state.extra;
                                bits -= state.extra;
                                //---//
                                state.back += state.extra;
                            }
                            //Tracevv((stderr, "inflate:         length %u\n", state.length));
                            state.was = state.length;
                            state.mode = DIST;
                        /* falls through */
                        case DIST:
                            for (;;) {
                                here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if ((here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            if ((here_op & 0xf0) === 0) {
                                last_bits = here_bits;
                                last_op = here_op;
                                last_val = here_val;
                                for (;;) {
                                    here = state.distcode[last_val +
                                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;

                                    if ((last_bits + here_bits) <= bits) { break; }
                                    //--- PULLBYTE() ---//
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                    //---//
                                }
                                //--- DROPBITS(last.bits) ---//
                                hold >>>= last_bits;
                                bits -= last_bits;
                                //---//
                                state.back += last_bits;
                            }
                            //--- DROPBITS(here.bits) ---//
                            hold >>>= here_bits;
                            bits -= here_bits;
                            //---//
                            state.back += here_bits;
                            if (here_op & 64) {
                                strm.msg = 'invalid distance code';
                                state.mode = BAD;
                                break;
                            }
                            state.offset = here_val;
                            state.extra = (here_op) & 15;
                            state.mode = DISTEXT;
                        /* falls through */
                        case DISTEXT:
                            if (state.extra) {
                                //=== NEEDBITS(state.extra);
                                n = state.extra;
                                while (bits < n) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
                                //--- DROPBITS(state.extra) ---//
                                hold >>>= state.extra;
                                bits -= state.extra;
                                //---//
                                state.back += state.extra;
                            }
//#ifdef INFLATE_STRICT
                            if (state.offset > state.dmax) {
                                strm.msg = 'invalid distance too far back';
                                state.mode = BAD;
                                break;
                            }
//#endif
                            //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                            state.mode = MATCH;
                        /* falls through */
                        case MATCH:
                            if (left === 0) { break inf_leave; }
                            copy = _out - left;
                            if (state.offset > copy) {         /* copy from window */
                                copy = state.offset - copy;
                                if (copy > state.whave) {
                                    if (state.sane) {
                                        strm.msg = 'invalid distance too far back';
                                        state.mode = BAD;
                                        break;
                                    }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
                                }
                                if (copy > state.wnext) {
                                    copy -= state.wnext;
                                    from = state.wsize - copy;
                                }
                                else {
                                    from = state.wnext - copy;
                                }
                                if (copy > state.length) { copy = state.length; }
                                from_source = state.window;
                            }
                            else {                              /* copy from output */
                                from_source = output;
                                from = put - state.offset;
                                copy = state.length;
                            }
                            if (copy > left) { copy = left; }
                            left -= copy;
                            state.length -= copy;
                            do {
                                output[put++] = from_source[from++];
                            } while (--copy);
                            if (state.length === 0) { state.mode = LEN; }
                            break;
                        case LIT:
                            if (left === 0) { break inf_leave; }
                            output[put++] = state.length;
                            left--;
                            state.mode = LEN;
                            break;
                        case CHECK:
                            if (state.wrap) {
                                //=== NEEDBITS(32);
                                while (bits < 32) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    // Use '|' instead of '+' to make sure that result is signed
                                    hold |= input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                _out -= left;
                                strm.total_out += _out;
                                state.total += _out;
                                if (_out) {
                                    strm.adler = state.check =
                                        /*UPDATE(state.check, put - _out, _out);*/
                                        (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

                                }
                                _out = left;
                                // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                                    strm.msg = 'incorrect data check';
                                    state.mode = BAD;
                                    break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                //Tracev((stderr, "inflate:   check matches trailer\n"));
                            }
                            state.mode = LENGTH;
                        /* falls through */
                        case LENGTH:
                            if (state.wrap && state.flags) {
                                //=== NEEDBITS(32);
                                while (bits < 32) {
                                    if (have === 0) { break inf_leave; }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                //===//
                                if (hold !== (state.total & 0xffffffff)) {
                                    strm.msg = 'incorrect length check';
                                    state.mode = BAD;
                                    break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                //Tracev((stderr, "inflate:   length matches trailer\n"));
                            }
                            state.mode = DONE;
                        /* falls through */
                        case DONE:
                            ret = Z_STREAM_END;
                            break inf_leave;
                        case BAD:
                            ret = Z_DATA_ERROR;
                            break inf_leave;
                        case MEM:
                            return Z_MEM_ERROR;
                        case SYNC:
                        /* falls through */
                        default:
                            return Z_STREAM_ERROR;
                    }
                }

            // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

            /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---

            if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                (state.mode < CHECK || flush !== Z_FINISH))) {
                if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
            }
            _in -= strm.avail_in;
            _out -= strm.avail_out;
            strm.total_in += _in;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap && _out) {
                strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                    (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
            }
            strm.data_type = state.bits + (state.last ? 64 : 0) +
                (state.mode === TYPE ? 128 : 0) +
                (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
            if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
                ret = Z_BUF_ERROR;
            }
            return ret;
        }

        function inflateEnd(strm) {

            if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
                return Z_STREAM_ERROR;
            }

            var state = strm.state;
            if (state.window) {
                state.window = null;
            }
            strm.state = null;
            return Z_OK;
        }

        function inflateGetHeader(strm, head) {
            var state;

            /* check state */
            if (!strm || !strm.state) { return Z_STREAM_ERROR; }
            state = strm.state;
            if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

            /* save header structure */
            state.head = head;
            head.done = false;
            return Z_OK;
        }

        function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;

            var state;
            var dictid;
            var ret;

            /* check state */
            if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
            state = strm.state;

            if (state.wrap !== 0 && state.mode !== DICT) {
                return Z_STREAM_ERROR;
            }

            /* check for correct dictionary identifier */
            if (state.mode === DICT) {
                dictid = 1; /* adler32(0, null, 0)*/
                /* dictid = adler32(dictid, dictionary, dictLength); */
                dictid = adler32(dictid, dictionary, dictLength, 0);
                if (dictid !== state.check) {
                    return Z_DATA_ERROR;
                }
            }
            /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
            ret = updatewindow(strm, dictionary, dictLength, dictLength);
            if (ret) {
                state.mode = MEM;
                return Z_MEM_ERROR;
            }
            state.havedict = 1;
            // Tracev((stderr, "inflate:   dictionary set\n"));
            return Z_OK;
        }

        exports.inflateReset = inflateReset;
        exports.inflateReset2 = inflateReset2;
        exports.inflateResetKeep = inflateResetKeep;
        exports.inflateInit = inflateInit;
        exports.inflateInit2 = inflateInit2;
        exports.inflate = inflate;
        exports.inflateEnd = inflateEnd;
        exports.inflateGetHeader = inflateGetHeader;
        exports.inflateSetDictionary = inflateSetDictionary;
        exports.inflateInfo = 'pako inflate (from Nodeca project)';

        /* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

    },{"../utils/common":3,"./adler32":5,"./crc32":7,"./inffast":10,"./inftrees":12}],12:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        var utils = require('../utils/common');

        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;

        var lbase = [ /* Length codes 257..285 base */
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
            35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        ];

        var lext = [ /* Length codes 257..285 extra */
            16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
            19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
        ];

        var dbase = [ /* Distance codes 0..29 base */
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
            257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
            8193, 12289, 16385, 24577, 0, 0
        ];

        var dext = [ /* Distance codes 0..29 extra */
            16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
            23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
            28, 28, 29, 29, 64, 64
        ];

        module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
        {
            var bits = opts.bits;
            //here = opts.here; /* table entry for duplication */

            var len = 0;               /* a code's length in bits */
            var sym = 0;               /* index of code symbols */
            var min = 0, max = 0;          /* minimum and maximum code lengths */
            var root = 0;              /* number of index bits for root table */
            var curr = 0;              /* number of index bits for current table */
            var drop = 0;              /* code bits to drop for sub-table */
            var left = 0;                   /* number of prefix codes available */
            var used = 0;              /* code entries in table used */
            var huff = 0;              /* Huffman code */
            var incr;              /* for incrementing code, index */
            var fill;              /* index for replicating entries */
            var low;               /* low bits for current root entry */
            var mask;              /* mask for low root bits */
            var next;             /* next available space in table */
            var base = null;     /* base value table to use */
            var base_index = 0;
//  var shoextra;    /* extra bits table to use */
            var end;                    /* use base and extra for symbol > end */
            var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
            var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
            var extra = null;
            var extra_index = 0;

            var here_bits, here_op, here_val;

            /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

            /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
            for (len = 0; len <= MAXBITS; len++) {
                count[len] = 0;
            }
            for (sym = 0; sym < codes; sym++) {
                count[lens[lens_index + sym]]++;
            }

            /* bound code lengths, force root to be within code lengths */
            root = bits;
            for (max = MAXBITS; max >= 1; max--) {
                if (count[max] !== 0) { break; }
            }
            if (root > max) {
                root = max;
            }
            if (max === 0) {                     /* no symbols to code at all */
                //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
                //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
                //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
                table[table_index++] = (1 << 24) | (64 << 16) | 0;


                //table.op[opts.table_index] = 64;
                //table.bits[opts.table_index] = 1;
                //table.val[opts.table_index++] = 0;
                table[table_index++] = (1 << 24) | (64 << 16) | 0;

                opts.bits = 1;
                return 0;     /* no symbols, but wait for decoding to report error */
            }
            for (min = 1; min < max; min++) {
                if (count[min] !== 0) { break; }
            }
            if (root < min) {
                root = min;
            }

            /* check for an over-subscribed or incomplete set of lengths */
            left = 1;
            for (len = 1; len <= MAXBITS; len++) {
                left <<= 1;
                left -= count[len];
                if (left < 0) {
                    return -1;
                }        /* over-subscribed */
            }
            if (left > 0 && (type === CODES || max !== 1)) {
                return -1;                      /* incomplete set */
            }

            /* generate offsets into symbol table for each length for sorting */
            offs[1] = 0;
            for (len = 1; len < MAXBITS; len++) {
                offs[len + 1] = offs[len] + count[len];
            }

            /* sort symbols by length, by symbol order within each length */
            for (sym = 0; sym < codes; sym++) {
                if (lens[lens_index + sym] !== 0) {
                    work[offs[lens[lens_index + sym]]++] = sym;
                }
            }

            /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

            /* set up for code type */
            // poor man optimization - use if-else instead of switch,
            // to avoid deopts in old v8
            if (type === CODES) {
                base = extra = work;    /* dummy value--not used */
                end = 19;

            } else if (type === LENS) {
                base = lbase;
                base_index -= 257;
                extra = lext;
                extra_index -= 257;
                end = 256;

            } else {                    /* DISTS */
                base = dbase;
                extra = dext;
                end = -1;
            }

            /* initialize opts for loop */
            huff = 0;                   /* starting code */
            sym = 0;                    /* starting code symbol */
            len = min;                  /* starting code length */
            next = table_index;              /* current table to fill in */
            curr = root;                /* current table index bits */
            drop = 0;                   /* current bits to drop from code for index */
            low = -1;                   /* trigger new sub-table when len > root */
            used = 1 << root;          /* use root table entries */
            mask = used - 1;            /* mask for comparing low */

            /* check available table space */
            if ((type === LENS && used > ENOUGH_LENS) ||
                (type === DISTS && used > ENOUGH_DISTS)) {
                return 1;
            }

            /* process all codes and make table entries */
            for (;;) {
                /* create table entry */
                here_bits = len - drop;
                if (work[sym] < end) {
                    here_op = 0;
                    here_val = work[sym];
                }
                else if (work[sym] > end) {
                    here_op = extra[extra_index + work[sym]];
                    here_val = base[base_index + work[sym]];
                }
                else {
                    here_op = 32 + 64;         /* end of block */
                    here_val = 0;
                }

                /* replicate for those indices with low len bits equal to huff */
                incr = 1 << (len - drop);
                fill = 1 << curr;
                min = fill;                 /* save offset to next table */
                do {
                    fill -= incr;
                    table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
                } while (fill !== 0);

                /* backwards increment the len-bit code huff */
                incr = 1 << (len - 1);
                while (huff & incr) {
                    incr >>= 1;
                }
                if (incr !== 0) {
                    huff &= incr - 1;
                    huff += incr;
                } else {
                    huff = 0;
                }

                /* go to next symbol, update count, len */
                sym++;
                if (--count[len] === 0) {
                    if (len === max) { break; }
                    len = lens[lens_index + work[sym]];
                }

                /* create new sub-table if needed */
                if (len > root && (huff & mask) !== low) {
                    /* if first time, transition to sub-tables */
                    if (drop === 0) {
                        drop = root;
                    }

                    /* increment past last table */
                    next += min;            /* here min is 1 << curr */

                    /* determine length of next table */
                    curr = len - drop;
                    left = 1 << curr;
                    while (curr + drop < max) {
                        left -= count[curr + drop];
                        if (left <= 0) { break; }
                        curr++;
                        left <<= 1;
                    }

                    /* check for enough space */
                    used += 1 << curr;
                    if ((type === LENS && used > ENOUGH_LENS) ||
                        (type === DISTS && used > ENOUGH_DISTS)) {
                        return 1;
                    }

                    /* point entry in root table to sub-table */
                    low = huff & mask;
                    /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
                    table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
                }
            }

            /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
            if (huff !== 0) {
                //table.op[next + huff] = 64;            /* invalid code marker */
                //table.bits[next + huff] = len - drop;
                //table.val[next + huff] = 0;
                table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
            }

            /* set return parameters */
            //opts.table_index += used;
            opts.bits = root;
            return 0;
        };

    },{"../utils/common":3}],13:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        module.exports = {
            2:      'need dictionary',     /* Z_NEED_DICT       2  */
            1:      'stream end',          /* Z_STREAM_END      1  */
            0:      '',                    /* Z_OK              0  */
            '-1':   'file error',          /* Z_ERRNO         (-1) */
            '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
            '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
            '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
            '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
            '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
        };

    },{}],14:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        /* eslint-disable space-unary-ops */

        var utils = require('../utils/common');

        /* Public constants ==========================================================*/
        /* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
        var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

        /* Possible values of the data_type field (though see inflate()) */
        var Z_BINARY              = 0;
        var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
        var Z_UNKNOWN             = 2;

        /*============================================================================*/


        function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES    = 2;
        /* The three kinds of block type */

        var MIN_MATCH    = 3;
        var MAX_MATCH    = 258;
        /* The minimum and maximum match lengths */

// From deflate.h
        /* ===========================================================================
 * Internal compression state.
 */

        var LENGTH_CODES  = 29;
        /* number of length codes, not counting the special END_BLOCK code */

        var LITERALS      = 256;
        /* number of literal bytes 0..255 */

        var L_CODES       = LITERALS + 1 + LENGTH_CODES;
        /* number of Literal or Length codes, including the END_BLOCK code */

        var D_CODES       = 30;
        /* number of distance codes */

        var BL_CODES      = 19;
        /* number of codes used to transfer the bit lengths */

        var HEAP_SIZE     = 2 * L_CODES + 1;
        /* maximum heap size */

        var MAX_BITS      = 15;
        /* All codes must not exceed MAX_BITS bits */

        var Buf_size      = 16;
        /* size of bit buffer in bi_buf */


        /* ===========================================================================
 * Constants
 */

        var MAX_BL_BITS = 7;
        /* Bit length codes must not exceed MAX_BL_BITS bits */

        var END_BLOCK   = 256;
        /* end of block literal code */

        var REP_3_6     = 16;
        /* repeat previous bit length 3-6 times (2 bits of repeat count) */

        var REPZ_3_10   = 17;
        /* repeat a zero length 3-10 times  (3 bits of repeat count) */

        var REPZ_11_138 = 18;
        /* repeat a zero length 11-138 times  (7 bits of repeat count) */

        /* eslint-disable comma-spacing,array-bracket-spacing */
        var extra_lbits =   /* extra bits for each length code */
            [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

        var extra_dbits =   /* extra bits for each distance code */
            [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

        var extra_blbits =  /* extra bits for each bit length code */
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

        var bl_order =
            [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
        /* eslint-enable comma-spacing,array-bracket-spacing */

        /* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

        /* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

        var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
        var static_ltree  = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        /* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

        var static_dtree  = new Array(D_CODES * 2);
        zero(static_dtree);
        /* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

        var _dist_code    = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        /* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

        var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        /* length code for each normalized match length (0 == MIN_MATCH) */

        var base_length   = new Array(LENGTH_CODES);
        zero(base_length);
        /* First normalized length for each code (0 = MIN_MATCH) */

        var base_dist     = new Array(D_CODES);
        zero(base_dist);
        /* First normalized distance for each code (0 = distance of 1) */


        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

            this.static_tree  = static_tree;  /* static tree or NULL */
            this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
            this.extra_base   = extra_base;   /* base index for extra_bits */
            this.elems        = elems;        /* max number of elements in the tree */
            this.max_length   = max_length;   /* max bit length for the codes */

            // show if `static_tree` has data or dummy - needed for monomorphic objects
            this.has_stree    = static_tree && static_tree.length;
        }


        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;


        function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree;     /* the dynamic tree */
            this.max_code = 0;            /* largest code with non zero frequency */
            this.stat_desc = stat_desc;   /* the corresponding static tree */
        }



        function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }


        /* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
        function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
            s.pending_buf[s.pending++] = (w) & 0xff;
            s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
        }


        /* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
        function send_bits(s, value, length) {
            if (s.bi_valid > (Buf_size - length)) {
                s.bi_buf |= (value << s.bi_valid) & 0xffff;
                put_short(s, s.bi_buf);
                s.bi_buf = value >> (Buf_size - s.bi_valid);
                s.bi_valid += length - Buf_size;
            } else {
                s.bi_buf |= (value << s.bi_valid) & 0xffff;
                s.bi_valid += length;
            }
        }


        function send_code(s, c, tree) {
            send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
        }


        /* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
        function bi_reverse(code, len) {
            var res = 0;
            do {
                res |= code & 1;
                code >>>= 1;
                res <<= 1;
            } while (--len > 0);
            return res >>> 1;
        }


        /* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
        function bi_flush(s) {
            if (s.bi_valid === 16) {
                put_short(s, s.bi_buf);
                s.bi_buf = 0;
                s.bi_valid = 0;

            } else if (s.bi_valid >= 8) {
                s.pending_buf[s.pending++] = s.bi_buf & 0xff;
                s.bi_buf >>= 8;
                s.bi_valid -= 8;
            }
        }


        /* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
        function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
        {
            var tree            = desc.dyn_tree;
            var max_code        = desc.max_code;
            var stree           = desc.stat_desc.static_tree;
            var has_stree       = desc.stat_desc.has_stree;
            var extra           = desc.stat_desc.extra_bits;
            var base            = desc.stat_desc.extra_base;
            var max_length      = desc.stat_desc.max_length;
            var h;              /* heap index */
            var n, m;           /* iterate over the tree elements */
            var bits;           /* bit length */
            var xbits;          /* extra bits */
            var f;              /* frequency */
            var overflow = 0;   /* number of elements with bit length too large */

            for (bits = 0; bits <= MAX_BITS; bits++) {
                s.bl_count[bits] = 0;
            }

            /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
            tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                n = s.heap[h];
                bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
                if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                }
                tree[n * 2 + 1]/*.Len*/ = bits;
                /* We overwrite tree[n].Dad which is no longer needed */

                if (n > max_code) { continue; } /* not a leaf node */

                s.bl_count[bits]++;
                xbits = 0;
                if (n >= base) {
                    xbits = extra[n - base];
                }
                f = tree[n * 2]/*.Freq*/;
                s.opt_len += f * (bits + xbits);
                if (has_stree) {
                    s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
                }
            }
            if (overflow === 0) { return; }

            // Trace((stderr,"\nbit length overflow\n"));
            /* This happens for example on obj2 and pic of the Calgary corpus */

            /* Find the first bit length which could increase: */
            do {
                bits = max_length - 1;
                while (s.bl_count[bits] === 0) { bits--; }
                s.bl_count[bits]--;      /* move one leaf down the tree */
                s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
                s.bl_count[max_length]--;
                /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
                overflow -= 2;
            } while (overflow > 0);

            /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
            for (bits = max_length; bits !== 0; bits--) {
                n = s.bl_count[bits];
                while (n !== 0) {
                    m = s.heap[--h];
                    if (m > max_code) { continue; }
                    if (tree[m * 2 + 1]/*.Len*/ !== bits) {
                        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
                        tree[m * 2 + 1]/*.Len*/ = bits;
                    }
                    n--;
                }
            }
        }


        /* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
        function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
        {
            var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
            var code = 0;              /* running code value */
            var bits;                  /* bit index */
            var n;                     /* code index */

            /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
            for (bits = 1; bits <= MAX_BITS; bits++) {
                next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
            }
            /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
            //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            //        "inconsistent bit counts");
            //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

            for (n = 0;  n <= max_code; n++) {
                var len = tree[n * 2 + 1]/*.Len*/;
                if (len === 0) { continue; }
                /* Now reverse the bits */
                tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

                //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
                //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
            }
        }


        /* ===========================================================================
 * Initialize the various 'constant' tables.
 */
        function tr_static_init() {
            var n;        /* iterates over tree elements */
            var bits;     /* bit counter */
            var length;   /* length value */
            var code;     /* code value */
            var dist;     /* distance index */
            var bl_count = new Array(MAX_BITS + 1);
            /* number of codes at each bit length for an optimal tree */

            // do check in _tr_init()
            //if (static_init_done) return;

            /* For some embedded targets, global variables are not initialized: */
            /*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

            /* Initialize the mapping length (0..255) -> length code (0..28) */
            length = 0;
            for (code = 0; code < LENGTH_CODES - 1; code++) {
                base_length[code] = length;
                for (n = 0; n < (1 << extra_lbits[code]); n++) {
                    _length_code[length++] = code;
                }
            }
            //Assert (length == 256, "tr_static_init: length != 256");
            /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
            _length_code[length - 1] = code;

            /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
            dist = 0;
            for (code = 0; code < 16; code++) {
                base_dist[code] = dist;
                for (n = 0; n < (1 << extra_dbits[code]); n++) {
                    _dist_code[dist++] = code;
                }
            }
            //Assert (dist == 256, "tr_static_init: dist != 256");
            dist >>= 7; /* from now on, all distances are divided by 128 */
            for (; code < D_CODES; code++) {
                base_dist[code] = dist << 7;
                for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
                    _dist_code[256 + dist++] = code;
                }
            }
            //Assert (dist == 256, "tr_static_init: 256+dist != 512");

            /* Construct the codes of the static literal tree */
            for (bits = 0; bits <= MAX_BITS; bits++) {
                bl_count[bits] = 0;
            }

            n = 0;
            while (n <= 143) {
                static_ltree[n * 2 + 1]/*.Len*/ = 8;
                n++;
                bl_count[8]++;
            }
            while (n <= 255) {
                static_ltree[n * 2 + 1]/*.Len*/ = 9;
                n++;
                bl_count[9]++;
            }
            while (n <= 279) {
                static_ltree[n * 2 + 1]/*.Len*/ = 7;
                n++;
                bl_count[7]++;
            }
            while (n <= 287) {
                static_ltree[n * 2 + 1]/*.Len*/ = 8;
                n++;
                bl_count[8]++;
            }
            /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
            gen_codes(static_ltree, L_CODES + 1, bl_count);

            /* The static distance tree is trivial: */
            for (n = 0; n < D_CODES; n++) {
                static_dtree[n * 2 + 1]/*.Len*/ = 5;
                static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
            }

            // Now data ready and we can init static trees
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

            //static_init_done = true;
        }


        /* ===========================================================================
 * Initialize a new block.
 */
        function init_block(s) {
            var n; /* iterates over tree elements */

            /* Initialize the trees. */
            for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
            for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
            for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

            s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
            s.opt_len = s.static_len = 0;
            s.last_lit = s.matches = 0;
        }


        /* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
        function bi_windup(s)
        {
            if (s.bi_valid > 8) {
                put_short(s, s.bi_buf);
            } else if (s.bi_valid > 0) {
                //put_byte(s, (Byte)s->bi_buf);
                s.pending_buf[s.pending++] = s.bi_buf;
            }
            s.bi_buf = 0;
            s.bi_valid = 0;
        }

        /* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
        function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
        {
            bi_windup(s);        /* align on byte boundary */

            if (header) {
                put_short(s, len);
                put_short(s, ~len);
            }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
            s.pending += len;
        }

        /* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
        function smaller(tree, n, m, depth) {
            var _n2 = n * 2;
            var _m2 = m * 2;
            return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
                (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
        }

        /* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
        function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
        {
            var v = s.heap[k];
            var j = k << 1;  /* left son of k */
            while (j <= s.heap_len) {
                /* Set j to the smallest of the two sons: */
                if (j < s.heap_len &&
                    smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                    j++;
                }
                /* Exit if v is smaller than both sons */
                if (smaller(tree, v, s.heap[j], s.depth)) { break; }

                /* Exchange v with the smallest son */
                s.heap[k] = s.heap[j];
                k = j;

                /* And continue down the tree, setting j to the left son of k */
                j <<= 1;
            }
            s.heap[k] = v;
        }


// inlined manually
// var SMALLEST = 1;

        /* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
        function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
        {
            var dist;           /* distance of matched string */
            var lc;             /* match length or unmatched char (if dist == 0) */
            var lx = 0;         /* running index in l_buf */
            var code;           /* the code to send */
            var extra;          /* number of extra bits to send */

            if (s.last_lit !== 0) {
                do {
                    dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
                    lc = s.pending_buf[s.l_buf + lx];
                    lx++;

                    if (dist === 0) {
                        send_code(s, lc, ltree); /* send a literal byte */
                        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                    } else {
                        /* Here, lc is the match length - MIN_MATCH */
                        code = _length_code[lc];
                        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
                        extra = extra_lbits[code];
                        if (extra !== 0) {
                            lc -= base_length[code];
                            send_bits(s, lc, extra);       /* send the extra length bits */
                        }
                        dist--; /* dist is now the match distance - 1 */
                        code = d_code(dist);
                        //Assert (code < D_CODES, "bad d_code");

                        send_code(s, code, dtree);       /* send the distance code */
                        extra = extra_dbits[code];
                        if (extra !== 0) {
                            dist -= base_dist[code];
                            send_bits(s, dist, extra);   /* send the extra distance bits */
                        }
                    } /* literal or match pair ? */

                    /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                    //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                    //       "pendingBuf overflow");

                } while (lx < s.last_lit);
            }

            send_code(s, END_BLOCK, ltree);
        }


        /* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
        function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
        {
            var tree     = desc.dyn_tree;
            var stree    = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var elems    = desc.stat_desc.elems;
            var n, m;          /* iterate over heap elements */
            var max_code = -1; /* largest code with non zero frequency */
            var node;          /* new node being created */

            /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;

            for (n = 0; n < elems; n++) {
                if (tree[n * 2]/*.Freq*/ !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;

                } else {
                    tree[n * 2 + 1]/*.Len*/ = 0;
                }
            }

            /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
            while (s.heap_len < 2) {
                node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
                tree[node * 2]/*.Freq*/ = 1;
                s.depth[node] = 0;
                s.opt_len--;

                if (has_stree) {
                    s.static_len -= stree[node * 2 + 1]/*.Len*/;
                }
                /* node is 0 or 1 so it does not have extra bits */
            }
            desc.max_code = max_code;

            /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
            for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

            /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
            node = elems;              /* next internal node of the tree */
            do {
                //pqremove(s, tree, n);  /* n = node of least frequency */
                /*** pqremove ***/
                n = s.heap[1/*SMALLEST*/];
                s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
                pqdownheap(s, tree, 1/*SMALLEST*/);
                /***/

                m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

                s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
                s.heap[--s.heap_max] = m;

                /* Create a new node father of n and m */
                tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
                s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

                /* and insert the new node in the heap */
                s.heap[1/*SMALLEST*/] = node++;
                pqdownheap(s, tree, 1/*SMALLEST*/);

            } while (s.heap_len >= 2);

            s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

            /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
            gen_bitlen(s, desc);

            /* The field len is now set, we can generate the bit codes */
            gen_codes(tree, max_code, s.bl_count);
        }


        /* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
        function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
        {
            var n;                     /* iterates over all tree elements */
            var prevlen = -1;          /* last emitted length */
            var curlen;                /* length of current code */

            var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

            var count = 0;             /* repeat count of the current code */
            var max_count = 7;         /* max repeat count */
            var min_count = 4;         /* min repeat count */

            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }
            tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

                if (++count < max_count && curlen === nextlen) {
                    continue;

                } else if (count < min_count) {
                    s.bl_tree[curlen * 2]/*.Freq*/ += count;

                } else if (curlen !== 0) {

                    if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
                    s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

                } else if (count <= 10) {
                    s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

                } else {
                    s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
                }

                count = 0;
                prevlen = curlen;

                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;

                } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;

                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }


        /* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
        function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
        {
            var n;                     /* iterates over all tree elements */
            var prevlen = -1;          /* last emitted length */
            var curlen;                /* length of current code */

            var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

            var count = 0;             /* repeat count of the current code */
            var max_count = 7;         /* max repeat count */
            var min_count = 4;         /* min repeat count */

            /* tree[max_code+1].Len = -1; */  /* guard already set */
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }

            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

                if (++count < max_count && curlen === nextlen) {
                    continue;

                } else if (count < min_count) {
                    do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

                } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                        send_code(s, curlen, s.bl_tree);
                        count--;
                    }
                    //Assert(count >= 3 && count <= 6, " 3_6?");
                    send_code(s, REP_3_6, s.bl_tree);
                    send_bits(s, count - 3, 2);

                } else if (count <= 10) {
                    send_code(s, REPZ_3_10, s.bl_tree);
                    send_bits(s, count - 3, 3);

                } else {
                    send_code(s, REPZ_11_138, s.bl_tree);
                    send_bits(s, count - 11, 7);
                }

                count = 0;
                prevlen = curlen;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;

                } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;

                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }


        /* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
        function build_bl_tree(s) {
            var max_blindex;  /* index of last bit length code of non zero freq */

            /* Determine the bit length frequencies for literal and distance trees */
            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

            /* Build the bit length tree: */
            build_tree(s, s.bl_desc);
            /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

            /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
                    break;
                }
            }
            /* Update opt_len to include the bit length tree and counts */
            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
            //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            //        s->opt_len, s->static_len));

            return max_blindex;
        }


        /* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
        function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
        {
            var rank;                    /* index in bl_order */

            //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
            //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            //        "too many codes");
            //Tracev((stderr, "\nbl counts: "));
            send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
            send_bits(s, dcodes - 1,   5);
            send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
            for (rank = 0; rank < blcodes; rank++) {
                //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
                send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
            }
            //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

            send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
            //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

            send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
            //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
        }


        /* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
        function detect_data_type(s) {
            /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
            var black_mask = 0xf3ffc07f;
            var n;

            /* Check for non-textual ("black-listed") bytes. */
            for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
                    return Z_BINARY;
                }
            }

            /* Check for textual ("white-listed") bytes. */
            if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
                s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
                return Z_TEXT;
            }
            for (n = 32; n < LITERALS; n++) {
                if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
                    return Z_TEXT;
                }
            }

            /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
            return Z_BINARY;
        }


        var static_init_done = false;

        /* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
        function _tr_init(s)
        {

            if (!static_init_done) {
                tr_static_init();
                static_init_done = true;
            }

            s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
            s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

            s.bi_buf = 0;
            s.bi_valid = 0;

            /* Initialize the first block of the first file: */
            init_block(s);
        }


        /* ===========================================================================
 * Send a stored block
 */
        function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
        {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
            copy_block(s, buf, stored_len, true); /* with header */
        }


        /* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
        function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
        }


        /* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
        function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
        {
            var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
            var max_blindex = 0;        /* index of last bit length code of non zero freq */

            /* Build the Huffman trees unless a stored block is forced */
            if (s.level > 0) {

                /* Check if the file is binary or text */
                if (s.strm.data_type === Z_UNKNOWN) {
                    s.strm.data_type = detect_data_type(s);
                }

                /* Construct the literal and distance trees */
                build_tree(s, s.l_desc);
                // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                //        s->static_len));

                build_tree(s, s.d_desc);
                // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                //        s->static_len));
                /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

                /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
                max_blindex = build_bl_tree(s);

                /* Determine the best encoding. Compute the block lengths in bytes. */
                opt_lenb = (s.opt_len + 3 + 7) >>> 3;
                static_lenb = (s.static_len + 3 + 7) >>> 3;

                // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                //        s->last_lit));

                if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

            } else {
                // Assert(buf != (char*)0, "lost buf");
                opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
            }

            if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
                /* 4: two words for the lengths */

                /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
                _tr_stored_block(s, buf, stored_len, last);

            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

                send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                compress_block(s, static_ltree, static_dtree);

            } else {
                send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                compress_block(s, s.dyn_ltree, s.dyn_dtree);
            }
            // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
            /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
            init_block(s);

            if (last) {
                bi_windup(s);
            }
            // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
            //       s->compressed_len-7*last));
        }

        /* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
        function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
        {
            //var out_length, in_length, dcode;

            s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

            s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
            s.last_lit++;

            if (dist === 0) {
                /* lc is the unmatched char */
                s.dyn_ltree[lc * 2]/*.Freq*/++;
            } else {
                s.matches++;
                /* Here, lc is the match length - MIN_MATCH */
                dist--;             /* dist = match distance - 1 */
                //Assert((ush)dist < (ush)MAX_DIST(s) &&
                //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
                //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

                s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
                s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
            }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

            return (s.last_lit === s.lit_bufsize - 1);
            /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
        }

        exports._tr_init  = _tr_init;
        exports._tr_stored_block = _tr_stored_block;
        exports._tr_flush_block  = _tr_flush_block;
        exports._tr_tally = _tr_tally;
        exports._tr_align = _tr_align;

    },{"../utils/common":3}],15:[function(require,module,exports){

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

        function ZStream() {
            /* next input byte */
            this.input = null; // JS specific, because we have no pointers
            this.next_in = 0;
            /* number of bytes available at input */
            this.avail_in = 0;
            /* total number of input bytes read so far */
            this.total_in = 0;
            /* next output byte should be put there */
            this.output = null; // JS specific, because we have no pointers
            this.next_out = 0;
            /* remaining free space at output */
            this.avail_out = 0;
            /* total number of bytes output so far */
            this.total_out = 0;
            /* last error message, NULL if no error */
            this.msg = ''/*Z_NULL*/;
            /* not visible by applications */
            this.state = null;
            /* best guess about the data type: binary or text */
            this.data_type = 2/*Z_UNKNOWN*/;
            /* adler32 value of the uncompressed data */
            this.adler = 0;
        }

        module.exports = ZStream;

    },{}],"/":[function(require,module,exports){

        var assign    = require('./lib/utils/common').assign;

        var deflate   = require('./lib/deflate');
        var inflate   = require('./lib/inflate');
        var constants = require('./lib/zlib/constants');

        var pako = {};

        assign(pako, deflate, inflate, constants);

        module.exports = pako;

    },{"./lib/deflate":1,"./lib/inflate":2,"./lib/utils/common":3,"./lib/zlib/constants":6}]},{},[])("/")
});

var p = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/*

 Parser for .XKT Format V1

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 DEPRECATED

 */

var pako$8 = window.pako || p;
if (!pako$8.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$8 = pako$8.default;
}

var decompressColor$8 = (function () {
    var color2 = new Float32Array(3);
    return function (color) {
        color2[0] = color[0] / 255.0;
        color2[1] = color[1] / 255.0;
        color2[2] = color[2] / 255.0;
        return color2;
    };
})();

function extract$8(elements) {
    return {
        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],
        meshPositions: elements[4],
        meshIndices: elements[5],
        meshEdgesIndices: elements[6],
        meshColors: elements[7],
        entityIDs: elements[8],
        entityMeshes: elements[9],
        entityIsObjects: elements[10],
        positionsDecodeMatrix: elements[11]
    };
}

function inflate$8(deflatedData) {
    return {
        positions: new Uint16Array(pako$8.inflate(deflatedData.positions).buffer),
        normals: new Int8Array(pako$8.inflate(deflatedData.normals).buffer),
        indices: new Uint32Array(pako$8.inflate(deflatedData.indices).buffer),
        edgeIndices: new Uint32Array(pako$8.inflate(deflatedData.edgeIndices).buffer),
        meshPositions: new Uint32Array(pako$8.inflate(deflatedData.meshPositions).buffer),
        meshIndices: new Uint32Array(pako$8.inflate(deflatedData.meshIndices).buffer),
        meshEdgesIndices: new Uint32Array(pako$8.inflate(deflatedData.meshEdgesIndices).buffer),
        meshColors: new Uint8Array(pako$8.inflate(deflatedData.meshColors).buffer),
        entityIDs: pako$8.inflate(deflatedData.entityIDs, {to: 'string'}),
        entityMeshes: new Uint32Array(pako$8.inflate(deflatedData.entityMeshes).buffer),
        entityIsObjects: new Uint8Array(pako$8.inflate(deflatedData.entityIsObjects).buffer),
        positionsDecodeMatrix: new Float32Array(pako$8.inflate(deflatedData.positionsDecodeMatrix).buffer)
    };
}

function load$8(viewer, options, inflatedData, performanceModel) {

    performanceModel.positionsCompression = "precompressed";
    performanceModel.normalsCompression = "precompressed";

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;
    var meshPositions = inflatedData.meshPositions;
    var meshIndices = inflatedData.meshIndices;
    var meshEdgesIndices = inflatedData.meshEdgesIndices;
    var meshColors = inflatedData.meshColors;
    var entityIDs = JSON.parse(inflatedData.entityIDs);
    var entityMeshes = inflatedData.entityMeshes;
    var entityIsObjects = inflatedData.entityIsObjects;
    var numMeshes = meshPositions.length;
    var numEntities = entityMeshes.length;

    for (var i = 0; i < numEntities; i++) {

        var xktEntityId = entityIDs [i];
        var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;
        var metaObject = viewer.metaScene.metaObjects[entityId];
        var entityDefaults = {};
        var meshDefaults = {};

        if (metaObject) {

            if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                continue;
            }

            if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                continue;
            }

            var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

            if (props) {
                if (props.visible === false) {
                    entityDefaults.visible = false;
                }
                if (props.pickable === false) {
                    entityDefaults.pickable = false;
                }
                if (props.colorize) {
                    meshDefaults.color = props.colorize;
                }
                if (props.opacity !== undefined && props.opacity !== null) {
                    meshDefaults.opacity = props.opacity;
                }
            }
        } else {
            if (options.excludeUnclassifiedObjects) {
                continue;
            }
        }

        var lastEntity = (i === numEntities - 1);
        var meshIds = [];

        for (var j = entityMeshes [i], jlen = lastEntity ? entityMeshes.length : entityMeshes [i + 1]; j < jlen; j++) {

            var lastMesh = (j === (numMeshes - 1));
            var meshId = entityId + ".mesh." + j;

            var color = decompressColor$8(meshColors.subarray((j * 4), (j * 4) + 3));
            var opacity = meshColors[(j * 4) + 3] / 255.0;

            performanceModel.createMesh(utils.apply(meshDefaults, {
                id: meshId,
                primitive: "triangles",
                positions: positions.subarray(meshPositions [j], lastMesh ? positions.length : meshPositions [j + 1]),
                normals: normals.subarray(meshPositions [j], lastMesh ? positions.length : meshPositions [j + 1]),
                indices: indices.subarray(meshIndices [j], lastMesh ? indices.length : meshIndices [j + 1]),
                edgeIndices: edgeIndices.subarray(meshEdgesIndices [j], lastMesh ? edgeIndices.length : meshEdgesIndices [j + 1]),
                positionsDecodeMatrix: inflatedData.positionsDecodeMatrix,
                color: color,
                opacity: opacity
            }));

            meshIds.push(meshId);
        }

        performanceModel.createEntity(utils.apply(entityDefaults, {
            id: entityId,
            isObject: (entityIsObjects [i] === 1),
            meshIds: meshIds
        }));
    }
}

/** @private */
var ParserV1 = {
    version: 1,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$8(elements);
        var inflatedData = inflate$8(deflatedData);
        load$8(viewer, options, inflatedData, performanceModel);
    }
};

/*

Parser for .XKT Format V2

DEPRECATED

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */

var pako$7 = window.pako || p;
if (!pako$7.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$7 = pako$7.default;
}

function extract$7(elements) {
    return {

        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],

        meshPositions: elements[4],
        meshIndices: elements[5],
        meshEdgesIndices: elements[6],
        meshColors: elements[7],

        entityIDs: elements[8],
        entityMeshes: elements[9],
        entityIsObjects: elements[10],

        positionsDecodeMatrix: elements[11],

        entityMeshIds: elements[12],
        entityMatrices: elements[13],
        entityUsesInstancing: elements[14]
    };
}

function inflate$7(deflatedData) {
    return {
        positions: new Uint16Array(pako$7.inflate(deflatedData.positions).buffer),
        normals: new Int8Array(pako$7.inflate(deflatedData.normals).buffer),
        indices: new Uint32Array(pako$7.inflate(deflatedData.indices).buffer),
        edgeIndices: new Uint32Array(pako$7.inflate(deflatedData.edgeIndices).buffer),

        meshPositions: new Uint32Array(pako$7.inflate(deflatedData.meshPositions).buffer),
        meshIndices: new Uint32Array(pako$7.inflate(deflatedData.meshIndices).buffer),
        meshEdgesIndices: new Uint32Array(pako$7.inflate(deflatedData.meshEdgesIndices).buffer),
        meshColors: new Uint8Array(pako$7.inflate(deflatedData.meshColors).buffer),

        entityIDs: pako$7.inflate(deflatedData.entityIDs, {to: 'string'}),
        entityMeshes: new Uint32Array(pako$7.inflate(deflatedData.entityMeshes).buffer),
        entityIsObjects: new Uint8Array(pako$7.inflate(deflatedData.entityIsObjects).buffer),

        positionsDecodeMatrix: new Float32Array(pako$7.inflate(deflatedData.positionsDecodeMatrix).buffer),

        entityMeshIds: new Uint32Array(pako$7.inflate(deflatedData.entityMeshIds).buffer),
        entityMatrices: new Float32Array(pako$7.inflate(deflatedData.entityMatrices).buffer),
        entityUsesInstancing: new Uint8Array(pako$7.inflate(deflatedData.entityUsesInstancing).buffer)
    };
}

var decompressColor$7 = (function () {
    var color2 = new Float32Array(3);
    return function (color) {
        color2[0] = color[0] / 255.0;
        color2[1] = color[1] / 255.0;
        color2[2] = color[2] / 255.0;
        return color2;
    };
})();

function load$7(viewer, options, inflatedData, performanceModel) {

    performanceModel.positionsCompression = "precompressed";
    performanceModel.normalsCompression = "precompressed";

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;
    var meshPositions = inflatedData.meshPositions;
    var meshIndices = inflatedData.meshIndices;
    var meshEdgesIndices = inflatedData.meshEdgesIndices;
    var meshColors = inflatedData.meshColors;
    var entityIDs = JSON.parse(inflatedData.entityIDs);
    var entityMeshes = inflatedData.entityMeshes;
    var entityIsObjects = inflatedData.entityIsObjects;
    var entityMeshIds = inflatedData.entityMeshIds;
    var entityMatrices = inflatedData.entityMatrices;
    var entityUsesInstancing = inflatedData.entityUsesInstancing;

    var numMeshes = meshPositions.length;
    var numEntities = entityMeshes.length;

    var alreadyCreatedGeometries = {};

    for (var i = 0; i < numEntities; i++) {

        var xktEntityId = entityIDs [i];
        var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;
        var metaObject = viewer.metaScene.metaObjects[entityId];
        var entityDefaults = {};
        var meshDefaults = {};
        var entityMatrix = entityMatrices.subarray((i * 16), (i * 16) + 16);

        if (metaObject) {
            if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                continue;
            }
            if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                continue;
            }
            var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;
            if (props) {
                if (props.visible === false) {
                    entityDefaults.visible = false;
                }
                if (props.pickable === false) {
                    entityDefaults.pickable = false;
                }
                if (props.colorize) {
                    meshDefaults.color = props.colorize;
                }
                if (props.opacity !== undefined && props.opacity !== null) {
                    meshDefaults.opacity = props.opacity;
                }
            }
        } else {
            if (options.excludeUnclassifiedObjects) {
                continue;
            }
        }

        var lastEntity = (i === numEntities - 1);

        var meshIds = [];

        for (var j = entityMeshes [i], jlen = lastEntity ? entityMeshIds.length : entityMeshes [i + 1]; j < jlen; j++) {

            var jj = entityMeshIds [j];

            var lastMesh = (jj === (numMeshes - 1));
            var meshId = entityId + ".mesh." + jj;

            var color = decompressColor$7(meshColors.subarray((jj * 4), (jj * 4) + 3));
            var opacity = meshColors[(jj * 4) + 3] / 255.0;

            var tmpPositions = positions.subarray(meshPositions [jj], lastMesh ? positions.length : meshPositions [jj + 1]);
            var tmpNormals = normals.subarray(meshPositions [jj], lastMesh ? positions.length : meshPositions [jj + 1]);
            var tmpIndices = indices.subarray(meshIndices [jj], lastMesh ? indices.length : meshIndices [jj + 1]);
            var tmpEdgeIndices = edgeIndices.subarray(meshEdgesIndices [jj], lastMesh ? edgeIndices.length : meshEdgesIndices [jj + 1]);

            if (entityUsesInstancing [i] === 1) {

                var geometryId = "geometry." + jj;

                if (!(geometryId in alreadyCreatedGeometries)) {

                    performanceModel.createGeometry({
                        id: geometryId,
                        positions: tmpPositions,
                        normals: tmpNormals,
                        indices: tmpIndices,
                        edgeIndices: tmpEdgeIndices,
                        primitive: "triangles",
                        positionsDecodeMatrix: inflatedData.positionsDecodeMatrix,
                    });

                    alreadyCreatedGeometries [geometryId] = true;
                }

                performanceModel.createMesh(utils.apply(meshDefaults, {
                    id: meshId,
                    color: color,
                    opacity: opacity,
                    matrix: entityMatrix,
                    geometryId: geometryId,
                }));

                meshIds.push(meshId);

            } else {

                performanceModel.createMesh(utils.apply(meshDefaults, {
                    id: meshId,
                    primitive: "triangles",
                    positions: tmpPositions,
                    normals: tmpNormals,
                    indices: tmpIndices,
                    edgeIndices: tmpEdgeIndices,
                    positionsDecodeMatrix: inflatedData.positionsDecodeMatrix,
                    color: color,
                    opacity: opacity
                }));

                meshIds.push(meshId);
            }
        }

        if (meshIds.length) {

            performanceModel.createEntity(utils.apply(entityDefaults, {
                id: entityId,
                isObject: (entityIsObjects [i] === 1),
                meshIds: meshIds
            }));
        }
    }
}

/** @private */
var ParserV2 = {
    version: 2,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$7(elements);
        var inflatedData = inflate$7(deflatedData);
        load$7(viewer, options, inflatedData, performanceModel);
    }
};

/*

Parser for .XKT Format V3

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */

var pako$6 = window.pako || p;
if (!pako$6.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$6 = pako$6.default;
}

function extract$6(elements) {
    return {
        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],
        meshPositions: elements[4],
        meshIndices: elements[5],
        meshEdgesIndices: elements[6],
        meshColors: elements[7],
        entityIDs: elements[8],
        entityMeshes: elements[9],
        entityIsObjects: elements[10],
        instancedPositionsDecodeMatrix: elements[11],
        batchedPositionsDecodeMatrix: elements[12],
        entityMeshIds: elements[13],
        entityMatrices: elements[14],
        entityUsesInstancing: elements[15]
    };
}

function inflate$6(deflatedData) {
    return {
        positions: new Uint16Array(pako$6.inflate(deflatedData.positions).buffer),
        normals: new Int8Array(pako$6.inflate(deflatedData.normals).buffer),
        indices: new Uint32Array(pako$6.inflate(deflatedData.indices).buffer),
        edgeIndices: new Uint32Array(pako$6.inflate(deflatedData.edgeIndices).buffer),
        meshPositions: new Uint32Array(pako$6.inflate(deflatedData.meshPositions).buffer),
        meshIndices: new Uint32Array(pako$6.inflate(deflatedData.meshIndices).buffer),
        meshEdgesIndices: new Uint32Array(pako$6.inflate(deflatedData.meshEdgesIndices).buffer),
        meshColors: new Uint8Array(pako$6.inflate(deflatedData.meshColors).buffer),
        entityIDs: pako$6.inflate(deflatedData.entityIDs, {to: 'string'}),
        entityMeshes: new Uint32Array(pako$6.inflate(deflatedData.entityMeshes).buffer),
        entityIsObjects: new Uint8Array(pako$6.inflate(deflatedData.entityIsObjects).buffer),
        instancedPositionsDecodeMatrix: new Float32Array(pako$6.inflate(deflatedData.instancedPositionsDecodeMatrix).buffer),
        batchedPositionsDecodeMatrix: new Float32Array(pako$6.inflate(deflatedData.batchedPositionsDecodeMatrix).buffer),
        entityMeshIds: new Uint32Array(pako$6.inflate(deflatedData.entityMeshIds).buffer),
        entityMatrices: new Float32Array(pako$6.inflate(deflatedData.entityMatrices).buffer),
        entityUsesInstancing: new Uint8Array(pako$6.inflate(deflatedData.entityUsesInstancing).buffer)
    };
}

var decompressColor$6 = (function () {
    var color2 = new Float32Array(3);
    return function (color) {
        color2[0] = color[0] / 255.0;
        color2[1] = color[1] / 255.0;
        color2[2] = color[2] / 255.0;
        return color2;
    };
})();

function load$6(viewer, options, inflatedData, performanceModel) {

    performanceModel.positionsCompression = "precompressed";
    performanceModel.normalsCompression = "precompressed";

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;
    var meshPositions = inflatedData.meshPositions;
    var meshIndices = inflatedData.meshIndices;
    var meshEdgesIndices = inflatedData.meshEdgesIndices;
    var meshColors = inflatedData.meshColors;
    var entityIDs = JSON.parse(inflatedData.entityIDs);
    var entityMeshes = inflatedData.entityMeshes;
    var entityIsObjects = inflatedData.entityIsObjects;
    var entityMeshIds = inflatedData.entityMeshIds;
    var entityMatrices = inflatedData.entityMatrices;
    var entityUsesInstancing = inflatedData.entityUsesInstancing;

    var numMeshes = meshPositions.length;
    var numEntities = entityMeshes.length;

    var _alreadyCreatedGeometries = {};

    for (var i = 0; i < numEntities; i++) {

        var xktEntityId = entityIDs [i];
        var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;
        var metaObject = viewer.metaScene.metaObjects[entityId];
        var entityDefaults = {};
        var meshDefaults = {};
        var entityMatrix = entityMatrices.subarray((i * 16), (i * 16) + 16);

        if (metaObject) {

            if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                continue;
            }

            if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                continue;
            }

            var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

            if (props) {
                if (props.visible === false) {
                    entityDefaults.visible = false;
                }
                if (props.pickable === false) {
                    entityDefaults.pickable = false;
                }
                if (props.colorize) {
                    meshDefaults.color = props.colorize;
                }
                if (props.opacity !== undefined && props.opacity !== null) {
                    meshDefaults.opacity = props.opacity;
                }
            }
        } else {
            if (options.excludeUnclassifiedObjects) {
                continue;
            }
        }

        var lastEntity = (i === numEntities - 1);

        var meshIds = [];

        for (var j = entityMeshes [i], jlen = lastEntity ? entityMeshIds.length : entityMeshes [i + 1]; j < jlen; j++) {
            var jj = entityMeshIds [j];

            var lastMesh = (jj === (numMeshes - 1));
            var meshId = entityId + ".mesh." + jj;

            var color = decompressColor$6(meshColors.subarray((jj * 4), (jj * 4) + 3));
            var opacity = meshColors[(jj * 4) + 3] / 255.0;

            var tmpPositions = positions.subarray(meshPositions [jj], lastMesh ? positions.length : meshPositions [jj + 1]);
            var tmpNormals = normals.subarray(meshPositions [jj], lastMesh ? positions.length : meshPositions [jj + 1]);
            var tmpIndices = indices.subarray(meshIndices [jj], lastMesh ? indices.length : meshIndices [jj + 1]);
            var tmpEdgeIndices = edgeIndices.subarray(meshEdgesIndices [jj], lastMesh ? edgeIndices.length : meshEdgesIndices [jj + 1]);

            if (entityUsesInstancing [i] === 1) {
                var geometryId = "geometry." + jj;

                if (!(geometryId in _alreadyCreatedGeometries)) {

                    performanceModel.createGeometry({
                        id: geometryId,
                        positions: tmpPositions,
                        normals: tmpNormals,
                        indices: tmpIndices,
                        edgeIndices: tmpEdgeIndices,
                        primitive: "triangles",
                        positionsDecodeMatrix: inflatedData.instancedPositionsDecodeMatrix
                    });

                    _alreadyCreatedGeometries [geometryId] = true;
                }

                performanceModel.createMesh(utils.apply(meshDefaults, {
                    id: meshId,
                    color: color,
                    opacity: opacity,
                    matrix: entityMatrix,
                    geometryId: geometryId,
                }));

                meshIds.push(meshId);

            } else {

                performanceModel.createMesh(utils.apply(meshDefaults, {
                    id: meshId,
                    primitive: "triangles",
                    positions: tmpPositions,
                    normals: tmpNormals,
                    indices: tmpIndices,
                    edgeIndices: tmpEdgeIndices,
                    positionsDecodeMatrix: inflatedData.batchedPositionsDecodeMatrix,
                    color: color,
                    opacity: opacity
                }));

                meshIds.push(meshId);
            }
        }

        if (meshIds.length) {
            performanceModel.createEntity(utils.apply(entityDefaults, {
                id: entityId,
                isObject: (entityIsObjects [i] === 1),
                meshIds: meshIds
            }));
        }
    }
}

/** @private */
var ParserV3 = {
    version: 3,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$6(elements);
        var inflatedData = inflate$6(deflatedData);
        load$6(viewer, options, inflatedData, performanceModel);
    }
};

/*

Parser for .XKT Format V4

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */

var pako$5 = window.pako || p;
if (!pako$5.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$5 = pako$5.default;
}

function extract$5(elements) {
    return {
        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],
        decodeMatrices: elements[4],
        matrices: elements[5],
        eachPrimitivePositionsAndNormalsPortion: elements[6],
        eachPrimitiveIndicesPortion: elements[7],
        eachPrimitiveEdgeIndicesPortion: elements[8],
        eachPrimitiveDecodeMatricesPortion: elements[9],
        eachPrimitiveColor: elements[10],
        primitiveInstances: elements[11],
        eachEntityId: elements[12],
        eachEntityPrimitiveInstancesPortion: elements[13],
        eachEntityMatricesPortion: elements[14],
        eachEntityMatrix: elements[15]
    };
}

function inflate$5(deflatedData) {
    return {
        positions: new Uint16Array(pako$5.inflate(deflatedData.positions).buffer),
        normals: new Int8Array(pako$5.inflate(deflatedData.normals).buffer),
        indices: new Uint32Array(pako$5.inflate(deflatedData.indices).buffer),
        edgeIndices: new Uint32Array(pako$5.inflate(deflatedData.edgeIndices).buffer),
        decodeMatrices: new Float32Array(pako$5.inflate(deflatedData.decodeMatrices).buffer),
        matrices: new Float32Array(pako$5.inflate(deflatedData.matrices).buffer),
        eachPrimitivePositionsAndNormalsPortion: new Uint32Array(pako$5.inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion).buffer),
        eachPrimitiveIndicesPortion: new Uint32Array(pako$5.inflate(deflatedData.eachPrimitiveIndicesPortion).buffer),
        eachPrimitiveEdgeIndicesPortion: new Uint32Array(pako$5.inflate(deflatedData.eachPrimitiveEdgeIndicesPortion).buffer),
        eachPrimitiveDecodeMatricesPortion: new Uint32Array(pako$5.inflate(deflatedData.eachPrimitiveDecodeMatricesPortion).buffer),
        eachPrimitiveColor: new Uint8Array(pako$5.inflate(deflatedData.eachPrimitiveColor).buffer),
        primitiveInstances: new Uint32Array(pako$5.inflate(deflatedData.primitiveInstances).buffer),
        eachEntityId: pako$5.inflate(deflatedData.eachEntityId, {to: 'string'}),
        eachEntityPrimitiveInstancesPortion: new Uint32Array(pako$5.inflate(deflatedData.eachEntityPrimitiveInstancesPortion).buffer),
        eachEntityMatricesPortion: new Uint32Array(pako$5.inflate(deflatedData.eachEntityMatricesPortion).buffer)
    };
}

var decompressColor$5 = (function () {
    var color2 = new Float32Array(3);
    return function (color) {
        color2[0] = color[0] / 255.0;
        color2[1] = color[1] / 255.0;
        color2[2] = color[2] / 255.0;
        return color2;
    };
})();

function load$5(viewer, options, inflatedData, performanceModel) {

    performanceModel.positionsCompression = "precompressed";
    performanceModel.normalsCompression = "precompressed";

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;
    var decodeMatrices = inflatedData.decodeMatrices;
    var matrices = inflatedData.matrices;

    var eachPrimitivePositionsAndNormalsPortion = inflatedData.eachPrimitivePositionsAndNormalsPortion;
    var eachPrimitiveIndicesPortion = inflatedData.eachPrimitiveIndicesPortion;
    var eachPrimitiveEdgeIndicesPortion = inflatedData.eachPrimitiveEdgeIndicesPortion;
    var eachPrimitiveDecodeMatricesPortion = inflatedData.eachPrimitiveDecodeMatricesPortion;
    var eachPrimitiveColor = inflatedData.eachPrimitiveColor;

    var primitiveInstances = inflatedData.primitiveInstances;

    var eachEntityId = JSON.parse(inflatedData.eachEntityId);
    var eachEntityPrimitiveInstancesPortion = inflatedData.eachEntityPrimitiveInstancesPortion;
    var eachEntityMatricesPortion = inflatedData.eachEntityMatricesPortion;

    var numPrimitives = eachPrimitivePositionsAndNormalsPortion.length;
    var numPrimitiveInstances = primitiveInstances.length;
    var primitiveInstanceCounts = new Uint8Array(numPrimitives); // For each mesh, how many times it is instanced
    var orderedPrimitiveIndexes = new Uint32Array(numPrimitives); // For each mesh, its index sorted into runs that share the same decode matrix

    var numEntities = eachEntityId.length;

    // Get lookup that orders primitives into runs that share the same decode matrices;
    // this is used to create meshes in batches that use the same decode matrix

    for (var primitiveIndex = 0; primitiveIndex < numPrimitives; primitiveIndex++) {
        orderedPrimitiveIndexes[primitiveIndex] = primitiveIndex;
    }

    orderedPrimitiveIndexes.sort(function (i1, i2) {
        if (eachPrimitiveDecodeMatricesPortion[i1] < eachPrimitiveDecodeMatricesPortion[i2]) {
            return -1;
        }
        if (eachPrimitiveDecodeMatricesPortion[i1] > eachPrimitiveDecodeMatricesPortion[i2]) {
            return 1;
        }
        return 0;
    });

    // Count instances of each primitive

    for (var primitiveInstanceIndex = 0; primitiveInstanceIndex < numPrimitiveInstances; primitiveInstanceIndex++) {
        var primitiveIndex$1 = primitiveInstances[primitiveInstanceIndex];
        primitiveInstanceCounts[primitiveIndex$1]++;
    }

    // Map batched primitives to the entities that will use them

    var batchedPrimitiveEntityIndexes = {};

    for (var entityIndex = 0; entityIndex < numEntities; entityIndex++) {

        var lastEntityIndex = (numEntities - 1);
        var atLastEntity = (entityIndex === lastEntityIndex);
        var firstEntityPrimitiveInstanceIndex = eachEntityPrimitiveInstancesPortion [entityIndex];
        var lastEntityPrimitiveInstanceIndex = atLastEntity ? eachEntityPrimitiveInstancesPortion[lastEntityIndex] : eachEntityPrimitiveInstancesPortion[entityIndex + 1];

        for (var primitiveInstancesIndex = firstEntityPrimitiveInstanceIndex; primitiveInstancesIndex < lastEntityPrimitiveInstanceIndex; primitiveInstancesIndex++) {

            var primitiveIndex$2 = primitiveInstances[primitiveInstancesIndex];
            var primitiveInstanceCount = primitiveInstanceCounts[primitiveIndex$2];
            var isInstancedPrimitive = (primitiveInstanceCount > 1);

            if (!isInstancedPrimitive) {
                batchedPrimitiveEntityIndexes[primitiveIndex$2] = entityIndex;
            }
        }
    }

    // Create 1) geometries for instanced primitives, and 2) meshes for batched primitives.  We create all the
    // batched meshes now, before we create entities, because we're creating the batched meshes in runs that share
    // the same decode matrices. Each run of meshes with the same decode matrix will end up in the same
    // BatchingLayer; the PerformanceModel#createMesh() method starts a new BatchingLayer each time the decode
    // matrix has changed since the last invocation of that method, hence why we need to order batched meshes
    // in runs like this.

    for (var primitiveIndex$3 = 0; primitiveIndex$3 < numPrimitives; primitiveIndex$3++) {

        var orderedPrimitiveIndex = orderedPrimitiveIndexes[primitiveIndex$3];

        var atLastPrimitive = (orderedPrimitiveIndex === (numPrimitives - 1));

        var primitiveInstanceCount$1 = primitiveInstanceCounts[orderedPrimitiveIndex];
        var isInstancedPrimitive$1 = (primitiveInstanceCount$1 > 1);

        var color = decompressColor$5(eachPrimitiveColor.subarray((orderedPrimitiveIndex * 4), (orderedPrimitiveIndex * 4) + 3));
        var opacity = eachPrimitiveColor[(orderedPrimitiveIndex * 4) + 3] / 255.0;

        var primitivePositions = positions.subarray(eachPrimitivePositionsAndNormalsPortion [orderedPrimitiveIndex], atLastPrimitive ? positions.length : eachPrimitivePositionsAndNormalsPortion [orderedPrimitiveIndex + 1]);
        var primitiveNormals = normals.subarray(eachPrimitivePositionsAndNormalsPortion [orderedPrimitiveIndex], atLastPrimitive ? normals.length : eachPrimitivePositionsAndNormalsPortion [orderedPrimitiveIndex + 1]);
        var primitiveIndices = indices.subarray(eachPrimitiveIndicesPortion [orderedPrimitiveIndex], atLastPrimitive ? indices.length : eachPrimitiveIndicesPortion [orderedPrimitiveIndex + 1]);
        var primitiveEdgeIndices = edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion [orderedPrimitiveIndex], atLastPrimitive ? edgeIndices.length : eachPrimitiveEdgeIndicesPortion [orderedPrimitiveIndex + 1]);
        var primitiveDecodeMatrix = decodeMatrices.subarray(eachPrimitiveDecodeMatricesPortion [orderedPrimitiveIndex], eachPrimitiveDecodeMatricesPortion [orderedPrimitiveIndex] + 16);

        if (isInstancedPrimitive$1) {

            // Primitive instanced by more than one entity, and has positions in Model-space

            var geometryId = "geometry" + orderedPrimitiveIndex; // These IDs are local to the PerformanceModel

            performanceModel.createGeometry({
                id: geometryId,
                primitive: "triangles",
                positions: primitivePositions,
                normals: primitiveNormals,
                indices: primitiveIndices,
                edgeIndices: primitiveEdgeIndices,
                positionsDecodeMatrix: primitiveDecodeMatrix
            });

        } else {

            // Primitive is used only by one entity, and has positions pre-transformed into World-space

            var meshId = orderedPrimitiveIndex; // These IDs are local to the PerformanceModel

            var entityIndex$1 = batchedPrimitiveEntityIndexes[orderedPrimitiveIndex];
            eachEntityId[entityIndex$1];

            var meshDefaults = {}; // TODO: get from lookup from entity IDs

            performanceModel.createMesh(utils.apply(meshDefaults, {
                id: meshId,
                primitive: "triangles",
                positions: primitivePositions,
                normals: primitiveNormals,
                indices: primitiveIndices,
                edgeIndices: primitiveEdgeIndices,
                positionsDecodeMatrix: primitiveDecodeMatrix,
                color: color,
                opacity: opacity
            }));
        }
    }

    var countInstances = 0;

    for (var entityIndex$2 = 0; entityIndex$2 < numEntities; entityIndex$2++) {

        var lastEntityIndex$1 = (numEntities - 1);
        var atLastEntity$1 = (entityIndex$2 === lastEntityIndex$1);
        var entityId$1 = eachEntityId[entityIndex$2];
        var firstEntityPrimitiveInstanceIndex$1 = eachEntityPrimitiveInstancesPortion [entityIndex$2];
        var lastEntityPrimitiveInstanceIndex$1 = atLastEntity$1 ? eachEntityPrimitiveInstancesPortion[lastEntityIndex$1] : eachEntityPrimitiveInstancesPortion[entityIndex$2 + 1];

        var meshIds = [];

        for (var primitiveInstancesIndex$1 = firstEntityPrimitiveInstanceIndex$1; primitiveInstancesIndex$1 < lastEntityPrimitiveInstanceIndex$1; primitiveInstancesIndex$1++) {

            var primitiveIndex$4 = primitiveInstances[primitiveInstancesIndex$1];
            var primitiveInstanceCount$2 = primitiveInstanceCounts[primitiveIndex$4];
            var isInstancedPrimitive$2 = (primitiveInstanceCount$2 > 1);

            if (isInstancedPrimitive$2) {

                var meshDefaults$1 = {}; // TODO: get from lookup from entity IDs

                var meshId$1 = "instance." + countInstances++;
                var geometryId$1 = "geometry" + primitiveIndex$4;
                var matricesIndex = (eachEntityMatricesPortion [entityIndex$2]) * 16;
                var matrix = matrices.subarray(matricesIndex, matricesIndex + 16);

                performanceModel.createMesh(utils.apply(meshDefaults$1, {
                    id: meshId$1,
                    geometryId: geometryId$1,
                    matrix: matrix
                }));

                meshIds.push(meshId$1);

            } else {
                meshIds.push(primitiveIndex$4);
            }
        }

        if (meshIds.length > 0) {

            var entityDefaults = {}; // TODO: get from lookup from entity IDs

            performanceModel.createEntity(utils.apply(entityDefaults, {
                id: entityId$1,
                isObject: true, ///////////////// TODO: If metaobject exists
                meshIds: meshIds
            }));
        }
    }
}

/** @private */
var ParserV4 = {
    version: 4,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$5(elements);
        var inflatedData = inflate$5(deflatedData);
        load$5(viewer, options, inflatedData, performanceModel);
    }
};

/*

 Parser for .XKT Format V5

.XKT specifications: https://github.com/xeokit/xeokit-sdk/wiki/XKT-Format

 */

var pako$4 = window.pako || p;
if (!pako$4.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$4 = pako$4.default;
}

function extract$4(elements) {
    return {
        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],
        matrices: elements[4],
        eachPrimitivePositionsAndNormalsPortion: elements[5],
        eachPrimitiveIndicesPortion: elements[6],
        eachPrimitiveEdgeIndicesPortion: elements[7],
        eachPrimitiveColor: elements[8],
        primitiveInstances: elements[9],
        eachEntityId: elements[10],
        eachEntityPrimitiveInstancesPortion: elements[11],
        eachEntityMatricesPortion: elements[12]
    };
}

function inflate$4(deflatedData) {
    return {
        positions: new Float32Array(pako$4.inflate(deflatedData.positions).buffer),
        normals: new Int8Array(pako$4.inflate(deflatedData.normals).buffer),
        indices: new Uint32Array(pako$4.inflate(deflatedData.indices).buffer),
        edgeIndices: new Uint32Array(pako$4.inflate(deflatedData.edgeIndices).buffer),
        matrices: new Float32Array(pako$4.inflate(deflatedData.matrices).buffer),
        eachPrimitivePositionsAndNormalsPortion: new Uint32Array(pako$4.inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion).buffer),
        eachPrimitiveIndicesPortion: new Uint32Array(pako$4.inflate(deflatedData.eachPrimitiveIndicesPortion).buffer),
        eachPrimitiveEdgeIndicesPortion: new Uint32Array(pako$4.inflate(deflatedData.eachPrimitiveEdgeIndicesPortion).buffer),
        eachPrimitiveColor: new Uint8Array(pako$4.inflate(deflatedData.eachPrimitiveColor).buffer),
        primitiveInstances: new Uint32Array(pako$4.inflate(deflatedData.primitiveInstances).buffer),
        eachEntityId: pako$4.inflate(deflatedData.eachEntityId, {to: 'string'}),
        eachEntityPrimitiveInstancesPortion: new Uint32Array(pako$4.inflate(deflatedData.eachEntityPrimitiveInstancesPortion).buffer),
        eachEntityMatricesPortion: new Uint32Array(pako$4.inflate(deflatedData.eachEntityMatricesPortion).buffer)
    };
}

var decompressColor$4 = (function () {
    var color2 = new Float32Array(3);
    return function (color) {
        color2[0] = color[0] / 255.0;
        color2[1] = color[1] / 255.0;
        color2[2] = color[2] / 255.0;
        return color2;
    };
})();

function load$4(viewer, options, inflatedData, performanceModel) {

    performanceModel.positionsCompression = "disabled"; // Positions in XKT V4 are floats, which we never quantize, for precision with big models
    performanceModel.normalsCompression = "precompressed"; // Normals are oct-encoded though

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;
    var matrices = inflatedData.matrices;

    var eachPrimitivePositionsAndNormalsPortion = inflatedData.eachPrimitivePositionsAndNormalsPortion;
    var eachPrimitiveIndicesPortion = inflatedData.eachPrimitiveIndicesPortion;
    var eachPrimitiveEdgeIndicesPortion = inflatedData.eachPrimitiveEdgeIndicesPortion;
    var eachPrimitiveColor = inflatedData.eachPrimitiveColor;

    var primitiveInstances = inflatedData.primitiveInstances;

    var eachEntityId = JSON.parse(inflatedData.eachEntityId);
    var eachEntityPrimitiveInstancesPortion = inflatedData.eachEntityPrimitiveInstancesPortion;
    var eachEntityMatricesPortion = inflatedData.eachEntityMatricesPortion;

    var numPrimitives = eachPrimitivePositionsAndNormalsPortion.length;
    var numPrimitiveInstances = primitiveInstances.length;
    var primitiveInstanceCounts = new Uint8Array(numPrimitives); // For each mesh, how many times it is instanced

    var numEntities = eachEntityId.length;

    // Count instances of each primitive

    for (var primitiveInstanceIndex = 0; primitiveInstanceIndex < numPrimitiveInstances; primitiveInstanceIndex++) {
        var primitiveIndex = primitiveInstances[primitiveInstanceIndex];
        primitiveInstanceCounts[primitiveIndex]++;
    }

    // Map batched primitives to the entities that will use them

    var batchedPrimitiveEntityIndexes = {};

    for (var entityIndex = 0; entityIndex < numEntities; entityIndex++) {

        var lastEntityIndex = (numEntities - 1);
        var atLastEntity = (entityIndex === lastEntityIndex);
        var firstEntityPrimitiveInstanceIndex = eachEntityPrimitiveInstancesPortion [entityIndex];
        var lastEntityPrimitiveInstanceIndex = atLastEntity ? eachEntityPrimitiveInstancesPortion[lastEntityIndex] : eachEntityPrimitiveInstancesPortion[entityIndex + 1];

        for (var primitiveInstancesIndex = firstEntityPrimitiveInstanceIndex; primitiveInstancesIndex < lastEntityPrimitiveInstanceIndex; primitiveInstancesIndex++) {

            var primitiveIndex$1 = primitiveInstances[primitiveInstancesIndex];
            var primitiveInstanceCount = primitiveInstanceCounts[primitiveIndex$1];
            var isInstancedPrimitive = (primitiveInstanceCount > 1);

            if (!isInstancedPrimitive) {
                batchedPrimitiveEntityIndexes[primitiveIndex$1] = entityIndex;
            }
        }
    }

    // Create geometries for instanced primitives and meshes for batched primitives.

    for (var primitiveIndex$2 = 0; primitiveIndex$2 < numPrimitives; primitiveIndex$2++) {

        var atLastPrimitive = (primitiveIndex$2 === (numPrimitives - 1));

        var primitiveInstanceCount$1 = primitiveInstanceCounts[primitiveIndex$2];
        var isInstancedPrimitive$1 = (primitiveInstanceCount$1 > 1);

        var color = decompressColor$4(eachPrimitiveColor.subarray((primitiveIndex$2 * 4), (primitiveIndex$2 * 4) + 3));
        var opacity = eachPrimitiveColor[(primitiveIndex$2 * 4) + 3] / 255.0;

        var primitivePositions = positions.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex$2], atLastPrimitive ? positions.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex$2 + 1]);
        var primitiveNormals = normals.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex$2], atLastPrimitive ? normals.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex$2 + 1]);
        var primitiveIndices = indices.subarray(eachPrimitiveIndicesPortion [primitiveIndex$2], atLastPrimitive ? indices.length : eachPrimitiveIndicesPortion [primitiveIndex$2 + 1]);
        var primitiveEdgeIndices = edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion [primitiveIndex$2], atLastPrimitive ? edgeIndices.length : eachPrimitiveEdgeIndicesPortion [primitiveIndex$2 + 1]);

        if (isInstancedPrimitive$1) {

            // Primitive instanced by more than one entity, and has positions in Model-space

            var geometryId = "geometry" + primitiveIndex$2; // These IDs are local to the PerformanceModel

            performanceModel.createGeometry({
                id: geometryId,
                primitive: "triangles",
                positions: primitivePositions,
                normals: primitiveNormals,
                indices: primitiveIndices,
                edgeIndices: primitiveEdgeIndices
            });

        } else {

            // Primitive is used only by one entity, and has positions pre-transformed into World-space

            var meshId = primitiveIndex$2; // These IDs are local to the PerformanceModel

            var entityIndex$1 = batchedPrimitiveEntityIndexes[primitiveIndex$2];
            eachEntityId[entityIndex$1];

            var meshDefaults = {}; // TODO: get from lookup from entity IDs

            performanceModel.createMesh(utils.apply(meshDefaults, {
                id: meshId,
                primitive: "triangles",
                positions: primitivePositions,
                normals: primitiveNormals,
                indices: primitiveIndices,
                edgeIndices: primitiveEdgeIndices,
                color: color,
                opacity: opacity
            }));
        }
    }

    var countInstances = 0;

    for (var entityIndex$2 = 0; entityIndex$2 < numEntities; entityIndex$2++) {

        var lastEntityIndex$1 = (numEntities - 1);
        var atLastEntity$1 = (entityIndex$2 === lastEntityIndex$1);
        var entityId$1 = eachEntityId[entityIndex$2];
        var firstEntityPrimitiveInstanceIndex$1 = eachEntityPrimitiveInstancesPortion [entityIndex$2];
        var lastEntityPrimitiveInstanceIndex$1 = atLastEntity$1 ? eachEntityPrimitiveInstancesPortion[lastEntityIndex$1] : eachEntityPrimitiveInstancesPortion[entityIndex$2 + 1];

        var meshIds = [];

        for (var primitiveInstancesIndex$1 = firstEntityPrimitiveInstanceIndex$1; primitiveInstancesIndex$1 < lastEntityPrimitiveInstanceIndex$1; primitiveInstancesIndex$1++) {

            var primitiveIndex$3 = primitiveInstances[primitiveInstancesIndex$1];
            var primitiveInstanceCount$2 = primitiveInstanceCounts[primitiveIndex$3];
            var isInstancedPrimitive$2 = (primitiveInstanceCount$2 > 1);

            if (isInstancedPrimitive$2) {

                var meshDefaults$1 = {}; // TODO: get from lookup from entity IDs

                var meshId$1 = "instance." + countInstances++;
                var geometryId$1 = "geometry" + primitiveIndex$3;
                var matricesIndex = (eachEntityMatricesPortion [entityIndex$2]) * 16;
                var matrix = matrices.subarray(matricesIndex, matricesIndex + 16);

                performanceModel.createMesh(utils.apply(meshDefaults$1, {
                    id: meshId$1,
                    geometryId: geometryId$1,
                    matrix: matrix
                }));

                meshIds.push(meshId$1);

            } else {
                meshIds.push(primitiveIndex$3);
            }
        }

        if (meshIds.length > 0) {

            var entityDefaults = {}; // TODO: get from lookup from entity IDs

            performanceModel.createEntity(utils.apply(entityDefaults, {
                id: entityId$1,
                isObject: true, ///////////////// TODO: If metaobject exists
                meshIds: meshIds
            }));
        }
    }
}

/** @private */
var ParserV5 = {
    version: 5,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$4(elements);
        var inflatedData = inflate$4(deflatedData);
        load$4(viewer, options, inflatedData, performanceModel);
    }
};

/*

 Parser for .XKT Format V6

 */

var pako$3 = window.pako || p;
if (!pako$3.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$3 = pako$3.default;
}

function extract$3(elements) {

    return {
        positions: elements[0],
        normals: elements[1],
        indices: elements[2],
        edgeIndices: elements[3],
        matrices: elements[4],
        reusedPrimitivesDecodeMatrix: elements[5],
        eachPrimitivePositionsAndNormalsPortion: elements[6],
        eachPrimitiveIndicesPortion: elements[7],
        eachPrimitiveEdgeIndicesPortion: elements[8],
        eachPrimitiveColorAndOpacity: elements[9],
        primitiveInstances: elements[10],
        eachEntityId: elements[11],
        eachEntityPrimitiveInstancesPortion: elements[12],
        eachEntityMatricesPortion: elements[13],
        eachTileAABB: elements[14],
        eachTileEntitiesPortion: elements[15]
    };
}

function inflate$3(deflatedData) {

    function inflate(array, options) {
        return (array.length === 0) ? [] : pako$3.inflate(array, options).buffer;
    }

    return {
        positions: new Uint16Array(inflate(deflatedData.positions)),
        normals: new Int8Array(inflate(deflatedData.normals)),
        indices: new Uint32Array(inflate(deflatedData.indices)),
        edgeIndices: new Uint32Array(inflate(deflatedData.edgeIndices)),
        matrices: new Float32Array(inflate(deflatedData.matrices)),
        reusedPrimitivesDecodeMatrix: new Float32Array(inflate(deflatedData.reusedPrimitivesDecodeMatrix)),
        eachPrimitivePositionsAndNormalsPortion: new Uint32Array(inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion)),
        eachPrimitiveIndicesPortion: new Uint32Array(inflate(deflatedData.eachPrimitiveIndicesPortion)),
        eachPrimitiveEdgeIndicesPortion: new Uint32Array(inflate(deflatedData.eachPrimitiveEdgeIndicesPortion)),
        eachPrimitiveColorAndOpacity: new Uint8Array(inflate(deflatedData.eachPrimitiveColorAndOpacity)),
        primitiveInstances: new Uint32Array(inflate(deflatedData.primitiveInstances)),
        eachEntityId: pako$3.inflate(deflatedData.eachEntityId, {to: 'string'}),
        eachEntityPrimitiveInstancesPortion: new Uint32Array(inflate(deflatedData.eachEntityPrimitiveInstancesPortion)),
        eachEntityMatricesPortion: new Uint32Array(inflate(deflatedData.eachEntityMatricesPortion)),
        eachTileAABB: new Float64Array(inflate(deflatedData.eachTileAABB)),
        eachTileEntitiesPortion: new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion))
    };
}

var decompressColor$3 = (function () {
    var floatColor = new Float32Array(3);
    return function (intColor) {
        floatColor[0] = intColor[0] / 255.0;
        floatColor[1] = intColor[1] / 255.0;
        floatColor[2] = intColor[2] / 255.0;
        return floatColor;
    };
})();

function load$3(viewer, options, inflatedData, performanceModel) {

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;

    var matrices = inflatedData.matrices;

    var reusedPrimitivesDecodeMatrix = inflatedData.reusedPrimitivesDecodeMatrix;

    var eachPrimitivePositionsAndNormalsPortion = inflatedData.eachPrimitivePositionsAndNormalsPortion;
    var eachPrimitiveIndicesPortion = inflatedData.eachPrimitiveIndicesPortion;
    var eachPrimitiveEdgeIndicesPortion = inflatedData.eachPrimitiveEdgeIndicesPortion;
    var eachPrimitiveColorAndOpacity = inflatedData.eachPrimitiveColorAndOpacity;

    var primitiveInstances = inflatedData.primitiveInstances;

    var eachEntityId = JSON.parse(inflatedData.eachEntityId);
    var eachEntityPrimitiveInstancesPortion = inflatedData.eachEntityPrimitiveInstancesPortion;
    var eachEntityMatricesPortion = inflatedData.eachEntityMatricesPortion;

    var eachTileAABB = inflatedData.eachTileAABB;
    var eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;

    var numPrimitives = eachPrimitivePositionsAndNormalsPortion.length;
    var numPrimitiveInstances = primitiveInstances.length;
    var numEntities = eachEntityId.length;
    var numTiles = eachTileEntitiesPortion.length;

    var nextMeshId = 0;

    // Count instances of each primitive

    var primitiveReuseCounts = new Uint32Array(numPrimitives);

    for (var primitiveInstanceIndex = 0; primitiveInstanceIndex < numPrimitiveInstances; primitiveInstanceIndex++) {
        var primitiveIndex = primitiveInstances[primitiveInstanceIndex];
        if (primitiveReuseCounts[primitiveIndex] !== undefined) {
            primitiveReuseCounts[primitiveIndex]++;
        } else {
            primitiveReuseCounts[primitiveIndex] = 1;
        }
    }

    // Iterate over tiles

    var tileCenter = math.vec3();
    var rtcAABB = math.AABB3();

    for (var tileIndex = 0; tileIndex < numTiles; tileIndex++) {

        var lastTileIndex = (numTiles - 1);

        var atLastTile = (tileIndex === lastTileIndex);

        var firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];
        var lastTileEntityIndex = atLastTile ? numEntities : eachTileEntitiesPortion[tileIndex + 1];

        var tileAABBIndex = tileIndex * 6;
        var tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);

        math.getAABB3Center(tileAABB, tileCenter);

        rtcAABB[0] = tileAABB[0] - tileCenter[0];
        rtcAABB[1] = tileAABB[1] - tileCenter[1];
        rtcAABB[2] = tileAABB[2] - tileCenter[2];
        rtcAABB[3] = tileAABB[3] - tileCenter[0];
        rtcAABB[4] = tileAABB[4] - tileCenter[1];
        rtcAABB[5] = tileAABB[5] - tileCenter[2];

        var tileDecodeMatrix = geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);

        var geometryCreated = {};

        // Iterate over each tile's entities

        for (var tileEntityIndex = firstTileEntityIndex; tileEntityIndex < lastTileEntityIndex; tileEntityIndex++) {

            var xktEntityId = eachEntityId[tileEntityIndex];
            var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;

            var entityMatrixIndex = eachEntityMatricesPortion[tileEntityIndex];
            var entityMatrix = matrices.slice(entityMatrixIndex, entityMatrixIndex + 16);

            var lastTileEntityIndex$1 = (numEntities - 1);
            var atLastTileEntity = (tileEntityIndex === lastTileEntityIndex$1);
            var firstPrimitiveInstanceIndex = eachEntityPrimitiveInstancesPortion [tileEntityIndex];
            var lastPrimitiveInstanceIndex = atLastTileEntity ? primitiveInstances.length : eachEntityPrimitiveInstancesPortion[tileEntityIndex + 1];

            var meshIds = [];

            var metaObject = viewer.metaScene.metaObjects[entityId];
            var entityDefaults = {};
            var meshDefaults = {};

            if (metaObject) {

                // Mask loading of object types

                if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                    continue;
                }

                if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                    continue;
                }

                // Get initial property values for object types

                var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

                if (props) {
                    if (props.visible === false) {
                        entityDefaults.visible = false;
                    }
                    if (props.pickable === false) {
                        entityDefaults.pickable = false;
                    }
                    if (props.colorize) {
                        meshDefaults.color = props.colorize;
                    }
                    if (props.opacity !== undefined && props.opacity !== null) {
                        meshDefaults.opacity = props.opacity;
                    }
                }

            } else {
                if (options.excludeUnclassifiedObjects) {
                    continue;
                }
            }

            // Iterate each entity's primitive instances

            for (var primitiveInstancesIndex = firstPrimitiveInstanceIndex; primitiveInstancesIndex < lastPrimitiveInstanceIndex; primitiveInstancesIndex++) {

                var primitiveIndex$1 = primitiveInstances[primitiveInstancesIndex];
                var primitiveReuseCount = primitiveReuseCounts[primitiveIndex$1];
                var isReusedPrimitive = (primitiveReuseCount > 1);

                var atLastPrimitive = (primitiveIndex$1 === (numPrimitives - 1));

                var primitivePositions = positions.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex$1], atLastPrimitive ? positions.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex$1 + 1]);
                var primitiveNormals = normals.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex$1], atLastPrimitive ? normals.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex$1 + 1]);
                var primitiveIndices = indices.subarray(eachPrimitiveIndicesPortion [primitiveIndex$1], atLastPrimitive ? indices.length : eachPrimitiveIndicesPortion [primitiveIndex$1 + 1]);
                var primitiveEdgeIndices = edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion [primitiveIndex$1], atLastPrimitive ? edgeIndices.length : eachPrimitiveEdgeIndicesPortion [primitiveIndex$1 + 1]);

                var color = decompressColor$3(eachPrimitiveColorAndOpacity.subarray((primitiveIndex$1 * 4), (primitiveIndex$1 * 4) + 3));
                var opacity = eachPrimitiveColorAndOpacity[(primitiveIndex$1 * 4) + 3] / 255.0;

                var meshId = nextMeshId++;

                if (isReusedPrimitive) {

                    // Create mesh for multi-use primitive - create (or reuse) geometry, create mesh using that geometry

                    var geometryId = "geometry." + tileIndex + "." + primitiveIndex$1; // These IDs are local to the PerformanceModel

                    if (!geometryCreated[geometryId]) {

                        performanceModel.createGeometry({
                            id: geometryId,
                            rtcCenter: tileCenter,
                            primitive: "triangles",
                            positions: primitivePositions,
                            normals: primitiveNormals,
                            indices: primitiveIndices,
                            edgeIndices: primitiveEdgeIndices,
                            positionsDecodeMatrix: reusedPrimitivesDecodeMatrix
                        });

                        geometryCreated[geometryId] = true;
                    }

                    performanceModel.createMesh(utils.apply(meshDefaults, {
                        id: meshId,
                        geometryId: geometryId,
                        matrix: entityMatrix,
                        color: color,
                        opacity: opacity
                    }));

                    meshIds.push(meshId);

                } else {

                    performanceModel.createMesh(utils.apply(meshDefaults, {
                        id: meshId,
                        rtcCenter: tileCenter,
                        primitive: "triangles",
                        positions: primitivePositions,
                        normals: primitiveNormals,
                        indices: primitiveIndices,
                        edgeIndices: primitiveEdgeIndices,
                        positionsDecodeMatrix: tileDecodeMatrix,
                        color: color,
                        opacity: opacity
                    }));

                    meshIds.push(meshId);
                }
            }

            if (meshIds.length > 0) {

                performanceModel.createEntity(utils.apply(entityDefaults, {
                    id: entityId,
                    isObject: true,
                    meshIds: meshIds
                }));
            }
        }
    }
}

/** @private */
var ParserV6 = {
    version: 6,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$3(elements);
        var inflatedData = inflate$3(deflatedData);
        load$3(viewer, options, inflatedData, performanceModel);
    }
};

/*

 Parser for .XKT Format V7

 */

var pako$2 = window.pako || p;
if (!pako$2.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$2 = pako$2.default;
}

function extract$2(elements) {

    return {

        // Vertex attributes

        positions: elements[0],
        normals: elements[1],
        colors: elements[2],

        // Indices

        indices: elements[3],
        edgeIndices: elements[4],

        // Transform matrices

        matrices: elements[5],

        reusedGeometriesDecodeMatrix: elements[6],

        // Geometries

        eachGeometryPrimitiveType: elements[7],
        eachGeometryPositionsPortion: elements[8],
        eachGeometryNormalsPortion: elements[9],
        eachGeometryColorsPortion: elements[10],
        eachGeometryIndicesPortion: elements[11],
        eachGeometryEdgeIndicesPortion: elements[12],

        // Meshes are grouped in runs that are shared by the same entities

        eachMeshGeometriesPortion: elements[13],
        eachMeshMatricesPortion: elements[14],
        eachMeshMaterial: elements[15],

        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles

        eachEntityId: elements[16],
        eachEntityMeshesPortion: elements[17],

        eachTileAABB: elements[18],
        eachTileEntitiesPortion: elements[19]
    };
}

function inflate$2(deflatedData) {

    function inflate(array, options) {
        return (array.length === 0) ? [] : pako$2.inflate(array, options).buffer;
    }

    return {
        positions: new Uint16Array(inflate(deflatedData.positions)),
        normals: new Int8Array(inflate(deflatedData.normals)),
        colors: new Uint8Array(inflate(deflatedData.colors)),

        indices: new Uint32Array(inflate(deflatedData.indices)),
        edgeIndices: new Uint32Array(inflate(deflatedData.edgeIndices)),

        matrices: new Float32Array(inflate(deflatedData.matrices)),

        reusedGeometriesDecodeMatrix: new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),

        eachGeometryPrimitiveType: new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),
        eachGeometryPositionsPortion: new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),
        eachGeometryNormalsPortion: new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),
        eachGeometryColorsPortion: new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),
        eachGeometryIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),
        eachGeometryEdgeIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),

        eachMeshGeometriesPortion: new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),
        eachMeshMatricesPortion: new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),
        eachMeshMaterial: new Uint8Array(inflate(deflatedData.eachMeshMaterial)),

        eachEntityId: pako$2.inflate(deflatedData.eachEntityId, {to: 'string'}),
        eachEntityMeshesPortion: new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),

        eachTileAABB: new Float64Array(inflate(deflatedData.eachTileAABB)),
        eachTileEntitiesPortion: new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion)),
    };
}

var decompressColor$2 = (function () {
    var floatColor = new Float32Array(3);
    return function (intColor) {
        floatColor[0] = intColor[0] / 255.0;
        floatColor[1] = intColor[1] / 255.0;
        floatColor[2] = intColor[2] / 255.0;
        return floatColor;
    };
})();

function convertColorsRGBToRGBA$1(colorsRGB) {
    var colorsRGBA = [];
    for (var i = 0, len = colorsRGB.length; i < len; i+=3) {
        colorsRGBA.push(colorsRGB[i]);
        colorsRGBA.push(colorsRGB[i+1]);
        colorsRGBA.push(colorsRGB[i+2]);
        colorsRGBA.push(1.0);
    }
    return colorsRGBA;
}

function load$2(viewer, options, inflatedData, performanceModel) {

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var colors = inflatedData.colors;

    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;

    var matrices = inflatedData.matrices;

    var reusedGeometriesDecodeMatrix = inflatedData.reusedGeometriesDecodeMatrix;

    var eachGeometryPrimitiveType = inflatedData.eachGeometryPrimitiveType;
    var eachGeometryPositionsPortion = inflatedData.eachGeometryPositionsPortion;
    var eachGeometryNormalsPortion = inflatedData.eachGeometryNormalsPortion;
    var eachGeometryColorsPortion = inflatedData.eachGeometryColorsPortion;
    var eachGeometryIndicesPortion = inflatedData.eachGeometryIndicesPortion;
    var eachGeometryEdgeIndicesPortion = inflatedData.eachGeometryEdgeIndicesPortion;

    var eachMeshGeometriesPortion = inflatedData.eachMeshGeometriesPortion;
    var eachMeshMatricesPortion = inflatedData.eachMeshMatricesPortion;
    var eachMeshMaterial = inflatedData.eachMeshMaterial;

    var eachEntityId = JSON.parse(inflatedData.eachEntityId);
    var eachEntityMeshesPortion = inflatedData.eachEntityMeshesPortion;

    var eachTileAABB = inflatedData.eachTileAABB;
    var eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;

    var numGeometries = eachGeometryPositionsPortion.length;
    var numMeshes = eachMeshGeometriesPortion.length;
    var numEntities = eachEntityId.length;
    var numTiles = eachTileEntitiesPortion.length;

    var nextMeshId = 0;

    // Count instances of each geometry

    var geometryReuseCounts = new Uint32Array(numGeometries);

    for (var meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
        var geometryIndex = eachMeshGeometriesPortion[meshIndex];
        if (geometryReuseCounts[geometryIndex] !== undefined) {
            geometryReuseCounts[geometryIndex]++;
        } else {
            geometryReuseCounts[geometryIndex] = 1;
        }
    }

    // Iterate over tiles

    var tileCenter = math.vec3();
    var rtcAABB = math.AABB3();

    for (var tileIndex = 0; tileIndex < numTiles; tileIndex++) {

        var lastTileIndex = (numTiles - 1);

        var atLastTile = (tileIndex === lastTileIndex);

        var firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];
        var lastTileEntityIndex = atLastTile ? numEntities : eachTileEntitiesPortion[tileIndex + 1];

        var tileAABBIndex = tileIndex * 6;
        var tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);

        math.getAABB3Center(tileAABB, tileCenter);

        rtcAABB[0] = tileAABB[0] - tileCenter[0];
        rtcAABB[1] = tileAABB[1] - tileCenter[1];
        rtcAABB[2] = tileAABB[2] - tileCenter[2];
        rtcAABB[3] = tileAABB[3] - tileCenter[0];
        rtcAABB[4] = tileAABB[4] - tileCenter[1];
        rtcAABB[5] = tileAABB[5] - tileCenter[2];

        var tileDecodeMatrix = geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);

        var geometryCreated = {};

        // Iterate over each tile's entities

        for (var tileEntityIndex = firstTileEntityIndex; tileEntityIndex < lastTileEntityIndex; tileEntityIndex++) {

            var xktEntityId = eachEntityId[tileEntityIndex];
            var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;

            var lastTileEntityIndex$1 = (numEntities - 1);
            var atLastTileEntity = (tileEntityIndex === lastTileEntityIndex$1);
            var firstMeshIndex = eachEntityMeshesPortion [tileEntityIndex];
            var lastMeshIndex = atLastTileEntity ? eachMeshGeometriesPortion.length : eachEntityMeshesPortion[tileEntityIndex + 1];

            var meshIds = [];

            var metaObject = viewer.metaScene.metaObjects[entityId];
            var entityDefaults = {};
            var meshDefaults = {};

            if (metaObject) {

                // Mask loading of object types

                if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                    continue;
                }

                if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                    continue;
                }

                // Get initial property values for object types

                var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

                if (props) {
                    if (props.visible === false) {
                        entityDefaults.visible = false;
                    }
                    if (props.pickable === false) {
                        entityDefaults.pickable = false;
                    }
                    if (props.colorize) {
                        meshDefaults.color = props.colorize;
                    }
                    if (props.opacity !== undefined && props.opacity !== null) {
                        meshDefaults.opacity = props.opacity;
                    }
                    if (props.metallic !== undefined && props.metallic !== null) {
                        meshDefaults.metallic = props.metallic;
                    }
                    if (props.roughness !== undefined && props.roughness !== null) {
                        meshDefaults.roughness = props.roughness;
                    }
                }

            } else {
                if (options.excludeUnclassifiedObjects) {
                    continue;
                }
            }

            // Iterate each entity's meshes

            for (var meshIndex$1 = firstMeshIndex; meshIndex$1 < lastMeshIndex; meshIndex$1++) {

                var geometryIndex$1 = eachMeshGeometriesPortion[meshIndex$1];
                var geometryReuseCount = geometryReuseCounts[geometryIndex$1];
                var isReusedGeometry = (geometryReuseCount > 1);

                var atLastGeometry = (geometryIndex$1 === (numGeometries - 1));

                var meshColor = decompressColor$2(eachMeshMaterial.subarray((meshIndex$1 * 6), (meshIndex$1 * 6) + 3));
                var meshOpacity = eachMeshMaterial[(meshIndex$1 * 6) + 3] / 255.0;
                var meshMetallic = eachMeshMaterial[(meshIndex$1 * 6) + 4] / 255.0;
                var meshRoughness = eachMeshMaterial[(meshIndex$1 * 6) + 5] / 255.0;

                var meshId = nextMeshId++;

                if (isReusedGeometry) {

                    // Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry

                    var meshMatrixIndex = eachMeshMatricesPortion[meshIndex$1];
                    var meshMatrix = matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);

                    var geometryId = "geometry." + tileIndex + "." + geometryIndex$1; // These IDs are local to the PerformanceModel

                    if (!geometryCreated[geometryId]) {

                        var primitiveType = eachGeometryPrimitiveType[geometryIndex$1];

                        var primitiveName = (void 0);
                        var geometryPositions = (void 0);
                        var geometryNormals = (void 0);
                        var geometryColors = (void 0);
                        var geometryIndices = (void 0);
                        var geometryEdgeIndices = (void 0);

                        switch (primitiveType) {
                            case 0:
                                primitiveName = "solid";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                break;
                            case 1:
                                primitiveName = "surface";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                break;
                            case 2:
                                primitiveName = "points";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryColors = convertColorsRGBToRGBA$1(colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]));
                                break;
                            case 3:
                                primitiveName = "lines";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                break;
                            default:
                                continue;
                        }

                        performanceModel.createGeometry({
                            id: geometryId,
                            rtcCenter: tileCenter,
                            primitive: primitiveName,
                            positions: geometryPositions,
                            normals: geometryNormals,
                            colors: geometryColors,
                            indices: geometryIndices,
                            edgeIndices: geometryEdgeIndices,
                            positionsDecodeMatrix: reusedGeometriesDecodeMatrix
                        });

                        geometryCreated[geometryId] = true;
                    }

                    performanceModel.createMesh(utils.apply(meshDefaults, {
                        id: meshId,
                        geometryId: geometryId,
                        matrix: meshMatrix,
                        color: meshColor,
                        metallic: meshMetallic,
                        roughness: meshRoughness,
                        opacity: meshOpacity
                    }));

                    meshIds.push(meshId);

                } else {

                    var primitiveType$1 = eachGeometryPrimitiveType[geometryIndex$1];

                    var primitiveName$1 = (void 0);
                    var geometryPositions$1 = (void 0);
                    var geometryNormals$1 = (void 0);
                    var geometryColors$1 = (void 0);
                    var geometryIndices$1 = (void 0);
                    var geometryEdgeIndices$1 = (void 0);

                    switch (primitiveType$1) {
                        case 0:
                            primitiveName$1 = "solid";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            break;
                        case 1:
                            primitiveName$1 = "surface";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            break;
                        case 2:
                            primitiveName$1 = "points";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryColors$1 = convertColorsRGBToRGBA$1(colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]));
                            break;
                        case 3:
                            primitiveName$1 = "lines";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            break;
                        default:
                            continue;
                    }

                    performanceModel.createMesh(utils.apply(meshDefaults, {
                        id: meshId,
                        rtcCenter: tileCenter,
                        primitive: primitiveName$1,
                        positions: geometryPositions$1,
                        normals: geometryNormals$1,
                        colors: geometryColors$1,
                        indices: geometryIndices$1,
                        edgeIndices: geometryEdgeIndices$1,
                        positionsDecodeMatrix: tileDecodeMatrix,
                        color: meshColor,
                        metallic: meshMetallic,
                        roughness: meshRoughness,
                        opacity: meshOpacity
                    }));

                    meshIds.push(meshId);
                }
            }

            if (meshIds.length > 0) {

                performanceModel.createEntity(utils.apply(entityDefaults, {
                    id: entityId,
                    isObject: true,
                    meshIds: meshIds
                }));
            }
        }
    }
}

/** @private */
var ParserV7 = {
    version: 7,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$2(elements);
        var inflatedData = inflate$2(deflatedData);
        load$2(viewer, options, inflatedData, performanceModel);
    }
};

/*

 Parser for .XKT Format V8

 */

var pako$1 = window.pako || p;
if (!pako$1.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako$1 = pako$1.default;
}

function extract$1(elements) {

    return {

        // Vertex attributes

        types: elements[0],
        eachMetaObjectId: elements[1],
        eachMetaObjectType: elements[2],
        eachMetaObjectName: elements[3],
        eachMetaObjectParent: elements[4],

        positions: elements[5],
        normals: elements[6],
        colors: elements[7],
        indices: elements[8],
        edgeIndices: elements[9],

        // Transform matrices

        matrices: elements[10],
        reusedGeometriesDecodeMatrix: elements[11],

        // Geometries

        eachGeometryPrimitiveType: elements[12],
        eachGeometryPositionsPortion: elements[13],
        eachGeometryNormalsPortion: elements[14],
        eachGeometryColorsPortion: elements[15],
        eachGeometryIndicesPortion: elements[16],
        eachGeometryEdgeIndicesPortion: elements[17],

        // Meshes are grouped in runs that are shared by the same entities

        eachMeshGeometriesPortion: elements[18],
        eachMeshMatricesPortion: elements[19],
        eachMeshMaterial: elements[20],

        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles

        eachEntityMetaObject: elements[21],
        eachEntityMeshesPortion: elements[22],

        eachTileAABB: elements[23],
        eachTileEntitiesPortion: elements[24]
    };
}

function inflate$1(deflatedData) {

    function inflate(array, options) {
        return (array.length === 0) ? [] : pako$1.inflate(array, options).buffer;
    }

    return {

        types: pako$1.inflate(deflatedData.types, {to: 'string'}),
        eachMetaObjectId: pako$1.inflate(deflatedData.eachMetaObjectId, {to: 'string'}),
        eachMetaObjectType: new Uint32Array(inflate(deflatedData.eachMetaObjectType)),
        eachMetaObjectName: pako$1.inflate(deflatedData.eachMetaObjectName, {to: 'string'}),
        eachMetaObjectParent: new Uint32Array(inflate(deflatedData.eachMetaObjectParent)),

        positions: new Uint16Array(inflate(deflatedData.positions)),
        normals: new Int8Array(inflate(deflatedData.normals)),
        colors: new Uint8Array(inflate(deflatedData.colors)),
        indices: new Uint32Array(inflate(deflatedData.indices)),
        edgeIndices: new Uint32Array(inflate(deflatedData.edgeIndices)),

        matrices: new Float32Array(inflate(deflatedData.matrices)),
        reusedGeometriesDecodeMatrix: new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),

        eachGeometryPrimitiveType: new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),
        eachGeometryPositionsPortion: new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),
        eachGeometryNormalsPortion: new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),
        eachGeometryColorsPortion: new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),
        eachGeometryIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),
        eachGeometryEdgeIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),

        eachMeshGeometriesPortion: new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),
        eachMeshMatricesPortion: new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),
        eachMeshMaterial: new Uint8Array(inflate(deflatedData.eachMeshMaterial)),

        eachEntityMetaObject: new Uint32Array(inflate(deflatedData.eachEntityMetaObject)),
        eachEntityMeshesPortion: new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),

        eachTileAABB: new Float64Array(inflate(deflatedData.eachTileAABB)),
        eachTileEntitiesPortion: new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion)),
    };
}

var decompressColor$1 = (function () {
    var floatColor = new Float32Array(3);
    return function (intColor) {
        floatColor[0] = intColor[0] / 255.0;
        floatColor[1] = intColor[1] / 255.0;
        floatColor[2] = intColor[2] / 255.0;
        return floatColor;
    };
})();

function convertColorsRGBToRGBA(colorsRGB) {
    var colorsRGBA = [];
    for (var i = 0, len = colorsRGB.length; i < len; i+=3) {
        colorsRGBA.push(colorsRGB[i]);
        colorsRGBA.push(colorsRGB[i+1]);
        colorsRGBA.push(colorsRGB[i+2]);
        colorsRGBA.push(1.0);
    }
    return colorsRGBA;
}

function load$1(viewer, options, inflatedData, performanceModel) {

    var types = JSON.parse(inflatedData.types);
    var eachMetaObjectId = JSON.parse(inflatedData.eachMetaObjectId);
    var eachMetaObjectType = inflatedData.eachMetaObjectType;
    var eachMetaObjectName = JSON.parse(inflatedData.eachMetaObjectName);
    var eachMetaObjectParent = inflatedData.eachMetaObjectParent;

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var colors = inflatedData.colors;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;

    var matrices = inflatedData.matrices;
    var reusedGeometriesDecodeMatrix = inflatedData.reusedGeometriesDecodeMatrix;

    var eachGeometryPrimitiveType = inflatedData.eachGeometryPrimitiveType;
    var eachGeometryPositionsPortion = inflatedData.eachGeometryPositionsPortion;
    var eachGeometryNormalsPortion = inflatedData.eachGeometryNormalsPortion;
    var eachGeometryColorsPortion = inflatedData.eachGeometryColorsPortion;
    var eachGeometryIndicesPortion = inflatedData.eachGeometryIndicesPortion;
    var eachGeometryEdgeIndicesPortion = inflatedData.eachGeometryEdgeIndicesPortion;

    var eachMeshGeometriesPortion = inflatedData.eachMeshGeometriesPortion;
    var eachMeshMatricesPortion = inflatedData.eachMeshMatricesPortion;
    var eachMeshMaterial = inflatedData.eachMeshMaterial;

    var eachEntityMetaObject = inflatedData.eachEntityMetaObject;
    var eachEntityMeshesPortion = inflatedData.eachEntityMeshesPortion;

    var eachTileAABB = inflatedData.eachTileAABB;
    var eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;

    var numMetaObjects = eachMetaObjectId.length;
    var numGeometries = eachGeometryPositionsPortion.length;
    var numMeshes = eachMeshGeometriesPortion.length;
    var numEntities = eachEntityMetaObject.length;
    var numTiles = eachTileEntitiesPortion.length;

    var nextMeshId = 0;

    // Create metamodel, unless already loaded from JSON by XKTLoaderPlugin

    var metaModelId = performanceModel.id;

    if (!viewer.metaScene.metaModels[metaModelId]) {

        var metaModelData = {
            metaObjects: []
        };

        for (var metaObjectIndex = 0; metaObjectIndex < numMetaObjects; metaObjectIndex++) {

            var metaObjectId = eachMetaObjectId[metaObjectIndex];
            var typeIndex = eachMetaObjectType[metaObjectIndex];
            var metaObjectType = types[typeIndex] || "default";
            var metaObjectName = eachMetaObjectName[metaObjectIndex];
            var metaObjectParentIndex = eachMetaObjectParent[metaObjectIndex];
            var metaObjectParentId = (metaObjectParentIndex !== metaObjectIndex) ? eachMetaObjectId[metaObjectParentIndex] : null;

            metaModelData.metaObjects.push({
                id: metaObjectId,
                type: metaObjectType,
                name: metaObjectName,
                parent: metaObjectParentId
            });
        }

        viewer.metaScene.createMetaModel(metaModelId, metaModelData, {
            includeTypes: options.includeTypes,
            excludeTypes: options.excludeTypes,
            globalizeObjectIds: options.globalizeObjectIds
        });

        performanceModel.once("destroyed", function () {
            viewer.metaScene.destroyMetaModel(metaModelId);
        });
    }

    // Count instances of each geometry

    var geometryReuseCounts = new Uint32Array(numGeometries);

    for (var meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
        var geometryIndex = eachMeshGeometriesPortion[meshIndex];
        if (geometryReuseCounts[geometryIndex] !== undefined) {
            geometryReuseCounts[geometryIndex]++;
        } else {
            geometryReuseCounts[geometryIndex] = 1;
        }
    }

    // Iterate over tiles

    var tileCenter = math.vec3();
    var rtcAABB = math.AABB3();

    for (var tileIndex = 0; tileIndex < numTiles; tileIndex++) {

        var lastTileIndex = (numTiles - 1);

        var atLastTile = (tileIndex === lastTileIndex);

        var firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];
        var lastTileEntityIndex = atLastTile ? numEntities : eachTileEntitiesPortion[tileIndex + 1];

        var tileAABBIndex = tileIndex * 6;
        var tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);

        math.getAABB3Center(tileAABB, tileCenter);

        rtcAABB[0] = tileAABB[0] - tileCenter[0];
        rtcAABB[1] = tileAABB[1] - tileCenter[1];
        rtcAABB[2] = tileAABB[2] - tileCenter[2];
        rtcAABB[3] = tileAABB[3] - tileCenter[0];
        rtcAABB[4] = tileAABB[4] - tileCenter[1];
        rtcAABB[5] = tileAABB[5] - tileCenter[2];

        var tileDecodeMatrix = geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);

        var geometryCreated = {};

        // Iterate over each tile's entities

        for (var tileEntityIndex = firstTileEntityIndex; tileEntityIndex < lastTileEntityIndex; tileEntityIndex++) {

            var xktMetaObjectIndex = eachEntityMetaObject[tileEntityIndex];
            var xktMetaObjectId = eachMetaObjectId[xktMetaObjectIndex];
            var xktEntityId = xktMetaObjectId;

            var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;

            var lastTileEntityIndex$1 = (numEntities - 1);
            var atLastTileEntity = (tileEntityIndex === lastTileEntityIndex$1);
            var firstMeshIndex = eachEntityMeshesPortion [tileEntityIndex];
            var lastMeshIndex = atLastTileEntity ? eachMeshGeometriesPortion.length : eachEntityMeshesPortion[tileEntityIndex + 1];

            var meshIds = [];

            var metaObject = viewer.metaScene.metaObjects[entityId];
            var entityDefaults = {};
            var meshDefaults = {};

            if (metaObject) {

                // Mask loading of object types

                if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                    continue;
                }

                if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                    continue;
                }

                // Get initial property values for object types

                var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

                if (props) {
                    if (props.visible === false) {
                        entityDefaults.visible = false;
                    }
                    if (props.pickable === false) {
                        entityDefaults.pickable = false;
                    }
                    if (props.colorize) {
                        meshDefaults.color = props.colorize;
                    }
                    if (props.opacity !== undefined && props.opacity !== null) {
                        meshDefaults.opacity = props.opacity;
                    }
                    if (props.metallic !== undefined && props.metallic !== null) {
                        meshDefaults.metallic = props.metallic;
                    }
                    if (props.roughness !== undefined && props.roughness !== null) {
                        meshDefaults.roughness = props.roughness;
                    }
                }

            } else {
                if (options.excludeUnclassifiedObjects) {
                    continue;
                }
            }

            // Iterate each entity's meshes

            for (var meshIndex$1 = firstMeshIndex; meshIndex$1 < lastMeshIndex; meshIndex$1++) {

                var geometryIndex$1 = eachMeshGeometriesPortion[meshIndex$1];
                var geometryReuseCount = geometryReuseCounts[geometryIndex$1];
                var isReusedGeometry = (geometryReuseCount > 1);

                var atLastGeometry = (geometryIndex$1 === (numGeometries - 1));

                var meshColor = decompressColor$1(eachMeshMaterial.subarray((meshIndex$1 * 6), (meshIndex$1 * 6) + 3));
                var meshOpacity = eachMeshMaterial[(meshIndex$1 * 6) + 3] / 255.0;
                var meshMetallic = eachMeshMaterial[(meshIndex$1 * 6) + 4] / 255.0;
                var meshRoughness = eachMeshMaterial[(meshIndex$1 * 6) + 5] / 255.0;

                var meshId = nextMeshId++;

                if (isReusedGeometry) {

                    // Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry

                    var meshMatrixIndex = eachMeshMatricesPortion[meshIndex$1];
                    var meshMatrix = matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);

                    var geometryId = "geometry." + tileIndex + "." + geometryIndex$1; // These IDs are local to the PerformanceModel

                    if (!geometryCreated[geometryId]) {

                        var primitiveType = eachGeometryPrimitiveType[geometryIndex$1];

                        var primitiveName = (void 0);
                        var geometryPositions = (void 0);
                        var geometryNormals = (void 0);
                        var geometryColors = (void 0);
                        var geometryIndices = (void 0);
                        var geometryEdgeIndices = (void 0);
                        var geometryValid = false;

                        switch (primitiveType) {
                            case 0:
                                primitiveName = "solid";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            case 1:
                                primitiveName = "surface";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            case 2:
                                primitiveName = "points";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryColors = convertColorsRGBToRGBA(colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]));
                                geometryValid = (geometryPositions.length > 0);
                                break;
                            case 3:
                                primitiveName = "lines";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            default:
                                continue;
                        }

                        if (geometryValid) {

                            performanceModel.createGeometry({
                                id: geometryId,
                                rtcCenter: tileCenter,
                                primitive: primitiveName,
                                positions: geometryPositions,
                                normals: geometryNormals,
                                colorsCompressed: geometryColors,
                                indices: geometryIndices,
                                edgeIndices: geometryEdgeIndices,
                                positionsDecodeMatrix: reusedGeometriesDecodeMatrix
                            });

                            geometryCreated[geometryId] = true;
                        }
                    }

                    if (geometryCreated[geometryId]) {

                        performanceModel.createMesh(utils.apply(meshDefaults, {
                            id: meshId,
                            geometryId: geometryId,
                            matrix: meshMatrix,
                            color: meshColor,
                            metallic: meshMetallic,
                            roughness: meshRoughness,
                            opacity: meshOpacity
                        }));

                        meshIds.push(meshId);
                    }

                } else {

                    var primitiveType$1 = eachGeometryPrimitiveType[geometryIndex$1];

                    var primitiveName$1 = (void 0);
                    var geometryPositions$1 = (void 0);
                    var geometryNormals$1 = (void 0);
                    var geometryColors$1 = (void 0);
                    var geometryIndices$1 = (void 0);
                    var geometryEdgeIndices$1 = (void 0);
                    var geometryValid$1 = false;

                    switch (primitiveType$1) {
                        case 0:
                            primitiveName$1 = "solid";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        case 1:
                            primitiveName$1 = "surface";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        case 2:
                            primitiveName$1 = "points";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryColors$1 = convertColorsRGBToRGBA(colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]));
                            geometryValid$1 = (geometryPositions$1.length > 0);
                            break;
                        case 3:
                            primitiveName$1 = "lines";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        default:
                            continue;
                    }

                    if (geometryValid$1) {

                        performanceModel.createMesh(utils.apply(meshDefaults, {
                            id: meshId,
                            rtcCenter: tileCenter,
                            primitive: primitiveName$1,
                            positions: geometryPositions$1,
                            normals: geometryNormals$1,
                            colorsCompressed: geometryColors$1,
                            indices: geometryIndices$1,
                            edgeIndices: geometryEdgeIndices$1,
                            positionsDecodeMatrix: tileDecodeMatrix,
                            color: meshColor,
                            metallic: meshMetallic,
                            roughness: meshRoughness,
                            opacity: meshOpacity
                        }));

                        meshIds.push(meshId);
                    }
                }
            }

            if (meshIds.length > 0) {

                performanceModel.createEntity(utils.apply(entityDefaults, {
                    id: entityId,
                    isObject: true,
                    meshIds: meshIds
                }));
            }
        }
    }
}

/** @private */
var ParserV8 = {
    version: 8,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract$1(elements);
        var inflatedData = inflate$1(deflatedData);
        load$1(viewer, options, inflatedData, performanceModel);
    }
};

/*

 Parser for .XKT Format V9

 */

var pako = window.pako || p;
if (!pako.inflate) {  // See https://github.com/nodeca/pako/issues/97
    pako = pako.default;
}

function extract(elements) {

    return {

        // Metadata

        metadata: elements[0],

        positions: elements[1],
        normals: elements[2],
        colors: elements[3],
        indices: elements[4],
        edgeIndices: elements[5],

        // Transform matrices

        matrices: elements[6],
        reusedGeometriesDecodeMatrix: elements[7],

        // Geometries

        eachGeometryPrimitiveType: elements[8],
        eachGeometryPositionsPortion: elements[9],
        eachGeometryNormalsPortion: elements[10],
        eachGeometryColorsPortion: elements[11],
        eachGeometryIndicesPortion: elements[12],
        eachGeometryEdgeIndicesPortion: elements[13],

        // Meshes are grouped in runs that are shared by the same entities

        eachMeshGeometriesPortion: elements[14],
        eachMeshMatricesPortion: elements[15],
        eachMeshMaterial: elements[16],

        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles

        eachEntityId: elements[17],
        eachEntityMeshesPortion: elements[18],

        eachTileAABB: elements[19],
        eachTileEntitiesPortion: elements[20]
    };
}

function inflate(deflatedData) {

    function inflate(array, options) {
        return (array.length === 0) ? [] : pako.inflate(array, options).buffer;
    }

    return {

        metadata: JSON.parse(pako.inflate(deflatedData.metadata, {to: 'string'})),

        positions: new Uint16Array(inflate(deflatedData.positions)),
        normals: new Int8Array(inflate(deflatedData.normals)),
        colors: new Uint8Array(inflate(deflatedData.colors)),
        indices: new Uint32Array(inflate(deflatedData.indices)),
        edgeIndices: new Uint32Array(inflate(deflatedData.edgeIndices)),

        matrices: new Float32Array(inflate(deflatedData.matrices)),
        reusedGeometriesDecodeMatrix: new Float32Array(inflate(deflatedData.reusedGeometriesDecodeMatrix)),

        eachGeometryPrimitiveType: new Uint8Array(inflate(deflatedData.eachGeometryPrimitiveType)),
        eachGeometryPositionsPortion: new Uint32Array(inflate(deflatedData.eachGeometryPositionsPortion)),
        eachGeometryNormalsPortion: new Uint32Array(inflate(deflatedData.eachGeometryNormalsPortion)),
        eachGeometryColorsPortion: new Uint32Array(inflate(deflatedData.eachGeometryColorsPortion)),
        eachGeometryIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryIndicesPortion)),
        eachGeometryEdgeIndicesPortion: new Uint32Array(inflate(deflatedData.eachGeometryEdgeIndicesPortion)),

        eachMeshGeometriesPortion: new Uint32Array(inflate(deflatedData.eachMeshGeometriesPortion)),
        eachMeshMatricesPortion: new Uint32Array(inflate(deflatedData.eachMeshMatricesPortion)),
        eachMeshMaterial: new Uint8Array(inflate(deflatedData.eachMeshMaterial)),

        eachEntityId: JSON.parse(pako.inflate(deflatedData.eachEntityId, {to: 'string'})),
        eachEntityMeshesPortion: new Uint32Array(inflate(deflatedData.eachEntityMeshesPortion)),

        eachTileAABB: new Float64Array(inflate(deflatedData.eachTileAABB)),
        eachTileEntitiesPortion: new Uint32Array(inflate(deflatedData.eachTileEntitiesPortion)),
    };
}

var decompressColor = (function () {
    var floatColor = new Float32Array(3);
    return function (intColor) {
        floatColor[0] = intColor[0] / 255.0;
        floatColor[1] = intColor[1] / 255.0;
        floatColor[2] = intColor[2] / 255.0;
        return floatColor;
    };
})();

function load(viewer, options, inflatedData, performanceModel) {

    var metadata = inflatedData.metadata;

    var positions = inflatedData.positions;
    var normals = inflatedData.normals;
    var colors = inflatedData.colors;
    var indices = inflatedData.indices;
    var edgeIndices = inflatedData.edgeIndices;

    var matrices = inflatedData.matrices;
    var reusedGeometriesDecodeMatrix = inflatedData.reusedGeometriesDecodeMatrix;

    var eachGeometryPrimitiveType = inflatedData.eachGeometryPrimitiveType;
    var eachGeometryPositionsPortion = inflatedData.eachGeometryPositionsPortion;
    var eachGeometryNormalsPortion = inflatedData.eachGeometryNormalsPortion;
    var eachGeometryColorsPortion = inflatedData.eachGeometryColorsPortion;
    var eachGeometryIndicesPortion = inflatedData.eachGeometryIndicesPortion;
    var eachGeometryEdgeIndicesPortion = inflatedData.eachGeometryEdgeIndicesPortion;

    var eachMeshGeometriesPortion = inflatedData.eachMeshGeometriesPortion;
    var eachMeshMatricesPortion = inflatedData.eachMeshMatricesPortion;
    var eachMeshMaterial = inflatedData.eachMeshMaterial;

    var eachEntityId = inflatedData.eachEntityId;
    var eachEntityMeshesPortion = inflatedData.eachEntityMeshesPortion;

    var eachTileAABB = inflatedData.eachTileAABB;
    var eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;

    var numGeometries = eachGeometryPositionsPortion.length;
    var numMeshes = eachMeshGeometriesPortion.length;
    var numEntities = eachEntityMeshesPortion.length;
    var numTiles = eachTileEntitiesPortion.length;

    var nextMeshId = 0;

    // Create metamodel, unless already loaded from external JSON file by XKTLoaderPlugin

    var metaModelId = performanceModel.id;

    if (!viewer.metaScene.metaModels[metaModelId]) {

        viewer.metaScene.createMetaModel(metaModelId, metadata, {
            includeTypes: options.includeTypes,
            excludeTypes: options.excludeTypes,
            globalizeObjectIds: options.globalizeObjectIds
        });

        performanceModel.once("destroyed", function () {
            viewer.metaScene.destroyMetaModel(metaModelId);
        });
    }

    // Count instances of each geometry

    var geometryReuseCounts = new Uint32Array(numGeometries);

    for (var meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
        var geometryIndex = eachMeshGeometriesPortion[meshIndex];
        if (geometryReuseCounts[geometryIndex] !== undefined) {
            geometryReuseCounts[geometryIndex]++;
        } else {
            geometryReuseCounts[geometryIndex] = 1;
        }
    }

    // Iterate over tiles

    var tileCenter = math.vec3();
    var rtcAABB = math.AABB3();

    for (var tileIndex = 0; tileIndex < numTiles; tileIndex++) {

        var lastTileIndex = (numTiles - 1);

        var atLastTile = (tileIndex === lastTileIndex);

        var firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];
        var lastTileEntityIndex = atLastTile ? (numEntities - 1) : (eachTileEntitiesPortion[tileIndex + 1] - 1);

        var tileAABBIndex = tileIndex * 6;
        var tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);

        math.getAABB3Center(tileAABB, tileCenter);

        rtcAABB[0] = tileAABB[0] - tileCenter[0];
        rtcAABB[1] = tileAABB[1] - tileCenter[1];
        rtcAABB[2] = tileAABB[2] - tileCenter[2];
        rtcAABB[3] = tileAABB[3] - tileCenter[0];
        rtcAABB[4] = tileAABB[4] - tileCenter[1];
        rtcAABB[5] = tileAABB[5] - tileCenter[2];

        var tileDecodeMatrix = geometryCompressionUtils.createPositionsDecodeMatrix(rtcAABB);

        var geometryCreated = {};

        // Iterate over each tile's entities

        for (var tileEntityIndex = firstTileEntityIndex; tileEntityIndex <= lastTileEntityIndex; tileEntityIndex++) {

            var xktEntityId = eachEntityId[tileEntityIndex];

            var entityId = options.globalizeObjectIds ? math.globalizeObjectId(performanceModel.id, xktEntityId) : xktEntityId;

            var finalTileEntityIndex = (numEntities - 1);
            var atLastTileEntity = (tileEntityIndex === finalTileEntityIndex);
            var firstMeshIndex = eachEntityMeshesPortion [tileEntityIndex];
            var lastMeshIndex = atLastTileEntity ? (eachMeshGeometriesPortion.length - 1) : (eachEntityMeshesPortion[tileEntityIndex + 1] - 1);

            var meshIds = [];

            var metaObject = viewer.metaScene.metaObjects[entityId];
            var entityDefaults = {};
            var meshDefaults = {};

            if (metaObject) {

                // Mask loading of object types

                if (options.excludeTypesMap && metaObject.type && options.excludeTypesMap[metaObject.type]) {
                    continue;
                }

                if (options.includeTypesMap && metaObject.type && (!options.includeTypesMap[metaObject.type])) {
                    continue;
                }

                // Get initial property values for object types

                var props = options.objectDefaults ? options.objectDefaults[metaObject.type] || options.objectDefaults["DEFAULT"] : null;

                if (props) {
                    if (props.visible === false) {
                        entityDefaults.visible = false;
                    }
                    if (props.pickable === false) {
                        entityDefaults.pickable = false;
                    }
                    if (props.colorize) {
                        meshDefaults.color = props.colorize;
                    }
                    if (props.opacity !== undefined && props.opacity !== null) {
                        meshDefaults.opacity = props.opacity;
                    }
                    if (props.metallic !== undefined && props.metallic !== null) {
                        meshDefaults.metallic = props.metallic;
                    }
                    if (props.roughness !== undefined && props.roughness !== null) {
                        meshDefaults.roughness = props.roughness;
                    }
                }

            } else {
                if (options.excludeUnclassifiedObjects) {
                    continue;
                }
            }

            // Iterate each entity's meshes

            for (var meshIndex$1 = firstMeshIndex; meshIndex$1 <= lastMeshIndex; meshIndex$1++) {

                var geometryIndex$1 = eachMeshGeometriesPortion[meshIndex$1];
                var geometryReuseCount = geometryReuseCounts[geometryIndex$1];
                var isReusedGeometry = (geometryReuseCount > 1);

                var atLastGeometry = (geometryIndex$1 === (numGeometries - 1));

                var meshColor = decompressColor(eachMeshMaterial.subarray((meshIndex$1 * 6), (meshIndex$1 * 6) + 3));
                var meshOpacity = eachMeshMaterial[(meshIndex$1 * 6) + 3] / 255.0;
                var meshMetallic = eachMeshMaterial[(meshIndex$1 * 6) + 4] / 255.0;
                var meshRoughness = eachMeshMaterial[(meshIndex$1 * 6) + 5] / 255.0;

                var meshId = nextMeshId++;

                if (isReusedGeometry) {

                    // Create mesh for multi-use geometry - create (or reuse) geometry, create mesh using that geometry

                    var meshMatrixIndex = eachMeshMatricesPortion[meshIndex$1];
                    var meshMatrix = matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);

                    var geometryId = "geometry." + tileIndex + "." + geometryIndex$1; // These IDs are local to the PerformanceModel

                    if (!geometryCreated[geometryId]) {

                        var primitiveType = eachGeometryPrimitiveType[geometryIndex$1];

                        var primitiveName = (void 0);
                        var geometryPositions = (void 0);
                        var geometryNormals = (void 0);
                        var geometryColors = (void 0);
                        var geometryIndices = (void 0);
                        var geometryEdgeIndices = (void 0);
                        var geometryValid = false;

                        switch (primitiveType) {
                            case 0:
                                primitiveName = "solid";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            case 1:
                                primitiveName = "surface";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            case 2:
                                primitiveName = "points";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryColors = colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0);
                                break;
                            case 3:
                                primitiveName = "lines";
                                geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                                geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                                geometryValid = (geometryPositions.length > 0 && geometryIndices.length > 0);
                                break;
                            default:
                                continue;
                        }

                        if (geometryValid) {

                            performanceModel.createGeometry({
                                id: geometryId,
                                rtcCenter: tileCenter,
                                primitive: primitiveName,
                                positions: geometryPositions,
                                normals: geometryNormals,
                                colorsCompressed: geometryColors,
                                indices: geometryIndices,
                                edgeIndices: geometryEdgeIndices,
                                positionsDecodeMatrix: reusedGeometriesDecodeMatrix
                            });

                            geometryCreated[geometryId] = true;
                        }
                    }

                    if (geometryCreated[geometryId]) {

                        performanceModel.createMesh(utils.apply(meshDefaults, {
                            id: meshId,
                            geometryId: geometryId,
                            matrix: meshMatrix,
                            color: meshColor,
                            metallic: meshMetallic,
                            roughness: meshRoughness,
                            opacity: meshOpacity
                        }));

                        meshIds.push(meshId);
                    }

                } else {

                    var primitiveType$1 = eachGeometryPrimitiveType[geometryIndex$1];

                    var primitiveName$1 = (void 0);
                    var geometryPositions$1 = (void 0);
                    var geometryNormals$1 = (void 0);
                    var geometryColors$1 = (void 0);
                    var geometryIndices$1 = (void 0);
                    var geometryEdgeIndices$1 = (void 0);
                    var geometryValid$1 = false;

                    switch (primitiveType$1) {
                        case 0:
                            primitiveName$1 = "solid";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        case 1:
                            primitiveName$1 = "surface";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryNormals$1 = normals.subarray(eachGeometryNormalsPortion [geometryIndex$1], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryEdgeIndices$1 = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex$1], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        case 2:
                            primitiveName$1 = "points";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryColors$1 = colors.subarray(eachGeometryColorsPortion [geometryIndex$1], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0);
                            break;
                        case 3:
                            primitiveName$1 = "lines";
                            geometryPositions$1 = positions.subarray(eachGeometryPositionsPortion [geometryIndex$1], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex$1 + 1]);
                            geometryIndices$1 = indices.subarray(eachGeometryIndicesPortion [geometryIndex$1], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex$1 + 1]);
                            geometryValid$1 = (geometryPositions$1.length > 0 && geometryIndices$1.length > 0);
                            break;
                        default:
                            continue;
                    }

                    if (geometryValid$1) {

                        performanceModel.createMesh(utils.apply(meshDefaults, {
                            id: meshId,
                            rtcCenter: tileCenter,
                            primitive: primitiveName$1,
                            positions: geometryPositions$1,
                            normals: geometryNormals$1,
                            colorsCompressed: geometryColors$1,
                            indices: geometryIndices$1,
                            edgeIndices: geometryEdgeIndices$1,
                            positionsDecodeMatrix: tileDecodeMatrix,
                            color: meshColor,
                            metallic: meshMetallic,
                            roughness: meshRoughness,
                            opacity: meshOpacity
                        }));

                        meshIds.push(meshId);
                    }
                }
            }

            if (meshIds.length > 0) {

                performanceModel.createEntity(utils.apply(entityDefaults, {
                    id: entityId,
                    isObject: true,
                    meshIds: meshIds
                }));
            }
        }
    }
}

/** @private */
var ParserV9 = {
    version: 9,
    parse: function (viewer, options, elements, performanceModel) {
        var deflatedData = extract(elements);
        var inflatedData = inflate(deflatedData);
        load(viewer, options, inflatedData, performanceModel);
    }
};

var parsers = {};

parsers[ParserV1.version] = ParserV1;
parsers[ParserV2.version] = ParserV2;
parsers[ParserV3.version] = ParserV3;
parsers[ParserV4.version] = ParserV4;
parsers[ParserV5.version] = ParserV5;
parsers[ParserV6.version] = ParserV6;
parsers[ParserV7.version] = ParserV7;
parsers[ParserV8.version] = ParserV8;
parsers[ParserV9.version] = ParserV9;

/**
 * {@link Viewer} plugin that loads models from xeokit's optimized *````.XKT````* format.
 *
 * <a href="https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_OTCConferenceCenter"><img src="http://xeokit.io/img/docs/XKTLoaderPlugin/XKTLoaderPlugin.png"></a>
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_OTCConferenceCenter)]
 *
 * ## Overview
 *
 * * XKTLoaderPlugin is the most efficient way to load high-detail models into xeokit.
 * * An *````.XKT````* file is a single BLOB containing a model, compressed using geometry quantization
 * and [pako](https://nodeca.github.io/pako/).
 * * Supports double-precision coordinates, via ````.XKT```` format version 6.
 * * Set the position, scale and rotation of each model as you load it.
 * * Filter which IFC types get loaded.
 * * Configure initial default appearances for IFC types.
 * * Set a custom data source for *````.XKT````* and IFC metadata files.
 * * Option to load multiple copies of the same model, without object ID clashes.
 *
 * ## Creating *````.XKT````* Files and Metadata
 *
 * See [Creating Files for Offline BIM](https://github.com/xeokit/xeokit-sdk/wiki/Creating-Files-for-Offline-BIM).
 *
 * ## Scene representation
 *
 * When loading a model, XKTLoaderPlugin creates an {@link Entity} that represents the model, which
 * will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id}
 * in {@link Scene#models}. The XKTLoaderPlugin also creates an {@link Entity} for each object within the
 * model. Those Entities will have {@link Entity#isObject} set ````true```` and will be registered
 * by {@link Entity#id} in {@link Scene#objects}.
 *
 * ## Metadata
 *
 * Since XKT V8, model metadata is included in the XKT file. If the XKT file has metadata, then loading it creates
 * model metadata components within the Viewer, namely a {@link MetaModel} corresponding to the model {@link Entity},
 * and a {@link MetaObject} for each object {@link Entity}.
 *
 * Each {@link MetaObject} has a {@link MetaObject#type}, which indicates the classification of its corresponding
 * {@link Entity}. When loading metadata, we can also configure XKTLoaderPlugin with a custom lookup table of initial
 * values to set on the properties of each type of {@link Entity}. By default, XKTLoaderPlugin uses its own map of
 * default colors and visibilities for IFC element types.
 *
 * For XKT versions prior to V8, we provided the metadata to XKTLoaderPlugin as an accompanying JSON file to load. We can
 * still do that for all XKT versions, and for XKT V8+ it will override any metadata provided within the XKT file.
 *
 * ## Usage
 *
 * In the example below we'll load the Schependomlaan model from a [.XKT file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/models/xkt/schependomlaan).
 *
 * This will create a bunch of {@link Entity}s that represents the model and its objects, along with a {@link MetaModel} and {@link MetaObject}s
 * that hold their metadata.
 *
 * Since this model contains IFC types, the XKTLoaderPlugin will set the initial appearance of each object
 * {@link Entity} according to its IFC type in {@link XKTLoaderPlugin#objectDefaults}.
 *
 * Read more about this example in the user guide on [Viewing BIM Models Offline](https://www.notion.so/xeokit/Viewing-an-IFC-Model-with-xeokit-c373e48bc4094ff5b6e5c5700ff580ee).
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_metadata_Schependomlaan)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a Viewer,
 * // 2. Arrange the camera
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 * });
 *
 * // 2
 * viewer.camera.eye = [-2.56, 8.38, 8.27];
 * viewer.camera.look = [13.44, 3.31, -14.83];
 * viewer.camera.up = [0.10, 0.98, -0.14];
 *
 * //------------------------------------------------------------------------------------------------------------------
 * // 1. Create a XKTLoaderPlugin,
 * // 2. Load a building model and JSON IFC metadata
 * //------------------------------------------------------------------------------------------------------------------
 *
 * // 1
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * // 2
 * const model = xktLoader.load({          // Returns an Entity that represents the model
 *     id: "myModel",
 *     src: "./models/xkt/Schependomlaan.xkt",
 *     edges: true
 * });
 *
 * model.on("loaded", () => {
 *
 *     //--------------------------------------------------------------------------------------------------------------
 *     // 1. Find metadata on the third storey
 *     // 2. Select all the objects in the building's third storey
 *     // 3. Fit the camera to all the objects on the third storey
 *     //--------------------------------------------------------------------------------------------------------------
 *
 *     // 1
 *     const metaModel = viewer.metaScene.metaModels["myModel"];       // MetaModel with ID "myModel"
 *     const metaObject
 *          = viewer.metaScene.metaObjects["0u4wgLe6n0ABVaiXyikbkA"];  // MetaObject with ID "0u4wgLe6n0ABVaiXyikbkA"
 *
 *     const name = metaObject.name;                                   // "01 eerste verdieping"
 *     const type = metaObject.type;                                   // "IfcBuildingStorey"
 *     const parent = metaObject.parent;                               // MetaObject with type "IfcBuilding"
 *     const children = metaObject.children;                           // Array of child MetaObjects
 *     const objectId = metaObject.id;                                 // "0u4wgLe6n0ABVaiXyikbkA"
 *     const objectIds = viewer.metaScene.getObjectIDsInSubtree(objectId);   // IDs of leaf sub-objects
 *     const aabb = viewer.scene.getAABB(objectIds);                   // Axis-aligned boundary of the leaf sub-objects
 *
 *     // 2
 *     viewer.scene.setObjectsSelected(objectIds, true);
 *
 *     // 3
 *     viewer.cameraFlight.flyTo(aabb);
 * });
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 *
 * ## Transforming
 *
 * We have the option to rotate, scale and translate each  *````.XKT````* model as we load it.
 *
 * This lets us load multiple models, or even multiple copies of the same model, and position them apart from each other.
 *
 * In the example below, we'll scale our model to half its size, rotate it 90 degrees about its local X-axis, then
 * translate it 100 units along its X axis.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_Duplex_transform)]
 *
 * ````javascript
 * xktLoader.load({
 *      src: "./models/xkt/Duplex.ifc.xkt",
 *      rotation: [90,0,0],
 *      scale: [0.5, 0.5, 0.5],
 *      position: [100, 0, 0]
 * });
 * ````
 *
 * ## Including and excluding IFC types
 *
 * We can also load only those objects that have the specified IFC types.
 *
 * In the example below, we'll load only the objects that represent walls.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_includeTypes)]
 *
 * ````javascript
 * const model2 = xktLoader.load({
 *     id: "myModel2",
 *     src: "./models/xkt/OTCConferenceCenter.xkt",
 *     includeTypes: ["IfcWallStandardCase"]
 * });
 * ````
 *
 * We can also load only those objects that **don't** have the specified IFC types.
 *
 * In the example below, we'll load only the objects that do not represent empty space.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_excludeTypes)]
 *
 * ````javascript
 * const model3 = xktLoader.load({
 *     id: "myModel3",
 *     src: "./models/xkt/OTCConferenceCenter.xkt",
 *     excludeTypes: ["IfcSpace"]
 * });
 * ````
 *
 * ## Configuring initial IFC object appearances
 *
 * We can specify the custom initial appearance of loaded objects according to their IFC types.
 *
 * This is useful for things like:
 *
 * * setting the colors to our objects according to their IFC types,
 * * automatically hiding ````IfcSpace```` objects, and
 * * ensuring that ````IfcWindow```` objects are always transparent.
 * <br>
 * In the example below, we'll load a model, while configuring ````IfcSpace```` elements to be always initially invisible,
 * and ````IfcWindow```` types to be always translucent blue.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_objectDefaults)]
 *
 * ````javascript
 * const myObjectDefaults = {
 *
 *      IfcSpace: {
 *          visible: false
 *      },
 *      IfcWindow: {
 *          colorize: [0.337255, 0.303922, 0.870588], // Blue
 *          opacity: 0.3
 *      },
 *
 *      //...
 *
 *      DEFAULT: {
 *          colorize: [0.5, 0.5, 0.5]
 *      }
 * };
 *
 * const model4 = xktLoader.load({
 *      id: "myModel4",
 *      src: "./models/xkt/Duplex.ifc.xkt",
 *      objectDefaults: myObjectDefaults // Use our custom initial default states for object Entities
 * });
 * ````
 *
 * When we don't customize the appearance of IFC types, as just above, then IfcSpace elements tend to obscure other
 * elements, which can be confusing.
 *
 * It's often helpful to make IfcSpaces transparent and unpickable, like this:
 *
 * ````javascript
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *    objectDefaults: {
 *        IfcSpace: {
 *            pickable: false,
 *            opacity: 0.2
 *        }
 *    }
 * });
 * ````
 *
 * Alternatively, we could just make IfcSpaces invisible, which also makes them unpickable:
 *
 * ````javascript
 * const xktLoader = new XKTLoaderPlugin(viewer, {
 *    objectDefaults: {
 *        IfcSpace: {
 *            visible: false
 *        }
 *    }
 * });
 * ````
 *
 * ## Configuring a custom data source
 *
 * By default, XKTLoaderPlugin will load *````.XKT````* files and metadata JSON over HTTP.
 *
 * In the example below, we'll customize the way XKTLoaderPlugin loads the files by configuring it with our own data source
 * object. For simplicity, our custom data source example also uses HTTP, using a couple of xeokit utility functions.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_XKT_dataSource)]
 *
 * ````javascript
 * import {utils} from "xeokit-sdk.es.js";
 *
 * class MyDataSource {
 *
 *      constructor() {
 *      }
 *
 *      // Gets metamodel JSON
 *      getMetaModel(metaModelSrc, ok, error) {
 *          console.log("MyDataSource#getMetaModel(" + metaModelSrc + ", ... )");
 *          utils.loadJSON(metaModelSrc,
 *              (json) => {
 *                  ok(json);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 *
 *      // Gets the contents of the given .XKT file in an arraybuffer
 *      getXKT(src, ok, error) {
 *          console.log("MyDataSource#getXKT(" + xKTSrc + ", ... )");
 *          utils.loadArraybuffer(src,
 *              (arraybuffer) => {
 *                  ok(arraybuffer);
 *              },
 *              function (errMsg) {
 *                  error(errMsg);
 *              });
 *      }
 * }
 *
 * const xktLoader2 = new XKTLoaderPlugin(viewer, {
 *       dataSource: new MyDataSource()
 * });
 *
 * const model5 = xktLoader2.load({
 *      id: "myModel5",
 *      src: "./models/xkt/Duplex.ifc.xkt"
 * });
 * ````
 *
 * ## Loading multiple copies of a model, without object ID clashes
 *
 * Sometimes we need to load two or more instances of the same model, without having clashes
 * between the IDs of the equivalent objects in the model instances.
 *
 * As shown in the example below, we do this by setting {@link XKTLoaderPlugin#globalizeObjectIds} ````true```` before we load our models.
 *
 * * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#TreeViewPlugin_Containment_MultipleModels)]
 *
 * ````javascript
 * xktLoader.globalizeObjectIds = true;
 *
 * const model = xktLoader.load({
 *      id: "model1",
 *      src: "./models/xkt/Schependomlaan.xkt"
 * });
 *
 * const model2 = xktLoader.load({
 *    id: "model2",
 *    src: "./models/xkt/Schependomlaan.xkt"
 * });
 * ````
 *
 * For each {@link Entity} loaded by these two calls, {@link Entity#id} and {@link MetaObject#id} will get prefixed by
 * the ID of their model, in order to avoid ID clashes between the two models.
 *
 * An Entity belonging to the first model will get an ID like this:
 *
 * ````
 * myModel1#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * The equivalent Entity in the second model will get an ID like this:
 *
 * ````
 * myModel2#0BTBFw6f90Nfh9rP1dlXrb
 * ````
 *
 * Now, to update the visibility of both of those Entities collectively, using {@link Scene#setObjectsVisible}, we can
 * supply just the IFC product ID part to that method:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("0BTBFw6f90Nfh9rP1dlXrb", true);
 * ````
 *
 * The method, along with {@link Scene#setObjectsXRayed}, {@link Scene#setObjectsHighlighted} etc, will internally expand
 * the given ID to refer to the instances of that Entity in both models.
 *
 * We can also, of course, reference each Entity directly, using its globalized ID:
 *
 * ````javascript
 * myViewer.scene.setObjectVisibilities("myModel1#0BTBFw6f90Nfh9rP1dlXrb", true);
 *````
 *
 * @class XKTLoaderPlugin
 */
var XKTLoaderPlugin = /*@__PURE__*/(function (Plugin) {
    function XKTLoaderPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "XKTLoader", viewer, cfg);

        this._maxGeometryBatchSize = cfg.maxGeometryBatchSize;

        this.dataSource = cfg.dataSource;
        this.objectDefaults = cfg.objectDefaults;
        this.includeTypes = cfg.includeTypes;
        this.excludeTypes = cfg.excludeTypes;
        this.excludeUnclassifiedObjects = cfg.excludeUnclassifiedObjects;
    }

    if ( Plugin ) XKTLoaderPlugin.__proto__ = Plugin;
    XKTLoaderPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    XKTLoaderPlugin.prototype.constructor = XKTLoaderPlugin;

    var prototypeAccessors = { supportedVersions: { configurable: true },dataSource: { configurable: true },objectDefaults: { configurable: true },includeTypes: { configurable: true },excludeTypes: { configurable: true },excludeUnclassifiedObjects: { configurable: true },globalizeObjectIds: { configurable: true } };

    /**
     * Gets the ````.xkt```` format versions supported by this XKTLoaderPlugin/
     * @returns {string[]}
     */
    prototypeAccessors.supportedVersions.get = function () {
        return Object.keys(parsers);
    };

    /**
     * Sets a custom data source through which the XKTLoaderPlugin can load models and metadata.
     *
     * Default value is {@link XKTDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.set = function (value) {
        this._dataSource = value || new XKTDefaultDataSource();
    };

    /**
     * Gets the custom data source through which the XKTLoaderPlugin can load models and metadata.
     *
     * Default value is {@link XKTDefaultDataSource}, which loads via HTTP.
     *
     * @type {Object}
     */
    prototypeAccessors.dataSource.get = function () {
        return this._dataSource;
    };

    /**
     * Sets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectDefaults.set = function (value) {
        this._objectDefaults = value || IFCObjectDefaults;
    };

    /**
     * Gets map of initial default states for each loaded {@link Entity} that represents an object.
     *
     * Default value is {@link IFCObjectDefaults}.
     *
     * @type {{String: Object}}
     */
    prototypeAccessors.objectDefaults.get = function () {
        return this._objectDefaults;
    };

    /**
     * Sets the whitelist of the IFC types loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */
    prototypeAccessors.includeTypes.set = function (value) {
        this._includeTypes = value;
    };

    /**
     * Gets the whitelist of the IFC types loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to only load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */
    prototypeAccessors.includeTypes.get = function () {
        return this._includeTypes;
    };

    /**
     * Sets the blacklist of IFC types that are never loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */
    prototypeAccessors.excludeTypes.set = function (value) {
        this._excludeTypes = value;
    };

    /**
     * Gets the blacklist of IFC types that are never loaded by this XKTLoaderPlugin.
     *
     * When loading models with metadata, causes this XKTLoaderPlugin to **not** load objects whose types are in this
     * list. An object's type is indicated by its {@link MetaObject}'s {@link MetaObject#type}.
     *
     * Default value is ````undefined````.
     *
     * @type {String[]}
     */
    prototypeAccessors.excludeTypes.get = function () {
        return this._excludeTypes;
    };


    /**
     * Sets whether we load objects that don't have IFC types.
     *
     * When loading models with metadata and this is ````true````, XKTLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.excludeUnclassifiedObjects.set = function (value) {
        this._excludeUnclassifiedObjects = !!value;
    };

    /**
     * Gets whether we load objects that don't have IFC types.
     *
     * When loading models with metadata and this is ````true````, XKTLoaderPlugin will not load objects
     * that don't have IFC types.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.excludeUnclassifiedObjects.get = function () {
        return this._excludeUnclassifiedObjects;
    };

    /**
     * Sets whether XKTLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Set  this ````true```` when you need to load multiple instances of the same model, to avoid ID clashes
     * between the objects in the different instances.
     *
     * When we load a model with this set ````true````, then each {@link Entity#id} and {@link MetaObject#id} will be
     * prefixed by the ID of the model, ie. ````<modelId>#<objectId>````.
     *
     * {@link Entity#originalSystemId} and {@link MetaObject#originalSystemId} will always hold the original, un-prefixed, ID values.
     *
     * Default value is ````false````.
     *
     * See the main {@link XKTLoaderPlugin} class documentation for usage info.
     *
     * @type {Boolean}
     */
    prototypeAccessors.globalizeObjectIds.set = function (value) {
        this._globalizeObjectIds = !!value;
    };

    /**
     * Gets whether XKTLoaderPlugin globalizes each {@link Entity#id} and {@link MetaObject#id} as it loads a model.
     *
     * Default value is ````false````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.globalizeObjectIds.get = function () {
        return this._globalizeObjectIds;
    };

    /**
     * Loads an ````.xkt```` model into this XKTLoaderPlugin's {@link Viewer}.
     *
     * Since xeokit/xeokit-sdk 1.9.0, XKTLoaderPlugin has supported XKT 8, which bundles the metamodel
     * data (eg. an IFC element hierarchy) in the XKT file itself. For XKT 8, we therefore no longer need to
     * load the metamodel data from a separate accompanying JSON file, as we did with previous XKT versions.
     * However, if we do choose to specify a separate metamodel JSON file to load (eg. for backward compatibility
     * in data pipelines), then that metamodel will be loaded and the metamodel in the XKT 8 file will be ignored.
     *
     * @param {*} params Loading parameters.
     * @param {String} [params.id] ID to assign to the root {@link Entity#id}, unique among all components in the Viewer's {@link Scene}, generated automatically by default.
     * @param {String} [params.src] Path to a *````.xkt````* file, as an alternative to the ````xkt```` parameter.
     * @param {ArrayBuffer} [params.xkt] The *````.xkt````* file data, as an alternative to the ````src```` parameter.
     * @param {String} [params.metaModelSrc] Path to an optional metadata file, as an alternative to the ````metaModelData```` parameter.
     * @param {*} [params.metaModelData] JSON model metadata, as an alternative to the ````metaModelSrc```` parameter.
     * @param {{String:Object}} [params.objectDefaults] Map of initial default states for each loaded {@link Entity} that represents an object. Default value is {@link IFCObjectDefaults}.
     * @param {String[]} [params.includeTypes] When loading metadata, only loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {String[]} [params.excludeTypes] When loading metadata, never loads objects that have {@link MetaObject}s with {@link MetaObject#type} values in this list.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the model with edges emphasized.
     * @param {Number[]} [params.position=[0,0,0]] The model World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [params.edges=false] Indicates if the model's edges are initially emphasized.
     * @param {Boolean} [params.saoEnabled=true] Indicates if Scalable Ambient Obscurance (SAO) will apply to the model. SAO is configured by the Scene's {@link SAO} component. Only works when {@link SAO#enabled} is also ````true````
     * @param {Boolean} [params.pbrEnabled=false] Indicates if physically-based rendering (PBR) will apply to the model. Only works when {@link Scene#pbrEnabled} is also ````true````.
     * @param {Number} [params.backfaces=false] When we set this ````true````, then we force rendering of backfaces for the model. When
     * we leave this ````false````, then we allow the Viewer to decide when to render backfaces. In that case, the
     * Viewer will hide backfaces on watertight meshes, show backfaces on open meshes, and always show backfaces on meshes when we slice them open with {@link SectionPlane}s.
     * @param {Boolean} [params.excludeUnclassifiedObjects=false] When loading metadata and this is ````true````, will only load {@link Entity}s that have {@link MetaObject}s (that are not excluded). This is useful when we don't want Entitys in the Scene that are not represented within IFC navigation components, such as {@link TreeViewPlugin}.
     * @param {Boolean} [params.globalizeObjectIds=false] Indicates whether to globalize each {@link Entity#id} and {@link MetaObject#id}, in case you need to prevent ID clashes with other models. See {@link XKTLoaderPlugin#globalizeObjectIds} for more info.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
     */
    XKTLoaderPlugin.prototype.load = function load (params) {
        var this$1 = this;
        if ( params === void 0 ) params = {};


        if (params.id && this.viewer.scene.components[params.id]) {
            this.error("Component with this ID already exists in viewer: " + params.id + " - will autogenerate this ID");
            delete params.id;
        }

        var performanceModel = new PerformanceModel(this.viewer.scene, utils.apply(params, {
            isModel: true,
            maxGeometryBatchSize: this._maxGeometryBatchSize
        }));

        var modelId = performanceModel.id;  // In case ID was auto-generated

        if (!params.src && !params.xkt) {
            this.error("load() param expected: src or xkt");
            return performanceModel; // Return new empty model
        }

        var options = {};
        var includeTypes = params.includeTypes || this._includeTypes;
        var excludeTypes = params.excludeTypes || this._excludeTypes;
        var objectDefaults = params.objectDefaults || this._objectDefaults;

        if (includeTypes) {
            options.includeTypesMap = {};
            for (var i = 0, len = includeTypes.length; i < len; i++) {
                options.includeTypesMap[includeTypes[i]] = true;
            }
        }

        if (excludeTypes) {
            options.excludeTypesMap = {};
            for (var i$1 = 0, len$1 = excludeTypes.length; i$1 < len$1; i$1++) {
                options.excludeTypesMap[excludeTypes[i$1]] = true;
            }
        }

        if (objectDefaults) {
            options.objectDefaults = objectDefaults;
        }

        options.excludeUnclassifiedObjects = (params.excludeUnclassifiedObjects !== undefined) ? (!!params.excludeUnclassifiedObjects) : this._excludeUnclassifiedObjects;
        options.globalizeObjectIds = (params.globalizeObjectIds !== undefined) ? (!!params.globalizeObjectIds) : this._globalizeObjectIds;

        if (params.metaModelSrc || params.metaModelData) {

            var processMetaModelData = function (metaModelData) {

                var metaModel = this$1.viewer.metaScene.createMetaModel(modelId, metaModelData, {
                    includeTypes: includeTypes,
                    excludeTypes: excludeTypes,
                    globalizeObjectIds: this$1.globalizeObjectIds
                });

                if (!metaModel) {
                    return false;
                }

                if (params.src) {
                    this$1._loadModel(params.src, params, options, performanceModel);
                } else {
                    this$1._parseModel(params.xkt, params, options, performanceModel);
                }

                performanceModel.once("destroyed", function () {
                    this$1.viewer.metaScene.destroyMetaModel(performanceModel.id);
                });

                return true;
            };

            if (params.metaModelSrc) {

                var metaModelSrc = params.metaModelSrc;

                this.viewer.scene.canvas.spinner.processes++;

                this._dataSource.getMetaModel(metaModelSrc, function (metaModelData) {

                    if (performanceModel.destroyed) {
                        return;
                    }

                    if (!processMetaModelData(metaModelData)) {

                        this$1.error(("load(): Failed to load model metadata for model '" + modelId + " from '" + metaModelSrc + "' - metadata not valid"));

                        performanceModel.fire("error", "Metadata not valid");
                    }

                    this$1.viewer.scene.canvas.spinner.processes--;

                }, function (errMsg) {

                    this$1.error(("load(): Failed to load model metadata for model '" + modelId + " from  '" + metaModelSrc + "' - " + errMsg));

                    performanceModel.fire("error", ("Failed to load model metadata from  '" + metaModelSrc + "' - " + errMsg));

                    this$1.viewer.scene.canvas.spinner.processes--;
                });

            } else if (params.metaModelData) {

                if (!processMetaModelData(params.metaModelData)) {

                    this.error(("load(): Failed to load model metadata for model '" + modelId + " from '" + (params.metaModelSrc) + "' - metadata not valid"));

                    performanceModel.fire("error", "Metadata not valid");
                }
            }

        } else {
            if (params.src) {
                this._loadModel(params.src, params, options, performanceModel);
            } else {
                this._parseModel(params.xkt, params, options, performanceModel);
            }
        }

        return performanceModel;
    };

    XKTLoaderPlugin.prototype._loadModel = function _loadModel (src, params, options, performanceModel) {
        var this$1 = this;


        var spinner = this.viewer.scene.canvas.spinner;

        spinner.processes++;

        this._dataSource.getXKT(params.src, function (arrayBuffer) {
                this$1._parseModel(arrayBuffer, params, options, performanceModel);
                spinner.processes--;
            },
            function (errMsg) {
                spinner.processes--;
                this$1.error(errMsg);
                performanceModel.fire("error", errMsg);
            });
    };

    XKTLoaderPlugin.prototype._parseModel = function _parseModel (arrayBuffer, params, options, performanceModel) {

        if (performanceModel.destroyed) {
            return;
        }

        var dataView = new DataView(arrayBuffer);
        var dataArray = new Uint8Array(arrayBuffer);
        var xktVersion = dataView.getUint32(0, true);
        var parser = parsers[xktVersion];

        if (!parser) {
            this.error("Unsupported .XKT file version: " + xktVersion + " - this XKTLoaderPlugin supports versions " + Object.keys(parsers));
            return;
        }

        this.log("Loading .xkt V" + xktVersion);

        var numElements = dataView.getUint32(4, true);
        var elements = [];
        var byteOffset = (numElements + 2) * 4;
        for (var i = 0; i < numElements; i++) {
            var elementSize = dataView.getUint32((i + 2) * 4, true);
            elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));
            byteOffset += elementSize;
        }

        parser.parse(this.viewer, options, elements, performanceModel);

        performanceModel.finalize();

        this._createDefaultMetaModelIfNeeded(performanceModel, params, options);

        performanceModel.scene.once("tick", function () {
            if (performanceModel.destroyed) {
                return;
            }
            performanceModel.scene.fire("modelLoaded", performanceModel.id); // FIXME: Assumes listeners know order of these two events
            performanceModel.fire("loaded", true, false); // Don't forget the event, for late subscribers
        });
    };

    XKTLoaderPlugin.prototype._createDefaultMetaModelIfNeeded = function _createDefaultMetaModelIfNeeded (performanceModel, params, options) {
        var this$1 = this;


        var metaModelId = performanceModel.id;

        if (!this.viewer.metaScene.metaModels[metaModelId]) {

            var metaModelData = {
                metaObjects: []
            };

            metaModelData.metaObjects.push({
                id: metaModelId,
                type: "default",
                name: metaModelId,
                parent: null
            });

            var entityList = performanceModel.entityList;

            for (var i = 0, len = entityList.length; i < len; i++) {
                var entity = entityList[i];
                if (entity.isObject) {
                    metaModelData.metaObjects.push({
                        id: entity.id,
                        type: "default",
                        name: entity.id,
                        parent: metaModelId
                    });
                }
            }

            var src = params.src;

            this.viewer.metaScene.createMetaModel(metaModelId, metaModelData, {

                includeTypes: options.includeTypes,
                excludeTypes: options.excludeTypes,
                globalizeObjectIds: options.globalizeObjectIds,

                getProperties: async function (propertiesId) {
                    return await this$1._dataSource.getProperties(src, propertiesId);
                }
            });

            performanceModel.once("destroyed", function () {
                this$1.viewer.metaScene.destroyMetaModel(metaModelId);
            });
        }
    };

    Object.defineProperties( XKTLoaderPlugin.prototype, prototypeAccessors );

    return XKTLoaderPlugin;
}(Plugin));

/**
 * @desc Configures the normal rendered appearance of {@link Mesh}es using the non-realistic but GPU-efficient <a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">Lambertian</a> flat shading model for calculating reflectance.
 *
 * * Useful for efficiently rendering non-realistic objects for high-detail CAD.
 * * Use  {@link PhongMaterial} when you need specular highlights.
 * * Use the physically-based {@link MetallicMaterial} or {@link SpecularMaterial} when you need more realism.
 * * For LambertMaterial, the illumination calculation is performed at each triangle vertex, and the resulting color is interpolated across the face of the triangle. For {@link PhongMaterial}, {@link MetallicMaterial} and
 * {@link SpecularMaterial}, vertex normals are interpolated across the surface of the triangle, and the illumination calculation is performed at each texel.
 *
 * ## Usage
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_LambertMaterial)]
 *
 * In the example below we'll create a {@link Mesh} with a shape defined by a {@link buildTorusGeometry} and normal rendering appearance configured with a LambertMaterial.
 *
 * ```` javascript
 * import {Viewer, Mesh, buildTorusGeometry, ReadableGeometry, LambertMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 12,
 *          tubeSegments: 8,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new LambertMaterial(viewer.scene, {
 *          ambient: [0.3, 0.3, 0.3],
 *          color: [0.5, 0.5, 0.0],
 *          alpha: 1.0, // Default
 *          lineWidth: 1,
 *          pointSize: 1,
 *          backfaces: false,
 *          frontFace: "ccw"
 *      })
 *  });
 * ````
 *
 * ## LambertMaterial Properties
 *
 * The following table summarizes LambertMaterial properties:
 *
 *  | Property | Type | Range | Default Value | Space | Description |
 *  |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 *  | {@link LambertMaterial#ambient} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 *  | {@link LambertMaterial#color} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 *  | {@link LambertMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 *  | {@link LambertMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 *  | {@link LambertMaterial#lineWidth} | Number | [0..100] | 1 |  | Line width in pixels. |
 *  | {@link LambertMaterial#pointSize} | Number | [0..100] | 1 |  | Point size in pixels. |
 *  | {@link LambertMaterial#backfaces} | Boolean |  | false |  | Whether to render {@link Geometry} backfaces. |
 *  | {@link LambertMaterial#frontface} | String | "ccw", "cw" | "ccw" |  | The winding order for {@link Geometry} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |
 *
 */
var LambertMaterial = /*@__PURE__*/(function (Material) {
    function LambertMaterial(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Material.call(this, owner, cfg);

        this._state = new RenderState({
            type: "LambertMaterial",
            ambient: math.vec3([1.0, 1.0, 1.0]),
            color: math.vec3([1.0, 1.0, 1.0]),
            emissive: math.vec3([0.0, 0.0, 0.0]),
            alpha: null,
            alphaMode: 0, // 2 ("blend") when transparent, so renderer knows when to add to transparency bin
            lineWidth: null,
            pointSize: null,
            backfaces: null,
            frontface: null, // Boolean for speed; true == "ccw", false == "cw"
            hash: "/lam;"
        });

        this.ambient = cfg.ambient;
        this.color = cfg.color;
        this.emissive = cfg.emissive;
        this.alpha = cfg.alpha;
        this.lineWidth = cfg.lineWidth;
        this.pointSize = cfg.pointSize;
        this.backfaces = cfg.backfaces;
        this.frontface = cfg.frontface;
    }

    if ( Material ) LambertMaterial.__proto__ = Material;
    LambertMaterial.prototype = Object.create( Material && Material.prototype );
    LambertMaterial.prototype.constructor = LambertMaterial;

    var prototypeAccessors = { type: { configurable: true },ambient: { configurable: true },color: { configurable: true },emissive: { configurable: true },alpha: { configurable: true },lineWidth: { configurable: true },pointSize: { configurable: true },backfaces: { configurable: true },frontface: { configurable: true } };

    /**
     * Sets the LambertMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.type.get = function () {
        return "LambertMaterial";
    };

    prototypeAccessors.ambient.set = function (value) {
        var ambient = this._state.ambient;
        if (!ambient) {
            ambient = this._state.ambient = new Float32Array(3);
        } else if (value && ambient[0] === value[0] && ambient[1] === value[1] && ambient[2] === value[2]) {
            return;
        }
        if (value) {
            ambient[0] = value[0];
            ambient[1] = value[1];
            ambient[2] = value[2];
        } else {
            ambient[0] = .2;
            ambient[1] = .2;
            ambient[2] = .2;
        }
        this.glRedraw();
    };

    /**
     * Gets the LambertMaterial's ambient color.
     *
     * Default value is ````[0.3, 0.3, 0.3]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.ambient.get = function () {
        return this._state.ambient;
    };

    /**
     * Sets the LambertMaterial's diffuse color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.color.set = function (value) {
        var color = this._state.color;
        if (!color) {
            color = this._state.color = new Float32Array(3);
        } else if (value && color[0] === value[0] && color[1] === value[1] && color[2] === value[2]) {
            return;
        }
        if (value) {
            color[0] = value[0];
            color[1] = value[1];
            color[2] = value[2];
        } else {
            color[0] = 1;
            color[1] = 1;
            color[2] = 1;
        }
        this.glRedraw();
    };

    /**
     * Gets the LambertMaterial's diffuse color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.color.get = function () {
        return this._state.color;
    };

    /**
     * Sets the LambertMaterial's emissive color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.set = function (value) {
        var emissive = this._state.emissive;
        if (!emissive) {
            emissive = this._state.emissive = new Float32Array(3);
        } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
            return;
        }
        if (value) {
            emissive[0] = value[0];
            emissive[1] = value[1];
            emissive[2] = value[2];
        } else {
            emissive[0] = 0;
            emissive[1] = 0;
            emissive[2] = 0;
        }
        this.glRedraw();
    };

    /**
     * Gets the LambertMaterial's emissive color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.emissive.get = function () {
        return this._state.emissive;
    };

    /**
     * Sets factor in the range ````[0..1]```` indicating how transparent the LambertMaterial is.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.set = function (value) {
        value = (value !== undefined && value !== null) ? value : 1.0;
        if (this._state.alpha === value) {
            return;
        }
        this._state.alpha = value;
        this._state.alphaMode = value < 1.0 ? 2 /* blend */ : 0;
        /* opaque */
        this.glRedraw();
    };

    /**
     * Gets factor in the range ````[0..1]```` indicating how transparent the LambertMaterial is.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````
     *
     * @type {Number}
     */
    prototypeAccessors.alpha.get = function () {
        return this._state.alpha;
    };

    /**
     * Sets the LambertMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.set = function (value) {
        this._state.lineWidth = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the LambertMaterial's line width.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.lineWidth.get = function () {
        return this._state.lineWidth;
    };

    /**
     * Sets the LambertMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.set = function (value) {
        this._state.pointSize = value || 1.0;
        this.glRedraw();
    };

    /**
     * Gets the LambertMaterial's point size.
     *
     * Default value is ````1.0````.
     *
     * @type {Number}
     */
    prototypeAccessors.pointSize.get = function () {
        return this._state.pointSize;
    };

    /**
     * Sets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.set = function (value) {
        value = !!value;
        if (this._state.backfaces === value) {
            return;
        }
        this._state.backfaces = value;
        this.glRedraw();
    };

    /**
     * Gets whether backfaces are visible on attached {@link Mesh}es.
     *
     * @type {Boolean}
     */
    prototypeAccessors.backfaces.get = function () {
        return this._state.backfaces;
    };

    /**
     * Sets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */
    prototypeAccessors.frontface.set = function (value) {
        value = value !== "cw";
        if (this._state.frontface === value) {
            return;
        }
        this._state.frontface = value;
        this.glRedraw();
    };

    /**
     * Gets the winding direction of front faces of {@link Geometry} of attached {@link Mesh}es.
     *
     * Default value is ````"ccw"````.
     *
     * @type {String}
     */
    prototypeAccessors.frontface.get = function () {
        return this._state.frontface ? "ccw" : "cw";
    };

    LambertMaterial.prototype._getState = function _getState () {
        return this._state;
    };

    /**
     * Destroys this LambertMaterial.
     */
    LambertMaterial.prototype.destroy = function destroy () {
        Material.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( LambertMaterial.prototype, prototypeAccessors );

    return LambertMaterial;
}(Material));

/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @private
 * @type {{}}
 */
var zipLib = {};

(function (obj) {

    var ERR_BAD_FORMAT = "File format is not recognized.";
    var ERR_CRC = "CRC failed.";
    var ERR_ENCRYPTED = "File contains encrypted entry.";
    var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
    var ERR_READ = "Error while reading zip file.";
    var ERR_WRITE = "Error while writing zip file.";
    var ERR_WRITE_DATA = "Error while writing file data.";
    var ERR_READ_DATA = "Error while reading file data.";
    var ERR_DUPLICATED_NAME = "File already exists.";
    var CHUNK_SIZE = 512 * 1024;

    var TEXT_PLAIN = "text/plain";

    var appendABViewSupported;
    try {
        appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
    } catch (e) {
    }

    function Crc32() {
        this.crc = -1;
    }

    Crc32.prototype.append = function append(data) {
        var crc = this.crc | 0, table = this.table;
        for (var offset = 0, len = data.length | 0; offset < len; offset++)
            { crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF]; }
        this.crc = crc;
    };
    Crc32.prototype.get = function get() {
        return ~this.crc;
    };
    Crc32.prototype.table = (function () {
        var i, j, t, table = []; // Uint32Array is actually slower than []
        for (i = 0; i < 256; i++) {
            t = i;
            for (j = 0; j < 8; j++)
                { if (t & 1)
                    { t = (t >>> 1) ^ 0xEDB88320; }
                else
                    { t = t >>> 1; } }
            table[i] = t;
        }
        return table;
    })();

    // "no-op" codec
    function NOOP() {
    }

    NOOP.prototype.append = function append(bytes, onprogress) {
        return bytes;
    };
    NOOP.prototype.flush = function flush() {
    };

    function blobSlice(blob, index, length) {
        if (index < 0 || length < 0 || index + length > blob.size)
            { throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size); }
        if (blob.slice)
            { return blob.slice(index, index + length); }
        else if (blob.webkitSlice)
            { return blob.webkitSlice(index, index + length); }
        else if (blob.mozSlice)
            { return blob.mozSlice(index, index + length); }
        else if (blob.msSlice)
            { return blob.msSlice(index, index + length); }
    }

    function getDataHelper(byteLength, bytes) {
        var dataBuffer, dataArray;
        dataBuffer = new ArrayBuffer(byteLength);
        dataArray = new Uint8Array(dataBuffer);
        if (bytes)
            { dataArray.set(bytes, 0); }
        return {
            buffer: dataBuffer,
            array: dataArray,
            view: new DataView(dataBuffer)
        };
    }

    // Readers
    function Reader() {
    }

    function TextReader(text) {
        var that = this, blobReader;

        function init(callback, onerror) {
            var blob = new Blob([text], {
                type: TEXT_PLAIN
            });
            blobReader = new BlobReader(blob);
            blobReader.init(function () {
                that.size = blobReader.size;
                callback();
            }, onerror);
        }

        function readUint8Array(index, length, callback, onerror) {
            blobReader.readUint8Array(index, length, callback, onerror);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }

    TextReader.prototype = new Reader();
    TextReader.prototype.constructor = TextReader;

    function Data64URIReader(dataURI) {
        var that = this, dataStart;

        function init(callback) {
            var dataEnd = dataURI.length;
            while (dataURI.charAt(dataEnd - 1) == "=")
                { dataEnd--; }
            dataStart = dataURI.indexOf(",") + 1;
            that.size = Math.floor((dataEnd - dataStart) * 0.75);
            callback();
        }

        function readUint8Array(index, length, callback) {
            var i, data = getDataHelper(length);
            var start = Math.floor(index / 3) * 4;
            var end = Math.ceil((index + length) / 3) * 4;
            var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
            var delta = index - Math.floor(start / 4) * 3;
            for (i = delta; i < delta + length; i++)
                { data.array[i - delta] = bytes.charCodeAt(i); }
            callback(data.array);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }

    Data64URIReader.prototype = new Reader();
    Data64URIReader.prototype.constructor = Data64URIReader;

    function BlobReader(blob) {
        var that = this;

        function init(callback) {
            that.size = blob.size;
            callback();
        }

        function readUint8Array(index, length, callback, onerror) {
            var reader = new FileReader();
            reader.onload = function (e) {
                callback(new Uint8Array(e.target.result));
            };
            reader.onerror = onerror;
            try {
                reader.readAsArrayBuffer(blobSlice(blob, index, length));
            } catch (e) {
                onerror(e);
            }
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }

    BlobReader.prototype = new Reader();
    BlobReader.prototype.constructor = BlobReader;

    // Writers

    function Writer() {
    }

    Writer.prototype.getData = function (callback) {
        callback(this.data);
    };

    function TextWriter(encoding) {
        var that = this, blob;

        function init(callback) {
            blob = new Blob([], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function getData(callback, onerror) {
            var reader = new FileReader();
            reader.onload = function (e) {
                callback(e.target.result);
            };
            reader.onerror = onerror;
            reader.readAsText(blob, encoding);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }

    TextWriter.prototype = new Writer();
    TextWriter.prototype.constructor = TextWriter;

    function Data64URIWriter(contentType) {
        var that = this, data = "", pending = "";

        function init(callback) {
            data += "data:" + (contentType || "") + ";base64,";
            callback();
        }

        function writeUint8Array(array, callback) {
            var i, delta = pending.length, dataString = pending;
            pending = "";
            for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
                { dataString += String.fromCharCode(array[i]); }
            for (; i < array.length; i++)
                { pending += String.fromCharCode(array[i]); }
            if (dataString.length > 2)
                { data += obj.btoa(dataString); }
            else
                { pending = dataString; }
            callback();
        }

        function getData(callback) {
            callback(data + obj.btoa(pending));
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }

    Data64URIWriter.prototype = new Writer();
    Data64URIWriter.prototype.constructor = Data64URIWriter;

    function BlobWriter(contentType) {
        var blob, that = this;

        function init(callback) {
            blob = new Blob([], {
                type: contentType
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: contentType
            });
            callback();
        }

        function getData(callback) {
            callback(blob);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }

    BlobWriter.prototype = new Writer();
    BlobWriter.prototype.constructor = BlobWriter;

    /**
     * inflate/deflate core functions
     * @param worker {Worker} web worker for the task.
     * @param initialMessage {Object} initial message to be sent to the worker. should contain
     *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
     *   This function may add more properties before sending.
     */
    function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

        function onflush() {
            worker.removeEventListener('message', onmessage, false);
            onend(outputSize, crc);
        }

        function onmessage(event) {
            var message = event.data, data = message.data, err = message.error;
            if (err) {
                err.toString = function () {
                    return 'Error: ' + this.message;
                };
                onreaderror(err);
                return;
            }
            if (message.sn !== sn)
                { return; }
            if (typeof message.codecTime === 'number')
                { worker.codecTime += message.codecTime; } // should be before onflush()
            if (typeof message.crcTime === 'number')
                { worker.crcTime += message.crcTime; }

            switch (message.type) {
                case 'append':
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function () {
                            step();
                        }, onwriteerror);
                    } else
                        { step(); }
                    break;
                case 'flush':
                    crc = message.crc;
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function () {
                            onflush();
                        }, onwriteerror);
                    } else
                        { onflush(); }
                    break;
                case 'progress':
                    if (onprogress)
                        { onprogress(index + message.loaded, size); }
                    break;
                case 'importScripts': //no need to handle here
                case 'newTask':
                case 'echo':
                    break;
                default:
                    console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
            }
        }

        function step() {
            index = chunkIndex * CHUNK_SIZE;
            // use `<=` instead of `<`, because `size` may be 0.
            if (index <= size) {
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (array) {
                    if (onprogress)
                        { onprogress(index, size); }
                    var msg = index === 0 ? initialMessage : {sn: sn};
                    msg.type = 'append';
                    msg.data = array;

                    // posting a message with transferables will fail on IE10
                    try {
                        worker.postMessage(msg, [array.buffer]);
                    } catch (ex) {
                        worker.postMessage(msg); // retry without transferables
                    }
                    chunkIndex++;
                }, onreaderror);
            } else {
                worker.postMessage({
                    sn: sn,
                    type: 'flush'
                });
            }
        }

        outputSize = 0;
        worker.addEventListener('message', onmessage, false);
        step();
    }

    function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0, index, outputSize = 0,
            crcInput = crcType === 'input',
            crcOutput = crcType === 'output',
            crc = new Crc32();

        function step() {
            var outputData;
            index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                { reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (inputData) {
                    var outputData;
                    try {
                        outputData = process.append(inputData, function (loaded) {
                            if (onprogress)
                                { onprogress(index + loaded, size); }
                        });
                    } catch (e) {
                        onreaderror(e);
                        return;
                    }
                    if (outputData) {
                        outputSize += outputData.length;
                        writer.writeUint8Array(outputData, function () {
                            chunkIndex++;
                            setTimeout(step, 1);
                        }, onwriteerror);
                        if (crcOutput)
                            { crc.append(outputData); }
                    } else {
                        chunkIndex++;
                        setTimeout(step, 1);
                    }
                    if (crcInput)
                        { crc.append(inputData); }
                    if (onprogress)
                        { onprogress(index, size); }
                }, onreaderror); }
            else {
                try {
                    outputData = process.flush();
                } catch (e) {
                    onreaderror(e);
                    return;
                }
                if (outputData) {
                    if (crcOutput)
                        { crc.append(outputData); }
                    outputSize += outputData.length;
                    writer.writeUint8Array(outputData, function () {
                        onend(outputSize, crc.get());
                    }, onwriteerror);
                } else
                    { onend(outputSize, crc.get()); }
            }
        }

        step();
    }

    function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = computeCrc32 ? 'output' : 'none';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                codecClass: 'Inflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            { launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror); }
    }

    function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                options: {level: level},
                codecClass: 'Deflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
        } else
            { launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror); }
    }

    function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers && computeCrc32) {
            var initialMessage = {
                sn: sn,
                codecClass: 'NOOP',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            { launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror); }
    }

    // ZipReader

    function decodeASCII(str) {
        var i, out = "", charCode, extendedASCII = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
            '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
            '\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
            '\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
            '\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
            '\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
            '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
            '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
            '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' '];
        for (i = 0; i < str.length; i++) {
            charCode = str.charCodeAt(i) & 0xFF;
            if (charCode > 127)
                { out += extendedASCII[charCode - 128]; }
            else
                { out += String.fromCharCode(charCode); }
        }
        return out;
    }

    function decodeUTF8(string) {
        return decodeURIComponent(escape(string));
    }

    function getString(bytes) {
        var i, str = "";
        for (i = 0; i < bytes.length; i++)
            { str += String.fromCharCode(bytes[i]); }
        return str;
    }

    function getDate(timeRaw) {
        var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
        try {
            return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
                (time & 0x001F) * 2, 0);
        } catch (e) {
        }
    }

    function readCommonHeader(entry, data, index, centralDirectory, onerror) {
        entry.version = data.view.getUint16(index, true);
        entry.bitFlag = data.view.getUint16(index + 2, true);
        entry.compressionMethod = data.view.getUint16(index + 4, true);
        entry.lastModDateRaw = data.view.getUint32(index + 6, true);
        entry.lastModDate = getDate(entry.lastModDateRaw);
        if ((entry.bitFlag & 0x01) === 0x01) {
            onerror(ERR_ENCRYPTED);
            return;
        }
        if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
            entry.crc32 = data.view.getUint32(index + 10, true);
            entry.compressedSize = data.view.getUint32(index + 14, true);
            entry.uncompressedSize = data.view.getUint32(index + 18, true);
        }
        if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
            onerror(ERR_ZIP64);
            return;
        }
        entry.filenameLength = data.view.getUint16(index + 22, true);
        entry.extraFieldLength = data.view.getUint16(index + 24, true);
    }

    function createZipReader(reader, callback, onerror) {
        var inflateSN = 0;

        function Entry() {
        }

        Entry.prototype.getData = function (writer, onend, onprogress, checkCrc32) {
            var that = this;

            function testCrc32(crc32) {
                var dataCrc32 = getDataHelper(4);
                dataCrc32.view.setUint32(0, crc32);
                return that.crc32 == dataCrc32.view.getUint32(0);
            }

            function getWriterData(uncompressedSize, crc32) {
                if (checkCrc32 && !testCrc32(crc32))
                    { onerror(ERR_CRC); }
                else
                    { writer.getData(function (data) {
                        onend(data);
                    }); }
            }

            function onreaderror(err) {
                onerror(err || ERR_READ_DATA);
            }

            function onwriteerror(err) {
                onerror(err || ERR_WRITE_DATA);
            }

            reader.readUint8Array(that.offset, 30, function (bytes) {
                var data = getDataHelper(bytes.length, bytes), dataOffset;
                if (data.view.getUint32(0) != 0x504b0304) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                }
                readCommonHeader(that, data, 4, false, onerror);
                dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
                writer.init(function () {
                    if (that.compressionMethod === 0)
                        { copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror); }
                    else
                        { inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror); }
                }, onwriteerror);
            }, onreaderror);
        };

        function seekEOCDR(eocdrCallback) {
            // "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
            // Zip file comment is the last part of EOCDR and has max length of 64KB,
            // so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
            var EOCDR_MIN = 22;
            if (reader.size < EOCDR_MIN) {
                onerror(ERR_BAD_FORMAT);
                return;
            }
            var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

            // In most cases, the EOCDR is EOCDR_MIN bytes long
            doSeek(EOCDR_MIN, function () {
                // If not found, try within EOCDR_MAX bytes
                doSeek(Math.min(EOCDR_MAX, reader.size), function () {
                    onerror(ERR_BAD_FORMAT);
                });
            });

            // seek last length bytes of file for EOCDR
            function doSeek(length, eocdrNotFoundCallback) {
                reader.readUint8Array(reader.size - length, length, function (bytes) {
                    for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
                        if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
                            eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
                            return;
                        }
                    }
                    eocdrNotFoundCallback();
                }, function () {
                    onerror(ERR_READ);
                });
            }
        }

        var zipReader = {
            getEntries: function (callback) {
                var worker = this._worker;
                // look for End of central directory record
                seekEOCDR(function (dataView) {
                    var datalength, fileslength;
                    datalength = dataView.getUint32(16, true);
                    fileslength = dataView.getUint16(8, true);
                    if (datalength < 0 || datalength >= reader.size) {
                        onerror(ERR_BAD_FORMAT);
                        return;
                    }
                    reader.readUint8Array(datalength, reader.size - datalength, function (bytes) {
                        var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
                        for (i = 0; i < fileslength; i++) {
                            entry = new Entry();
                            entry._worker = worker;
                            if (data.view.getUint32(index) != 0x504b0102) {
                                onerror(ERR_BAD_FORMAT);
                                return;
                            }
                            readCommonHeader(entry, data, index + 6, true, onerror);
                            entry.commentLength = data.view.getUint16(index + 32, true);
                            entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
                            entry.offset = data.view.getUint32(index + 42, true);
                            filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
                            entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
                            if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
                                { entry.directory = true; }
                            comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
                                + entry.filenameLength + entry.extraFieldLength + entry.commentLength));
                            entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
                            entries.push(entry);
                            index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
                        }
                        callback(entries);
                    }, function () {
                        onerror(ERR_READ);
                    });
                });
            },
            close: function (callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }
                if (callback)
                    { callback(); }
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            { callback(zipReader); }
        else {
            createWorker('inflater',
                function (worker) {
                    zipReader._worker = worker;
                    callback(zipReader);
                },
                function (err) {
                    onerror(err);
                }
            );
        }
    }

    // ZipWriter

    function encodeUTF8(string) {
        return unescape(encodeURIComponent(string));
    }

    function getBytes(str) {
        var i, array = [];
        for (i = 0; i < str.length; i++)
            { array.push(str.charCodeAt(i)); }
        return array;
    }

    function createZipWriter(writer, callback, onerror, dontDeflate) {
        var files = {}, filenames = [], datalength = 0;
        var deflateSN = 0;

        function onwriteerror(err) {
            onerror(err || ERR_WRITE);
        }

        function onreaderror(err) {
            onerror(err || ERR_READ_DATA);
        }

        var zipWriter = {
            add: function (name, reader, onend, onprogress, options) {
                var header, filename, date;
                var worker = this._worker;

                function writeHeader(callback) {
                    var data;
                    date = options.lastModDate || new Date();
                    header = getDataHelper(26);
                    files[name] = {
                        headerArray: header.array,
                        directory: options.directory,
                        filename: filename,
                        offset: datalength,
                        comment: getBytes(encodeUTF8(options.comment || ""))
                    };
                    header.view.setUint32(0, 0x14000808);
                    if (options.version)
                        { header.view.setUint8(0, options.version); }
                    if (!dontDeflate && options.level !== 0 && !options.directory)
                        { header.view.setUint16(4, 0x0800); }
                    header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
                    header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
                    header.view.setUint16(22, filename.length, true);
                    data = getDataHelper(30 + filename.length);
                    data.view.setUint32(0, 0x504b0304);
                    data.array.set(header.array, 4);
                    data.array.set(filename, 30);
                    datalength += data.array.length;
                    writer.writeUint8Array(data.array, callback, onwriteerror);
                }

                function writeFooter(compressedLength, crc32) {
                    var footer = getDataHelper(16);
                    datalength += compressedLength || 0;
                    footer.view.setUint32(0, 0x504b0708);
                    if (typeof crc32 != "undefined") {
                        header.view.setUint32(10, crc32, true);
                        footer.view.setUint32(4, crc32, true);
                    }
                    if (reader) {
                        footer.view.setUint32(8, compressedLength, true);
                        header.view.setUint32(14, compressedLength, true);
                        footer.view.setUint32(12, reader.size, true);
                        header.view.setUint32(18, reader.size, true);
                    }
                    writer.writeUint8Array(footer.array, function () {
                        datalength += 16;
                        onend();
                    }, onwriteerror);
                }

                function writeFile() {
                    options = options || {};
                    name = name.trim();
                    if (options.directory && name.charAt(name.length - 1) != "/")
                        { name += "/"; }
                    if (files.hasOwnProperty(name)) {
                        onerror(ERR_DUPLICATED_NAME);
                        return;
                    }
                    filename = getBytes(encodeUTF8(name));
                    filenames.push(name);
                    writeHeader(function () {
                        if (reader)
                            { if (dontDeflate || options.level === 0)
                                { copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror); }
                            else
                                { deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror); } }
                        else
                            { writeFooter(); }
                    });
                }

                if (reader)
                    { reader.init(writeFile, onreaderror); }
                else
                    { writeFile(); }
            },
            close: function (callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }

                var data, length = 0, index = 0, indexFilename, file;
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    length += 46 + file.filename.length + file.comment.length;
                }
                data = getDataHelper(length + 22);
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    data.view.setUint32(index, 0x504b0102);
                    data.view.setUint16(index + 4, 0x1400);
                    data.array.set(file.headerArray, index + 6);
                    data.view.setUint16(index + 32, file.comment.length, true);
                    if (file.directory)
                        { data.view.setUint8(index + 38, 0x10); }
                    data.view.setUint32(index + 42, file.offset, true);
                    data.array.set(file.filename, index + 46);
                    data.array.set(file.comment, index + 46 + file.filename.length);
                    index += 46 + file.filename.length + file.comment.length;
                }
                data.view.setUint32(index, 0x504b0506);
                data.view.setUint16(index + 8, filenames.length, true);
                data.view.setUint16(index + 10, filenames.length, true);
                data.view.setUint32(index + 12, length, true);
                data.view.setUint32(index + 16, datalength, true);
                writer.writeUint8Array(data.array, function () {
                    writer.getData(callback);
                }, onwriteerror);
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            { callback(zipWriter); }
        else {
            createWorker('deflater',
                function (worker) {
                    zipWriter._worker = worker;
                    callback(zipWriter);
                },
                function (err) {
                    onerror(err);
                }
            );
        }
    }

    function resolveURLs(urls) {
        var a = document.createElement('a');
        return urls.map(function (url) {
            a.href = url;
            return a.href;
        });
    }

    var DEFAULT_WORKER_SCRIPTS = {
        deflater: ['z-worker.js', 'deflate.js'],
        inflater: ['z-worker.js', 'inflate.js']
    };

    function createWorker(type, callback, onerror) {
        if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
            onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
            return;
        }
        var scripts;
        if (obj.zip.workerScripts) {
            scripts = obj.zip.workerScripts[type];
            if (!Array.isArray(scripts)) {
                onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
                return;
            }
            scripts = resolveURLs(scripts);
        } else {
            scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
            scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
        }
        var worker = new Worker(scripts[0]);
        // record total consumed time by inflater/deflater/crc32 in this worker
        worker.codecTime = worker.crcTime = 0;
        worker.postMessage({type: 'importScripts', scripts: scripts.slice(1)});
        worker.addEventListener('message', onmessage);
        function onmessage(ev) {
            var msg = ev.data;
            if (msg.error) {
                worker.terminate(); // should before onerror(), because onerror() may throw.
                onerror(msg.error);
                return;
            }
            if (msg.type === 'importScripts') {
                worker.removeEventListener('message', onmessage);
                worker.removeEventListener('error', errorHandler);
                callback(worker);
            }
        }

        // catch entry script loading error and other unhandled errors
        worker.addEventListener('error', errorHandler);
        function errorHandler(err) {
            worker.terminate();
            onerror(err);
        }
    }

    function onerror_default(error) {
        console.error(error);
    }

    obj.zip = {
        Reader: Reader,
        Writer: Writer,
        BlobReader: BlobReader,
        Data64URIReader: Data64URIReader,
        TextReader: TextReader,
        BlobWriter: BlobWriter,
        Data64URIWriter: Data64URIWriter,
        TextWriter: TextWriter,
        createReader: function (reader, callback, onerror) {
            onerror = onerror || onerror_default;

            reader.init(function () {
                createZipReader(reader, callback, onerror);
            }, onerror);
        },
        createWriter: function (writer, callback, onerror, dontDeflate) {
            onerror = onerror || onerror_default;
            dontDeflate = !!dontDeflate;

            writer.init(function () {
                createZipWriter(writer, callback, onerror, dontDeflate);
            }, onerror);
        },
        useWebWorkers: true,
        /**
         * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
         * E.g.: zip.workerScripts = './';
         */
        workerScriptsPath: null,
        /**
         * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
         * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
         * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
         * All urls are relative to current base url.
         * E.g.:
         * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
         */
        workerScripts: null,
    };

})(zipLib);

/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @private
 */
var zipExt = function(zipObj) {

	var ERR_HTTP_RANGE = "HTTP Range not supported.";

	var Reader = zipObj.Reader;
	var Writer = zipObj.Writer;

	var ZipDirectoryEntry;

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
	} catch (e) {
	}

	function isHttpFamily(url) {
		var a = document.createElement("a");
		a.href = url;
		return a.protocol === "http:" || a.protocol === "https:";
	}

	function HttpReader(url) {
		var that = this;

		function getData(callback, onerror) {
			var request;
			if (!that.data) {
				request = new XMLHttpRequest();
				request.addEventListener("load", function () {
					if (!that.size)
						{ that.size = Number(request.getResponseHeader("Content-Length")) || Number(request.response.byteLength); }
					that.data = new Uint8Array(request.response);
					callback();
				}, false);
				request.addEventListener("error", onerror, false);
				request.open("GET", url);
				request.responseType = "arraybuffer";
				request.send();
			} else
				{ callback(); }
		}

		function init(callback, onerror) {
			if (!isHttpFamily(url)) {
				// For schemas other than http(s), HTTP HEAD may be unavailable,
				// so use HTTP GET instead.
				getData(callback, onerror);
				return;
			}
			var request = new XMLHttpRequest();
			request.addEventListener("load", function () {
				that.size = Number(request.getResponseHeader("Content-Length"));
				// If response header doesn't return size then prefetch the content.
				if (!that.size) {
					getData(callback, onerror);
				} else {
					callback();
				}
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			getData(function () {
				callback(new Uint8Array(that.data.subarray(index, index + length)));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}

	HttpReader.prototype = new Reader();
	HttpReader.prototype.constructor = HttpReader;

	function HttpRangeReader(url) {
		var that = this;

		function init(callback, onerror) {
			var request = new XMLHttpRequest();
			request.addEventListener("load", function () {
				that.size = Number(request.getResponseHeader("Content-Length"));
				if (request.getResponseHeader("Accept-Ranges") == "bytes")
					{ callback(); }
				else
					{ onerror(ERR_HTTP_RANGE); }
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readArrayBuffer(index, length, callback, onerror) {
			var request = new XMLHttpRequest();
			request.open("GET", url);
			request.responseType = "arraybuffer";
			request.setRequestHeader("Range", "bytes=" + index + "-" + (index + length - 1));
			request.addEventListener("load", function () {
				callback(request.response);
			}, false);
			request.addEventListener("error", onerror, false);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			readArrayBuffer(index, length, function (arraybuffer) {
				callback(new Uint8Array(arraybuffer));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}

	HttpRangeReader.prototype = new Reader();
	HttpRangeReader.prototype.constructor = HttpRangeReader;

	function ArrayBufferReader(arrayBuffer) {
		var that = this;

		function init(callback, onerror) {
			that.size = arrayBuffer.byteLength;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			callback(new Uint8Array(arrayBuffer.slice(index, index + length)));
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}

	ArrayBufferReader.prototype = new Reader();
	ArrayBufferReader.prototype.constructor = ArrayBufferReader;

	function ArrayBufferWriter() {
		var array, that = this;

		function init(callback, onerror) {
			array = new Uint8Array();
			callback();
		}

		function writeUint8Array(arr, callback, onerror) {
			var tmpArray = new Uint8Array(array.length + arr.length);
			tmpArray.set(array);
			tmpArray.set(arr, array.length);
			array = tmpArray;
			callback();
		}

		function getData(callback) {
			callback(array.buffer);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}

	ArrayBufferWriter.prototype = new Writer();
	ArrayBufferWriter.prototype.constructor = ArrayBufferWriter;

	function FileWriter(fileEntry, contentType) {
		var writer, that = this;

		function init(callback, onerror) {
			fileEntry.createWriter(function (fileWriter) {
				writer = fileWriter;
				callback();
			}, onerror);
		}

		function writeUint8Array(array, callback, onerror) {
			var blob = new Blob([appendABViewSupported ? array : array.buffer], {
				type: contentType
			});
			writer.onwrite = function () {
				writer.onwrite = null;
				callback();
			};
			writer.onerror = onerror;
			writer.write(blob);
		}

		function getData(callback) {
			fileEntry.file(callback);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}

	FileWriter.prototype = new Writer();
	FileWriter.prototype.constructor = FileWriter;

	zipObj.FileWriter = FileWriter;
	zipObj.HttpReader = HttpReader;
	zipObj.HttpRangeReader = HttpRangeReader;
	zipObj.ArrayBufferReader = ArrayBufferReader;
	zipObj.ArrayBufferWriter = ArrayBufferWriter;

	if (zipObj.fs) {
		ZipDirectoryEntry = zipObj.fs.ZipDirectoryEntry;
		ZipDirectoryEntry.prototype.addHttpContent = function (name, URL, useRangeHeader) {
			function addChild(parent, name, params, directory) {
				if (parent.directory)
					{ return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zipObj.fs.ZipFileEntry(parent.fs, name, params, parent); }
				else
					{ throw "Parent entry is not a directory."; }
			}

			return addChild(this, name, {
				data: URL,
				Reader: useRangeHeader ? HttpRangeReader : HttpReader
			});
		};
		ZipDirectoryEntry.prototype.importHttpContent = function (URL, useRangeHeader, onend, onerror) {
			this.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);
		};
		zipObj.fs.FS.prototype.importHttpContent = function (URL, useRangeHeader, onend, onerror) {
			this.entries = [];
			this.root = new ZipDirectoryEntry(this);
			this.root.importHttpContent(URL, useRangeHeader, onend, onerror);
		};
	}
};

var zip = zipLib.zip;
zipExt(zip);

var supportedSchemas = ["4.2"];

/**
 * @private
 */
var XML3DSceneGraphLoader = function XML3DSceneGraphLoader(plugin, cfg) {
    if ( cfg === void 0 ) cfg = {};


    /**
     * Supported 3DXML schema versions
     * @property supportedSchemas
     * @type {string[]}
     */
    this.supportedSchemas = supportedSchemas;

    this._xrayOpacity = 0.7;
    this._src = null;
    this._options = cfg;

    /**
     * Default viewpoint, containing eye, look and up vectors.
     * Only defined if found in the 3DXML file.
     * @property viewpoint
     * @type {Number[]}
     */
    this.viewpoint = null;

    if (!cfg.workerScriptsPath) {
        plugin.error("Config expected: workerScriptsPath");
        return
    }
    zip.workerScriptsPath = cfg.workerScriptsPath;

    this.src = cfg.src;
    this.xrayOpacity = 0.7;
    this.displayEffect = cfg.displayEffect;
    this.createMetaModel = cfg.createMetaModel;
};

XML3DSceneGraphLoader.prototype.load = function load (plugin, modelNode, src, options, ok, error) {

    switch (options.materialType) {
        case "MetallicMaterial":
            modelNode._defaultMaterial = new MetallicMaterial(modelNode, {
                baseColor: [1, 1, 1],
                metallic: 0.6,
                roughness: 0.6
            });
            break;

        case "SpecularMaterial":
            modelNode._defaultMaterial = new SpecularMaterial(modelNode, {
                diffuse: [1, 1, 1],
                specular: math.vec3([1.0, 1.0, 1.0]),
                glossiness: 0.5
            });
            break;

        default:
            modelNode._defaultMaterial = new PhongMaterial(modelNode, {
                reflectivity: 0.75,
                shiness: 100,
                diffuse: [1, 1, 1]
            });
    }

    modelNode._wireframeMaterial = new LambertMaterial(modelNode, {
        color: [0, 0, 0],
        lineWidth: 2
    });

    var spinner = modelNode.scene.canvas.spinner;
    spinner.processes++;

    load3DXML(plugin, modelNode, src, options, function () {
            spinner.processes--;
            if (ok) {
                ok();
            }
            modelNode.fire("loaded", true, false);
        },
        function (msg) {
            spinner.processes--;
            modelNode.error(msg);
            if (error) {
                error(msg);
            }
            /**
             Fired whenever this XML3D fails to load the 3DXML file
             specified by {@link XML3D/src}.
             @event error
             @param msg {String} Description of the error
             */
            modelNode.fire("error", msg);
        },
        function (err) {
            console.log("Error, Will Robinson: " + err);
        });
};

var load3DXML = (function () {
    return function (plugin, modelNode, src, options, ok, error) {
        loadZIP(src, function (zip) { // OK
                parse3DXML(plugin, zip, options, modelNode, ok, error);
            },
            error);
    };
})();

var parse3DXML = (function () {
    return function (plugin, zip, options, modelNode, ok) {
        var ctx = {
            plugin: plugin,
            zip: zip,
            edgeThreshold: 30, // Guess at degrees of normal deviation between adjacent tris below which we remove edge between them
            materialType: options.materialType,
            scene: modelNode.scene,
            modelNode: modelNode,
            info: {
                references: {}
            },
            materials: {}
        };

        if (options.createMetaModel) {
            ctx.metaModelData = {
                modelId: modelNode.id,
                metaObjects: [{
                    name: modelNode.id,
                    type: "Default",
                    id: modelNode.id
                }]
            };
        }
        modelNode.scene.loading++; // Disables (re)compilation

        parseDocument(ctx, function () {
            if (ctx.metaModelData) {
                plugin.viewer.metaScene.createMetaModel(modelNode.id, ctx.metaModelData);
            }
            modelNode.scene.loading--; // Re-enables (re)compilation
            ok();
        });
    };

    function parseDocument(ctx, ok) {
        ctx.zip.getFile("Manifest.xml", function (xmlDoc, json) {
            var node = json;
            var children = node.children;
            for (var i = 0, len = children.length; i < len; i++) {
                var child = children[i];
                switch (child.type) {
                    case "Manifest":
                        parseManifest(ctx, child, ok);
                        break;
                }
            }
        });
    }

    function parseManifest(ctx, manifest, ok) {
        var children = manifest.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Root":
                    var rootFileSrc = child.children[0];
                    ctx.zip.getFile(rootFileSrc, function (xmlDoc, json) {
                        parseRoot(ctx, json, ok);
                    });
                    break;
            }
        }
    }

    function parseRoot(ctx, node, ok) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Model_3dxml":
                    parseModel(ctx, child, ok);
                    break;
            }
        }
    }

    function parseModel(ctx, node, ok) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Header":
                    parseHeader(ctx, child);
                    break;
                case "ProductStructure":
                    parseProductStructure(ctx, child, ok);
                    break;
                case "DefaultView":
                    parseDefaultView(ctx, child);
                    break;
            }
        }
    }

    function parseHeader(ctx, node) {
        var children = node.children;
        var metaData = {};
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "SchemaVersion":
                    metaData.schemaVersion = child.children[0];
                    if (!isSchemaVersionSupported(ctx, metaData.schemaVersion)) {
                        ctx.plugin.error("Schema version not supported: " + metaData.schemaVersion + " - supported versions are: " + ctx.modelNode.supportedSchemas.join(","));
                    }
                    break;
                case "Title":
                    metaData.title = child.children[0];
                    break;
                case "Author":
                    metaData.author = child.children[0];
                    break;
                case "Created":
                    metaData.created = child.children[0];
                    break;
            }
        }
        ctx.modelNode.meta = metaData;
    }

    function isSchemaVersionSupported(ctx, schemaVersion) {
        for (var i = 0, len = supportedSchemas.length; i < len; i++) {
            if (schemaVersion === supportedSchemas[i]) {
                return true;
            }
        }
        return false;
    }

    function parseProductStructure(ctx, productStructureNode, ok) {

        parseReferenceReps(ctx, productStructureNode, function (referenceReps) {

            // Parse out an intermediate scene DAG representation, that we can then
            // recursive descend through to build a xeokit Object hierarchy.

            var children = productStructureNode.children;

            var reference3Ds = {};
            var instanceReps = {};
            var instance3Ds = {};

            // Map all the elements

            for (var i = 0, len = children.length; i < len; i++) {
                var child = children[i];
                switch (child.type) {

                    case "Reference3D":
                        reference3Ds[child.id] = {
                            type: "Reference3D",
                            id: child.id,
                            name: child.name,
                            instance3Ds: {},
                            instanceReps: {}
                        };
                        break;

                    case "InstanceRep":
                        var isAggregatedBy;
                        var isInstanceOf;
                        var relativeMatrix;
                        for (var j = 0, lenj = child.children.length; j < lenj; j++) {
                            var child2 = child.children[j];
                            switch (child2.type) {
                                case "IsAggregatedBy":
                                    isAggregatedBy = child2.children[0];
                                    break;
                                case "IsInstanceOf":
                                    isInstanceOf = child2.children[0];
                                    break;
                            }
                        }
                        instanceReps[child.id] = {
                            type: "InstanceRep",
                            id: child.id,
                            name: child.name,
                            isAggregatedBy: isAggregatedBy,
                            isInstanceOf: isInstanceOf,
                            referenceReps: {}
                        };
                        break;

                    case "Instance3D":
                        var isAggregatedBy;
                        var isInstanceOf;
                        var relativeMatrix;
                        for (var j = 0, lenj = child.children.length; j < lenj; j++) {
                            var child2 = child.children[j];
                            switch (child2.type) {
                                case "IsAggregatedBy":
                                    isAggregatedBy = child2.children[0];
                                    break;
                                case "IsInstanceOf":
                                    isInstanceOf = child2.children[0];
                                    break;
                                case "RelativeMatrix":
                                    relativeMatrix = child2.children[0];
                                    break;
                            }
                        }
                        instance3Ds[child.id] = {
                            type: "Instance3D",
                            id: child.id,
                            name: child.name,
                            isAggregatedBy: isAggregatedBy,
                            isInstanceOf: isInstanceOf,
                            relativeMatrix: relativeMatrix,
                            reference3Ds: {}
                        };
                        break;
                }
            }

            // Connect Reference3Ds to the Instance3Ds they aggregate

            for (var id in instance3Ds) {
                var instance3D = instance3Ds[id];
                var reference3D = reference3Ds[instance3D.isAggregatedBy];
                if (reference3D) {
                    reference3D.instance3Ds[instance3D.id] = instance3D;
                } else {
                    alert("foo");
                }
            }

            // Connect Instance3Ds to the Reference3Ds they instantiate

            for (var id in instance3Ds) {
                var instance3D = instance3Ds[id];
                var reference3D = reference3Ds[instance3D.isInstanceOf];
                instance3D.reference3Ds[reference3D.id] = reference3D;
                reference3D.instance3D = instance3D;
            }

            // Connect InstanceReps to the ReferenceReps they instantiate

            for (var id in instanceReps) {
                var instanceRep = instanceReps[id];
                var referenceRep = referenceReps[instanceRep.isInstanceOf];
                if (referenceRep) {
                    instanceRep.referenceReps[referenceRep.id] = referenceRep;
                }
            }

            // Connect Reference3Ds to the InstanceReps they aggregate

            for (var id in instanceReps) {
                var instanceRep = instanceReps[id];
                var reference3D = reference3Ds[instanceRep.isAggregatedBy];
                if (reference3D) {
                    reference3D.instanceReps[instanceRep.id] = instanceRep;
                }
            }

            function parseReference3D(ctx, reference3D, group) {
                //ctx.plugin.log("parseReference3D( " + reference3D.id + " )");
                for (var id in reference3D.instance3Ds) {
                    parseInstance3D(ctx, reference3D.instance3Ds[id], group);
                }
                for (var id in reference3D.instanceReps) {
                    parseInstanceRep(ctx, reference3D.instanceReps[id], group);
                }
            }

            function parseInstance3D(ctx, instance3D, group) {
                //ctx.plugin.log("parseInstance3D( " + instance3D.id + " )");

                if (instance3D.relativeMatrix) {
                    var matrix = parseFloatArray(instance3D.relativeMatrix, 12);
                    var translate = [matrix[9], matrix[10], matrix[11]];
                    var mat3 = matrix.slice(0, 9); // Rotation matrix
                    var mat4 = math.mat3ToMat4(mat3, math.identityMat4()); // Convert rotation matrix to 4x4
                    var childGroup = new Node(ctx.modelNode, {
                        position: translate
                    });
                    if (ctx.metaModelData) {
                        ctx.metaModelData.metaObjects.push({
                            id: childGroup.id,
                            type: "Default",
                            name: instance3D.name,
                            parent: group ? group.id : ctx.modelNode.id
                        });
                    }
                    if (group) {
                        group.addChild(childGroup, true);
                    } else {
                        ctx.modelNode.addChild(childGroup, true);
                    }
                    group = childGroup;
                    childGroup = new Node(ctx.modelNode, {
                        matrix: mat4
                    });
                    if (ctx.metaModelData) {
                        ctx.metaModelData.metaObjects.push({
                            id: childGroup.id,
                            type: "Default",
                            name: instance3D.name,
                            parent: group ? group.id : ctx.modelNode.id
                        });
                    }
                    group.addChild(childGroup, true);
                    group = childGroup;
                } else {
                    var childGroup = new Node(ctx.modelNode, {});
                    if (ctx.metaModelData) {
                        ctx.metaModelData.metaObjects.push({
                            id: childGroup.id,
                            type: "Default",
                            name: instance3D.name,
                            parent: group ? group.id : ctx.modelNode.id
                        });
                    }
                    if (group) {
                        group.addChild(childGroup, true);
                    } else {
                        ctx.modelNode.addChild(childGroup, true);
                    }
                    group = childGroup;
                }
                for (var id in instance3D.reference3Ds) {
                    parseReference3D(ctx, instance3D.reference3Ds[id], group);
                }
            }

            function parseInstanceRep(ctx, instanceRep, group) {
                //ctx.plugin.log("parseInstanceRep( " + instanceRep.id + " )");
                if (instanceRep.referenceReps) {
                    for (var id in instanceRep.referenceReps) {
                        var referenceRep = instanceRep.referenceReps[id];
                        for (var id2 in referenceRep) {
                            if (id2 === "id") {
                                continue; // HACK
                            }
                            var meshCfg = referenceRep[id2];
                            var lines = meshCfg.geometry.primitive === "lines";
                            var material = lines ? ctx.modelNode._wireframeMaterial : (meshCfg.materialId ? ctx.materials[meshCfg.materialId] : null);
                            var colorize = meshCfg.color;
                            var mesh = new Mesh(ctx.modelNode, {
                                isObject: true,
                                geometry: meshCfg.geometry,
                                material: material || ctx.modelNode._defaultMaterial,
                                colorize: colorize,
                                backfaces: false
                            });
                            if (ctx.metaModelData) {
                                ctx.metaModelData.metaObjects.push({
                                    id: mesh.id,
                                    type: "Default",
                                    name: instanceRep.name,
                                    parent: group ? group.id : ctx.modelNode.id
                                });
                            }
                            if (group) {
                                group.addChild(mesh, true);
                            } else {
                                ctx.modelNode.addChild(mesh, true);
                            }
                            mesh.colorize = colorize; // HACK: Mesh has inherited modelNode's colorize state, so we need to restore it (we'd better not modify colorize on the modelNode).
                        }
                    }
                }
            }

            // Find the root Reference3D

            for (var id in reference3Ds) {
                var reference3D = reference3Ds[id];
                if (!reference3D.instance3D) {
                    parseReference3D(ctx, reference3D, null); // HACK: Assuming that root has id == "1"
                    ok();
                    return;
                }
            }

            alert("No root Reference3D element found in this modelNode - can't load.");

            ok();
        });
    }

    function parseIntArray(str) {
        var parts = str.trim().split(" ");
        var result = new Int32Array(parts.length);
        for (var i = 0; i < parts.length; i++) {
            result[i] = parseInt(parts[i]);
        }
        return result;
    }

    function parseReferenceReps(ctx, node, ok) {
        var referenceReps = {};
        var children = node.children;
        var numToLoad = 0;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            if (child.type === "ReferenceRep") {
                numToLoad++;
            }
        }
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "ReferenceRep":
                    if (child.associatedFile) {
                        var src = stripURN(child.associatedFile);
                        (function () {
                            var childId = child.id;
                            ctx.zip.getFile(src, function (xmlDoc, json) {

                                    var materialIds = xmlDoc.getElementsByTagName("MaterialId");

                                    loadCATMaterialRefDocuments(ctx, materialIds, function () {

                                        // ctx.plugin.log("reference loaded: " + src);
                                        var referenceRep = {
                                            id: childId
                                        };
                                        parse3DRepDocument(ctx, json, referenceRep);
                                        referenceReps[childId] = referenceRep;
                                        if (--numToLoad === 0) {
                                            ok(referenceReps);
                                        }
                                    });
                                },
                                function (error) {
                                    // TODO:
                                });
                        })();
                    }
                    break;
            }
        }
    }


    function parseDefaultView(ctx, node) {
        // ctx.plugin.log("parseDefaultView");
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Viewpoint":
                    var children2 = child.children;
                    ctx.modelNode.viewpoint = {};
                    for (var i2 = 0, len2 = children2.length; i2 < len2; i2++) {
                        var child2 = children2[i];
                        switch (child2.type) {
                            case "Position":
                                ctx.modelNode.viewpoint.eye = parseFloatArray(child2.children[0], 3);
                                break;
                            case "Sight":
                                ctx.modelNode.viewpoint.look = parseFloatArray(child2.children[0], 3);
                                break;
                            case "Up":
                                ctx.modelNode.viewpoint.up = parseFloatArray(child2.children[0], 3);
                                break;
                        }
                    }
                    break;
            }
        }
    }

    function parse3DRepDocument(ctx, node, result) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "XMLRepresentation":
                    parseXMLRepresentation(ctx, child, result);
                    break;
            }
        }
    }

    function parseXMLRepresentation(ctx, node, result) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Root":
                    parse3DRepRoot(ctx, child, result);
                    break;
            }
        }
    }

    function parse3DRepRoot(ctx, node, result) {
        switch (node["xsi:type"]) {
                    }
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Rep":
                    parse3DRepRep(ctx, child, result);
                    break;
            }
        }
    }

    function parse3DRepRep(ctx, node, result) {
        switch (node["xsi:type"]) {
                    }
        var meshesResult = {
            edgeThreshold: ctx.edgeThreshold || 30,
            compressGeometry: true
        };
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Rep":
                    parse3DRepRep(ctx, child, result);
                    break;
                case "Edges":
                    // Ignoring edges because we auto-generate our own using xeokit
                    break;
                case "Faces":
                    meshesResult.primitive = "triangles";
                    parseFaces(ctx, child, meshesResult);
                    break;
                case "VertexBuffer":
                    parseVertexBuffer(ctx, child, meshesResult);
                    break;
                case "SurfaceAttributes":
                    parseSurfaceAttributes(ctx, child, meshesResult);
                    break;
            }
        }
        if (meshesResult.positions) {
            var geometry = new ReadableGeometry(ctx.modelNode, meshesResult);
            result[geometry.id] = {
                geometry: geometry,
                color: meshesResult.color || [1.0, 1.0, 1.0, 1.0],
                materialId: meshesResult.materialId
            };
        }
    }

    function parseFaces(ctx, node, result) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Face":
                    parseFace(ctx, child, result);
                    break;
            }
        }
    }

    function parseFace(ctx, node, result) {
        var strips = node.strips;
        if (strips) {
            // Triangle strips
            var arrays = parseIntArrays(strips);
            if (arrays.length > 0) {
                result.primitive = "triangles";
                var indices = [];
                for (var i = 0, len = arrays.length; i < len; i++) {
                    var array = convertTriangleStrip(arrays[i]);
                    for (var j = 0, lenj = array.length; j < lenj; j++) {
                        indices.push(array[j]);
                    }
                }
                result.indices = indices; // TODO
            }
        } else {
            // Triangle meshes
            var triangles = node.triangles;
            if (triangles) {
                result.primitive = "triangles";
                result.indices = parseIntArray(triangles);
            }
        }
        // Material
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "SurfaceAttributes":
                    parseSurfaceAttributes(ctx, child, result);
                    break;
            }
        }
    }

    function convertTriangleStrip(indices) {
        var indices2 = [];
        for (var i = 0, len = indices.length; i < len - 2; i++) {
            {
                if (i & 1) { //
                    indices2.push(indices[i]);
                    indices2.push(indices[i + 2]);
                    indices2.push(indices[i + 1]);
                } else {
                    indices2.push(indices[i]);
                    indices2.push(indices[i + 1]);
                    indices2.push(indices[i + 2]);
                }
            }
        }
        return indices2;
    }

    function parseVertexBuffer(ctx, node, result) {
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Positions":
                    result.positions = parseFloatArray(child.children[0], 3);
                    break;
                case "Normals":
                    result.normals = parseFloatArray(child.children[0], 3);
                    break;
                case "TextureCoordinates": // TODO: Support dimension and channel?
                    result.uv = parseFloatArray(child.children[0], 2);
                    break;
            }
        }
    }

    function parseIntArrays(str) {
        var coordStrings = str.split(",");
        var array = [];
        for (var i = 0, len = coordStrings.length; i < len; i++) {
            var coordStr = coordStrings[i].trim();
            if (coordStr.length > 0) {
                var elemStrings = coordStr.trim().split(" ");
                var arr = new Int16Array(elemStrings.length);
                var arrIdx = 0;
                for (var j = 0, lenj = elemStrings.length; j < lenj; j++) {
                    if (elemStrings[j] !== "") {
                        arr[arrIdx++] = parseInt(elemStrings[j]);
                    }
                }
                array.push(arr);
            }
        }
        return array;
    }

    function parseFloatArray(str, numElems) {
        str = str.split(",");
        var arr = new Float32Array(str.length * numElems);
        var arrIdx = 0;
        for (var i = 0, len = str.length; i < len; i++) {
            var value = str[i];
            value = value.split(" ");
            for (var j = 0, lenj = value.length; j < lenj; j++) {
                if (value[j] !== "") {
                    arr[arrIdx++] = parseFloat(value[j]);
                }
            }
        }
        return arr;
    }

    function parseIntArray(str) {
        str = str.trim().split(" ");
        var arr = new Int32Array(str.length);
        for (var i = 0, len = str.length; i < len; i++) {
            var value = str[i];
            arr[i] = parseInt(value);
        }
        return arr;
    }

    function parseSurfaceAttributes(ctx, node, result) {
        result.color = [1, 1, 1, 1];
        var children = node.children;
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            switch (child.type) {
                case "Color":
                    result.color[0] = child.red;
                    result.color[1] = child.green;
                    result.color[2] = child.blue;
                    result.color[3] = child.alpha;
                    break;
                case "MaterialApplication":
                    var children2 = child.children;
                    for (var j = 0, lenj = children2.length; j < lenj; j++) {
                        var child2 = children2[j];
                        switch (child2.type) {
                            case "MaterialId":
                                var materialId = getIDFromURI(child2.id);
                                var material = ctx.materials[materialId];
                                if (!material) {
                                    ctx.plugin.error("material  not found: " + materialId);
                                }
                                result.materialId = materialId;
                                break;
                        }
                    }
                    break;
            }
        }
    }
})();

function loadCATMaterialRefDocuments(ctx, materialIds, ok) {
    var loaded = {};

    function load(i, done) {
        if (i >= materialIds.length) {
            ok();
            return;
        }
        var materialId = materialIds[i];
        var src = materialId.id;
        var colonIdx = src.lastIndexOf(":");
        if (colonIdx > 0) {
            src = src.substring(colonIdx + 1);
        }
        var hashIdx = src.lastIndexOf("#");
        if (hashIdx > 0) {
            src = src.substring(0, hashIdx);
        }
        if (!loaded[src]) {
            loadCATMaterialRefDocument(ctx, src, function () {
                loaded[src] = true;
                load(i + 1);
            });
        } else {
            load(i + 1);
        }
    }

    load(0);
}

function loadCATMaterialRefDocument(ctx, src, ok) { // Loads CATMaterialRef.3dxml
    ctx.zip.getFile(src, function (xmlDoc, json) {
        parseCATMaterialRefDocument(ctx, json, ok);
    });
}

function parseCATMaterialRefDocument(ctx, node, ok) { // Parse CATMaterialRef.3dxml
    // ctx.plugin.log("parseCATMaterialRefDocument");
    var children = node.children;
    var child;
    for (var i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.type === "Model_3dxml") {
            parseModel_3dxml(ctx, child, ok);
        }
    }
}

function parseModel_3dxml(ctx, node, ok) { // Parse CATMaterialRef.3dxml
    // ctx.plugin.log("parseModel_3dxml");
    var children = node.children;
    var child;
    for (var i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.type === "CATMaterialRef") {
            parseCATMaterialRef(ctx, child, ok);
        }
    }
}

function parseCATMaterialRef(ctx, node, ok) {
    var domainToReferenceMap = {};
    var children = node.children;
    var numToLoad = 0;
    for (var j = 0, lenj = children.length; j < lenj; j++) {
        var child2 = children[j];
        switch (child2.type) {
            case "MaterialDomainInstance":
                var isAggregatedBy;
                var isInstanceOf;
                for (var k = 0, lenk = child2.children.length; k < lenk; k++) {
                    var child3 = child2.children[k];
                    switch (child3.type) {
                        case "IsAggregatedBy":
                            isAggregatedBy = child3.children[0];
                            break;
                        case "IsInstanceOf":
                            isInstanceOf = child3.children[0];
                            break;
                    }
                }
                domainToReferenceMap[isInstanceOf] = isAggregatedBy;
                break;
        }
    }
    for (var j = 0, lenj = children.length; j < lenj; j++) {
        var child2 = children[j];
        switch (child2.type) {
            case "MaterialDomain":
                numToLoad++;
                break;
        }
    }
    // Now load them
    for (var j = 0, lenj = children.length; j < lenj; j++) {
        var child2 = children[j];
        switch (child2.type) {
            case "MaterialDomain":
                if (child2.associatedFile) {
                    (function () {
                        var childId = child2.id;
                        var src = stripURN(child2.associatedFile);
                        ctx.zip.getFile(src, function (xmlDoc, json) {
                                // ctx.plugin.log("Material def loaded: " + src);
                                ctx.materials[domainToReferenceMap[childId]] = parseMaterialDefDocument(ctx, json);

                                if (--numToLoad === 0) {
                                    //       console.log("All ReferenceReps loaded.");
                                    ok();
                                }
                            },
                            function (error) {
                                // TODO:
                            });
                    })();
                }
                break;
        }
    }
}

function parseMaterialDefDocument(ctx, node) {
    var children = node.children;
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        switch (child.type) {
            case "Osm":
                return parseMaterialDefDocumentOsm(ctx, child);
        }
    }
}

function parseMaterialDefDocumentOsm(ctx, node) {
    var children = node.children;
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        switch (child.type) {
            case "RenderingRootFeature":
                //..
                break;
            case "Feature":

                if (child.Alias === "RenderingFeature") {
                    // Parse the coefficients, then parse the colors, scaling those by their coefficients.
                    var coeffs = {};
                    var materialCfg = {};
                    var children2 = child.children;
                    var j;
                    var lenj;
                    var child2;
                    for (j = 0, lenj = children2.length; j < lenj; j++) {
                        child2 = children2[j];
                        switch (child2.Name) {
                            case "AmbientCoef":
                                coeffs.ambient = parseFloat(child2.Value);
                                break;
                            case "DiffuseCoef":
                                coeffs.diffuse = parseFloat(child2.Value);
                                break;
                            case "EmissiveCoef":
                                coeffs.emissive = parseFloat(child2.Value);
                                break;
                            case "SpecularExponent":
                                coeffs.specular = parseFloat(child2.Value);
                                break;
                        }
                    }
                    for (j = 0, lenj = children2.length; j < lenj; j++) {
                        child2 = children2[j];
                        switch (child2.Name) {
                            case "AmbientColor":
                                materialCfg.ambient = parseRGB(child2.Value, coeffs.ambient);
                                break;
                            case "DiffuseColor":
                                materialCfg.diffuse = parseRGB(child2.Value, coeffs.diffuse);
                                break;
                            case "EmissiveColor":
                                materialCfg.emissive = parseRGB(child2.Value, coeffs.emissive);
                                break;
                            case "SpecularColor":
                                materialCfg.specular = parseRGB(child2.Value, coeffs.specular);
                                break;
                            case "Transparency":
                                var alpha = 1.0 - parseFloat(child2.Value); // GOTCHA: Degree of transparency, not degree of opacity
                                if (alpha < 1.0) {
                                    materialCfg.alpha = alpha;
                                    materialCfg.alphaMode = "blend";
                                }
                                break;
                        }
                    }

                    var material;

                    switch (ctx.materialType) {
                        case "MetallicMaterial":
                            material = new MetallicMaterial(ctx.modelNode, {
                                baseColor: materialCfg.diffuse,
                                metallic: 0.7,
                                roughness: 0.5,
                                emissive: materialCfg.emissive,
                                alpha: materialCfg.alpha,
                                alphaMode: materialCfg.alphaMode
                            });
                            break;

                        case "SpecularMaterial":
                            material = new SpecularMaterial(ctx.modelNode, {
                                diffuse: materialCfg.diffuse,
                                specular: materialCfg.specular,
                                glossiness: 0.5,
                                emissive: materialCfg.emissive,
                                alpha: materialCfg.alpha,
                                alphaMode: materialCfg.alphaMode
                            });
                            break;

                        default:
                            material = new PhongMaterial(ctx.modelNode, {
                                reflectivity: 0.5,
                                ambient: materialCfg.ambient,
                                diffuse: materialCfg.diffuse,
                                specular: materialCfg.specular,
                                // shininess: node.shine,
                                emissive: materialCfg.emissive,
                                alphaMode: materialCfg.alphaMode,
                                alpha: node.alpha
                            });
                    }
                    return material;
                }
                break;
        }
    }
}

function parseRGB(str, coeff) {
    coeff = (coeff !== undefined) ? coeff : 0.5;
    var openBracketIndex = str.indexOf("[");
    var closeBracketIndex = str.indexOf("]");
    str = str.substring(openBracketIndex + 1, closeBracketIndex - openBracketIndex);
    str = str.split(",");
    var arr = new Float32Array(str.length);
    var arrIdx = 0;
    for (var i = 0, len = str.length; i < len; i++) {
        var value = str[i];
        value = value.trim().split(" ");
        for (var j = 0, lenj = value.length; j < lenj; j++) {
            if (value[j] !== "") {
                arr[arrIdx++] = parseFloat(value[j]) * coeff;
            }
        }
    }
    return arr;
}


//----------------------------------------------------------------------------------------------------

/**
 * Wraps zip.js to provide an in-memory ZIP archive representing the 3DXML file bundle.
 *
 * Allows us to pluck each file from it as XML and JSON.
 *
 * @constructor
 */
var ZIP = function () {

    var reader;
    var files = {};

    /**
     Loads this ZIP

     @param src
     @param ok
     @param error
     */
    this.load = function (src, ok, error) {
        zip.createReader(new zip.HttpReader(src), function (reader) {
            reader.getEntries(function (entries) {
                if (entries.length > 0) {
                    for (var i = 0, len = entries.length; i < len; i++) {
                        var entry = entries[i];
                        files[entry.filename] = entry;
                    }
                }
                ok();
            });
        }, error);
    };

    /**
     Gets a file as XML and JSON from this ZIP
     @param src
     @param ok
     @param error
     */
    this.getFile = function (src, ok, error) {
        var entry = files[src];
        if (!entry) {
            var errMsg = "ZIP entry not found: " + src;
            console.error(errMsg);
            if (error) {
                error(errMsg);
            }
            return;
        }
        entry.getData(new zip.TextWriter(), function (text) {

            // Parse to XML
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(text, "text/xml");

            // Parse to JSON
            var json = xmlToJSON(xmlDoc, {});

            ok(xmlDoc, json);
        });
    };

    function xmlToJSON(node, attributeRenamer) {
        if (node.nodeType === node.TEXT_NODE) {
            var v = node.nodeValue;
            if (v.match(/^\s+$/) === null) {
                return v;
            }
        } else if (node.nodeType === node.ELEMENT_NODE ||
            node.nodeType === node.DOCUMENT_NODE) {
            var json = {type: node.nodeName, children: []};
            if (node.nodeType === node.ELEMENT_NODE) {
                for (var j = 0; j < node.attributes.length; j++) {
                    var attribute = node.attributes[j];
                    var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;
                    json[nm] = attribute.nodeValue;
                }
            }
            for (var i = 0; i < node.childNodes.length; i++) {
                var item = node.childNodes[i];
                var j = xmlToJSON(item, attributeRenamer);
                if (j) { json.children.push(j); }
            }
            return json;
        }
    }

    /**
     Disposes of this ZIP
     */
    this.destroy = function () {
        reader.close(function () {
            // onclose callback
        });
    };
};

function

loadZIP(src, ok, err) {
    var zip = new ZIP();
    zip.load(src, function () {
        ok(zip);
    }, function (errMsg) {
        err("Error loading ZIP archive: " + errMsg);
    });
}

function

stripURN(str) {
    var subStr = "urn:3DXML:";
    return (str.indexOf(subStr) === 0) ? str.substring(subStr.length) : str;
}


function

getIDFromURI(str) {
    var hashIdx = str.lastIndexOf("#");
    return hashIdx !== -1 ? str.substring(hashIdx + 1) : str;
}

/**
 * {@link Viewer} plugin that loads models from [3DXML](https://en.wikipedia.org/wiki/3DXML) files.
 *
 * [<img src="https://xeokit.io/img/docs/XML3DLoaderPlugin/XML3DPluginTreeView.png">](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)
 *
 * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)]
 *
 * ## Overview
 *
 * * Currently supports 3DXML V4.2.
 * * Creates an {@link Entity} representing each model it loads, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}.
 * * Creates an {@link Entity} for each object within the model, which will have {@link Entity#isObject} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#objects}.
 * * When loading, can set the World-space position, scale and rotation of each model within World space, along with initial properties for all the model's {@link Entity}s.
 * * Can optionally load a {@link MetaModel} to classify the objects within the model, from which you can create a tree view using the {@link TreeViewPlugin}.
 * <br>
 * Note that the name of this plugin is intentionally munged to "XML3D" because a JavaScript class name cannot begin with a numeral.
 *
 * An 3DXML model is a zip archive that bundles multiple XML files and assets. Internally, the XML3DLoaderPlugin uses the
 * [zip.js](https://gildas-lormeau.github.io/zip.js/) library to unzip them before loading. The zip.js library uses
 * [Web workers](https://www.w3.org/TR/workers/) for fast unzipping, so XML3DLoaderPlugin requires that we configure it
 * with a ````workerScriptsPath```` property specifying the directory where zip.js keeps its Web worker script. See
 * the example for how to do that.
 *
 * ## Usage
 *
 * In the example below, we'll use an XML3DLoaderPlugin to load a 3DXML model. When the model has loaded,
 * we'll use the {@link CameraFlightAnimation} to fly the {@link Camera} to look at boundary of the model. We'll
 * then get the model's {@link Entity} from the {@link Scene} and highlight the whole model.
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_Widget)]
 *
 * ````javascript
 * // Create a xeokit Viewer
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * // Add an XML3DLoaderPlugin to the Viewer
 * var plugin = new XML3DLoaderPlugin(viewer, {
 *      id: "XML3DLoader",  // Default value
 *      workerScriptsPath : "../../src/plugins/XML3DLoader/zipjs/" // Path to zip.js workers dir
 * });
 *
 * // Load the 3DXML model
 * var model = plugin.load({ // Model is an Entity
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     scale: [0.1, 0.1, 0.1],
 *     rotate: [90, 0, 0],
 *     translate: [100,0,0],
 *     edges: true
 * });
 *
 * // When the model has loaded, fit it to view
 * model.on("loaded", function() {
 *      viewer.cameraFlight.flyTo(model);
 * });
 *
 * // Update properties of the model via the entity
 * model.highlighted = true;
 *
 * // Find the model Entity by ID
 * model = viewer.scene.models["myModel"];
 *
 * // Destroy the model
 * model.destroy();
 * ````
 * ## Loading MetaModels
 *
 * We have the option to load a {@link MetaModel} that contains a hierarchy of {@link MetaObject}s that classifes the objects within
 * our 3DXML model.
 *
 * This is useful for building a tree view to navigate the objects, using {@link TreeViewPlugin}.
 *
 * Let's load the model again, this time creating a MetaModel:
 *
 * ````javascript
 * var model = plugin.load({
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     scale: [0.1, 0.1, 0.1],
 *     rotate: [90, 0, 0],
 *     translate: [100,0,0],
 *     edges: true,
 *
 *     createMetaModel: true // <<-------- Create a MetaModel
 * });
 * ````
 *
 * The MetaModel can then be found on the {@link Viewer}'s {@link MetaScene}, using the model's ID:
 *
 * ````javascript
 * const metaModel = viewer.metaScene.metaModels["myModel"];
 * ````
 *
 * Now we can use {@link TreeViewPlugin} to create a tree view to navigate our model's objects:
 *
 * ````javascript
 * import {TreeViewPlugin} from "xeokit-sdk.es.js""xeokit-sdk.es.js";
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *     containerElement: document.getElementById("myTreeViewContainer")
 * });
 *
 * const treeView = new TreeViewPlugin(viewer, {
 *      containerElement: document.getElementById("treeViewContainer"),
 *      autoExpandDepth: 3, // Initially expand tree three storeys deep
 *      hierarchy: "containment",
 *      autoAddModels: false
 * });
 *
 * model.on("loaded", () => {
 *      treeView.addModel(model.id);
 * });
 * ````
 *
 * Note that only the TreeViewPlugin "containment" hierarchy makes sense for an XML3D model. A "types" hierarchy
 * does not make sense because XML3DLoaderPlugin will set each {@link MetaObject#type} to "Default", and "storeys"
 * does not make sense because that requires some of the MetaObject#type values to be "IfcBuildingStorey".
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_TreeView)]
 *
 * ## Material Type
 *
 * Although 3DXML only supports Phong materials, XML3DLoaderPlugin is able to convert them to physically-based materials.
 *
 * The plugin supports three material types:
 *
 * | Material Type | Material Components Loaded  | Description | Example |
 * |:--------:|:----:|:-----:|:-----:|
 * | "PhongMaterial" (default) | {@link PhongMaterial}  | Non-physically-correct Blinn-Phong shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Phong) |
 * | "MetallicMaterial" | {@link MetallicMaterial} | Physically-accurate specular-glossiness shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Metallic) |
 * | "SpecularMaterial" | {@link SpecularMaterial} | Physically-accurate metallic-roughness shading model | [Run example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Specular) |
 *
 * <br>
 * Let's load our model again, this time converting the 3DXML Blinn-Phong materials to {@link SpecularMaterial}s:
 *
 * ````javascript
 * var model = plugin.load({ // Model is an Entity
 *     id: "myModel",
 *     src: "./models/xml3d/3dpreview.3dxml",
 *     materialtype: "SpecularMaterial": true"
 * });
 * ````
 *
 * * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#loading_3DXML_materialType_Specular)]
 *
 * @class XML3DLoaderPlugin
 */

var XML3DLoaderPlugin = /*@__PURE__*/(function (Plugin) {
    function XML3DLoaderPlugin(viewer, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Plugin.call(this, "XML3DLoader", viewer, cfg);

        if (!cfg.workerScriptsPath) {
            this.error("Config expected: workerScriptsPath");
            return
        }

        this._workerScriptsPath = cfg.workerScriptsPath;

        /**
         * @private
         */
        this._loader = new XML3DSceneGraphLoader(this, cfg);

        /**
         * Supported 3DXML schema versions
         * @property supportedSchemas
         * @type {string[]}
         */
        this.supportedSchemas = this._loader.supportedSchemas;
    }

    if ( Plugin ) XML3DLoaderPlugin.__proto__ = Plugin;
    XML3DLoaderPlugin.prototype = Object.create( Plugin && Plugin.prototype );
    XML3DLoaderPlugin.prototype.constructor = XML3DLoaderPlugin;

    /**
     * Loads a 3DXML model from a file into this XML3DLoaderPlugin's {@link Viewer}.
     *
     * Creates a tree of {@link Entity}s within the Viewer's {@link Scene} that represents the model.
     *
     * @param {*} params  Loading parameters.
     * @param {String} params.id ID to assign to the model's root {@link Entity}, unique among all components in the Viewer's {@link Scene}.
     * @param {String} [params.src] Path to a 3DXML file.
     * @param {Boolean} [params.edges=false] Whether or not xeokit renders the {@link Entity} with edges emphasized.
     * @param {Number[]} [params.position=[0,0,0]] The model's World-space 3D position.
     * @param {Number[]} [params.scale=[1,1,1]] The model's World-space scale.
     * @param {Number[]} [params.rotation=[0,0,0]] The model's World-space rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
     * @param {Number[]} [params.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] The model's world transform matrix. Overrides the position, scale and rotation parameters.
     * @param {Boolean} [params.backfaces=false] When true, allows visible backfaces, wherever specified in the 3DXML. When false, ignores backfaces.
     * @param {Number} [params.edgeThreshold=20] When xraying, highlighting, selecting or edging, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
     * @param {String} [params.materialType="PhongMaterial"] What type of materials to create while loading: "MetallicMaterial" to create {@link MetallicMaterial}s, "SpecularMaterial" to create {@link SpecularMaterial}s or "PhongMaterial" to create {@link PhongMaterial}s. As it loads XML3D's Phong materials, the XMLLoaderPlugin will do its best approximate conversion of those to the specified workflow.
     * @param {Boolean} [params.createMetaModel=false] When true, will create a {@link MetaModel} for the model in {@link MetaScene#metaModels}.
     * @returns {Entity} Entity representing the model, which will have {@link Entity#isModel} set ````true```` and will be registered by {@link Entity#id} in {@link Scene#models}
     */
    XML3DLoaderPlugin.prototype.load = function load (params) {
        if ( params === void 0 ) params = {};


        params.workerScriptsPath = this._workerScriptsPath;

        if (params.id && this.viewer.scene.components[params.id]) {
            this.error("Component with this ID already exists in viewer: " + params.id + " - will autogenerate this ID");
            delete params.id;
        }

        var modelNode = new Node(this.viewer.scene, utils.apply(params, {
            isModel: true
        }));

        var src = params.src;

        if (!src) {
            this.error("load() param expected: src");
            return modelNode; // Return new empty model
        }

        this._loader.load(this, modelNode, src, params);

        return modelNode;
    };

    return XML3DLoaderPlugin;
}(Plugin));

/**
 * @desc Localization service for a {@link Viewer}.
 *
 * * A LocaleService is a container of string translations ("messages") for various locales.
 * * A {@link Viewer} has its own default LocaleService at {@link Viewer#localeService}.
 * * We can replace that with our own LocaleService, or a custom subclass, via the Viewer's constructor.
 * * Viewer plugins that need localized translations will attempt to them for the currently active locale from the LocaleService.
 * * Whenever we switch the LocaleService to a different locale, plugins will automatically refresh their translations for that locale.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} that uses an {@link XKTLoaderPlugin} to load a BIM model, and a
 * {@link NavCubePlugin}, which shows a camera navigation cube in the corner of the canvas.
 *
 * We'll also configure our Viewer with our own LocaleService instance, configured with English, Mori and French
 * translations for our NavCubePlugin.
 *
 * We could instead have just used the Viewer's default LocaleService, but this example demonstrates how we might
 * configure the Viewer our own custom LocaleService subclass.
 *
 * The translations fetched by our NavCubePlugin will be:
 *
 *  * "NavCube.front"
 *  * "NavCube.back"
 *  * "NavCube.top"
 *  * "NavCube.bottom"
 *  * "NavCube.left"
 *  * "NavCube.right"
 *
 * <br>
 * These are paths that resolve to our translations for the currently active locale, and are hard-coded within
 * the NavCubePlugin.
 *
 * For example, if  the LocaleService's locale is set to "fr", then the path "NavCube.back" will drill down
 * into ````messages->fr->NavCube->front```` and fetch "Arrire".
 *
 * If we didn't provide that particular translation in our LocaleService, or any translations for that locale,
 * then the NavCubePlugin will just fall back on its own default hard-coded translation, which in this case is "BACK".
 *
 * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#localization_NavCubePlugin)]
 *
 * ````javascript
 * import {Viewer, LocaleService, NavCubePlugin, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *
 *      canvasId: "myCanvas",
 *
 *      localeService: new LocaleService({
 *          messages: {
 *              "en": { // English
 *                  "NavCube": {
 *                      "front": "Front",
 *                      "back": "Back",
 *                      "top": "Top",
 *                      "bottom": "Bottom",
 *                      "left": "Left",
 *                      "right": "Right"
 *                  }
 *              },
 *              "mi": { // Mori
 *                  "NavCube": {
 *                      "front": "Mua",
 *                      "back": "Tuar",
 *                      "top": "Runga",
 *                      "bottom": "Raro",
 *                      "left": "Mau",
 *                      "right": "Tika"
 *                  }
 *              },
 *              "fr": { // Francais
 *                  "NavCube": {
 *                      "front": "Avant",
 *                      "back": "Arrire",
 *                      "top": "Suprieur",
 *                      "bottom": "Infrieur",
 *                      "left": "Gauche",
 *                      "right": "Droit"
 *                  }
 *              }
 *          },
 *          locale: "en"
 *      })
 *  });
 *
 * viewer.camera.eye = [-3.93, 2.85, 27.01];
 * viewer.camera.look = [4.40, 3.72, 8.89];
 * viewer.camera.up = [-0.01, 0.99, 0.03];
 *
 * const navCubePlugin = new NavCubePlugin(viewer, {
 *      canvasID: "myNavCubeCanvas"
 *  });
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/Duplex.ifc.xkt",
 *     edges: true
 * });
 * ````
 *
 * We can dynamically switch our Viewer to a different locale at any time, which will update the text on the
 * faces of our NavCube:
 *
 * ````javascript
 * viewer.localeService.locale = "mi"; // Switch to Mori
 * ````
 *
 * We can load new translations at any time:
 *
 * ````javascript
 * viewer.localeService.loadMessages({
 *     "jp": { // Japanese
 *         "NavCube": {
 *             "front": "",
 *             "back": "",
 *             "top": "",
 *             "bottom": "",
 *             "left": "",
 *             "right": ""
 *         }
 *     }
 * });
 * ````
 *
 * And we can clear the translations if needed:
 *
 * ````javascript
 * viewer.localeService.clearMessages();
 * ````
 *
 * We can get an "updated" event from the LocaleService whenever we switch locales or load messages, which is useful
 * for triggering UI elements to refresh themselves with updated translations. Internally, our {@link NavCubePlugin}
 * subscribes to this event, fetching new strings for itself via {@link LocaleService#translate} each time the
 * event is fired.
 *
 * ````javascript
 * viewer.localeService.on("updated", () => {
 *     console.log( viewer.localeService.translate("NavCube.left") );
 * });
 * ````
 * @since 2.0
 */
var LocaleService = function LocaleService(params) {
    if ( params === void 0 ) params = {};


    this._eventSubIDMap = null;
    this._eventSubEvents = null;
    this._eventSubs = null;
    this._events = null;

    this._locale = "en";
    this._messages = {};
    this._locales = [];
    this._locale = "en";

    this.messages = params.messages;
    this.locale = params.locale;
};

var prototypeAccessors = { messages: { configurable: true },locales: { configurable: true },locale: { configurable: true } };

/**
 * Replaces the current set of locale translations.
 *
 * * Fires an "updated" event when done.
 * * Automatically refreshes any plugins that depend on the translations.
 * * Does not change the current locale.
 *
 * ## Usage
 *
 * ````javascript
 * viewer.localeService.setMessages({
 * messages: {
 *     "en": { // English
 *         "NavCube": {
 *             "front": "Front",
 *             "back": "Back",
 *             "top": "Top",
 *             "bottom": "Bottom",
 *             "left": "Left",
 *             "right": "Right"
 *         }
 *     },
 *     "mi": { // Mori
 *         "NavCube": {
 *             "front": "Mua",
 *             "back": "Tuar",
 *             "top": "Runga",
 *             "bottom": "Raro",
 *             "left": "Mau",
 *             "right": "Tika"
 *         }
 *     }
 *}
 * });
 * ````
 *
 * @param {*} messages The new translations.
 */
prototypeAccessors.messages.set = function (messages) {
    this._messages = messages || {};
    this._locales = Object.keys(this._messages);
    this.fire("updated", this);
};

/**
 * Loads a new set of locale translations, adding them to the existing translations.
 *
 * * Fires an "updated" event when done.
 * * Automatically refreshes any plugins that depend on the translations.
 * * Does not change the current locale.
 *
 * ## Usage
 *
 * ````javascript
 * viewer.localeService.loadMessages({
 * "jp": { // Japanese
 *     "NavCube": {
 *         "front": "",
 *         "back": "",
 *         "top": "",
 *         "bottom": "",
 *         "left": "",
 *         "right": ""
 *     }
 * }
 * });
 * ````
 *
 * @param {*} messages The new translations.
 */
LocaleService.prototype.loadMessages = function loadMessages (messages) {
        if ( messages === void 0 ) messages = {};

    for (var locale in messages) {
        this._messages[locale] = messages[locale];
    }
    this.messages = this._messages;
};

/**
 * Clears all locale translations.
 *
 * * Fires an "updated" event when done.
 * * Does not change the current locale.
 * * Automatically refreshes any plugins that depend on the translations, which will cause those
 * plugins to fall back on their internal hard-coded text values, since this method removes all
 * our translations.
 */
LocaleService.prototype.clearMessages = function clearMessages () {
    this.messages = {};
};

/**
 * Gets the list of available locales.
 *
 * These are derived from the currently configured set of translations.
 *
 * @returns {String[]} The list of available locales.
 */
prototypeAccessors.locales.get = function () {
    return this._locales;
};

/**
 * Sets the current locale.
 *
 * * Fires an "updated" event when done.
 * * The given locale does not need to be in the list of available locales returned by {@link LocaleService#locales}, since
 * this method assumes that you may want to load the locales at a later point.
 * * Automatically refreshes any plugins that depend on the translations.
 * * We can then get translations for the locale, if translations have been loaded for it, via {@link LocaleService#translate} and {@link LocaleService#translatePlurals}.
 *
 * @param {String} locale The new current locale.
 */
prototypeAccessors.locale.set = function (locale) {
    locale = locale || "de";
    if (this._locale === locale) {
        return;
    }
    this._locale = locale;
    this.fire("updated", locale);
};

/**
 * Gets the current locale.
 *
 * @returns {String} The current locale.
 */
prototypeAccessors.locale.get = function () {
    return this._locale;
};

/**
 * Translates the given string according to the current locale.
 *
 * Returns null if no translation can be found.
 *
 * @param {String} msg String to translate.
 * @param {*} [args] Extra parameters.
 * @returns {String|null} Translated string if found, else null.
 */
LocaleService.prototype.translate = function translate (msg, args) {
    var localeMessages = this._messages[this._locale];
    if (!localeMessages) {
        return null;
    }
    var localeMessage = resolvePath(msg, localeMessages);
    if (localeMessage) {
        if (args) {
            return vsprintf(localeMessage, args);
        }
        return localeMessage;
    }
    return null;
};

/**
 * Translates the given phrase according to the current locale.
 *
 * Returns null if no translation can be found.
 *
 * @param {String} msg Phrase to translate.
 * @param {Number} count The plural number.
 * @param {*} [args] Extra parameters.
 * @returns {String|null} Translated string if found, else null.
 */
LocaleService.prototype.translatePlurals = function translatePlurals (msg, count, args) {
    var localeMessages = this._messages[this._locale];
    if (!localeMessages) {
        return null;
    }
    var localeMessage = resolvePath(msg, localeMessages);
    count = parseInt("" + count, 10);
    if (count === 0) {
        localeMessage = localeMessage.zero;
    } else {
        localeMessage = (count > 1) ? localeMessage.other : localeMessage.one;
    }
    if (!localeMessage) {
        return null;
    }
    localeMessage = vsprintf(localeMessage, [count]);
    if (args) {
        localeMessage = vsprintf(localeMessage, args);
    }
    return localeMessage;
};

/**
 * Fires an event on this LocaleService.
 *
 * Notifies existing subscribers to the event, optionally retains the event to give to
 * any subsequent notifications on the event as they are made.
 *
 * @param {String} event The event type name.
 * @param {Object} value The event parameters.
 * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers.
 */
LocaleService.prototype.fire = function fire (event, value, forget) {
    if (!this._events) {
        this._events = {};
    }
    if (!this._eventSubs) {
        this._eventSubs = {};
    }
    if (forget !== true) {
        this._events[event] = value || true; // Save notification
    }
    var subs = this._eventSubs[event];
    if (subs) {
        for (var subId in subs) {
            if (subs.hasOwnProperty(subId)) {
                var sub = subs[subId];
                sub.callback(value);
            }
        }
    }
};

/**
 * Subscribes to an event on this LocaleService.
 *
 * @param {String} event The event
 * @param {Function} callback Callback fired on the event
 * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
 */
LocaleService.prototype.on = function on (event, callback) {
    if (!this._events) {
        this._events = {};
    }
    if (!this._eventSubIDMap) {
        this._eventSubIDMap = new Map(); // Subscription subId pool
    }
    if (!this._eventSubEvents) {
        this._eventSubEvents = {};
    }
    if (!this._eventSubs) {
        this._eventSubs = {};
    }
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = {};
        this._eventSubs[event] = subs;
    }
    var subId = this._eventSubIDMap.addItem(); // Create unique subId
    subs[subId] = {
        callback: callback
    };
    this._eventSubEvents[subId] = event;
    var value = this._events[event];
    if (value !== undefined) {
        callback(value);
    }
    return subId;
};

/**
 * Cancels an event subscription that was previously made with {@link LocaleService#on}.
 *
 * @param {String} subId Subscription ID
 */
LocaleService.prototype.off = function off (subId) {
    if (subId === undefined || subId === null) {
        return;
    }
    if (!this._eventSubEvents) {
        return;
    }
    var event = this._eventSubEvents[subId];
    if (event) {
        delete this._eventSubEvents[subId];
        var subs = this._eventSubs[event];
        if (subs) {
            delete subs[subId];
        }
        this._eventSubIDMap.removeItem(subId); // Release subId
    }
};

Object.defineProperties( LocaleService.prototype, prototypeAccessors );

function resolvePath(key, json) {
    if (json[key]) {
        return json[key];
    }
    var parts = key.split(".");
    var obj = json;
    for (var i = 0, len = parts.length; obj && (i < len); i++) {
        var part = parts[i];
        obj = obj[part];
    }
    return obj;
}

function vsprintf(msg, args) {
    if ( args === void 0 ) args = [];

    return msg.replace(/\{\{|\}\}|\{(\d+)\}/g, function (m, n) {
        if (m === "{{") {
            return "{";
        }
        if (m === "}}") {
            return "}";
        }
        return args[n];
    });
}

/**
 * @desc Abstract base class for curve classes.
 */
var Curve = /*@__PURE__*/(function (Component) {
    function Curve(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Component.call(this, owner, cfg);
        this.t = cfg.t;
    }

    if ( Component ) Curve.__proto__ = Component;
    Curve.prototype = Object.create( Component && Component.prototype );
    Curve.prototype.constructor = Curve;

    var prototypeAccessors = { t: { configurable: true },tangent: { configurable: true },length: { configurable: true } };

    /**
     * Sets the progress along this Curve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The progress value.
     */
    prototypeAccessors.t.set = function (value) {
        value = value || 0;
        this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
    };

    /**
     * Gets the progress along this Curve.
     *
     * @returns {Number} The progress value.
     */
    prototypeAccessors.t.get = function () {
        return this._t;
    };

    /**
     * Gets the tangent on this Curve at position {@link Curve#t}.
     *
     * @returns {{Number[]}} The tangent.
     */
    prototypeAccessors.tangent.get = function () {
        return this.getTangent(this._t);
    };

    /**
     * Gets the length of this Curve.
     *
     * @returns {Number} The Curve length.
     */
    prototypeAccessors.length.get = function () {
        var lengths = this._getLengths();
        return lengths[lengths.length - 1];
    };

    /**
     * Returns a normalized tangent vector on this Curve at the given position.
     *
     * @param {Number} t Position to get tangent at.
     * @returns {{Number[]}} Normalized tangent vector
     */
    Curve.prototype.getTangent = function getTangent (t) {
        var delta = 0.0001;
        if (t === undefined) {
            t = this._t;
        }
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0) {
            t1 = 0;
        }
        if (t2 > 1) {
            t2 = 1;
        }
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = math.subVec3(pt2, pt1, []);
        return math.normalizeVec3(vec, []);
    };

    Curve.prototype.getPointAt = function getPointAt (u) {
        var t = this.getUToTMapping(u);
        return this.getPoint(t);
    };

    /**
     * Samples points on this Curve, at the given number of equally-spaced divisions.
     *
     * @param {Number} divisions The number of divisions.
     * @returns {{Array of Array}} Array of sampled 3D points.
     */
    Curve.prototype.getPoints = function getPoints (divisions) {
        if (!divisions) {
            divisions = 5;
        }
        var d, pts = [];
        for (d = 0; d <= divisions; d++) {
            pts.push(this.getPoint(d / divisions));
        }
        return pts;
    };

    Curve.prototype._getLengths = function _getLengths (divisions) {
        if (!divisions) {
            divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
        }
        if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
            return this.cacheArcLengths;

        }
        this.needsUpdate = false;
        var cache = [];
        var current;
        var last = this.getPoint(0);
        var p;
        var sum = 0;
        cache.push(0);
        for (p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += math.lenVec3(math.subVec3(current, last, []));
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum:sum }, Sum is in the last element.
    };

    Curve.prototype._updateArcLengths = function _updateArcLengths () {
        this.needsUpdate = true;
        this._getLengths();
    };

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

    Curve.prototype.getUToTMapping = function getUToTMapping (u, distance) {
        var arcLengths = this._getLengths();
        var i = 0;
        var il = arcLengths.length;
        var t;
        var targetArcLength; // The targeted u distance value to get
        if (distance) {
            targetArcLength = distance;
        } else {
            targetArcLength = u * arcLengths[il - 1];
        }
        //var time = Date.now();
        var low = 0, high = il - 1, comparison;
        while (low <= high) {
            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
                low = i + 1;
            } else if (comparison > 0) {
                high = i - 1;
            } else {
                high = i;
                break;
                // DONE
            }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
            t = i / (il - 1);
            return t;
        }
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        t = (i + segmentFraction) / (il - 1);
        return t;
    };

    Object.defineProperties( Curve.prototype, prototypeAccessors );

    return Curve;
}(Component));

/**
 * @desc A {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a SplineCurve is defined by three or more control points.
 * * You can sample a {@link SplineCurve#point} and a {@link Curve#tangent} vector on a SplineCurve for any given value of {@link SplineCurve#t} in the range ````[0..1]````.
 * * When you set {@link SplineCurve#t} on a SplineCurve, its {@link SplineCurve#point} and {@link Curve#tangent} will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of SplineCurves, {@link CubicBezierCurve} and {@link QuadraticBezierCurve} into a {@link Path}.
 * <br>
 * <img style="border:1px solid; background: white;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Quadratic_spline_six_segments.svg/200px-Quadratic_spline_six_segments.svg.png"/><br>
 *
 * * <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">Spline Curve from Wikipedia</a>*
 */
var SplineCurve = /*@__PURE__*/(function (Curve) {
    function SplineCurve(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Curve.call(this, owner, cfg);
        this.points = cfg.points;
        this.t = cfg.t;
    }

    if ( Curve ) SplineCurve.__proto__ = Curve;
    SplineCurve.prototype = Object.create( Curve && Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;

    var prototypeAccessors = { points: { configurable: true },t: { configurable: true },point: { configurable: true } };

    /**
     * Sets the control points on this SplineCurve.
     *
     * Default value is ````[]````.
     *
     * @param {Number[]} value New control points.
     */
    prototypeAccessors.points.set = function (value) {
        this._points = value || [];
    };

    /**
     * Gets the control points on this SplineCurve.
     *
     * Default value is ````[]````.
     *
     * @returns {Number[]} The control points.
     */
    prototypeAccessors.points.get = function () {
        return this._points;
    };

    /**
     * Sets the progress along this SplineCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The new progress.
     */
    prototypeAccessors.t.set = function (value) {
        value = value || 0;
        this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
    };

    /**
     * Gets the progress along this SplineCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The new progress.
     */
    prototypeAccessors.t.get = function () {
        return this._t;
    };

    /**
     * Gets the point on this SplineCurve at position {@link SplineCurve#t}.
     *
     * @returns {Number[]} The point at {@link SplineCurve#t}.
     */
    prototypeAccessors.point.get = function () {
        return this.getPoint(this._t);
    };

    /**
     * Returns point on this SplineCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     * @returns {Number[]} Point at the given position.
     */
    SplineCurve.prototype.getPoint = function getPoint (t) {

        var points = this.points;

        if (points.length < 3) {
            this.error("Can't sample point from SplineCurve - not enough points on curve - returning [0,0,0].");
            return;
        }

        var point = (points.length - 1) * t;

        var intPoint = Math.floor(point);
        var weight = point - intPoint;

        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var point1 = points[intPoint];
        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

        var vector = math.vec3();

        vector[0] = math.catmullRomInterpolate(point0[0], point1[0], point2[0], point3[0], weight);
        vector[1] = math.catmullRomInterpolate(point0[1], point1[1], point2[1], point3[1], weight);
        vector[2] = math.catmullRomInterpolate(point0[2], point1[2], point2[2], point3[2], weight);

        return vector;
    };

    SplineCurve.prototype.getJSON = function getJSON () {
        return {
            points: points,
            t: this._t
        };
    };

    Object.defineProperties( SplineCurve.prototype, prototypeAccessors );

    return SplineCurve;
}(Curve));

var tempVec3a$3 = math.vec3();

/**
 * @desc Defines a sequence of frames along which a {@link CameraPathAnimation} can animate a {@link Camera}.
 *
 * See {@link CameraPathAnimation} for usage.
 */
var CameraPath = /*@__PURE__*/(function (Component) {
    function CameraPath(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._frames = [];

        this._eyeCurve = new SplineCurve(this);
        this._lookCurve = new SplineCurve(this);
        this._upCurve = new SplineCurve(this);

        if (cfg.frames) {
            this.addFrames(cfg.frames);
            this.smoothFrameTimes(1);
        }
    }

    if ( Component ) CameraPath.__proto__ = Component;
    CameraPath.prototype = Object.create( Component && Component.prototype );
    CameraPath.prototype.constructor = CameraPath;

    var prototypeAccessors = { type: { configurable: true },frames: { configurable: true },eyeCurve: { configurable: true },lookCurve: { configurable: true },upCurve: { configurable: true } };

    /**
     * Gets the camera frames in this CameraPath.
     *
     * @returns {{t:Number, eye:Object, look:Object, up: Object}[]} The frames on this CameraPath.
     */
    prototypeAccessors.type.get = function () {
        return "CameraPath"
    };

    prototypeAccessors.frames.get = function () {
        return this._frames;
    };

    /**
     * Gets the {@link SplineCurve} along which {@link Camera#eye} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#eye}.
     */
    prototypeAccessors.eyeCurve.get = function () {
        return this._eyeCurve;
    };

    /**
     * Gets the {@link SplineCurve} along which {@link Camera#look} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#look}.
     */
    prototypeAccessors.lookCurve.get = function () {
        return this._lookCurve;
    };

    /**
     * Gets the {@link SplineCurve} along which {@link Camera#up} travels.
     * @returns {SplineCurve} The SplineCurve for {@link Camera#up}.
     */
    prototypeAccessors.upCurve.get = function () {
        return this._upCurve;
    };

    /**
     * Adds a frame to this CameraPath, given as the current position of the {@link Camera}.
     *
     * @param {Number} t Time instant for the new frame.
     */
    CameraPath.prototype.saveFrame = function saveFrame (t) {
        var camera = this.scene.camera;
        this.addFrame(t, camera.eye, camera.look, camera.up);
    };

    /**
     * Adds a frame to this CameraPath, specified as values for eye, look and up vectors at a given time instant.
     *
     * @param {Number} t Time instant for the new frame.
     * @param {Number[]} eye A three-element vector specifying the eye position for the new frame.
     * @param {Number[]} look A three-element vector specifying the look position for the new frame.
     * @param {Number[]} up A three-element vector specifying the up vector for the new frame.
     */
    CameraPath.prototype.addFrame = function addFrame (t, eye, look, up) {
        var frame = {
            t: t,
            eye: eye.slice(0),
            look: look.slice(0),
            up: up.slice(0)
        };
        this._frames.push(frame);
        this._eyeCurve.points.push(frame.eye);
        this._lookCurve.points.push(frame.look);
        this._upCurve.points.push(frame.up);
    };

    /**
     * Adds multiple frames to this CameraPath, each frame specified as a set of values for eye, look and up vectors at a given time instant.
     *
     * @param {{t:Number, eye:Object, look:Object, up: Object}[]} frames Frames to add to this CameraPath.
     */
    CameraPath.prototype.addFrames = function addFrames (frames) {
        var frame;
        for (var i = 0, len = frames.length; i < len; i++) {
            frame = frames[i];
            this.addFrame(frame.t || 0, frame.eye, frame.look, frame.up);
        }
    };

    /**
     * Sets the position of the {@link Camera} to a position interpolated within this CameraPath at the given time instant.
     *
     * @param {Number} t Time instant.
     */
    CameraPath.prototype.loadFrame = function loadFrame (t) {

        var camera = this.scene.camera;

        t = t / (this._frames[this._frames.length - 1].t - this._frames[0].t);
        t = t < 0.0 ? 0.0 : (t > 1.0 ? 1.0 : t);

        camera.eye = this._eyeCurve.getPoint(t, tempVec3a$3);
        camera.look = this._lookCurve.getPoint(t, tempVec3a$3);
        camera.up = this._upCurve.getPoint(t, tempVec3a$3);
    };

    /**
     * Gets eye, look and up vectors on this CameraPath at a given instant.
     *
     * @param {Number} t Time instant.
     * @param {Number[]} eye The eye position to update.
     * @param {Number[]} look The look position to update.
     * @param {Number[]} up The up vector to update.
     */
    CameraPath.prototype.sampleFrame = function sampleFrame (t, eye, look, up) {
        t = t < 0.0 ? 0.0 : (t > 1.0 ? 1.0 : t);
        this._eyeCurve.getPoint(t, eye);
        this._lookCurve.getPoint(t, look);
        this._upCurve.getPoint(t, up);
    };

    /**
     * Given a total duration (in seconds) for this CameraPath, recomputes the time instant at each frame so that,
     * when animated by {@link CameraPathAnimation}, the {@link Camera} will move along the path at a constant rate.
     *
     * @param {Number} duration The total duration for this CameraPath.
     */
    CameraPath.prototype.smoothFrameTimes = function smoothFrameTimes (duration) {
        var numFrames = this._frames.length;
        if (numFrames === 0) {
            return;
        }
        var vec = math.vec3();
        var totalLen = 0;
        this._frames[0].t = 0;
        var lens = [];
        for (var i = 1, len = this._frames.length; i < len; i++) {
            var lenVec = math.lenVec3(math.subVec3(this._frames[i].eye, this._frames[i - 1].eye, vec));
            lens[i] = lenVec;
            totalLen += lenVec;
        }
        for (var i$1 = 1, len$1 = this._frames.length; i$1 < len$1; i$1++) {
            var interFrameRate = (lens[i$1] / totalLen) * duration;
            this._frames[i$1].t = this._frames[i$1-1].t + interFrameRate;
        }
    };

    /**
     * Removes all frames from this CameraPath.
     */
    CameraPath.prototype.clearFrames = function clearFrames () {
        this._frames = [];
        this._eyeCurve.points = [];
        this._lookCurve.points = [];
        this._upCurve.points = [];
    };

    Object.defineProperties( CameraPath.prototype, prototypeAccessors );

    return CameraPath;
}(Component));

var tempVec3$2 = math.vec3();
var newLook = math.vec3();
var newEye = math.vec3();
var newUp = math.vec3();
var newLookEyeVec = math.vec3();

/**
 * @desc Jumps or flies the {@link Scene}'s {@link Camera} to a given target.
 *
 * * Located at {@link Viewer#cameraFlight}
 * * Can fly or jump to its target.
 * * While flying, can be stopped, or redirected to a different target.
 * * Can also smoothly transition between ortho and perspective projections.
 *
 *
 * A CameraFlightAnimation's target can be:
 *
 * * specific ````eye````, ````look```` and ````up```` positions,
 * * an axis-aligned World-space bounding box (AABB), or
 * * an instance or ID of any {@link Component} subtype that provides a World-space AABB.
 *
 * A target can also contain a ````projection```` type to transition into. For example, if your {@link Camera#projection} is
 * currently ````"perspective"```` and you supply {@link CameraFlightAnimation#flyTo} with a ````projection```` property
 * equal to "ortho", then CameraFlightAnimation will smoothly transition the Camera into an orthographic projection.
 *
 * Configure {@link CameraFlightAnimation#fit} and {@link CameraFlightAnimation#fitFOV} to make it stop at the point
 * where the target occupies a certain amount of the field-of-view.
 *
 * ## Flying to an Entity
 *
 * Flying to an {@link Entity}:
 *
 * ````Javascript
 * var entity = new Mesh(viewer.scene);
 *
 * // Fly to the Entity's World-space AABB
 * viewer.cameraFlight.flyTo(entity);
 * ````
 * ## Flying to a Position
 *
 * Flying the CameraFlightAnimation from the previous example to specified eye, look and up positions:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({
 *    eye: [-5,-5,-5],
 *    look: [0,0,0]
 *    up: [0,1,0],
 *    duration: 1 // Default, seconds
 * },() => {
 *      // Done
 * });
 * ````
 *
 * ## Flying to an AABB
 *
 * Flying the CameraFlightAnimation from the previous two examples explicitly to the {@link Boundary3D"}}Boundary3D's{{/crossLink}}
 * axis-aligned bounding box:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo(entity.aabb);
 * ````
 *
 * ## Transitioning Between Projections
 *
 * CameraFlightAnimation also allows us to smoothly transition between Camera projections. We can do that by itself, or
 * in addition to flying the Camera to a target.
 *
 * Let's transition the Camera to orthographic projection:
 *
 * [[Run example](http://xeokit.github.io/xeokit-sdk/examples/#camera_CameraFlightAnimation_projection)]
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({ projection: "ortho", () => {
 *      // Done
 * });
 * ````
 *
 * Now let's transition the Camera back to perspective projection:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({ projection: "perspective"}, () => {
 *      // Done
 * });
 * ````
 *
 * Fly Camera to a position, while transitioning to orthographic projection:
 *
 * ````Javascript
 * viewer.cameraFlight.flyTo({
 *     eye: [-100,20,2],
 *     look: [0,0,-40],
 *     up: [0,1,0],
 *     projection: "ortho", () => {
 *        // Done
 * });
 * ````
 */
var CameraFlightAnimation = /*@__PURE__*/(function (Component) {
    function CameraFlightAnimation(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._look1 = math.vec3();
        this._eye1 = math.vec3();
        this._up1 = math.vec3();
        this._look2 = math.vec3();
        this._eye2 = math.vec3();
        this._up2 = math.vec3();
        this._orthoScale1 = 1;
        this._orthoScale2 = 1;
        this._flying = false;
        this._flyEyeLookUp = false;
        this._flyingEye = false;
        this._flyingLook = false;
        this._callback = null;
        this._callbackScope = null;
        this._time1 = null;
        this._time2 = null;
        this.easing = cfg.easing !== false;

        this.duration = cfg.duration;
        this.fit = cfg.fit;
        this.fitFOV = cfg.fitFOV;
        this.trail = cfg.trail;
    }

    if ( Component ) CameraFlightAnimation.__proto__ = Component;
    CameraFlightAnimation.prototype = Object.create( Component && Component.prototype );
    CameraFlightAnimation.prototype.constructor = CameraFlightAnimation;

    var prototypeAccessors = { type: { configurable: true },duration: { configurable: true },fit: { configurable: true },fitFOV: { configurable: true },trail: { configurable: true } };

    /**
     * Flies the {@link Camera} to a target.
     *
     *  * When the target is a boundary, the {@link Camera} will fly towards the target and stop when the target fills most of the canvas.
     *  * When the target is an explicit {@link Camera} position, given as ````eye````, ````look```` and ````up````, then CameraFlightAnimation will interpolate the {@link Camera} to that target and stop there.
     *
     * @param {Object|Component} [params=Scene] Either a parameters object or a {@link Component} subtype that has
     * an AABB. Defaults to the {@link Scene}, which causes the {@link Camera} to fit the Scene in view.
     * @param {Number} [params.arc=0] Factor in range ````[0..1]```` indicating how much the {@link Camera#eye} position
     * will swing away from its {@link Camera#look} position as it flies to the target.
     * @param {Number|String|Component} [params.component] ID or instance of a component to fly to. Defaults to the entire {@link Scene}.
     * @param {Number[]} [params.aabb] World-space axis-aligned bounding box (AABB) target to fly to.
     * @param {Number[]} [params.eye] Position to fly the eye position to.
     * @param {Number[]} [params.look] Position to fly the look position to.
     * @param {Number[]} [params.up] Position to fly the up vector to.
     * @param {String} [params.projection] Projection type to transition into as we fly. Can be any of the values of {@link Camera.projection}.
     * @param {Boolean} [params.fit=true] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation#fit}.
     * @param {Number} [params.fitFOV] How much of field-of-view, in degrees, that a target {@link Entity} or its AABB should
     * fill the canvas on arrival. Overrides {@link CameraFlightAnimation#fitFOV}.
     * @param {Number} [params.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation#duration}.
     * @param {Number} [params.orthoScale] Animate the Camera's orthographic scale to this target value. See {@link Ortho#scale}.
     * @param {Function} [callback] Callback fired on arrival.
     * @param {Object} [scope] Optional scope for callback.
     */
    prototypeAccessors.type.get = function () {
        return "CameraFlightAnimation";
    };

    CameraFlightAnimation.prototype.flyTo = function flyTo (params, callback, scope) {

        params = params || this.scene;

        if (this._flying) {
            this.stop();
        }

        this._flying = false;
        this._flyingEye = false;
        this._flyingLook = false;
        this._flyingEyeLookUp = false;

        this._callback = callback;
        this._callbackScope = scope;

        var camera = this.scene.camera;
        var flyToProjection = (!!params.projection) && (params.projection !== camera.projection);

        this._eye1[0] = camera.eye[0];
        this._eye1[1] = camera.eye[1];
        this._eye1[2] = camera.eye[2];

        this._look1[0] = camera.look[0];
        this._look1[1] = camera.look[1];
        this._look1[2] = camera.look[2];

        this._up1[0] = camera.up[0];
        this._up1[1] = camera.up[1];
        this._up1[2] = camera.up[2];

        this._orthoScale1 = camera.ortho.scale;
        this._orthoScale2 = params.orthoScale || this._orthoScale1;

        var aabb;
        var eye;
        var look;
        var up;
        var componentId;

        if (params.aabb) {
            aabb = params.aabb;

        } else if (params.length === 6) {
            aabb = params;

        } else if ((params.eye && params.look) || params.up) {
            eye = params.eye;
            look = params.look;
            up = params.up;

        } else if (params.eye) {
            eye = params.eye;

        } else if (params.look) {
            look = params.look;

        } else { // Argument must be an instance or ID of a Component (subtype)

            var component = params;

            if (utils.isNumeric(component) || utils.isString(component)) {

                componentId = component;
                component = this.scene.components[componentId];

                if (!component) {
                    this.error("Component not found: " + utils.inQuotes(componentId));
                    if (callback) {
                        if (scope) {
                            callback.call(scope);
                        } else {
                            callback();
                        }
                    }
                    return;
                }
            }
            if (!flyToProjection) {
                aabb = component.aabb || this.scene.aabb;
            }
        }

        var poi = params.poi;

        if (aabb) {

            if (aabb[3] < aabb[0] || aabb[4] < aabb[1] || aabb[5] < aabb[2]) { // Don't fly to an inverted boundary
                return;
            }

            if (aabb[3] === aabb[0] && aabb[4] === aabb[1] && aabb[5] === aabb[2]) { // Don't fly to an empty boundary
                return;
            }

            aabb = aabb.slice();
            var aabbCenter = math.getAABB3Center(aabb);

            this._look2 = poi || aabbCenter;

            var eyeLookVec = math.subVec3(this._eye1, this._look1, tempVec3$2);
            var eyeLookVecNorm = math.normalizeVec3(eyeLookVec);
            var diag = poi ? math.getAABB3DiagPoint(aabb, poi) : math.getAABB3Diag(aabb);
            var fitFOV = params.fitFOV || this._fitFOV;
            var sca = Math.abs(diag / Math.tan(fitFOV * math.DEGTORAD));

            this._orthoScale2 = diag * 1.1;

            this._eye2[0] = this._look2[0] + (eyeLookVecNorm[0] * sca);
            this._eye2[1] = this._look2[1] + (eyeLookVecNorm[1] * sca);
            this._eye2[2] = this._look2[2] + (eyeLookVecNorm[2] * sca);

            this._up2[0] = this._up1[0];
            this._up2[1] = this._up1[1];
            this._up2[2] = this._up1[2];

            this._flyingEyeLookUp = true;

        } else if (eye || look || up) {

            this._flyingEyeLookUp = !!eye && !!look && !!up;
            this._flyingEye = !!eye && !look;
            this._flyingLook = !!look && !eye;

            if (eye) {
                this._eye2[0] = eye[0];
                this._eye2[1] = eye[1];
                this._eye2[2] = eye[2];
            }

            if (look) {
                this._look2[0] = look[0];
                this._look2[1] = look[1];
                this._look2[2] = look[2];
            }

            if (up) {
                this._up2[0] = up[0];
                this._up2[1] = up[1];
                this._up2[2] = up[2];
            }
        }

        if (flyToProjection) {

            if (params.projection === "ortho" && camera.projection !== "ortho") {
                this._projection2 = "ortho";
                this._projMatrix1 = camera.projMatrix.slice();
                this._projMatrix2 = camera.ortho.matrix.slice();
                camera.projection = "customProjection";
            }

            if (params.projection === "perspective" && camera.projection !== "perspective") {
                this._projection2 = "perspective";
                this._projMatrix1 = camera.projMatrix.slice();
                this._projMatrix2 = camera.perspective.matrix.slice();
                camera.projection = "customProjection";
            }
        } else {
            this._projection2 = null;
        }

        this.fire("started", params, true);

        this._time1 = Date.now();
        this._time2 = this._time1 + (params.duration ? params.duration * 1000 : this._duration);

        this._flying = true; // False as soon as we stop

        core.scheduleTask(this._update, this);
    };

    /**
     * Jumps the {@link Scene}'s {@link Camera} to the given target.
     *
     * * When the target is a boundary, this CameraFlightAnimation will position the {@link Camera} at where the target fills most of the canvas.
     * * When the target is an explicit {@link Camera} position, given as ````eye````, ````look```` and ````up```` vectors, then this CameraFlightAnimation will jump the {@link Camera} to that target.
     *
     * @param {*|Component} params  Either a parameters object or a {@link Component} subtype that has a World-space AABB.
     * @param {Number} [params.arc=0]  Factor in range [0..1] indicating how much the {@link Camera#eye} will swing away from its {@link Camera#look} as it flies to the target.
     * @param {Number|String|Component} [params.component] ID or instance of a component to fly to.
     * @param {Number[]} [params.aabb]  World-space axis-aligned bounding box (AABB) target to fly to.
     * @param {Number[]} [params.eye] Position to fly the eye position to.
     * @param {Number[]} [params.look]  Position to fly the look position to.
     * @param {Number[]} [params.up] Position to fly the up vector to.
     * @param {String} [params.projection] Projection type to transition into. Can be any of the values of {@link Camera.projection}.
     * @param {Number} [params.fitFOV] How much of field-of-view, in degrees, that a target {@link Entity} or its AABB should fill the canvas on arrival. Overrides {@link CameraFlightAnimation#fitFOV}.
     * @param {Boolean} [params.fit] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation#fit}.
     */
    CameraFlightAnimation.prototype.jumpTo = function jumpTo (params) {
        this._jumpTo(params);
    };

    CameraFlightAnimation.prototype._jumpTo = function _jumpTo (params) {

        if (this._flying) {
            this.stop();
        }

        var camera = this.scene.camera;

        var aabb;
        var componentId;
        var newEye;
        var newLook;
        var newUp;

        if (params.aabb) { // Boundary3D
            aabb = params.aabb;

        } else if (params.length === 6) { // AABB
            aabb = params;

        } else if (params.eye || params.look || params.up) { // Camera pose
            newEye = params.eye;
            newLook = params.look;
            newUp = params.up;

        } else { // Argument must be an instance or ID of a Component (subtype)

            var component = params;

            if (utils.isNumeric(component) || utils.isString(component)) {
                componentId = component;
                component = this.scene.components[componentId];
                if (!component) {
                    this.error("Component not found: " + utils.inQuotes(componentId));
                    return;
                }
            }
            aabb = component.aabb || this.scene.aabb;
        }

        var poi = params.poi;

        if (aabb) {

            if (aabb[3] <= aabb[0] || aabb[4] <= aabb[1] || aabb[5] <= aabb[2]) { // Don't fly to an empty boundary
                return;
            }

            var diag = poi ? math.getAABB3DiagPoint(aabb, poi) : math.getAABB3Diag(aabb);

            newLook = poi || math.getAABB3Center(aabb, newLook);

            if (this._trail) {
                math.subVec3(camera.look, newLook, newLookEyeVec);
            } else {
                math.subVec3(camera.eye, camera.look, newLookEyeVec);
            }

            math.normalizeVec3(newLookEyeVec);
            var dist;
            var fit = (params.fit !== undefined) ? params.fit : this._fit;

            if (fit) {
                dist = Math.abs((diag) / Math.tan((params.fitFOV || this._fitFOV) * math.DEGTORAD));

            } else {
                dist = math.lenVec3(math.subVec3(camera.eye, camera.look, tempVec3$2));
            }

            math.mulVec3Scalar(newLookEyeVec, dist);

            camera.eye = math.addVec3(newLook, newLookEyeVec, tempVec3$2);
            camera.look = newLook;

            this.scene.camera.ortho.scale = diag * 1.1;

        } else if (newEye || newLook || newUp) {

            if (newEye) {
                camera.eye = newEye;
            }
            if (newLook) {
                camera.look = newLook;
            }
            if (newUp) {
                camera.up = newUp;
            }
        }

        if (params.projection) {
            camera.projection = params.projection;
        }
    };

    CameraFlightAnimation.prototype._update = function _update () {
        if (!this._flying) {
            return;
        }
        var time = Date.now();
        var t = (time - this._time1) / (this._time2 - this._time1);
        var stopping = (t >= 1);

        if (t > 1) {
            t = 1;
        }

        var tFlight = this.easing ? CameraFlightAnimation._ease(t, 0, 1, 1) : t;
        var camera = this.scene.camera;

        if (this._flyingEye || this._flyingLook) {

            if (this._flyingEye) {
                math.subVec3(camera.eye, camera.look, newLookEyeVec);
                camera.eye = math.lerpVec3(tFlight, 0, 1, this._eye1, this._eye2, newEye);
                camera.look = math.subVec3(newEye, newLookEyeVec, newLook);
            } else if (this._flyingLook) {
                camera.look = math.lerpVec3(tFlight, 0, 1, this._look1, this._look2, newLook);
                camera.up = math.lerpVec3(tFlight, 0, 1, this._up1, this._up2, newUp);
            }

        } else if (this._flyingEyeLookUp) {

            camera.eye = math.lerpVec3(tFlight, 0, 1, this._eye1, this._eye2, newEye);
            camera.look = math.lerpVec3(tFlight, 0, 1, this._look1, this._look2, newLook);
            camera.up = math.lerpVec3(tFlight, 0, 1, this._up1, this._up2, newUp);
        }

        if (this._projection2) {
            var tProj = (this._projection2 === "ortho") ? CameraFlightAnimation._easeOutExpo(t, 0, 1, 1) : CameraFlightAnimation._easeInCubic(t, 0, 1, 1);
            camera.customProjection.matrix = math.lerpMat4(tProj, 0, 1, this._projMatrix1, this._projMatrix2);

        } else {
            camera.ortho.scale = this._orthoScale1 + (t * (this._orthoScale2 - this._orthoScale1));
        }

        if (stopping) {
            camera.ortho.scale = this._orthoScale2;
            this.stop();
            return;
        }
        core.scheduleTask(this._update, this); // Keep flying
    };

    CameraFlightAnimation._ease = function _ease (t, b, c, d) { // Quadratic easing out - decelerating to zero velocity http://gizma.com/easing
        t /= d;
        return -c * t * (t - 2) + b;
    };

    CameraFlightAnimation._easeInCubic = function _easeInCubic (t, b, c, d) {
        t /= d;
        return c * t * t * t + b;
    };

    CameraFlightAnimation._easeOutExpo = function _easeOutExpo (t, b, c, d) {
        return c * (-Math.pow(2, -10 * t / d) + 1) + b;
    };

    /**
     * Stops an earlier flyTo, fires arrival callback.
     */
    CameraFlightAnimation.prototype.stop = function stop () {
        if (!this._flying) {
            return;
        }
        this._flying = false;
        this._time1 = null;
        this._time2 = null;
        if (this._projection2) {
            this.scene.camera.projection = this._projection2;
        }
        var callback = this._callback;
        if (callback) {
            this._callback = null;
            if (this._callbackScope) {
                callback.call(this._callbackScope);
            } else {
                callback();
            }
        }
        this.fire("stopped", true, true);
    };

    /**
     * Cancels an earlier flyTo without calling the arrival callback.
     */
    CameraFlightAnimation.prototype.cancel = function cancel () {
        if (!this._flying) {
            return;
        }
        this._flying = false;
        this._time1 = null;
        this._time2 = null;
        if (this._callback) {
            this._callback = null;
        }
        this.fire("canceled", true, true);
    };

    /**
     * Sets the flight duration, in seconds, when calling {@link CameraFlightAnimation#flyTo}.
     *
     * Stops any flight currently in progress.
     *
     * default value is ````0.5````.
     *
     * @param {Number} value New duration value.
     */
    prototypeAccessors.duration.set = function (value) {
        this._duration = value ? (value * 1000.0) : 500;
        this.stop();
    };

    /**
     * Gets the flight duration, in seconds, when calling {@link CameraFlightAnimation#flyTo}.
     *
     * default value is ````0.5````.
     *
     * @returns {Number} New duration value.
     */
    prototypeAccessors.duration.get = function () {
        return this._duration / 1000.0;
    };

    /**
     * Sets if, when CameraFlightAnimation is flying to a boundary, it will always adjust the distance between the
     * {@link Camera#eye} and {@link Camera#look} so as to ensure that the target boundary is always filling the view volume.
     *
     * When false, the eye will remain at its current distance from the look position.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate this behaviour.
     */
    prototypeAccessors.fit.set = function (value) {
        this._fit = value !== false;
    };

    /**
     * Gets if, when CameraFlightAnimation is flying to a boundary, it will always adjust the distance between the
     * {@link Camera#eye} and {@link Camera#look} so as to ensure that the target boundary is always filling the view volume.
     *
     * When false, the eye will remain at its current distance from the look position.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} value Set ````true```` to activate this behaviour.
     */
    prototypeAccessors.fit.get = function () {
        return this._fit;
    };

    /**
     * Sets how much of the perspective field-of-view, in degrees, that a target {@link Entity#aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation#flyTo} or {@link CameraFlightAnimation#jumpTo}.
     *
     * Default value is ````45````.
     *
     * @param {Number} value New FOV value.
     */
    prototypeAccessors.fitFOV.set = function (value) {
        this._fitFOV = value || 45;
    };

    /**
     * Gets how much of the perspective field-of-view, in degrees, that a target {@link Entity#aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation#flyTo} or {@link CameraFlightAnimation#jumpTo}.
     *
     * Default value is ````45````.
     *
     * @returns {Number} Current FOV value.
     */
    prototypeAccessors.fitFOV.get = function () {
        return this._fitFOV;
    };

    /**
     * Sets if this CameraFlightAnimation to point the {@link Camera}
     * in the direction that it is travelling when flying to a target after calling {@link CameraFlightAnimation#flyTo}.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate trailing behaviour.
     */
    prototypeAccessors.trail.set = function (value) {
        this._trail = !!value;
    };

    /**
     * Gets if this CameraFlightAnimation points the {@link Camera}
     * in the direction that it is travelling when flying to a target after calling {@link CameraFlightAnimation#flyTo}.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} True if trailing behaviour is active.
     */
    prototypeAccessors.trail.get = function () {
        return this._trail;
    };

    /**
     * @private
     */
    CameraFlightAnimation.prototype.destroy = function destroy () {
        this.stop();
        Component.prototype.destroy.call(this);
    };

    Object.defineProperties( CameraFlightAnimation.prototype, prototypeAccessors );

    return CameraFlightAnimation;
}(Component));

/**
 * @desc Animates the {@link Scene}'s's {@link Camera} along a {@link CameraPath}.
 *
 * ## Usage
 *
 * In the example below, we'll load a model using a {@link GLTFLoaderPlugin}, then animate a {@link Camera}
 * through the frames in a {@link CameraPath}.
 *
 *  * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#camera_CameraPathAnimation)]
 *
 * ````Javascript
 * import {Viewer, GLTFLoaderPlugin, CameraPath, CameraPathAnimation} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange camera
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [124.86756896972656, -93.50288391113281, 173.2632598876953];
 * viewer.camera.look = [102.14186096191406, -90.24193572998047, 173.4224395751953];
 * viewer.camera.up = [0.23516440391540527, 0.9719591736793518, -0.0016466031083837152];
 *
 * // Load model
 *
 * const gltfLoader = new GLTFLoaderPlugin(viewer);
 *
 * const model = gltfLoader.load({
 *     id: "myModel",
 *     src: "./models/gltf/modern_office/scene.gltf",
 *     edges: true,
 *     edgeThreshold: 20,
 *     xrayed: false
 * });
 *
 * // Create a CameraPath
 *
 * var cameraPath = new CameraPath(viewer.scene, {
 *     frames: [
 *         {
 *             t:    0,
 *             eye:  [124.86, -93.50, 173.26],
 *             look: [102.14, -90.24, 173.42],
 *             up:   [0.23, 0.97, -0.00]
 *         },
 *         {
 *             t:    1,
 *             eye:  [79.75, -85.98, 226.57],
 *             look: [99.24, -84.11, 238.56],
 *             up:   [-0.14, 0.98, -0.09]
 *         },
 *         // Rest of the frames omitted for brevity
 *     ]
 * });
 *
 * // Create a CameraPathAnimation to play our CameraPath
 *
 * var cameraPathAnimation = new CameraPathAnimation(viewer.scene, {
 *     cameraPath: cameraPath,
 *     playingRate: 0.2 // Playing 0.2 time units per second
 * });
 *
 * // Once model loaded, start playing after a couple of seconds delay
 *
 * model.on("loaded", function () {
 *     setTimeout(function () {
 *         cameraPathAnimation.play(0); // Play from the beginning of the CameraPath
 *     }, 2000);
 * });
 * ````
 */
var CameraPathAnimation = /*@__PURE__*/(function (Component) {
    function CameraPathAnimation(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._cameraFlightAnimation = new CameraFlightAnimation(this);
        this._t = 0;
        this.state = CameraPathAnimation.SCRUBBING;
        this._playingFromT = 0;
        this._playingToT = 0;
        this._playingRate = cfg.playingRate || 1.0;
        this._playingDir = 1.0;
        this._lastTime = null;

        this.cameraPath = cfg.cameraPath;

        this._tick = this.scene.on("tick", this._updateT, this);
    }

    if ( Component ) CameraPathAnimation.__proto__ = Component;
    CameraPathAnimation.prototype = Object.create( Component && Component.prototype );
    CameraPathAnimation.prototype.constructor = CameraPathAnimation;

    var prototypeAccessors = { type: { configurable: true },cameraPath: { configurable: true },rate: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "CameraPathAnimation"
    };

    CameraPathAnimation.prototype._updateT = function _updateT () {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        var numFrames;
        var t;
        var time = performance.now();
        var elapsedSecs = (this._lastTime) ? (time - this._lastTime) * 0.001 : 0;
        this._lastTime = time;
        if (elapsedSecs === 0) {
            return;
        }
        switch (this.state) {
            case CameraPathAnimation.SCRUBBING:
                return;
            case CameraPathAnimation.PLAYING:
                this._t += this._playingRate * elapsedSecs;
                numFrames = this._cameraPath.frames.length;
                if (numFrames === 0 || (this._playingDir < 0 && this._t <= 0) || (this._playingDir > 0 && this._t >= this._cameraPath.frames[numFrames - 1].t)) {
                    this.state = CameraPathAnimation.SCRUBBING;
                    this._t = this._cameraPath.frames[numFrames - 1].t;
                    this.fire("stopped");
                    return;
                }
                cameraPath.loadFrame(this._t);
                break;
            case CameraPathAnimation.PLAYING_TO:
                t = this._t + (this._playingRate * elapsedSecs * this._playingDir);
                if ((this._playingDir < 0 && t <= this._playingToT) || (this._playingDir > 0 && t >= this._playingToT)) {
                    t = this._playingToT;
                    this.state = CameraPathAnimation.SCRUBBING;
                    this.fire("stopped");
                }
                this._t = t;
                cameraPath.loadFrame(this._t);
                break;
        }
    };

    /*
    * @private
     */
    CameraPathAnimation.prototype._ease = function _ease (t, b, c, d) {
        t /= d;
        return -c * t * (t - 2) + b;
    };

    /**
     * Sets the {@link CameraPath} animated by this CameraPathAnimation.
     *
     @param {CameraPath} value The new CameraPath.
     */
    prototypeAccessors.cameraPath.set = function (value) {
        this._cameraPath = value;
    };

    /**
     * Gets the {@link CameraPath} animated by this CameraPathAnimation.
     *
     @returns {CameraPath} The CameraPath.
     */
    prototypeAccessors.cameraPath.get = function () {
        return this._cameraPath;
    };

    /**
     * Sets the rate at which the CameraPathAnimation animates the {@link Camera} along the {@link CameraPath}.
     *
     *  @param {Number} value The amount of progress per second.
     */
    prototypeAccessors.rate.set = function (value) {
        this._playingRate = value;
    };

    /**
     * Gets the rate at which the CameraPathAnimation animates the {@link Camera} along the {@link CameraPath}.
     *
     * @returns {*|number} The current playing rate.
     */
    prototypeAccessors.rate.get = function () {
        return this._playingRate;
    };

    /**
     * Begins animating the {@link Camera} along CameraPathAnimation's {@link CameraPath} from the beginning.
     */
    CameraPathAnimation.prototype.play = function play () {
        if (!this._cameraPath) {
            return;
        }
        this._lastTime = null;
        this.state = CameraPathAnimation.PLAYING;
    };

    /**
     * Begins animating the {@link Camera} along CameraPathAnimation's {@link CameraPath} from the given time.
     *
     * @param {Number} t Time instant.
     */
    CameraPathAnimation.prototype.playToT = function playToT (t) {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        this._playingFromT = this._t;
        this._playingToT = t;
        this._playingDir = (this._playingToT - this._playingFromT) < 0 ? -1 : 1;
        this._lastTime = null;
        this.state = CameraPathAnimation.PLAYING_TO;
    };

    /**
     * Animates the {@link Camera} along CameraPathAnimation's {@link CameraPath} to the given frame.
     *
     * @param {Number} frameIdx Index of the frame to play to.
     */
    CameraPathAnimation.prototype.playToFrame = function playToFrame (frameIdx) {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        var frame = cameraPath.frames[frameIdx];
        if (!frame) {
            this.error("playToFrame - frame index out of range: " + frameIdx);
            return;
        }
        this.playToT(frame.t);
    };

    /**
     * Flies the {@link Camera} directly to the given frame on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} frameIdx Index of the frame to play to.
     * @param {Function} [ok] Callback to fire when playing is complete.
     */
    CameraPathAnimation.prototype.flyToFrame = function flyToFrame (frameIdx, ok) {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        var frame = cameraPath.frames[frameIdx];
        if (!frame) {
            this.error("flyToFrame - frame index out of range: " + frameIdx);
            return;
        }
        this.state = CameraPathAnimation.SCRUBBING;
        this._cameraFlightAnimation.flyTo(frame, ok);
    };

    /**
     * Scrubs the {@link Camera} to the given time on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} t Time instant.
     */
    CameraPathAnimation.prototype.scrubToT = function scrubToT (t) {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        var camera = this.scene.camera;
        if (!camera) {
            return;
        }
        this._t = t;
        cameraPath.loadFrame(this._t);
        this.state = CameraPathAnimation.SCRUBBING;
    };

    /**
     * Scrubs the {@link Camera} to the given frame on the CameraPathAnimation's {@link CameraPath}.
     *
     * @param {Number} frameIdx Index of the frame to scrub to.
     */
    CameraPathAnimation.prototype.scrubToFrame = function scrubToFrame (frameIdx) {
        var cameraPath = this._cameraPath;
        if (!cameraPath) {
            return;
        }
        var camera = this.scene.camera;
        if (!camera) {
            return;
        }
        var frame = cameraPath.frames[frameIdx];
        if (!frame) {
            this.error("playToFrame - frame index out of range: " + frameIdx);
            return;
        }
        cameraPath.loadFrame(this._t);
        this.state = CameraPathAnimation.SCRUBBING;
    };

    /**
     * Stops playing this CameraPathAnimation.
     */
    CameraPathAnimation.prototype.stop = function stop () {
        this.state = CameraPathAnimation.SCRUBBING;
        this.fire("stopped");
    };

    CameraPathAnimation.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this.scene.off(this._tick);
    };

    Object.defineProperties( CameraPathAnimation.prototype, prototypeAccessors );

    return CameraPathAnimation;
}(Component));

CameraPathAnimation.STOPPED = 0;
CameraPathAnimation.SCRUBBING = 1;
CameraPathAnimation.PLAYING = 2;
CameraPathAnimation.PLAYING_TO = 3;

/**
 * @private
 */
var K3D = {};

K3D.load = function(path, resp)
{
    var request = new XMLHttpRequest();
    request.open("GET", path, true);
    request.responseType = "arraybuffer";
    request.onload = function(e){resp(e.target.response);};
    request.send();
};

K3D.save = function(buff, path)
{
    var dataURI = "data:application/octet-stream;base64," + btoa(K3D.parse._buffToStr(buff));
    window.location.href = dataURI;
};

K3D.clone = function(o)
{
    return JSON.parse(JSON.stringify(o));
};



K3D.bin = {};

K3D.bin.f  = new Float32Array(1);
K3D.bin.fb = new Uint8Array(K3D.bin.f.buffer);

K3D.bin.rf		= function(buff, off) { var f = K3D.bin.f, fb = K3D.bin.fb; for(var i=0; i<4; i++) { fb[i] = buff[off+i]; } return f[0]; };
K3D.bin.rsl		= function(buff, off) { return buff[off] | buff[off+1]<<8; };
K3D.bin.ril		= function(buff, off) { return buff[off] | buff[off+1]<<8 | buff[off+2]<<16 | buff[off+3]<<24; };
K3D.bin.rASCII0 = function(buff, off) { var s = ""; while(buff[off]!=0) { s += String.fromCharCode(buff[off++]); } return s; };


K3D.bin.wf		= function(buff, off, v) { var f=new Float32Array(buff.buffer, off, 1); f[0]=v; };
K3D.bin.wsl		= function(buff, off, v) { buff[off]=v; buff[off+1]=v>>8; };
K3D.bin.wil		= function(buff, off, v) { buff[off]=v; buff[off+1]=v>>8; buff[off+2]=v>>16; buff[off+3]>>24; };
K3D.parse = {};

K3D.parse._buffToStr = function(buff)
{
    var a = new Uint8Array(buff);
    var s = "";
    for(var i=0; i<a.length; i++) { s = s.concat(String.fromCharCode(a[i])); }
    return s;
};

K3D.parse._strToBuff = function(str)
{
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i=0; i<str.length; i++) { bufView[i] = str.charCodeAt(i); }
    return buf;
};

K3D.parse._readLine = function(a, off)	// Uint8Array, offset
{
    var s = "";
    while(a[off] != 10) { s += String.fromCharCode(a[off++]); }
    return s;
};
K3D.parse.fromJSON = function(buff)
{
    var json = JSON.parse(K3D.parse._buffToStr(buff));
    return json;
};

K3D.parse.toJSON = function(object)
{
    var str = JSON.stringify(object);
    return K3D.parse._strToBuff(str);
};

K3D.parse.fromOBJ = function(buff)
{
    var res = {};
    res.groups = {};

    res.c_verts = [];
    res.c_uvt	= [];
    res.c_norms = [];

    res.i_verts = [];
    res.i_uvt   = [];
    res.i_norms = [];

    var cg = {from: 0, to:0};	// current group
    var off = 0;
    var a = new Uint8Array(buff);

    while(off < a.length)
    {
        var line = K3D.parse._readLine(a, off);
        off += line.length + 1;
        line = line.replace(/ +(?= )/g,'');
        line = line.replace(/(^\s+|\s+$)/g, '');
        var cds = line.split(" ");
        if(cds[0] == "g")
        {
            cg.to = res.i_verts.length;
            if(res.groups[cds[1]] == null) { res.groups[cds[1]] = {from:res.i_verts.length, to:0}; }
            cg = res.groups[cds[1]];
        }
        if(cds[0] == "v")
        {
            var x = parseFloat(cds[1]);
            var y = parseFloat(cds[2]);
            var z = parseFloat(cds[3]);
            res.c_verts.push(x,y,z);
        }
        if(cds[0] == "vt")
        {
            var x = parseFloat(cds[1]);
            var y = 1-parseFloat(cds[2]);
            res.c_uvt.push(x,y);
        }
        if(cds[0] == "vn")
        {
            var x = parseFloat(cds[1]);
            var y = parseFloat(cds[2]);
            var z = parseFloat(cds[3]);
            res.c_norms.push(x,y,z);
        }
        if(cds[0] == "f")
        {
            var v0a = cds[1].split("/"), v1a = cds[2].split("/"), v2a = cds[3].split("/");
            var vi0 = parseInt(v0a[0])-1, vi1 = parseInt(v1a[0])-1, vi2 = parseInt(v2a[0])-1;
            var ui0 = parseInt(v0a[1])-1, ui1 = parseInt(v1a[1])-1, ui2 = parseInt(v2a[1])-1;
            var ni0 = parseInt(v0a[2])-1, ni1 = parseInt(v1a[2])-1, ni2 = parseInt(v2a[2])-1;

            var vlen = res.c_verts.length/3, ulen = res.c_uvt.length/2, nlen = res.c_norms.length/3;
            if(vi0<0) { vi0 = vlen + vi0+1; } if(vi1<0) { vi1 = vlen + vi1+1; }	if(vi2<0) { vi2 = vlen + vi2+1; }
            if(ui0<0) { ui0 = ulen + ui0+1; } if(ui1<0) { ui1 = ulen + ui1+1; }	if(ui2<0) { ui2 = ulen + ui2+1; }
            if(ni0<0) { ni0 = nlen + ni0+1; } if(ni1<0) { ni1 = nlen + ni1+1; }	if(ni2<0) { ni2 = nlen + ni2+1; }

            res.i_verts.push(vi0, vi1, vi2);  //cg.i_verts.push(vi0, vi1, vi2)
            res.i_uvt  .push(ui0, ui1, ui2);  //cg.i_uvt  .push(ui0, ui1, ui2);
            res.i_norms.push(ni0, ni1, ni2);  //cg.i_norms.push(ni0, ni1, ni2);
            if(cds.length == 5)
            {
                var v3a = cds[4].split("/");
                var vi3 = parseInt(v3a[0])-1, ui3 = parseInt(v3a[1])-1, ni3 = parseInt(v3a[2])-1;
                if(vi3<0) { vi3 = vlen + vi3+1; }
                if(ui3<0) { ui3 = ulen + ui3+1; }
                if(ni3<0) { ni3 = nlen + ni3+1; }
                res.i_verts.push(vi0, vi2, vi3);  //cg.i_verts.push(vi0, vi2, vi3);
                res.i_uvt  .push(ui0, ui2, ui3);  //cg.i_uvt  .push(ui0, ui2, ui3);
                res.i_norms.push(ni0, ni2, ni3);  //cg.i_norms.push(ni0, ni2, ni3);
            }
        }
    }
    cg.to = res.i_verts.length;

    return res;
};


K3D.parse.fromMD2 = function(buff)
{
    buff = new Uint8Array(buff);
    var res = {};
    var head = {};
    //res.head = head;
    head.ident			= K3D.bin.ril(buff,  0);             /* magic number: "IDP2" */
    head.version		= K3D.bin.ril(buff,  4);             /* version: must be 8 */

    head.skinwidth		= K3D.bin.ril(buff,  8);             /* texture width */
    head.skinheight		= K3D.bin.ril(buff, 12);             /* texture height */

    head.framesize		= K3D.bin.ril(buff, 16);             /* size in bytes of a frame */

    head.num_skins		= K3D.bin.ril(buff, 20);             /* number of skins */
    head.num_vertices	= K3D.bin.ril(buff, 24);             /* number of vertices per frame */
    head.num_st			= K3D.bin.ril(buff, 28);             /* number of texture coordinates */
    head.num_tris		= K3D.bin.ril(buff, 32);             /* number of triangles */
    head.num_glcmds		= K3D.bin.ril(buff, 36);             /* number of opengl commands */
    head.num_frames		= K3D.bin.ril(buff, 40);             /* number of frames */

    head.offset_skins	= K3D.bin.ril(buff, 44);             /* offset skin data */
    head.offset_st		= K3D.bin.ril(buff, 48);             /* offset texture coordinate data */
    head.offset_tris	= K3D.bin.ril(buff, 52);             /* offset triangle data */
    head.offset_frames	= K3D.bin.ril(buff, 56);             /* offset frame data */
    head.offset_glcmds	= K3D.bin.ril(buff, 60);             /* offset OpenGL command data */
    head.offset_end		= K3D.bin.ril(buff, 64);             /* offset end of file */

    var off = head.offset_st;
    res.c_uvt = [];
    for(var i=0; i<head.num_st; i++)
    {
        var x = K3D.bin.rsl(buff, off  )/head.skinwidth;
        var y = K3D.bin.rsl(buff, off+2)/head.skinheight;
        res.c_uvt.push(x,y);  off += 4;
    }

    var off = head.offset_tris;
    var vi = [], ti = [];
    res.i_verts = vi;
    res.i_uvt = ti;
    //res.tris = {i_verts : vi, i_uvt : ti};
    for(var i=0; i<head.num_tris; i++)
    {
        vi.push(K3D.bin.rsl(buff, off  ), K3D.bin.rsl(buff, off+2), K3D.bin.rsl(buff, off+4 ));
        ti.push(K3D.bin.rsl(buff, off+6), K3D.bin.rsl(buff, off+8), K3D.bin.rsl(buff, off+10));
        off += 12;
    }

    var off = head.offset_skins;
    res.skins = [];
    for(var i=0; i<head.num_skins; i++)
    {
        res.skins.push(K3D.bin.rASCII0(buff, off));
        off += 64;
    }

    var off = head.offset_frames;
    res.frames = [];
    var nms = K3D.parse.fromMD2._normals;
    for(var i=0; i<head.num_frames; i++)
    {
        var fr = {};
        var sx = K3D.bin.rf(buff, off), sy = K3D.bin.rf(buff, off+4), sz = K3D.bin.rf(buff, off+8);  off += 12;
        var tx = K3D.bin.rf(buff, off), ty = K3D.bin.rf(buff, off+4), tz = K3D.bin.rf(buff, off+8);  off += 12;
        fr.name		 = K3D.bin.rASCII0(buff, off); off += 16;
        fr.verts	 = [];
        fr.norms	 = [];

        for(var j=0; j<head.num_vertices; j++)
        {
            fr.verts.push(buff[off]*sx+tx, buff[off+1]*sy+ty, buff[off+2]*sz+tz);
            fr.norms.push(nms[3*buff[off+3]], nms[3*buff[off+3]+1], nms[3*buff[off+3]+2]);
            off += 4;
        }
        res.frames.push(fr);
    }
    return res;
};



/*
 static MD2 normals
 */

K3D.parse.fromMD2._normals =
    [
        -0.525731,  0.000000,  0.850651,
        -0.442863,  0.238856,  0.864188,
        -0.295242,  0.000000,  0.955423,
        -0.309017,  0.500000,  0.809017,
        -0.162460,  0.262866,  0.951056,
        0.000000,  0.000000,  1.000000,
        0.000000,  0.850651,  0.525731,
        -0.147621,  0.716567,  0.681718,
        0.147621,  0.716567,  0.681718,
        0.000000,  0.525731,  0.850651,
        0.309017,  0.500000,  0.809017,
        0.525731,  0.000000,  0.850651,
        0.295242,  0.000000,  0.955423,
        0.442863,  0.238856,  0.864188,
        0.162460,  0.262866,  0.951056,
        -0.681718,  0.147621,  0.716567,
        -0.809017,  0.309017,  0.500000,
        -0.587785,  0.425325,  0.688191,
        -0.850651,  0.525731,  0.000000,
        -0.864188,  0.442863,  0.238856,
        -0.716567,  0.681718,  0.147621,
        -0.688191,  0.587785,  0.425325,
        -0.500000,  0.809017,  0.309017,
        -0.238856,  0.864188,  0.442863,
        -0.425325,  0.688191,  0.587785,
        -0.716567,  0.681718, -0.147621,
        -0.500000,  0.809017, -0.309017,
        -0.525731,  0.850651,  0.000000,
        0.000000,  0.850651, -0.525731,
        -0.238856,  0.864188, -0.442863,
        0.000000,  0.955423, -0.295242,
        -0.262866,  0.951056, -0.162460,
        0.000000,  1.000000,  0.000000,
        0.000000,  0.955423,  0.295242,
        -0.262866,  0.951056,  0.162460,
        0.238856,  0.864188,  0.442863,
        0.262866,  0.951056,  0.162460,
        0.500000,  0.809017,  0.309017,
        0.238856,  0.864188, -0.442863,
        0.262866,  0.951056, -0.162460,
        0.500000,  0.809017, -0.309017,
        0.850651,  0.525731,  0.000000,
        0.716567,  0.681718,  0.147621,
        0.716567,  0.681718, -0.147621,
        0.525731,  0.850651,  0.000000,
        0.425325,  0.688191,  0.587785,
        0.864188,  0.442863,  0.238856,
        0.688191,  0.587785,  0.425325,
        0.809017,  0.309017,  0.500000,
        0.681718,  0.147621,  0.716567,
        0.587785,  0.425325,  0.688191,
        0.955423,  0.295242,  0.000000,
        1.000000,  0.000000,  0.000000,
        0.951056,  0.162460,  0.262866,
        0.850651, -0.525731,  0.000000,
        0.955423, -0.295242,  0.000000,
        0.864188, -0.442863,  0.238856,
        0.951056, -0.162460,  0.262866,
        0.809017, -0.309017,  0.500000,
        0.681718, -0.147621,  0.716567,
        0.850651,  0.000000,  0.525731,
        0.864188,  0.442863, -0.238856,
        0.809017,  0.309017, -0.500000,
        0.951056,  0.162460, -0.262866,
        0.525731,  0.000000, -0.850651,
        0.681718,  0.147621, -0.716567,
        0.681718, -0.147621, -0.716567,
        0.850651,  0.000000, -0.525731,
        0.809017, -0.309017, -0.500000,
        0.864188, -0.442863, -0.238856,
        0.951056, -0.162460, -0.262866,
        0.147621,  0.716567, -0.681718,
        0.309017,  0.500000, -0.809017,
        0.425325,  0.688191, -0.587785,
        0.442863,  0.238856, -0.864188,
        0.587785,  0.425325, -0.688191,
        0.688191,  0.587785, -0.425325,
        -0.147621,  0.716567, -0.681718,
        -0.309017,  0.500000, -0.809017,
        0.000000,  0.525731, -0.850651,
        -0.525731,  0.000000, -0.850651,
        -0.442863,  0.238856, -0.864188,
        -0.295242,  0.000000, -0.955423,
        -0.162460,  0.262866, -0.951056,
        0.000000,  0.000000, -1.000000,
        0.295242,  0.000000, -0.955423,
        0.162460,  0.262866, -0.951056,
        -0.442863, -0.238856, -0.864188,
        -0.309017, -0.500000, -0.809017,
        -0.162460, -0.262866, -0.951056,
        0.000000, -0.850651, -0.525731,
        -0.147621, -0.716567, -0.681718,
        0.147621, -0.716567, -0.681718,
        0.000000, -0.525731, -0.850651,
        0.309017, -0.500000, -0.809017,
        0.442863, -0.238856, -0.864188,
        0.162460, -0.262866, -0.951056,
        0.238856, -0.864188, -0.442863,
        0.500000, -0.809017, -0.309017,
        0.425325, -0.688191, -0.587785,
        0.716567, -0.681718, -0.147621,
        0.688191, -0.587785, -0.425325,
        0.587785, -0.425325, -0.688191,
        0.000000, -0.955423, -0.295242,
        0.000000, -1.000000,  0.000000,
        0.262866, -0.951056, -0.162460,
        0.000000, -0.850651,  0.525731,
        0.000000, -0.955423,  0.295242,
        0.238856, -0.864188,  0.442863,
        0.262866, -0.951056,  0.162460,
        0.500000, -0.809017,  0.309017,
        0.716567, -0.681718,  0.147621,
        0.525731, -0.850651,  0.000000,
        -0.238856, -0.864188, -0.442863,
        -0.500000, -0.809017, -0.309017,
        -0.262866, -0.951056, -0.162460,
        -0.850651, -0.525731,  0.000000,
        -0.716567, -0.681718, -0.147621,
        -0.716567, -0.681718,  0.147621,
        -0.525731, -0.850651,  0.000000,
        -0.500000, -0.809017,  0.309017,
        -0.238856, -0.864188,  0.442863,
        -0.262866, -0.951056,  0.162460,
        -0.864188, -0.442863,  0.238856,
        -0.809017, -0.309017,  0.500000,
        -0.688191, -0.587785,  0.425325,
        -0.681718, -0.147621,  0.716567,
        -0.442863, -0.238856,  0.864188,
        -0.587785, -0.425325,  0.688191,
        -0.309017, -0.500000,  0.809017,
        -0.147621, -0.716567,  0.681718,
        -0.425325, -0.688191,  0.587785,
        -0.162460, -0.262866,  0.951056,
        0.442863, -0.238856,  0.864188,
        0.162460, -0.262866,  0.951056,
        0.309017, -0.500000,  0.809017,
        0.147621, -0.716567,  0.681718,
        0.000000, -0.525731,  0.850651,
        0.425325, -0.688191,  0.587785,
        0.587785, -0.425325,  0.688191,
        0.688191, -0.587785,  0.425325,
        -0.955423,  0.295242,  0.000000,
        -0.951056,  0.162460,  0.262866,
        -1.000000,  0.000000,  0.000000,
        -0.850651,  0.000000,  0.525731,
        -0.955423, -0.295242,  0.000000,
        -0.951056, -0.162460,  0.262866,
        -0.864188,  0.442863, -0.238856,
        -0.951056,  0.162460, -0.262866,
        -0.809017,  0.309017, -0.500000,
        -0.864188, -0.442863, -0.238856,
        -0.951056, -0.162460, -0.262866,
        -0.809017, -0.309017, -0.500000,
        -0.681718,  0.147621, -0.716567,
        -0.681718, -0.147621, -0.716567,
        -0.850651,  0.000000, -0.525731,
        -0.688191,  0.587785, -0.425325,
        -0.587785,  0.425325, -0.688191,
        -0.425325,  0.688191, -0.587785,
        -0.425325, -0.688191, -0.587785,
        -0.587785, -0.425325, -0.688191,
        -0.688191, -0.587785, -0.425325
    ];

K3D.parse.fromCollada = function(buff)
{
    var str = K3D.parse._buffToStr(buff);
    var xml = new DOMParser().parseFromString(str,"text/xml");
    xml = xml.childNodes[0];
    var resp = {};

    //console.log(xml);

    var ass = xml.getElementsByTagName("asset"             )[0];
    var geo = xml.getElementsByTagName("library_geometries")[0];
    var ima = xml.getElementsByTagName("library_images"    )[0];
    var mat = xml.getElementsByTagName("library_materials" )[0];
    var eff = xml.getElementsByTagName("library_effects"   )[0];

    //console.log(xml);
    if(ass) { resp.asset 		= K3D.parse.fromCollada._asset        (ass); }
    if(geo) { resp.geometries = K3D.parse.fromCollada._libGeometries(geo); }
    if(ima) { resp.images     = K3D.parse.fromCollada._libImages    (ima); }
    if(mat) { resp.materials  = K3D.parse.fromCollada._libMaterials (mat); }
    if(eff) { resp.effects    = K3D.parse.fromCollada._libEffects   (eff); }
    return resp;
};

K3D.parse.fromCollada._asset = function(xml)
{
    //console.log(xml);
    return {
        created : xml.getElementsByTagName("created" )[0].textContent,
        modified: xml.getElementsByTagName("modified")[0].textContent,
        up_axis : xml.getElementsByTagName("up_axis" )[0].textContent
    };
};

K3D.parse.fromCollada._libGeometries = function(xml)
{
    xml = xml.getElementsByTagName("geometry");
    var res = [];
    for(var i=0; i<xml.length; i++)
    {
        var g = xml[i];
        var o = K3D.parse.fromCollada._getMesh(g.getElementsByTagName("mesh")[0]);
        res.push(o);
    }
    return res;
};

K3D.parse.fromCollada._getMesh = function(mesh)
{
    //console.log(mesh);
    var res = {};
    var ss = mesh.getElementsByTagName("source");
    var sources = res.sources = {};
    for(var i=0; i<ss.length; i++)
    {
        var farr = ss[i].getElementsByTagName("float_array")[0].textContent.split(" ");
        var fl = farr.length - (farr[farr.length-1] == "" ? 1 : 0);
        var arr = new Array(fl);
        for(var j=0; j<fl; j++) { arr[j] = parseFloat(farr[j]); }
        sources[ss[i].getAttribute("id")] = arr;
    }

    res.triangles = [];
    var tgs = mesh.getElementsByTagName("triangles");
    if(tgs == null) { return res; }
    for(var i=0; i<tgs.length; i++)
    {
        var t = {};
        var tnode = tgs[i];
        t.material = tnode.getAttribute("material");
        var inputs = tnode.getElementsByTagName("input");
        var inds = [];
        for(var j=0; j<inputs.length; j++)
        {
            var inp = inputs[j], arr = [];
            inds[parseInt(inp.getAttribute("offset"))] = arr;
            var par = inp.getAttribute("semantic");
            t["s_"+par] = (par == "VERTEX") ?
                mesh.getElementsByTagName("vertices")[0].getElementsByTagName("input")[0].getAttribute("source").substring(1)
                : inp.getAttribute("source").substring(1);

            t["i_"+par] = arr;
            sources[t["s_"+par]];
        }
        var indices = tnode.getElementsByTagName("p")[0].textContent.split(" ");
        var inum = 3*Math.floor(indices.length/3);
        for(var j=0; j<inum; j++) { inds[j%inputs.length].push(parseInt(indices[j])); }

        /*
         if(t.s_VERTEX  ) t.u_VERTEX   = K3D.edit.unwrap(t.i_VERTEX  , sources[t.s_VERTEX  ], 3);
         if(t.s_TEXCOORD) t.u_TEXCOORD = K3D.edit.unwrap(t.i_TEXCOORD, sources[t.s_TEXCOORD], 2);
         if(t.s_NORMAL  ) t.u_NORMAL   = K3D.edit.unwrap(t.i_NORMAL  , sources[t.s_NORMAL  ], 3);
         //*/
        //if(t.s_TEXCOORD) for(var j=1; j<t.u_TEXCOORD.length; j+=2) t.u_TEXCOORD[j] = 1 - t.u_TEXCOORD[j];

        /*
         t.u_INDEX = new Array(t.i_VERTEX.length);
         for(var j=0; j<t.i_VERTEX.length; j++) t.u_INDEX[j] = j;
         */

        res.triangles.push(t);
    }
    return res;
};

K3D.parse.fromCollada._libImages = function(xml)
{
    xml = xml.getElementsByTagName("image");
    var res = {};
    for(var i=0; i<xml.length; i++)
    {
        res[xml[i].getAttribute("id")] = xml[i].getElementsByTagName("init_from")[0].textContent;
    }
    return res;
};

K3D.parse.fromCollada._libMaterials = function(xml)
{
    xml = xml.getElementsByTagName("material");
    var res = {};
    for(var i=0; i<xml.length; i++)
    {
        res[xml[i].getAttribute("name")] = xml[i].getElementsByTagName("instance_effect")[0].getAttribute("url").substring(1);
    }
    return res;
};

K3D.parse.fromCollada._libEffects = function(xml)
{
    xml = xml.getElementsByTagName("effect");
    var res = {};
    for(var i=0; i<xml.length; i++)
    {
        var eff = {};
        var params = xml[i].getElementsByTagName("newparam");
        for(var j=0; j<params.length; j++)
        {
            var srf = params[j].getElementsByTagName("surface")[0];
            if(srf) { eff.surface = srf.getElementsByTagName("init_from")[0].textContent; }
        }
        res[xml[i].getAttribute("id")] = eff;
    }
    return res;
};





K3D.parse.from3DS = function(buff)
{
    buff = new Uint8Array(buff);
    var res = {};
    if(K3D.bin.rsl(buff, 0) != 0x4d4d) { return null; }
    var lim = K3D.bin.ril(buff, 2);

    var off = 6;
    while(off < lim)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log(cid.toString(16), lng);

        if(cid == 0x3d3d) { res.edit = K3D.parse.from3DS._edit3ds(buff, off, lng); }
        if(cid == 0xb000) { res.keyf = K3D.parse.from3DS._keyf3ds(buff, off, lng); }

        off += lng;
    }
    return res;
};

K3D.parse.from3DS._edit3ds = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = {};
    var off = coff+6;
    while(off < coff+clng)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log("\t", cid.toString(16), lng);

        if(cid == 0x4000) { if(res.objects==null) { res.objects = []; } res.objects.push(K3D.parse.from3DS._edit_object(buff, off, lng)); }
        //if(cid == 0xb000) res.KEYF3DS = K3D.parse.from3DS._keyf3ds(buff, off, lng);

        off += lng;
    }
    return res;
};

K3D.parse.from3DS._keyf3ds = function(buff, coff, clng)
{
    var res = {};
    var off = coff+6;
    while(off < coff+clng)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log("\t\t", cid.toString(16), lng);

        //if(cid == 0x4000) { res.objects.push(K3D.parse.from3DS._edit_object(buff, off, lng)); }
        if(cid == 0xb002) { if(res.desc==null) { res.desc = []; } res.desc.push(K3D.parse.from3DS._keyf_objdes(buff, off, lng)); }

        off += lng;
    }
    return res;
};

K3D.parse.from3DS._keyf_objdes = function(buff, coff, clng)
{
    var res = {};
    var off = coff+6;
    while(off < coff+clng)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log("\t\t\t", cid.toString(16), lng);

        if(cid == 0xb010) { res.hierarchy = K3D.parse.from3DS._keyf_objhierarch(buff, off, lng); }
        if(cid == 0xb011) { res.dummy_name = K3D.bin.rASCII0(buff, off+6); }
        off += lng;
    }
    return res;
};

K3D.parse.from3DS._keyf_objhierarch = function(buff, coff, clng)
{
    var res = {};
    var off = coff+6;
    res.name = K3D.bin.rASCII0(buff, off);  off += res.name.length+1;
    res.hierarchy = K3D.bin.rsl(buff, off+4);
    return res;
};

K3D.parse.from3DS._edit_object = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = {};
    var off = coff+6;
    res.name = K3D.bin.rASCII0(buff, off);  off += res.name.length+1;
    //console.log(res.name);
    while(off < coff+clng)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log("\t\t", cid.toString(16), lng);

        if(cid == 0x4100) { res.mesh = K3D.parse.from3DS._obj_trimesh(buff, off, lng); }
        //if(cid == 0xb000) res.KEYF3DS = K3D.parse.from3DS._keyf3ds(buff, off, lng);

        off += lng;
    }
    return res;
};

K3D.parse.from3DS._obj_trimesh = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = {};
    var off = coff+6;

    while(off < coff+clng)
    {
        var cid = K3D.bin.rsl(buff, off);
        var lng = K3D.bin.ril(buff, off+2);
        //console.log("\t\t\t", cid.toString(16), lng);

        if(cid == 0x4110) { res.vertices      = K3D.parse.from3DS._tri_vertexl     (buff, off, lng); }
        if(cid == 0x4120) { res.indices       = K3D.parse.from3DS._tri_facel1      (buff, off, lng); }
        if(cid == 0x4140) { res.uvt			= K3D.parse.from3DS._tri_mappingcoors(buff, off, lng); }
        if(cid == 0x4160) { res.local		    = K3D.parse.from3DS._tri_local       (buff, off, lng); }
        off += lng;
    }
    return res;
};

K3D.parse.from3DS._tri_vertexl = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = [];
    var off = coff+6;
    var n = K3D.bin.rsl(buff, off);  off += 2;
    for(var i=0; i<n; i++)
    {
        res.push(K3D.bin.rf(buff, off  ));	res.push(K3D.bin.rf(buff, off+4));	res.push(K3D.bin.rf(buff, off+8));
        off += 12;
    }
    return res;
};

K3D.parse.from3DS._tri_facel1 = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = [];
    var off = coff+6;
    var n = K3D.bin.rsl(buff, off);  off += 2;
    for(var i=0; i<n; i++)
    {
        res.push(K3D.bin.rsl(buff, off  ));
        res.push(K3D.bin.rsl(buff, off+2));
        res.push(K3D.bin.rsl(buff, off+4));
        off += 8;
    }
    return res;
};

K3D.parse.from3DS._tri_mappingcoors = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = [];
    var off = coff+6;
    var n = K3D.bin.rsl(buff, off);  off += 2;
    for(var i=0; i<n; i++)
    {
        res.push(  K3D.bin.rf(buff, off  ));
        res.push(1-K3D.bin.rf(buff, off+4));
        off += 8;
    }
    return res;
};

K3D.parse.from3DS._tri_local = function(buff, coff, clng)	// buffer, chunk offset, length
{
    var res = {};
    var off = coff+6;
    res.X = [K3D.bin.rf(buff, off), K3D.bin.rf(buff, off+4), K3D.bin.rf(buff, off+8)];  off += 12;
    res.Y = [K3D.bin.rf(buff, off), K3D.bin.rf(buff, off+4), K3D.bin.rf(buff, off+8)];  off += 12;
    res.Z = [K3D.bin.rf(buff, off), K3D.bin.rf(buff, off+4), K3D.bin.rf(buff, off+8)];  off += 12;
    res.C = [K3D.bin.rf(buff, off), K3D.bin.rf(buff, off+4), K3D.bin.rf(buff, off+8)];  off += 12;
    return res;
};

K3D.parse.fromBIV = function(buff)
{
    buff = new Uint8Array(buff);
    var res = {};

    var head = {};

    head.id		= K3D.bin.ril(buff,  0);

    head.verS	= K3D.bin.ril(buff,  4);
    head.texS	= K3D.bin.ril(buff,  8);
    head.indS	= K3D.bin.ril(buff, 12);

    head.verO	= K3D.bin.ril(buff, 16);
    head.verL	= K3D.bin.ril(buff, 20);
    head.texO	= K3D.bin.ril(buff, 24);
    head.texL	= K3D.bin.ril(buff, 28);
    head.indO	= K3D.bin.ril(buff, 32);
    head.indL	= K3D.bin.ril(buff, 36);

    if(head.verO != 0) { res.vertices = K3D.parse.fromBIV._readFloats(buff, head.verO, head.verL); }
    if(head.texO != 0) { res.uvt      = K3D.parse.fromBIV._readFloats(buff, head.texO, head.texL); }
    if(head.indO != 0) { res.indices  = K3D.parse.fromBIV._readInts  (buff, head.indO, head.indL, head.indS); }

    return res;
};

K3D.parse.toBIV = function(obj)
{
    var maxi = 0;
    for(var i=0; i<obj.indices.length; i++)	{ maxi = Math.max(maxi, obj.indices[i]); }

    var indS = 32;
    if(maxi<=0xffff) { indS = 16; }

    var len = 40;
    if(obj.vertices) { len+=obj.vertices.length*4; }
    if(obj.uvt     ) { len+=obj.uvt     .length*4; }
    if(obj.indices ) { len+=obj.indices .length*indS/8; }


    var buff = new Uint8Array(len);

    K3D.bin.wil(buff,  0, 0x6976616e);

    K3D.bin.wil(buff,  4, 32);
    K3D.bin.wil(buff,  8, 32);
    K3D.bin.wil(buff, 12, indS);

    var off = 40;
    if(obj.vertices)
    {
        K3D.bin.wil(buff, 16, off);
        K3D.bin.wil(buff, 20, 4*obj.vertices.length);
        K3D.parse.fromBIV._writeFloats(buff, off, obj.vertices);
        off += 4*obj.vertices.length;
    }
    if(obj.uvt)
    {
        K3D.bin.wil(buff, 24, off);
        K3D.bin.wil(buff, 28, 4*obj.uvt.length);
        K3D.parse.fromBIV._writeFloats(buff, off, obj.uvt);
        off += 4*obj.uvt.length;
    }
    if(obj.indices)
    {
        K3D.bin.wil(buff, 32, off);
        K3D.bin.wil(buff, 36, 4*obj.indices.length);
        K3D.parse.fromBIV._writeInts  (buff, off, obj.indices, indS);
    }
    return buff.buffer;
};

K3D.parse.fromBIV._readFloats = function(buff, off, len)
{
    var arr = [];
    for(var i=0; i<len/4; i++) { arr.push( K3D.bin.rf(buff, off+4*i)); }
    return arr;
};

K3D.parse.fromBIV._writeFloats = function(buff, off, arr)
{
    for(var i=0; i<arr.length; i++) { K3D.bin.wf(buff, off+4*i, arr[i]); }
};

K3D.parse.fromBIV._readInts   = function(buff, off, len, cs)
{
    var arr = [];
    for(var i=0; i<len/4; i++)
    {
        if(cs==16) { arr.push( K3D.bin.rsl(buff, off+2*i)); }
        if(cs==32) { arr.push( K3D.bin.ril(buff, off+4*i)); }
    }
    return arr;
};

K3D.parse.fromBIV._writeInts   = function(buff, off, arr, cs)
{
    for(var i=0; i<arr.length; i++)
    {
        if(cs==16) { K3D.bin.wsl(buff, off+2*i, arr[i]); }
        if(cs==32) { K3D.bin.wil(buff, off+4*i, arr[i]); }
    }
};
K3D.gen = {};

K3D.gen.Plane = function(sw, sh, tsw, tsh)
{
    if(!tsw) { tsw = 1; }
    if(!tsh) { tsh = 1; }
    var r = {verts:[], inds:[], uvt:[]};
    var ssw = sw+1, ssh = sh+1;
    for(var i=0; i<ssh; i++)
    {
        for(var j=0; j<ssw; j++)
        {
            var x = -1 + j*(2/sw);
            var y = -1 + i*(2/sh);
            r.verts.push(x, y, 0);
            r.uvt.push(tsw*j/sw, tsh*i/sh);
            if(i<sh && j<sw)
                { r.inds.push(i*ssw+j, i*ssw+j+1, (i+1)*ssw+j,   i*ssw+j+1, (i+1)*ssw+j, (i+1)*ssw+j+1); }
        }
    }
    return r;
};
K3D.gen.Cube = function()
{
    var r = {
        verts:[	-1, 1,-1,   1, 1,-1,  -1,-1,-1,   1,-1,-1, // front
            -1, 1, 1,   1, 1, 1,  -1,-1, 1,   1,-1, 1, // back

            -1, 1, 1,  -1, 1,-1,  -1,-1, 1,  -1,-1,-1, // left
            1, 1, 1,   1, 1,-1,   1,-1, 1,   1,-1,-1, // right

            -1, 1,-1,   1, 1,-1,  -1, 1, 1,   1, 1, 1, // top
            -1,-1,-1,   1,-1,-1,  -1,-1, 1,   1,-1, 1  // bottom
        ],
        inds:[	0,1,2, 1,2,3, 4,5,6, 5,6,7,
            8,9,10, 9,10,11, 12,13,14, 13,14,15,
            16,17,18, 17,18,19, 20,21,22, 21,22,23
        ],
        uvt:[
            1/4,1/4,  2/4,1/4,  1/4,2/4,  2/4,2/4, // front
            4/4,1/4,  3/4,1/4,  4/4,2/4,  3/4,2/4, // back

            0/4,1/4,  1/4,1/4,  0/4,2/4,  1/4,2/4, // left
            3/4,1/4,  2/4,1/4,  3/4,2/4,  2/4,2/4, // right

            1/4,1/4,  2/4,1/4,  1/4,0/4,  2/4,0/4, // top
            1/4,2/4,  2/4,2/4,  1/4,3/4,  2/4,3/4 ]
    };
    return r;
};

K3D.gen.Sphere = function(sx, sy){
    var r = {verts:[], inds:[], uvt:[]};
    var nx = sx+1, ny = sy+1;
    for(var i=0; i<ny; i++)	// rows
    {
        for(var j=0; j<nx; j++) // cols
        {
            var lat = -Math.PI/2 + i*Math.PI/sy;
            var lon =  j*2*Math.PI/sx;
            var x = Math.cos(lat) * Math.cos(lon);
            var y = Math.sin(lat);
            var z = Math.cos(lat) * Math.sin(lon);

            r.verts.push(x,y,z);
            r.uvt.push(j/sx, i/sy);
            if(i<sy && j<sx)          // 6 indices for 2 triangles
                { r.inds.push(nx*i+j, nx*i+j+1, nx*(i+1)+j, nx*i+j+1, nx*(i+1)+j, nx*(i+1)+j+1); }
        }
    }
    return r;
};

K3D.mat = {};

K3D.mat.scale = function(x,y,z){
    return [
        x,0,0,0,
        0,y,0,0,
        0,0,z,0,
        0,0,0,1
    ];
};

K3D.mat.translate = function(x,y,z){
    return [
        1,0,0,0,
        0,1,0,0,
        0,0,1,0,
        x,y,z,1
    ];
};

K3D.mat.rotateDeg = function(x,y,z){
    var r = Math.PI/180;
    return K3D.mat.rotate(x*r, y*r, z*r);
};

K3D.mat.rotate = function(x,y,z){
    var m = [
        1,0,0,0,
        0,1,0,0,
        0,0,1,0,
        0,0,0,1
    ];
    var a =  x;	// alpha
    var b =  y;	// beta
    var g =  z;	// gama

    var ca = Math.cos(a), cb = Math.cos(b), cg = Math.cos(g);
    var sa = Math.sin(a), sb = Math.sin(b), sg = Math.sin(g);

    m[0] = cb*cg;				m[1] = -cb*sg;					m[2 ] = sb;
    m[4] = (ca*sg+sa*sb*cg);	m[5] = (ca*cg-sa*sb*sg);		m[6 ] = -sa*cb;
    m[8] = (sa*sg-ca*sb*cg);	m[9] = (sa*cg+ca*sb*sg);		m[10] = ca*cb;

    return m;
};


K3D.edit = {};

K3D.edit.interpolate = function(a, b, d, t){
    for(var i=0; i<a.length; i++) { d[i] = a[i] + t*(b[i] - a[i]); }
};


K3D.edit.transform = function(a, m){
    for(var i=0; i<a.length; i+=3)    {
        var x = a[i], y = a[i+1], z = a[i+2];
        a[i+0] = m[0]*x + m[4]*y + m[8 ]*z + m[12];
        a[i+1] = m[1]*x + m[5]*y + m[9 ]*z + m[13];
        a[i+2] = m[2]*x + m[6]*y + m[10]*z + m[14];
    }
};

// starting indices, starting coordinates, coordinates per index

K3D.edit.unwrap = function(ind, crd, cpi){
    var ncrd = new Array(Math.floor(ind.length/3)*cpi);
    for(var i=0; i<ind.length; i++)
    {
        for(var j=0; j<cpi; j++)
        {
            ncrd[i*cpi+j] = crd[ind[i]*cpi+j];
        }
    }
    return ncrd;
};

// current indices, new indices, current array, coordinates per vertex

K3D.edit.remap = function(ind, nind, arr, cpi){
    var ncrd = new Array(arr.length);
    for(var i=0; i<ind.length; i++)
    {
        for(var j=0; j<cpi; j++)
        {
            ncrd[nind[i]*cpi+j] = arr[ind[i]*cpi+j];
        }
    }
    return ncrd;
};

K3D.utils = {};

K3D.utils.getAABB = function(vts)
{
    var minx, miny, minz, maxx, maxy, maxz;
    minx = miny = minz = 999999999;
    maxx = maxy = maxz = -minx;

    for(var i=0; i<vts.length; i+=3)
    {
        var vx = vts[i+0];
        var vy = vts[i+1];
        var vz = vts[i+2];
        if(vx<minx) { minx = vx; }  if(vx>maxx) { maxx = vx; }
        if(vy<miny) { miny = vy; }  if(vy>maxy) { maxy = vy; }
        if(vz<minz) { minz = vz; }  if(vy>maxz) { maxz = vz; }
    }
    return {min:{x:minx, y:miny, z:minz}, max:{x:maxx, y:maxy, z:maxz}};
};

/**
 * @desc Loads {@link Geometry} from 3DS.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link PhongMaterial}, {@link Texture} and a {@link ReadableGeometry} loaded from 3DS.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_loaders_3DS)]
 *
 * ````javascript
 * import {Viewer, Mesh, load3DSGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [40.04, 23.46, 79.06];
 * viewer.scene.camera.look = [-6.48, 13.92, -0.56];
 * viewer.scene.camera.up = [-0.04, 0.98, -0.08];
 *
 * load3DSGeometry(viewer.scene, {
 *      src: "models/3ds/lexus.3ds",
 *      compressGeometry: false
 *
 *  }).then(function (geometryCfg) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometryCfg),
 *
 *          material: new PhongMaterial(viewer.scene, {
 *
 *              emissive: [1, 1, 1],
 *              emissiveMap: new Texture({  // .3DS has no normals so relies on emissive illumination
 *                  src: "models/3ds/lexus.jpg"
 *              })
 *          }),
 *
 *          rotation: [-90, 0, 0] // +Z is up for this particular 3DS
 *      });
 *  }, function () {
 *      // Error
 *  });
 * ````
 *
 * @function load3DSGeometry
 * @param {Scene} scene Scene we're loading the geometry for.
 * @param {*} cfg Configs, also added to the result object.
 * @param {String} [cfg.src]  Path to 3DS file.
 * @returns {Object} Configuration to pass into a {@link Geometry} constructor, containing geometry arrays loaded from the OBJ file.
 */
function load3DSGeometry(scene, cfg) {
    if ( cfg === void 0 ) cfg = {};


    return new Promise(function (resolve, reject) {

        if (!cfg.src) {
            console.error("load3DSGeometry: Parameter expected: src");
            reject();
        }

        var spinner = scene.canvas.spinner;
        spinner.processes++;

        utils.loadArraybuffer(cfg.src, function (data) {

                if (!data.byteLength) {
                    console.error("load3DSGeometry: no data loaded");
                    spinner.processes--;
                    reject();
                }

                var m = K3D.parse.from3DS(data);	// done !

                var mesh = m.edit.objects[0].mesh;
                var positions = mesh.vertices;
                var uv = mesh.uvt;
                var indices = mesh.indices;

                spinner.processes--;

                resolve(utils.apply(cfg, {
                    primitive: "triangles",
                    positions: positions,
                    normals: null,
                    uv: uv,
                    indices: indices
                }));
            },

            function (msg) {
                console.error("load3DSGeometry: " + msg);
                spinner.processes--;
                reject();
            });
    });
}

/**
 * @desc Loads {@link Geometry} from OBJ.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with {@link MetallicMaterial} and {@link ReadableGeometry} loaded from OBJ.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_loaders_OBJ)]
 *
 * ````javascript
 * import {Viewer, Mesh, loadOBJGeometry, ReadableGeometry,
 *      MetallicMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0.57, 1.37, 1.14];
 * viewer.scene.camera.look = [0.04, 0.58, 0.00];
 * viewer.scene.camera.up = [-0.22, 0.84, -0.48];
 *
 * loadOBJGeometry(viewer.scene, {
 *
 *      src: "models/obj/fireHydrant/FireHydrantMesh.obj",
 *      compressGeometry: false
 *
 *  }).then(function (geometryCfg) {
 *
 *      // Success
 *
 *      new Mesh(viewer.scene, {
 *
 *          geometry: new ReadableGeometry(viewer.scene, geometryCfg),
 *
 *          material: new MetallicMaterial(viewer.scene, {
 *
 *              baseColor: [1, 1, 1],
 *              metallic: 1.0,
 *              roughness: 1.0,
 * 
 *              baseColorMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Base_Color.png",
 *                  encoding: "sRGB"
 *              }),
 *              normalMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Normal_OpenGL.png"
 *              }),
 *              roughnessMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Roughness.png"
 *              }),
 *              metallicMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Metallic.png"
 *              }),
 *              occlusionMap: new Texture(viewer.scene, {
 *                  src: "models/obj/fireHydrant/fire_hydrant_Mixed_AO.png"
 *              }),
 * 
 *              specularF0: 0.7
 *          })
 *      });
 *  }, function () {
 *      // Error
 *  });
 * ````
 *
 * @function loadOBJGeometry
 * @param {Scene} scene Scene we're loading the geometry for.
 * @param {*} [cfg] Configs, also added to the result object.
 * @param {String} [cfg.src]  Path to OBJ file.
 * @returns {Object} Configuration to pass into a {@link Geometry} constructor, containing geometry arrays loaded from the OBJ file.
 */
function loadOBJGeometry(scene, cfg) {
    if ( cfg === void 0 ) cfg = {};


    return new Promise(function (resolve, reject) {

        if (!cfg.src) {
            console.error("loadOBJGeometry: Parameter expected: src");
            reject();
        }

        var spinner = scene.canvas.spinner;
        spinner.processes++;

        utils.loadArraybuffer(cfg.src, function (data) {

                if (!data.byteLength) {
                    console.error("loadOBJGeometry: no data loaded");
                    spinner.processes--;
                    reject();
                }

                var m = K3D.parse.fromOBJ(data);	// done !

                // unwrap simply duplicates some values, so they can be indexed with indices [0,1,2,3 ... ]
                // In some rendering engines, you can have only one index value for vertices, UVs, normals ...,
                // so "unwrapping" is a simple solution.

                var positions = K3D.edit.unwrap(m.i_verts, m.c_verts, 3);
                var normals = K3D.edit.unwrap(m.i_norms, m.c_norms, 3);
                var uv = K3D.edit.unwrap(m.i_uvt, m.c_uvt, 2);
                var indices = new Int32Array(m.i_verts.length);

                for (var i = 0; i < m.i_verts.length; i++) {
                    indices[i] = i;
                }

                spinner.processes--;

                resolve(utils.apply(cfg, {
                    primitive: "triangles",
                    positions: positions,
                    normals: normals.length > 0 ? normals : null,
                    autoNormals: normals.length === 0,
                    uv: uv,
                    indices: indices
                }));
            },

            function (msg) {
                console.error("loadOBJGeometry: " + msg);
                spinner.processes--;
                reject();
            });
    });
}

/**
 * @desc Creates a box-shaped lines {@link Geometry}.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a box-shaped {@link ReadableGeometry} that has lines primitives.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildBoxLinesGeometry, ReadableGeometry, PhongMaterial} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *         canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildBoxLinesGeometry({
 *         center: [0,0,0],
 *         xSize: 1,  // Half-size on each axis
 *         ySize: 1,
 *         zSize: 1
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *         emissive: [0,1,0]
 *      })
 * });
 * ````
 *
 * @function buildBoxLinesGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.
 * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.
 * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildBoxLinesGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var xSize = cfg.xSize || 1;
    if (xSize < 0) {
        console.error("negative xSize not allowed - will invert");
        xSize *= -1;
    }

    var ySize = cfg.ySize || 1;
    if (ySize < 0) {
        console.error("negative ySize not allowed - will invert");
        ySize *= -1;
    }

    var zSize = cfg.zSize || 1;
    if (zSize < 0) {
        console.error("negative zSize not allowed - will invert");
        zSize *= -1;
    }

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;

    var xmin = -xSize + centerX;
    var ymin = -ySize + centerY;
    var zmin = -zSize + centerZ;
    var xmax = xSize + centerX;
    var ymax = ySize + centerY;
    var zmax = zSize + centerZ;

    return utils.apply(cfg, {
        primitive: "lines",
        positions: [
            xmin, ymin, zmin,
            xmin, ymin, zmax,
            xmin, ymax, zmin,
            xmin, ymax, zmax,
            xmax, ymin, zmin,
            xmax, ymin, zmax,
            xmax, ymax, zmin,
            xmax, ymax, zmax
        ],
        indices: [
            0, 1,
            1, 3,
            3, 2,
            2, 0,
            4, 5,
            5, 7,
            7, 6,
            6, 4,
            0, 4,
            1, 5,
            2, 6,
            3, 7
        ]
    });
}

/**
 * @desc Creates a grid-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a GridGeometry and a {@link PhongMaterial}:
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildGridGeometry, VBOGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new VBOGeometry(viewer.scene, buildGridGeometry({
 *          size: 1000,
 *          divisions: 500
 *      })),
 *      material: new PhongMaterial(viewer.scene, {
 *          color: [0.0, 0.0, 0.0],
 *          emissive: [0.4, 0.4, 0.4]
 *      }),
 *      position: [0, -1.6, 0]
 * });
 * ````
 *
 * @function buildGridGeometry
 * @param {*} [cfg] Configs
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number} [cfg.size=1] Dimension on the X and Z-axis.
 * @param {Number} [cfg.divisions=1] Number of divisions on X and Z axis..
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildGridGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var size = cfg.size || 1;
    if (size < 0) {
        console.error("negative size not allowed - will invert");
        size *= -1;
    }

    var divisions = cfg.divisions || 1;
    if (divisions < 0) {
        console.error("negative divisions not allowed - will invert");
        divisions *= -1;
    }
    if (divisions < 1) {
        divisions = 1;
    }

    size = size || 10;
    divisions = divisions || 10;

    var step = size / divisions;
    var halfSize = size / 2;

    var positions = [];
    var indices = [];
    var l = 0;

    for (var i = 0, k = -halfSize; i <= divisions; i++, k += step) {

        positions.push(-halfSize);
        positions.push(0);
        positions.push(k);

        positions.push(halfSize);
        positions.push(0);
        positions.push(k);

        positions.push(k);
        positions.push(0);
        positions.push(-halfSize);

        positions.push(k);
        positions.push(0);
        positions.push(halfSize);

        indices.push(l++);
        indices.push(l++);
        indices.push(l++);
        indices.push(l++);
    }

    return utils.apply(cfg, {
        primitive: "lines",
        positions: positions,
        indices: indices
    });
}

/**
 * @desc Creates a plane-shaped {@link Geometry}.
 *
 * ## Usage
 *
 * Creating a {@link Mesh} with a PlaneGeometry and a {@link PhongMaterial} with diffuse {@link Texture}:
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildPlaneGeometry, ReadableGeometry, PhongMaterial, Texture} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.camera.eye = [0, 0, 5];
 * viewer.camera.look = [0, 0, 0];
 * viewer.camera.up = [0, 1, 0];

 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildPlaneGeometry({
 *          center: [0,0,0],
 *          xSize: 2,
 *          zSize: 2,
 *          xSegments: 10,
 *          zSegments: 10
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 *  });
 * ````
 *
 * @function buildPlaneGeometry
 * @param {*} [cfg] Configs
 * @param {Number[]} [cfg.center]  3D point indicating the center position.
 * @param {String} [cfg.id] Optional ID for the {@link Geometry}, unique among all components in the parent {@link Scene}, generated automatically when omitted.
 * @param {Number} [cfg.xSize=1] Dimension on the X-axis.
 * @param {Number} [cfg.zSize=1] Dimension on the Z-axis.
 * @param {Number} [cfg.xSegments=1] Number of segments on the X-axis.
 * @param {Number} [cfg.zSegments=1] Number of segments on the Z-axis.
 * @returns {Object} Configuration for a {@link Geometry} subtype.
 */
function buildPlaneGeometry(cfg) {
    if ( cfg === void 0 ) cfg = {};


    var xSize = cfg.xSize || 1;
    if (xSize < 0) {
        console.error("negative xSize not allowed - will invert");
        xSize *= -1;
    }

    var zSize = cfg.zSize || 1;
    if (zSize < 0) {
        console.error("negative zSize not allowed - will invert");
        zSize *= -1;
    }

    var xSegments = cfg.xSegments || 1;
    if (xSegments < 0) {
        console.error("negative xSegments not allowed - will invert");
        xSegments *= -1;
    }
    if (xSegments < 1) {
        xSegments = 1;
    }

    var zSegments = cfg.xSegments || 1;
    if (zSegments < 0) {
        console.error("negative zSegments not allowed - will invert");
        zSegments *= -1;
    }
    if (zSegments < 1) {
        zSegments = 1;
    }

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;

    var halfWidth = xSize / 2;
    var halfHeight = zSize / 2;

    var planeX = Math.floor(xSegments) || 1;
    var planeZ = Math.floor(zSegments) || 1;

    var planeX1 = planeX + 1;
    var planeZ1 = planeZ + 1;

    var segmentWidth = xSize / planeX;
    var segmentHeight = zSize / planeZ;

    var positions = new Float32Array(planeX1 * planeZ1 * 3);
    var normals = new Float32Array(planeX1 * planeZ1 * 3);
    var uvs = new Float32Array(planeX1 * planeZ1 * 2);

    var offset = 0;
    var offset2 = 0;

    var iz;
    var ix;
    var x;
    var a;
    var b;
    var c;
    var d;

    for (iz = 0; iz < planeZ1; iz++) {

        var z = iz * segmentHeight - halfHeight;

        for (ix = 0; ix < planeX1; ix++) {

            x = ix * segmentWidth - halfWidth;

            positions[offset] = x + centerX;
            positions[offset + 1] = centerY;
            positions[offset + 2] = -z + centerZ;

            normals[offset + 2] = -1;

            uvs[offset2] = (ix) / planeX;
            uvs[offset2 + 1] = ((planeZ - iz) / planeZ);

            offset += 3;
            offset2 += 2;
        }
    }

    offset = 0;

    var indices = new ((positions.length / 3) > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);

    for (iz = 0; iz < planeZ; iz++) {

        for (ix = 0; ix < planeX; ix++) {

            a = ix + planeX1 * iz;
            b = ix + planeX1 * (iz + 1);
            c = (ix + 1) + planeX1 * (iz + 1);
            d = (ix + 1) + planeX1 * iz;

            indices[offset] = d;
            indices[offset + 1] = b;
            indices[offset + 2] = a;

            indices[offset + 3] = d;
            indices[offset + 4] = c;
            indices[offset + 5] = b;

            offset += 6;
        }
    }

    return utils.apply(cfg, {
        positions: positions,
        normals: normals,
        uv: uvs,
        indices: indices
    });
}

var tempVec3$1 = math.vec3();
var tempVec3b$3 = math.vec3();
math.vec3();
var zeroVec = math.vec3([0, -1, 0]);
var tempQuat = math.vec4([0, 0, 0, 1]);

/**
 *  @desc A plane-shaped 3D object containing a bitmap image.
 *
 * Use ````ImagePlane```` to embed bitmap images in your scenes.
 *
 * As shown in the examples below, ````ImagePlane```` is useful for creating ground planes from satellite maps and embedding 2D plan
 * view images in cross-section slicing planes.
 *
 * # Example 1: Create a ground plane from a satellite image
 *
 * In our first example, we'll load the Schependomlaan model, then use
 * an ````ImagePlane```` to create a ground plane, which will contain
 * a satellite image sourced from Google Maps.
 *
 * <img src="http://xeokit.io/img/docs/ImagePlane/schependomlaanGoogleSatMapMed.png">
 *
 * [<img src="http://xeokit.io/img/docs/ImagePlane/ImagePlane.png">](http://xeokit.github.io/xeokit-sdk/examples/#ImagePlane_groundPlane)
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#ImagePlane_groundPlane)]
 *
 * ````javascript
 * import {Viewer, ImagePlane, XKTLoaderPlugin} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas",
 *      transparent: true
 *  });
 *
 * viewer.camera.eye = [-8.31, 42.21, 54.30];
 * viewer.camera.look = [-0.86, 15.40, 14.90];
 * viewer.camera.up = [0.10, 0.83, -0.54];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * xktLoader.load({             // Load IFC model
 *      id: "myModel",
 *      src: "./models/xkt/Schependomlaan.xkt",
 *      edges: true,
 *
 *      rotation: [0, 22, 0],   // Rotate, position and scale the model to align it correctly with the ImagePlane
 *      position: [-8, 0, 15],
 *      scale: [1.1, 1.1, 1.1]
 *  });
 *
 * new ImagePlane(viewer.scene, {
 *      src: "./images/schependomlaanSatMap.png",       // Google satellite image; accepted file types are PNG and JPEG
 *      visible: true,                                  // Show the ImagePlane
 *      gridVisible: true,                              // Show the grid - grid is only visible when ImagePlane is also visible
 *      size: 190,                                      // Size of ImagePlane's longest edge
 *      position: [0, -1, 0],                           // World-space position of ImagePlane's center
 *      rotation: [0, 0, 0],                            // Euler angles for X, Y and Z
 *      opacity: 1.0,                                   // Fully opaque
 *      collidable: false,                              // ImagePlane does not contribute to Scene boundary
 *      clippable: true,                                // ImagePlane can be clipped by SectionPlanes
 *      pickable: true                                  // Allow the ground plane to be picked
 * });
 * ````
 *<br>
 *
 * # Example 2: Embed an image in a cross-section plane
 *
 * In our second example, we'll load the Schependomlaan model again, then slice it in half with
 * a {@link SectionPlanesPlugin}, then use an ````ImagePlane```` to embed a 2D plan view image in the slicing plane.
 *
 * <img src="http://xeokit.io/img/docs/ImagePlane/schependomlaanPlanViewMed.png">
 *
 * [<img src="http://xeokit.io/img/docs/ImagePlane/ImagePlane_planView.png">](http://xeokit.github.io/xeokit-sdk/examples/#ImagePlane_imageInSectionPlane)
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#ImagePlane_imageInSectionPlane)]
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin, SectionPlanesPlugin, ImagePlane} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas",
 *     transparent: true
 * });
 *
 * viewer.camera.eye = [-9.11, 20.01, 5.13];
 * viewer.camera.look = [9.07, 0.77, -9.78];
 * viewer.camera.up = [0.47, 0.76, -0.38];
 *
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const sectionPlanes = new SectionPlanesPlugin(viewer, {
 *     overviewVisible: false
 * });
 *
 * model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt",
 *     metaModelSrc: "./metaModels/schependomlaan/metaModel.json",
 *     edges: true,
 * });
 *
 * const sectionPlane = sectionPlanes.createSectionPlane({
 *     id: "mySectionPlane",
 *     pos: [10.95, 1.95, -10.35],
 *     dir: [0.0, -1.0, 0.0]
 * });
 *
 * const imagePlane = new ImagePlane(viewer.scene, {
 *     src: "./images/schependomlaanPlanView.png",  // Plan view image; accepted file types are PNG and JPEG
 *     visible: true,
 *     gridVisible: true,
 *     size: 23.95,
 *     position: sectionPlane.pos,
 *     dir: sectionPlane.dir,
 *     collidable: false,
 *     opacity: 0.75,
 *     clippable: false,                            // Don't allow ImagePlane to be clipped by the SectionPlane
 *     pickable: false                              // Don't allow ImagePlane to be picked
 *  });
 * ````
 */
var ImagePlane = /*@__PURE__*/(function (Component) {
    function ImagePlane(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._src = null;
        this._image = null;
        this._pos = math.vec3();
        this._rtcCenter = math.vec3();
        this._rtcPos = math.vec3();
        this._dir = math.vec3();
        this._size = 1.0;
        this._imageSize = math.vec2();

        this._texture = new Texture(this);

        this._plane = new Mesh(this, {

            geometry: new ReadableGeometry(this, buildPlaneGeometry({
                center: [0, 0, 0],
                xSize: 1,
                zSize: 1,
                xSegments: 10,
                zSegments: 10
            })),

            material: new PhongMaterial(this, {
                diffuse: [0, 0, 0],
                ambient: [0, 0, 0],
                specular: [0, 0, 0],
                diffuseMap: this._texture,
                emissiveMap: this._texture,
                backfaces: true
            }),
            clippable: cfg.clippable
        });

        this._grid = new Mesh(this, {
            geometry: new ReadableGeometry(this, buildGridGeometry({
                size: 1,
                divisions: 10
            })),
            material: new PhongMaterial(this, {
                diffuse: [0.0, 0.0, 0.0],
                ambient: [0.0, 0.0, 0.0],
                emissive: [0.2, 0.8, 0.2]
            }),
            position: [0, 0.001, 0.0],
            clippable: cfg.clippable
        });

        this._node = new Node(this, {
            rotation: [0, 0, 0],
            position: [0, 0, 0],
            scale: [1, 1, 1],
            clippable: false,
            children: [
                this._plane,
                this._grid
            ]
        });

        this._gridVisible = false;

        this.visible = true;
        this.gridVisible = cfg.gridVisible;
        this.position = cfg.position;
        this.rotation = cfg.rotation;
        this.dir = cfg.dir;
        this.size = cfg.size;
        this.collidable = cfg.collidable;
        this.clippable = cfg.clippable;
        this.pickable = cfg.pickable;
        this.opacity = cfg.opacity;

        if (cfg.image) {
            this.image = cfg.image;
        } else {
            this.src = cfg.src;
        }
    }

    if ( Component ) ImagePlane.__proto__ = Component;
    ImagePlane.prototype = Object.create( Component && Component.prototype );
    ImagePlane.prototype.constructor = ImagePlane;

    var prototypeAccessors = { visible: { configurable: true },gridVisible: { configurable: true },image: { configurable: true },src: { configurable: true },position: { configurable: true },rotation: { configurable: true },size: { configurable: true },dir: { configurable: true },collidable: { configurable: true },clippable: { configurable: true },pickable: { configurable: true },opacity: { configurable: true } };

    /**
     * Sets if this ````ImagePlane```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @param {Boolean} visible Set ````true```` to make this ````ImagePlane```` visible.
     */
    prototypeAccessors.visible.set = function (visible) {
        this._plane.visible = visible;
        this._grid.visible = (this._gridVisible && visible);
    };

    /**
     * Gets if this ````ImagePlane```` is visible or not.
     *
     * Default value is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */
    prototypeAccessors.visible.get = function () {
        return this._plane.visible;
    };

    /**
     * Sets if this ````ImagePlane````'s grid  is visible or not.
     *
     * Default value is ````false````.
     *
     * Grid is only visible when ````ImagePlane```` is also visible.
     *
     * @param {Boolean} visible Set ````true```` to make this ````ImagePlane````'s grid visible.
     */
    prototypeAccessors.gridVisible.set = function (visible) {
        visible = (visible !== false);
        this._gridVisible = visible;
        this._grid.visible = (this._gridVisible && this.visible);
    };

    /**
     * Gets if this ````ImagePlane````'s grid is visible or not.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} Returns ````true```` if visible.
     */
    prototypeAccessors.gridVisible.get = function () {
        return this._gridVisible;
    };

    /**
     * Sets an ````HTMLImageElement```` to source the image from.
     *
     * Sets {@link Texture#src} null.
     *
     * @type {HTMLImageElement}
     */
    prototypeAccessors.image.set = function (image) {
        this._image = image;
        if (this._image) {
            this._imageSize[0] = image.width;
            this._imageSize[1] = image.height;
            this._updatePlaneSizeFromImage();
            this._src = null;
            this._texture.image = this._image;
        }
    };

    /**
     * Gets the ````HTMLImageElement```` the ````ImagePlane````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {HTMLImageElement}
     */
    prototypeAccessors.image.get = function () {
        return this._image;
    };

    /**
     * Sets an image file path that the ````ImagePlane````'s image is sourced from.
     *
     * Accepted file types are PNG and JPEG.
     *
     * Sets {@link Texture#image} null.
     *
     * @type {String}
     */
    prototypeAccessors.src.set = function (src) {
        var this$1 = this;

        this._src = src;
        if (this._src) {
            this._image = null;
            var image = new Image();
            image.onload = function () {
                this$1._texture.image = image;
                this$1._imageSize[0] = image.width;
                this$1._imageSize[1] = image.height;
                this$1._updatePlaneSizeFromImage();
            };
            image.src = this._src;
        }
    };

    /**
     * Gets the image file path that the ````ImagePlane````'s image is sourced from, if set.
     *
     * Returns null if not set.
     *
     * @type {String}
     */
    prototypeAccessors.src.get = function () {
        return this._src;
    };

    /**
     * Sets the World-space position of this ````ImagePlane````.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value New position.
     */
    prototypeAccessors.position.set = function (value) {
        this._pos.set(value || [0, 0, 0]);
        worldToRTCPos(this._pos, this._rtcCenter, this._rtcPos);
        this._node.rtcCenter = this._rtcCenter;
        this._node.position = this._rtcPos;
    };

    /**
     * Gets the World-space position of this ````ImagePlane````.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns {Number[]} Current position.
     */
    prototypeAccessors.position.get = function () {
        return this._pos;
    };

    /**
     * Sets the direction of this ````ImagePlane```` using Euler angles.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param {Number[]} value Euler angles for ````X````, ````Y```` and ````Z```` axis rotations.
     */
    prototypeAccessors.rotation.set = function (value) {
        this._node.rotation = value;
    };

    /**
     * Gets the direction of this ````ImagePlane```` as Euler angles.
     *
     * @returns {Number[]} Euler angles for ````X````, ````Y```` and ````Z```` axis rotations.
     */
    prototypeAccessors.rotation.get = function () {
        return this._node.rotation;
    };

    /**
     * Sets the World-space size of the longest edge of the ````ImagePlane````.
     *
     * Note that ````ImagePlane```` sets its aspect ratio to match its image. If we set a value of ````1000````, and
     * the image has size ````400x300````, then the ````ImagePlane```` will then have size ````1000 x 750````.
     *
     * Default value is ````1.0````.
     *
     * @param {Number} size New World-space size of the ````ImagePlane````.
     */
    prototypeAccessors.size.set = function (size) {
        this._size = (size === undefined || size === null) ? 1.0 : size;
        if (this._image) {
            this._updatePlaneSizeFromImage();
        }
    };

    /**
     * Gets the World-space size of the longest edge of the ````ImagePlane````.
     *
     * Returns {Number} World-space size of the ````ImagePlane````.
     */
    prototypeAccessors.size.get = function () {
        return this._size;
    };

    /**
     * Sets the direction of this ````ImagePlane```` as a direction vector.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @param {Number[]} dir New direction vector.
     */
    prototypeAccessors.dir.set = function (dir) {

        this._dir.set(dir || [0, 0, -1]);

        if (dir) {

            var origin = this.scene.center;
            var negDir = [-this._dir[0], -this._dir[1], -this._dir[2]];

            math.subVec3(origin, this.position, tempVec3$1);

            var dist = -math.dotVec3(negDir, tempVec3$1);

            math.normalizeVec3(negDir);
            math.mulVec3Scalar(negDir, dist, tempVec3b$3);
            math.vec3PairToQuaternion(zeroVec, dir, tempQuat);

            this._node.quaternion = tempQuat;
        }
    };

    /**
     * Gets the direction of this ````ImagePlane```` as a direction vector.
     *
     * @returns {Number[]} value Current direction.
     */
    prototypeAccessors.dir.get = function () {
        return this._dir;
    };

    /**
     * Sets if this ````ImagePlane```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.set = function (value) {
        this._node.collidable = (value !== false);
    };

    /**
     * Gets if this ````ImagePlane```` is included in boundary calculations.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.collidable.get = function () {
        return this._node.collidable;
    };

    /**
     * Sets if this ````ImagePlane```` is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.set = function (value) {
        this._node.clippable = (value !== false);
    };

    /**
     * Gets if this ````ImagePlane````  is clippable.
     *
     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.clippable.get = function () {
        return this._node.clippable;
    };

    /**
     * Sets if this ````ImagePlane```` is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.set = function (value) {
        this._node.pickable = (value !== false);
    };

    /**
     * Gets if this ````ImagePlane````  is pickable.
     *
     * Default is ````true````.
     *
     * @type {Boolean}
     */
    prototypeAccessors.pickable.get = function () {
        return this._node.pickable;
    };

    /**
     * Sets the opacity factor for this ````ImagePlane````.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.set = function (opacity) {
        this._node.opacity = opacity;
    };

    /**
     * Gets this ````ImagePlane````'s opacity factor.
     *
     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     *
     * @type {Number}
     */
    prototypeAccessors.opacity.get = function () {
        return this._node.opacity;
    };

    /**
     * @destroy
     */
    ImagePlane.prototype.destroy = function destroy () {
        this._state.destroy();
        Component.prototype.destroy.call(this);
    };

    ImagePlane.prototype._updatePlaneSizeFromImage = function _updatePlaneSizeFromImage () {
        var size = this._size;
        var width = this._imageSize[0];
        var height = this._imageSize[1];
        var aspect = height / width;
        if (width > height) {
            this._node.scale = [size, 1.0, size * aspect];
        } else {
            this._node.scale = [size * aspect, 1.0, size];
        }
    };

    Object.defineProperties( ImagePlane.prototype, prototypeAccessors );

    return ImagePlane;
}(Component));

/**
 * A positional light source that originates from a single point and spreads outward in all directions, with optional attenuation over distance.
 *
 * * Has a position in {@link PointLight#pos}, but no direction.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link PointLight#pos} is relative to
 * the World coordinate system, and will appear to move as the {@link Camera} moves. When in View-space,
 * {@link PointLight#pos} is relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * Has {@link PointLight#constantAttenuation}, {@link PointLight#linearAttenuation} and {@link PointLight#quadraticAttenuation}
 * factors, which indicate how intensity attenuates over distance.
 * * {@link AmbientLight}s, {@link PointLight}s and {@link PointLight}s are registered by their {@link Component#id} on {@link Scene#lights}.
 *
 * ## Usage
 *
 * In the example below we'll replace the {@link Scene}'s default light sources with three World-space PointLights.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#lights_PointLight_world)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry, buildPlaneGeometry,
 *      ReadableGeometry, PhongMaterial, Texture, PointLight} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * // Replace the Scene's default lights with three custom world-space PointLights
 *
 * viewer.scene.clearLights();
 *
 * new PointLight(viewer.scene,{
 *      id: "keyLight",
 *      pos: [-80, 60, 80],
 *      color: [1.0, 0.3, 0.3],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * new PointLight(viewer.scene,{
 *      id: "fillLight",
 *      pos: [80, 40, 40],
 *      color: [0.3, 1.0, 0.3],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * new PointLight(viewer.scene,{
 *      id: "rimLight",
 *      pos: [-20, 80, -80],
 *      color: [0.6, 0.6, 0.6],
 *      intensity: 1.0,
 *      space: "world"
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 1.3
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuse: [0.7, 0.7, 0.7],
 *          specular: [1.0, 1.0, 1.0],
 *          emissive: [0, 0, 0],
 *          alpha: 1.0,
 *          ambient: [1, 1, 0],
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          })
 *      })
 * });
 *
 * new Mesh(viewer.scene, {
 *      geometry: buildPlaneGeometry(ReadableGeometry, viewer.scene, {
 *          xSize: 30,
 *          zSize: 30
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          diffuseMap: new Texture(viewer.scene, {
 *               src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          backfaces: true
 *      }),
 *      position: [0, -2.1, 0]
 * });
 * ````
 */
var PointLight = /*@__PURE__*/(function (Light) {
    function PointLight(owner, cfg) {
        var this$1 = this;
        if ( cfg === void 0 ) cfg = {};


        Light.call(this, owner, cfg);

        var self = this;

        this._shadowRenderBuf = null;
        this._shadowViewMatrix = null;
        this._shadowProjMatrix = null;
        this._shadowViewMatrixDirty = true;
        this._shadowProjMatrixDirty = true;

        var camera = this.scene.camera;
        var canvas = this.scene.canvas;

        this._onCameraViewMatrix = camera.on("viewMatrix", function () {
            this$1._shadowViewMatrixDirty = true;
        });

        this._onCameraProjMatrix = camera.on("projMatrix", function () {
            this$1._shadowProjMatrixDirty = true;
        });

        this._onCanvasBoundary = canvas.on("boundary", function () {
            this$1._shadowProjMatrixDirty = true;
        });

        this._state = new RenderState({

            type: "point",
            pos: math.vec3([1.0, 1.0, 1.0]),
            color: math.vec3([0.7, 0.7, 0.8]),
            intensity: 1.0, attenuation: [0.0, 0.0, 0.0],
            space: cfg.space || "view",
            castsShadow: false,

            getShadowViewMatrix: function () {
                if (self._shadowViewMatrixDirty) {
                    if (!self._shadowViewMatrix) {
                        self._shadowViewMatrix = math.identityMat4();
                    }
                    var eye = self._state.pos;
                    var look = camera.look;
                    var up = camera.up;
                    math.lookAtMat4v(eye, look, up, self._shadowViewMatrix);
                    self._shadowViewMatrixDirty = false;
                }
                return self._shadowViewMatrix;
            },

            getShadowProjMatrix: function () {
                if (self._shadowProjMatrixDirty) { // TODO: Set when canvas resizes
                    if (!self._shadowProjMatrix) {
                        self._shadowProjMatrix = math.identityMat4();
                    }
                    var canvas = self.scene.canvas.canvas;
                    math.perspectiveMat4(70 * (Math.PI / 180.0), canvas.clientWidth / canvas.clientHeight, 0.1, 500.0, self._shadowProjMatrix);
                    self._shadowProjMatrixDirty = false;
                }
                return self._shadowProjMatrix;
            },

            getShadowRenderBuf: function () {
                if (!self._shadowRenderBuf) {
                    self._shadowRenderBuf = new RenderBuffer(self.scene.canvas.canvas, self.scene.canvas.gl, {size: [1024, 1024]}); // Super old mobile devices have a limit of 1024x1024 textures
                }
                return self._shadowRenderBuf;
            }
        });

        this.pos = cfg.pos;
        this.color = cfg.color;
        this.intensity = cfg.intensity;
        this.constantAttenuation = cfg.constantAttenuation;
        this.linearAttenuation = cfg.linearAttenuation;
        this.quadraticAttenuation = cfg.quadraticAttenuation;
        this.castsShadow = cfg.castsShadow;

        this.scene._lightCreated(this);
    }

    if ( Light ) PointLight.__proto__ = Light;
    PointLight.prototype = Object.create( Light && Light.prototype );
    PointLight.prototype.constructor = PointLight;

    var prototypeAccessors = { type: { configurable: true },pos: { configurable: true },color: { configurable: true },intensity: { configurable: true },constantAttenuation: { configurable: true },linearAttenuation: { configurable: true },quadraticAttenuation: { configurable: true },castsShadow: { configurable: true } };

    /**
     * Sets the position of this PointLight.
     *
     * This will be either World- or View-space, depending on the value of {@link PointLight#space}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param {Number[]} pos The position.
     */
    prototypeAccessors.type.get = function () {
        return "PointLight";
    };

    prototypeAccessors.pos.set = function (pos) {
        this._state.pos.set(pos || [1.0, 1.0, 1.0]);
        this._shadowViewMatrixDirty = true;
        this.glRedraw();
    };

    /**
     * Gets the position of this PointLight.
     *
     * This will be either World- or View-space, depending on the value of {@link PointLight#space}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @returns {Number[]} The position.
     */
    prototypeAccessors.pos.get = function () {
        return this._state.pos;
    };

    /**
     * Sets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param {Number[]} color The PointLight's RGB color.
     */
    prototypeAccessors.color.set = function (color) {
        this._state.color.set(color || [0.7, 0.7, 0.8]);
        this.glRedraw();
    };

    /**
     * Gets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The PointLight's RGB color.
     */
    prototypeAccessors.color.get = function () {
        return this._state.color;
    };

    /**
     * Sets the intensity of this PointLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param {Number} intensity The PointLight's intensity
     */
    prototypeAccessors.intensity.set = function (intensity) {
        intensity = intensity !== undefined ? intensity : 1.0;
        this._state.intensity = intensity;
        this.glRedraw();
    };

    /**
     * Gets the intensity of this PointLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The PointLight's intensity.
     */
    prototypeAccessors.intensity.get = function () {
        return this._state.intensity;
    };

    /**
     * Sets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The constant attenuation factor.
     */
    prototypeAccessors.constantAttenuation.set = function (value) {
        this._state.attenuation[0] = value || 0.0;
        this.glRedraw();
    };

    /**
     * Gets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The constant attenuation factor.
     */
    prototypeAccessors.constantAttenuation.get = function () {
        return this._state.attenuation[0];
    };

    /**
     * Sets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The linear attenuation factor.
     */
    prototypeAccessors.linearAttenuation.set = function (value) {
        this._state.attenuation[1] = value || 0.0;
        this.glRedraw();
    };

    /**
     * Gets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The linear attenuation factor.
     */
    prototypeAccessors.linearAttenuation.get = function () {
        return this._state.attenuation[1];
    };

    /**
     * Sets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The quadratic attenuation factor.
     */
    prototypeAccessors.quadraticAttenuation.set = function (value) {
        this._state.attenuation[2] = value || 0.0;
        this.glRedraw();
    };

    /**
     * Gets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The quadratic attenuation factor.
     */
    prototypeAccessors.quadraticAttenuation.get = function () {
        return this._state.attenuation[2];
    };

    /**
     * Sets if this PointLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @param {Boolean} castsShadow Set ````true```` to cast shadows.
     */
    prototypeAccessors.castsShadow.set = function (castsShadow) {
        castsShadow = !!castsShadow;
        if (this._state.castsShadow === castsShadow) {
            return;
        }
        this._state.castsShadow = castsShadow;
        this._shadowViewMatrixDirty = true;
        this.glRedraw();
    };

    /**
     * Gets if this PointLight casts a shadow.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if this PointLight casts shadows.
     */
    prototypeAccessors.castsShadow.get = function () {
        return this._state.castsShadow;
    };

    /**
     * Destroys this PointLight.
     */
    PointLight.prototype.destroy = function destroy () {

        var camera = this.scene.camera;
        var canvas = this.scene.canvas;
        camera.off(this._onCameraViewMatrix);
        camera.off(this._onCameraProjMatrix);
        canvas.off(this._onCanvasBoundary);

        Light.prototype.destroy.call(this);

        this._state.destroy();
        if (this._shadowRenderBuf) {
            this._shadowRenderBuf.destroy();
        }
        this.scene._lightDestroyed(this);
        this.glRedraw();
    };

    Object.defineProperties( PointLight.prototype, prototypeAccessors );

    return PointLight;
}(Light));

function ensureImageSizePowerOfTwo(image) {
    if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
        var canvas = document.createElement("canvas");
        canvas.width = nextHighestPowerOfTwo(image.width);
        canvas.height = nextHighestPowerOfTwo(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image,
            0, 0, image.width, image.height,
            0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
}

function isPowerOfTwo(x) {
    return (x & (x - 1)) === 0;
}

function nextHighestPowerOfTwo(x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
}

/**
 * @desc A cube texture map.
 */
var CubeTexture = /*@__PURE__*/(function (Component) {
    function CubeTexture(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        var gl = this.scene.canvas.gl;

        this._state = new RenderState({
            texture: new Texture2D(gl, gl.TEXTURE_CUBE_MAP),
            flipY: this._checkFlipY(cfg.minFilter),
            encoding: this._checkEncoding(cfg.encoding),
            minFilter: "linearMipmapLinear",
            magFilter: "linear",
            wrapS: "clampToEdge",
            wrapT: "clampToEdge",
            mipmaps: true
        });

        this._src = cfg.src;
        this._images = [];

        this._loadSrc(cfg.src);

        stats.memory.textures++;
    }

    if ( Component ) CubeTexture.__proto__ = Component;
    CubeTexture.prototype = Object.create( Component && Component.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    var prototypeAccessors = { type: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "CubeTexture";
    };

    CubeTexture.prototype._checkFlipY = function _checkFlipY (value) {
        return !!value;
    };

    CubeTexture.prototype._checkEncoding = function _checkEncoding (value) {
        value = value || "linear";
        if (value !== "linear" && value !== "sRGB" && value !== "gamma") {
            this.error("Unsupported value for 'encoding': '" + value + "' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");
            value = "linear";
        }
        return value;
    };

    CubeTexture.prototype._webglContextRestored = function _webglContextRestored () {
        this.scene.canvas.gl;
        this._state.texture = null;
        // if (this._images.length > 0) {
        //     this._state.texture = new xeokit.renderer.Texture2D(gl, gl.TEXTURE_CUBE_MAP);
        //     this._state.texture.setImage(this._images, this._state);
        //     this._state.texture.setProps(this._state);
        // } else
        if (this._src) {
            this._loadSrc(this._src);
        }
    };

    CubeTexture.prototype._loadSrc = function _loadSrc (src) {
        var self = this;
        var gl = this.scene.canvas.gl;
        this._images = [];
        var loadFailed = false;
        var numLoaded = 0;
        var loop = function ( i ) {
            var image = new Image();
            image.onload = (function () {
                var _image = image;
                var index = i;
                return function () {
                    if (loadFailed) {
                        return;
                    }
                    _image = ensureImageSizePowerOfTwo(_image);
                    self._images[index] = _image;
                    numLoaded++;
                    if (numLoaded === 6) {
                        var texture = self._state.texture;
                        if (!texture) {
                            texture = new Texture2D(gl, gl.TEXTURE_CUBE_MAP);
                            self._state.texture = texture;
                        }
                        texture.setImage(self._images, self._state);
                        texture.setProps(self._state);
                        self.fire("loaded", self._src, false);
                        self.glRedraw();
                    }
                };
            })();
            image.onerror = function () {
                loadFailed = true;
            };
            image.src = src[i];
        };

        for (var i = 0; i < src.length; i++) loop( i );
    };

    /**
     * Destroys this CubeTexture
     *
     */
    CubeTexture.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        if (this._state.texture) {
            this._state.texture.destroy();
        }
        stats.memory.textures--;
        this._state.destroy();
    };

    Object.defineProperties( CubeTexture.prototype, prototypeAccessors );

    return CubeTexture;
}(Component));

/**
 * @desc A reflection cube map.
 *
 * ## Usage
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, MetallicMaterial, ReflectionMap} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new ReflectionMap(viewer.scene, {
 *     src: [
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PX.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NX.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PY.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NY.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PZ.png",
 *         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NZ.png"
 *     ]
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      new MetallicMaterial(viewer.scene, {
 *          baseColor: [1, 1, 1],
 *          metallic: 1.0,
 *          roughness: 1.0
 *      })
 * });
 * ````
 */
var ReflectionMap = /*@__PURE__*/(function (CubeTexture) {
    function ReflectionMap(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        CubeTexture.call(this, owner, cfg);
        this.scene._lightsState.addReflectionMap(this._state);
        this.scene._reflectionMapCreated(this);
    }

    if ( CubeTexture ) ReflectionMap.__proto__ = CubeTexture;
    ReflectionMap.prototype = Object.create( CubeTexture && CubeTexture.prototype );
    ReflectionMap.prototype.constructor = ReflectionMap;

    var prototypeAccessors = { type: { configurable: true } };

    /**
     * Destroys this ReflectionMap.
     */
    prototypeAccessors.type.get = function () {
        return "ReflectionMap";
    };

    ReflectionMap.prototype.destroy = function destroy () {
        CubeTexture.prototype.destroy.call(this);
        this.scene._reflectionMapDestroyed(this);
    };

    Object.defineProperties( ReflectionMap.prototype, prototypeAccessors );

    return ReflectionMap;
}(CubeTexture));

/**
 * @desc A **LightMap** specifies a cube texture light map.
 *
 * ## Usage
 *
 * ````javascript
 * import {Viewer, Mesh, buildSphereGeometry,
 *      ReadableGeometry, MetallicMaterial, LightMap} from "xeokit-sdk.es.js";
 *
 * // Create a Viewer and arrange the camera
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new LightMap(viewer.scene, {
 *     src: [
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
 *         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
 *     ]
 * });
 *
 * // Create a sphere and ground plane
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildSphereGeometry({
 *          radius: 2.0
 *      }),
 *      new MetallicMaterial(viewer.scene, {
 *          baseColor: [1, 1, 1],
 *          metallic: 1.0,
 *          roughness: 1.0
 *      })
 * });
 * ````
 */
var LightMap = /*@__PURE__*/(function (CubeTexture) {
    function LightMap(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        CubeTexture.call(this, owner, cfg);
        this.scene._lightMapCreated(this);
    }

    if ( CubeTexture ) LightMap.__proto__ = CubeTexture;
    LightMap.prototype = Object.create( CubeTexture && CubeTexture.prototype );
    LightMap.prototype.constructor = LightMap;

    var prototypeAccessors = { type: { configurable: true } };

    prototypeAccessors.type.get = function () {
        return "LightMap";
    };

    LightMap.prototype.destroy = function destroy () {
        CubeTexture.prototype.destroy.call(this);
        this.scene._lightMapDestroyed(this);
    };

    Object.defineProperties( LightMap.prototype, prototypeAccessors );

    return LightMap;
}(CubeTexture));

/**
 * @desc Configures Fresnel effects for {@link PhongMaterial}s.
 *
 * Fresnels are attached to {@link PhongMaterial}s, which are attached to {@link Mesh}es.
 *
 * ## Usage
 *
 * In the example below we'll create a {@link Mesh} with a {@link PhongMaterial} that applies a Fresnel to its alpha channel to give a glasss-like effect.
 *
 * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_Fresnel)]
 *
 * ````javascript
 * import {Viewer, Mesh, buildTorusGeometry,
 *      ReadableGeometry, PhongMaterial, Texture, Fresnel} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *       canvasId: "myCanvas",
 *       transparent: true
 * });
 *
 * viewer.scene.camera.eye = [0, 0, 5];
 * viewer.scene.camera.look = [0, 0, 0];
 * viewer.scene.camera.up = [0, 1, 0];
 *
 * new Mesh(viewer.scene, {
 *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({
 *          center: [0, 0, 0],
 *          radius: 1.5,
 *          tube: 0.5,
 *          radialSegments: 32,
 *          tubeSegments: 24,
 *          arc: Math.PI * 2.0
 *      }),
 *      material: new PhongMaterial(viewer.scene, {
 *          alpha: 0.9,
 *          alphaMode: "blend",
 *          ambient: [0.0, 0.0, 0.0],
 *          shininess: 30,
 *          diffuseMap: new Texture(viewer.scene, {
 *              src: "textures/diffuse/uvGrid2.jpg"
 *          }),
 *          alphaFresnel: new Fresnel(viewer.scene, {
v               edgeBias: 0.2,
 *              centerBias: 0.8,
 *              edgeColor: [1.0, 1.0, 1.0],
 *              centerColor: [0.0, 0.0, 0.0],
 *              power: 2
 *          })
 *      })
 * });
 * ````
 */
var Fresnel = /*@__PURE__*/(function (Component) {
    function Fresnel(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        this._state = new RenderState({
            edgeColor: math.vec3([0, 0, 0]),
            centerColor: math.vec3([1, 1, 1]),
            edgeBias: 0,
            centerBias: 1,
            power: 1
        });

        this.edgeColor = cfg.edgeColor;
        this.centerColor = cfg.centerColor;
        this.edgeBias = cfg.edgeBias;
        this.centerBias = cfg.centerBias;
        this.power = cfg.power;
    }

    if ( Component ) Fresnel.__proto__ = Component;
    Fresnel.prototype = Object.create( Component && Component.prototype );
    Fresnel.prototype.constructor = Fresnel;

    var prototypeAccessors = { type: { configurable: true },edgeColor: { configurable: true },centerColor: { configurable: true },edgeBias: { configurable: true },centerBias: { configurable: true },power: { configurable: true } };

    /**
     * Sets the Fresnel's edge color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.type.get = function () {
        return "Fresnel";
    };

    prototypeAccessors.edgeColor.set = function (value) {
        this._state.edgeColor.set(value || [0.0, 0.0, 0.0]);
        this.glRedraw();
    };

    /**
     * Gets the Fresnel's edge color.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.edgeColor.get = function () {
        return this._state.edgeColor;
    };

    /**
     * Sets the Fresnel's center color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.centerColor.set = function (value) {
        this._state.centerColor.set(value || [1.0, 1.0, 1.0]);
        this.glRedraw();
    };

    /**
     * Gets the Fresnel's center color.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @type {Number[]}
     */
    prototypeAccessors.centerColor.get = function () {
        return this._state.centerColor;
    };

    /**
     * Sets the Fresnel's edge bias.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeBias.set = function (value) {
        this._state.edgeBias = value || 0;
        this.glRedraw();
    };

    /**
     * Gets the Fresnel's edge bias.
     *
     * Default value is ````0````.
     *
     * @type {Number}
     */
    prototypeAccessors.edgeBias.get = function () {
        return this._state.edgeBias;
    };

    /**
     * Sets the Fresnel's center bias.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.centerBias.set = function (value) {
        this._state.centerBias = (value !== undefined && value !== null) ? value : 1;
        this.glRedraw();
    };

    /**
     * Gets the Fresnel's center bias.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.centerBias.get = function () {
        return this._state.centerBias;
    };

    /**
     * Sets the Fresnel's power.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.power.set = function (value) {
        this._state.power = (value !== undefined && value !== null) ? value : 1;
        this.glRedraw();
    };

    /**
     * Gets the Fresnel's power.
     *
     * Default value is ````1````.
     *
     * @type {Number}
     */
    prototypeAccessors.power.get = function () {
        return this._state.power;
    };

    /**
     * Destroys this Fresnel.
     */
    Fresnel.prototype.destroy = function destroy () {
        Component.prototype.destroy.call(this);
        this._state.destroy();
    };

    Object.defineProperties( Fresnel.prototype, prototypeAccessors );

    return Fresnel;
}(Component));

var color = math.vec3();

/**
 * @desc Saves and restores a snapshot of the visual state of the {@link Entity}'s of a model within a {@link Scene}.
 *
 * ## Usage
 *
 * In the example below, we'll create a {@link Viewer} and use an {@link XKTLoaderPlugin} to load an ````.xkt```` model. When the model has loaded, we'll hide a couple of {@link Entity}s and save a snapshot of the visual states of all its Entitys in an ModelMemento. Then we'll show all the Entitys
 * again, and then we'll restore the visual states of all the Entitys again from the ModelMemento, which will hide those two Entitys again.
 *
 * ## See Also
 *
 * * {@link CameraMemento} - Saves and restores the state of a {@link Scene}'s {@link Camera}.
 * * {@link ObjectsMemento} - Saves and restores a snapshot of the visual state of the {@link Entity}'s that represent objects within a {@link Scene}.
 *
 * ````javascript
 * import {Viewer, XKTLoaderPlugin,  ModelMemento} from "xeokit-sdk.es.js";
 *
 * const viewer = new Viewer({
 *     canvasId: "myCanvas"
 * });
 *
 * // Load a model
 * const xktLoader = new XKTLoaderPlugin(viewer);
 *
 * const model = xktLoader.load({
 *     id: "myModel",
 *     src: "./models/xkt/schependomlaan/schependomlaan.xkt"
 * });
 *
 * model.on("loaded", () => {
 *
 *      // Model has loaded
 *
 *      // Hide a couple of objects
 *      viewer.scene.objects["0u4wgLe6n0ABVaiXyikbkA"].visible = false;
 *      viewer.scene.objects["3u4wgLe3n0AXVaiXyikbYO"].visible = false;
 *
 *      // Save memento of all object states, which includes those two hidden objects
 *      const ModelMemento = new ModelMemento();
 *
 * const metaModel = viewer.metaScene.metaModels
 *      ModelMemento.saveObjects(viewer.scene);
 *
 *      // Show all objects
 *      viewer.scene.setObjectsVisible(viewer.scene.objectIds, true);
 *
 *      // Restore the objects states again, which involves hiding those two objects again
 *      ModelMemento.restoreObjects(viewer.scene);
 * });
 * `````
 *
 * ## Masking Saved State
 *
 * We can optionally supply a mask to focus what state we save and restore.
 *
 * For example, to save and restore only the {@link Entity#visible} and {@link Entity#clippable} states:
 *
 * ````javascript
 * ModelMemento.saveObjects(viewer.scene, {
 *     visible: true,
 *     clippable: true
 * });
 *
 * //...
 *
 * // Restore the objects states again
 * ModelMemento.restoreObjects(viewer.scene);
 * ````
 */
var ModelMemento = function ModelMemento(metaModel) {

    /** @private */
    this.objectsVisible = [];

    /** @private */
    this.objectsEdges = [];

    /** @private */
    this.objectsXrayed = [];

    /** @private */
    this.objectsHighlighted = [];

    /** @private */
    this.objectsSelected = [];

    /** @private */
    this.objectsClippable = [];

    /** @private */
    this.objectsPickable = [];

    /** @private */
    this.objectsColorize = [];

    /** @private */
    this.objectsOpacity = [];

    /** @private */
    this.numObjects = 0;

    if (metaModel) {
        var metaScene = metaModel.metaScene;
        var scene = metaScene.scene;
        this.saveObjects(scene, metaModel);
    }
};

/**
 * Saves a snapshot of the visual state of the {@link Entity}'s that represent objects within a model.
 *
 * @param {Scene} scene The scene.
 * @param {MetaModel} metaModel Represents the model. Corresponds with an {@link Entity} that represents the model in the scene.
 * @param {Object} [mask] Masks what state gets saved. Saves all state when not supplied.
 * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
 * @param {boolean} [mask.visible] Saves {@link Entity#visible} values when ````true````.
 * @param {boolean} [mask.edges] Saves {@link Entity#edges} values when ````true````.
 * @param {boolean} [mask.xrayed] Saves {@link Entity#xrayed} values when ````true````.
 * @param {boolean} [mask.highlighted] Saves {@link Entity#highlighted} values when ````true````.
 * @param {boolean} [mask.selected] Saves {@link Entity#selected} values when ````true````.
 * @param {boolean} [mask.clippable] Saves {@link Entity#clippable} values when ````true````.
 * @param {boolean} [mask.pickable] Saves {@link Entity#pickable} values when ````true````.
 * @param {boolean} [mask.colorize] Saves {@link Entity#colorize} values when ````true````.
 * @param {boolean} [mask.opacity] Saves {@link Entity#opacity} values when ````true````.
 */
ModelMemento.prototype.saveObjects = function saveObjects (scene, metaModel, mask) {

    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        return;
    }

    var objectIds = rootMetaObject.getObjectIDsInSubtree();

    this.numObjects = 0;

    this._mask = mask ? utils.apply(mask, {}) : null;

    var objects = scene.objects;
    var visible = (!mask || mask.visible);
    var edges = (!mask || mask.edges);
    var xrayed = (!mask || mask.xrayed);
    var highlighted = (!mask || mask.highlighted);
    var selected = (!mask || mask.selected);
    var clippable = (!mask || mask.clippable);
    var pickable = (!mask || mask.pickable);
    var colorize = (!mask || mask.colorize);
    var opacity = (!mask || mask.opacity);

    for (var i = 0, len = objectIds.length; i < len; i++) {
        var objectId = objectIds[i];
        var object = objects[objectId];
        if (!object) {
            continue;
        }
        if (visible) {
            this.objectsVisible[i] = object.visible;
        }
        if (edges) {
            this.objectsEdges[i] = object.edges;
        }
        if (xrayed) {
            this.objectsXrayed[i] = object.xrayed;
        }
        if (highlighted) {
            this.objectsHighlighted[i] = object.highlighted;
        }
        if (selected) {
            this.objectsSelected[i] = object.selected;
        }
        if (clippable) {
            this.objectsClippable[i] = object.clippable;
        }
        if (pickable) {
            this.objectsPickable[i] = object.pickable;
        }
        if (colorize) {
            var objectColor = object.colorize;
            this.objectsColorize[i * 3 + 0] = objectColor[0];
            this.objectsColorize[i * 3 + 1] = objectColor[1];
            this.objectsColorize[i * 3 + 2] = objectColor[2];
        }
        if (opacity) {
            this.objectsOpacity[i] = object.opacity;
        }
        this.numObjects++;
    }
};

/**
 * Restores a {@link Scene}'s {@link Entity}'s to their state previously captured with {@link ModelMemento#saveObjects}.
 *
 * Assumes that the model has not been destroyed or modified since saving.
 *
 * @param {Scene} scene The scene that was given to {@link ModelMemento#saveObjects}.
 * @param {MetaModel} metaModel The metamodel that was given to {@link ModelMemento#saveObjects}.
 */
ModelMemento.prototype.restoreObjects = function restoreObjects (scene, metaModel) {

    var rootMetaObject = metaModel.rootMetaObject;
    if (!rootMetaObject) {
        return;
    }

    var objectIds = rootMetaObject.getObjectIDsInSubtree();

    var mask = this._mask;

    var visible = (!mask || mask.visible);
    var edges = (!mask || mask.edges);
    var xrayed = (!mask || mask.xrayed);
    var highlighted = (!mask || mask.highlighted);
    var selected = (!mask || mask.selected);
    var clippable = (!mask || mask.clippable);
    var pickable = (!mask || mask.pickable);
    var colorize = (!mask || mask.colorize);
    var opacity = (!mask || mask.opacity);

    var objects = scene.objects;

    for (var i = 0, len = objectIds.length; i < len; i++) {
        var objectId = objectIds[i];
        var object = objects[objectId];
        if (!object) {
            continue;
        }
        if (visible) {
            object.visible = this.objectsVisible[i];
        }
        if (edges) {
            object.edges = this.objectsEdges[i];
        }
        if (xrayed) {
            object.xrayed = this.objectsXrayed[i];
        }
        if (highlighted) {
            object.highlighted = this.objectsHighlighted[i];
        }
        if (selected) {
            object.selected = this.objectsSelected[i];
        }
        if (clippable) {
            object.clippable = this.objectsClippable[i];
        }
        if (pickable) {
            object.pickable = this.objectsPickable[i];
        }
        if (colorize) {
            color[0] = this.objectsColorize[i * 3 + 0];
            color[1] = this.objectsColorize[i * 3 + 1];
            color[2] = this.objectsColorize[i * 3 + 2];
            object.colorize = color;
        }
        if (opacity) {
            object.opacity = this.objectsOpacity[i];
        }
    }
};

/**
 * @desc A {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a CubicBezierCurve is defined by four control points.
 * * You can sample a {@link CubicBezierCurve#point} and a {@link CubicBezierCurve#tangent} vector on a CubicBezierCurve for any given value of {@link CubicBezierCurve#t} in the range [0..1].
 * * When you set {@link CubicBezierCurve#t} on a CubicBezierCurve, its {@link CubicBezierCurve#point} and {@link CubicBezierCurve#tangent} properties will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of CubicBezierCurves, {@link QuadraticBezierCurve}s and {@link SplineCurve}s into a {@link Path}.
 *
 * <br>
 * <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/B%C3%A9zier_3_big.gif/240px-B%C3%A9zier_3_big.gif"/>
 * <br>
 * [Cubic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
 */
var CubicBezierCurve = /*@__PURE__*/(function (Curve) {
    function CubicBezierCurve(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Curve.call(this, owner, cfg);
        this.v0 = cfg.v0;
        this.v1 = cfg.v1;
        this.v2 = cfg.v2;
        this.v3 = cfg.v3;
        this.t = cfg.t;
    }

    if ( Curve ) CubicBezierCurve.__proto__ = Curve;
    CubicBezierCurve.prototype = Object.create( Curve && Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    var prototypeAccessors = { v0: { configurable: true },v1: { configurable: true },v2: { configurable: true },v3: { configurable: true },t: { configurable: true },point: { configurable: true } };

    /**
     * Sets the starting point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The starting point.
     */
    prototypeAccessors.v0.set = function (value) {
        this._v0 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the starting point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The starting point.
     */
    prototypeAccessors.v0.get = function () {
        return this._v0;
    };

    /**
     * Sets the first control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The first control point.
     */
    prototypeAccessors.v1.set = function (value) {
        this._v1 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the first control point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v1:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The first control point.
     */
    prototypeAccessors.v1.get = function () {
        return this._v1;
    };

    /**
     * Sets the second control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The second control point.
     */
    prototypeAccessors.v2.set = function (value) {
        this._v2 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the second control point on this CubicBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The second control point.
     */
    prototypeAccessors.v2.get = function () {
        return this._v2;
    };

    /**
     * Sets the end point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v3:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @param {Number[]} value The end point.
     */
    prototypeAccessors.v3.set = function (value) {
        this.fire("v3", this._v3 = value || math.vec3([0, 0, 0]));
    };

    /**
     * Gets the end point on this CubicBezierCurve.
     *
     * Fires a {@link CubicBezierCurve#v3:event} event on change.
     *
     * Default value is ````[0.0, 0.0, 0.0]````
     *
     * @returns {Number[]} The end point.
     */
    prototypeAccessors.v3.get = function () {
        return this._v3;
    };

    /**
     * Sets the current position of progress along this CubicBezierCurve.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * @param {Number} value New progress time value.
     */
    prototypeAccessors.t.set = function (value) {
        value = value || 0;
        this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
    };

    /**
     * Gets the current position of progress along this CubicBezierCurve.
     *
     * @returns {Number} Current progress time value.
     */
    prototypeAccessors.t.get = function () {
        return this._t;
    };

    /**
     * Returns point on this CubicBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     *
     * @returns {{Number[]}} The point at the given position.
     */
    prototypeAccessors.point.get = function () {
        return this.getPoint(this._t);
    };

    /**
     * Returns point on this CubicBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     *
     * @returns {{Number[]}} The point at the given position.
     */
    CubicBezierCurve.prototype.getPoint = function getPoint (t) {

        var vector = math.vec3();

        vector[0] = math.b3(t, this._v0[0], this._v1[0], this._v2[0], this._v3[0]);
        vector[1] = math.b3(t, this._v0[1], this._v1[1], this._v2[1], this._v3[1]);
        vector[2] = math.b3(t, this._v0[2], this._v1[2], this._v2[2], this._v3[2]);

        return vector;
    };

    CubicBezierCurve.prototype.getJSON = function getJSON () {
        return {
            v0: this._v0,
            v1: this._v1,
            v2: this._v2,
            v3: this._v3,
            t: this._t
        };
    };

    Object.defineProperties( CubicBezierCurve.prototype, prototypeAccessors );

    return CubicBezierCurve;
}(Curve));

/**
 * @desc A complex curved path constructed from various {@link Curve} subtypes.
 *
 * * A Path can be constructed from these {@link Curve} subtypes: {@link SplineCurve}, {@link CubicBezierCurve} and {@link QuadraticBezierCurve}.
 * * You can sample a {@link Path#point} and a {@link Curve#tangent} vector on a Path for any given value of {@link Path#t} in the range ````[0..1]````.
 * * When you set {@link Path#t} on a Path, its {@link Path#point} and {@link Curve#tangent} properties will update accordingly.
 */
var Path = /*@__PURE__*/(function (Curve) {
    function Path(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Curve.call(this, owner, cfg);
        this._cachedLengths = [];
        this._dirty = true;
        this._curves = []; // Array of child Curve components
        this._t = 0;
        this._dirtySubs = []; // Subscriptions to "dirty" events from child Curve components
        this._destroyedSubs = []; // Subscriptions to "destroyed" events from child Curve components
        this.curves = cfg.curves || [];    // Add initial curves
        this.t = cfg.t; // Set initial progress
    }

    if ( Curve ) Path.__proto__ = Curve;
    Path.prototype = Object.create( Curve && Curve.prototype );
    Path.prototype.constructor = Path;

    var prototypeAccessors = { curves: { configurable: true },t: { configurable: true },point: { configurable: true },length: { configurable: true } };

    /**
     * Adds a {@link Curve} to this Path.
     *
     * @param {Curve} curve The {@link Curve} to add.
     */
    Path.prototype.addCurve = function addCurve (curve) {
        this._curves.push(curve);
        this._dirty = true;
    };

    /**
     * Sets the {@link Curve}s in this Path.
     *
     * Default value is ````[]````.
     *
     * @param {{Array of Spline, Path, QuadraticBezierCurve or CubicBezierCurve}} value.
     */
    prototypeAccessors.curves.set = function (value) {

        value = value || [];

        var curve;
        // Unsubscribe from events on old curves
        var i;
        var len;
        for (i = 0, len = this._curves.length; i < len; i++) {
            curve = this._curves[i];
            curve.off(this._dirtySubs[i]);
            curve.off(this._destroyedSubs[i]);
        }

        this._curves = [];
        this._dirtySubs = [];
        this._destroyedSubs = [];

        var self = this;

        function curveDirty() {
            self._dirty = true;
        }

        function curveDestroyed() {
            var id = this.id;
            for (i = 0, len = self._curves.length; i < len; i++) {
                if (self._curves[i].id === id) {
                    self._curves = self._curves.slice(i, i + 1);
                    self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                    self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);
                    self._dirty = true;
                    return;
                }
            }
        }

        for (i = 0, len = value.length; i < len; i++) {
            curve = value[i];
            if (utils.isNumeric(curve) || utils.isString(curve)) {
                // ID given for curve - find the curve component
                var id = curve;
                curve = this.scene.components[id];
                if (!curve) {
                    this.error("Component not found: " + _inQuotes(id));
                    continue;
                }
            }

            var type = curve.type;

            if (type !== "xeokit.SplineCurve" &&
                type !== "xeokit.Path" &&
                type !== "xeokit.CubicBezierCurve" &&
                type !== "xeokit.QuadraticBezierCurve") {

                this.error("Component " + _inQuotes(curve.id)
                    + " is not a xeokit.SplineCurve, xeokit.Path or xeokit.QuadraticBezierCurve");

                continue;
            }

            this._curves.push(curve);
            this._dirtySubs.push(curve.on("dirty", curveDirty));
            this._destroyedSubs.push(curve.once("destroyed", curveDestroyed));
        }

        this._dirty = true;
    };

    /**
     * Gets the {@link Curve}s in this Path.
     *
     * @returns {{Array of Spline, Path, QuadraticBezierCurve or CubicBezierCurve}} the {@link Curve}s in this path.
     */
    prototypeAccessors.curves.get = function () {
        return this._curves;
    };

    /**
     * Sets the current point of progress along this Path.
     *
     * Automatically clamps to range ````[0..1]````.
     *
     * Default value is ````0````.
     *
     * @param {Number} value The current point of progress.
     */
    prototypeAccessors.t.set = function (value) {
        value = value || 0;
        this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
    };

    /**
     * Gets the current point of progress along this Path.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The current point of progress.
     */
    prototypeAccessors.t.get = function () {
        return this._t;
    };

    /**
     * Gets point on this Path corresponding to the current value of {@link Path#t}.
     *
     * @returns {{Number[]}} The point.
     */
    prototypeAccessors.point.get = function () {
        return this.getPoint(this._t);
    };

    /**
     * Length of this Path, which is the cumulative length of all {@link Curve}s currently in {@link Path#curves}.
     *
     * @return {Number} Length of this path.
     */
    prototypeAccessors.length.get = function () {
        var lens = this._getCurveLengths();
        return lens[lens.length - 1];
    };

    /**
     * Gets a point on this Path corresponding to the given progress position.
     *
     * @param {Number} t Indicates point of progress along this curve, in the range [0..1].
     * @returns {{Number[]}}
     */
    Path.prototype.getPoint = function getPoint (t) {
        var d = t * this.length;
        var curveLengths = this._getCurveLengths();
        var i = 0, diff, curve;
        while (i < curveLengths.length) {
            if (curveLengths[i] >= d) {
                diff = curveLengths[i] - d;
                curve = this._curves[i];
                var u = 1 - diff / curve.length;
                return curve.getPointAt(u);
            }
            i++;
        }
        return null;
    };

    Path.prototype._getCurveLengths = function _getCurveLengths () {
        if (!this._dirty) {
            return this._cachedLengths;
        }
        var lengths = [];
        var sums = 0;
        var i, il = this._curves.length;
        for (i = 0; i < il; i++) {
            sums += this._curves[i].length;
            lengths.push(sums);

        }
        this._cachedLengths = lengths;
        this._dirty = false;
        return lengths;
    };

    Path.prototype._getJSON = function _getJSON () {
        var curveIds = [];
        for (var i = 0, len = this._curves.length; i < len; i++) {
            curveIds.push(this._curves[i].id);
        }
        return {
            curves: curveIds,
            t: this._t
        };
    };

    /**
     * Destroys this Path.
     */
    Path.prototype.destroy = function destroy () {
        Curve.prototype.destroy.call(this);
        var i;
        var len;
        var curve;
        for (i = 0, len = this._curves.length; i < len; i++) {
            curve = this._curves[i];
            curve.off(this._dirtySubs[i]);
            curve.off(this._destroyedSubs[i]);
        }
    };

    Object.defineProperties( Path.prototype, prototypeAccessors );

    return Path;
}(Curve));

/**
 * A **QuadraticBezierCurve** is a {@link Curve} along which a 3D position can be animated.
 *
 * * As shown in the diagram below, a QuadraticBezierCurve is defined by three control points
 * * You can sample a {@link QuadraticBezierCurve#point} and a {@link Curve#tangent} vector on a QuadraticBezierCurve for any given value of {@link QuadraticBezierCurve#t} in the range ````[0..1]````
 * * When you set {@link QuadraticBezierCurve#t} on a QuadraticBezierCurve, its {@link QuadraticBezierCurve#point} and {@link Curve#tangent} will update accordingly.
 * * To build a complex path, you can combine an unlimited combination of QuadraticBezierCurves, {@link CubicBezierCurve}s and {@link SplineCurve}s into a {@link Path}.</li>
 * <br>
 * <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/B%C3%A9zier_2_big.gif/240px-B%C3%A9zier_2_big.gif"/>
 * <br>
 * *[Quadratic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)*
 */
var QuadraticBezierCurve = /*@__PURE__*/(function (Curve) {
    function QuadraticBezierCurve(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};

        Curve.call(this, owner, cfg);
        this.v0 = cfg.v0;
        this.v1 = cfg.v1;
        this.v2 = cfg.v2;
        this.t = cfg.t;
    }

    if ( Curve ) QuadraticBezierCurve.__proto__ = Curve;
    QuadraticBezierCurve.prototype = Object.create( Curve && Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

    var prototypeAccessors = { v0: { configurable: true },v1: { configurable: true },v2: { configurable: true },t: { configurable: true },point: { configurable: true } };

    /**
     * Sets the starting point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value New starting point.
     */
    prototypeAccessors.v0.set = function (value) {
        this._v0 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the starting point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The starting point.
     */
    prototypeAccessors.v0.get = function () {
        return this._v0;
    };

    /**
     * Sets the middle control point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value New middle control point.
     */
    prototypeAccessors.v1.set = function (value) {
        this._v1 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the middle control point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The middle control point.
     */
    prototypeAccessors.v1.get = function () {
        return this._v1;
    };

    /**
     * Sets the end point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @param {Number[]} value The new end point.
     */
    prototypeAccessors.v2.set = function (value) {
        this._v2 = value || math.vec3([0, 0, 0]);
    };

    /**
     * Gets the end point on this QuadraticBezierCurve.
     *
     * Default value is ````[0.0, 0.0, 0.0]````.
     *
     * @returns {Number[]} The end point.
     */
    prototypeAccessors.v2.get = function () {
        return this._v2;
    };

    /**
     * Sets the progress along this QuadraticBezierCurve.
     *
     * Automatically clamps to range [0..1].
     *
     * Default value is ````0````.
     *
     * @param {Number} value The new progress location.
     */
    prototypeAccessors.t.set = function (value) {
        value = value || 0;
        this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);
    };

    /**
     * Gets the progress along this QuadraticBezierCurve.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The current progress location.
     */
    prototypeAccessors.t.get = function () {
        return this._t;
    };

    /**
     Point on this QuadraticBezierCurve at position {@link QuadraticBezierCurve/t}.

     @property point
     @type {{Number[]}}
     */
    prototypeAccessors.point.get = function () {
        return this.getPoint(this._t);
    };

    /**
     * Returns the point on this QuadraticBezierCurve at the given position.
     *
     * @param {Number} t Position to get point at.
     * @returns {Number[]} The point.
     */
    QuadraticBezierCurve.prototype.getPoint = function getPoint (t) {
        var vector = math.vec3();
        vector[0] = math.b2(t, this._v0[0], this._v1[0], this._v2[0]);
        vector[1] = math.b2(t, this._v0[1], this._v1[1], this._v2[1]);
        vector[2] = math.b2(t, this._v0[2], this._v1[2], this._v2[2]);
        return vector;
    };

    QuadraticBezierCurve.prototype.getJSON = function getJSON () {
        return {
            v0: this._v0,
            v1: this._v1,
            v2: this._v2,
            t: this._t
        };
    };

    Object.defineProperties( QuadraticBezierCurve.prototype, prototypeAccessors );

    return QuadraticBezierCurve;
}(Curve));

var screenPos = math.vec4();
var viewPos = math.vec4();

var tempVec3a$2 = math.vec3();
var tempVec3b$2 = math.vec3();
var tempVec3c$2 = math.vec3();

var tempVec4a$1 = math.vec4();
var tempVec4b$1 = math.vec4();
var tempVec4c$1 = math.vec4();

/**
 * @private
 */
var PanController = function PanController(scene) {
    this._scene = scene;
};

/**
 * Dollys the Camera towards the given target 2D canvas position.
 *
 * When the target's corresponding World-space position is also provided, then this function will also test if we've
 * dollied past the target, and will return ````true```` if that's the case.
 *
 * @param [optionalTargetWorldPos] Optional world position of the target
 * @param targetCanvasPos Canvas position of the target
 * @param dollyDelta Amount to dolly
 * @return True if optionalTargetWorldPos was given, and we've dollied past that position.
 */
PanController.prototype.dollyToCanvasPos = function dollyToCanvasPos (optionalTargetWorldPos, targetCanvasPos, dollyDelta) {

    var dolliedThroughSurface = false;

    var camera = this._scene.camera;

    if (optionalTargetWorldPos) {
        var eyeToWorldPosVec = math.subVec3(optionalTargetWorldPos, camera.eye, tempVec3a$2);
        var eyeWorldPosDist = math.lenVec3(eyeToWorldPosVec);
        dolliedThroughSurface = (eyeWorldPosDist < dollyDelta);
    }

    if (camera.projection === "perspective") {

        camera.ortho.scale = camera.ortho.scale - dollyDelta;

        var unprojectedWorldPos = this._unproject(targetCanvasPos, tempVec4a$1);
        var offset = math.subVec3(unprojectedWorldPos, camera.eye, tempVec4c$1);
        var moveVec = math.mulVec3Scalar(math.normalizeVec3(offset), -dollyDelta, []);

        camera.eye = [camera.eye[0] - moveVec[0], camera.eye[1] - moveVec[1], camera.eye[2] - moveVec[2]];
        camera.look = [camera.look[0] - moveVec[0], camera.look[1] - moveVec[1], camera.look[2] - moveVec[2]];

        if (optionalTargetWorldPos) {

            // Subtle UX tweak - if we have a target World position, then set camera eye->look distance to
            // the same distance as from eye->target. This just gives us a better position for look,
            // if we subsequently orbit eye about look, so that we don't orbit a position that's
            // suddenly a lot closer than the point we pivoted about on the surface of the last object
            // that we click-drag-pivoted on.

            var eyeTargetVec = math.subVec3(optionalTargetWorldPos, camera.eye, tempVec3a$2);
            var lenEyeTargetVec = math.lenVec3(eyeTargetVec);
            var eyeLookVec = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(camera.look, camera.eye, tempVec3b$2)), lenEyeTargetVec);
            camera.look = [camera.eye[0] + eyeLookVec[0], camera.eye[1] + eyeLookVec[1], camera.eye[2] + eyeLookVec[2]];
        }

    } else if (camera.projection === "ortho") {

        // - set ortho scale, getting the unprojected targetCanvasPos before and after, get that difference in a vector;
        // - get the vector in which we're dollying;
        // - add both vectors to camera eye and look.

        var worldPos1 = this._unproject(targetCanvasPos, tempVec4a$1);

        camera.ortho.scale = camera.ortho.scale - dollyDelta;
        camera.ortho._update(); // HACK

        var worldPos2 = this._unproject(targetCanvasPos, tempVec4b$1);
        var offset$1 = math.subVec3(worldPos2, worldPos1, tempVec4c$1);
        var eyeLookMoveVec = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(camera.look, camera.eye, tempVec3a$2)), -dollyDelta, tempVec3b$2);
        var moveVec$1 = math.addVec3(offset$1, eyeLookMoveVec, tempVec3c$2);

        camera.eye = [camera.eye[0] - moveVec$1[0], camera.eye[1] - moveVec$1[1], camera.eye[2] - moveVec$1[2]];
        camera.look = [camera.look[0] - moveVec$1[0], camera.look[1] - moveVec$1[1], camera.look[2] - moveVec$1[2]];
    }

    return dolliedThroughSurface;
};

PanController.prototype._unproject = function _unproject (canvasPos, worldPos) {

    var camera = this._scene.camera;
    var transposedProjectMat = camera.project.transposedMatrix;
    var Pt3 = transposedProjectMat.subarray(8, 12);
    var Pt4 = transposedProjectMat.subarray(12);
    var D = [0, 0, -1.0, 1];
    var screenZ = math.dotVec4(D, Pt3) / math.dotVec4(D, Pt4);

    camera.project.unproject(canvasPos, screenZ, screenPos, viewPos, worldPos);

    return worldPos;
};

PanController.prototype.destroy = function destroy () {
};

var tempVec3a$1 = math.vec3();
var tempVec3b$1 = math.vec3();
var tempVec3c$1 = math.vec3();

var tempVec4a = math.vec4();
var tempVec4b = math.vec4();
var tempVec4c = math.vec4();


/** @private */
var PivotController = function PivotController(scene, configs) {
    var this$1 = this;


    // Pivot math by: http://www.derschmale.com/

    this._scene = scene;
    this._configs = configs;
    this._pivotWorldPos = math.vec3();
    this._cameraOffset = math.vec3();
    this._azimuth = 0;
    this._polar = 0;
    this._radius = 0;
    this._pivotPosSet = false; // Initially false, true as soon as _pivotWorldPos has been set to some value
    this._pivoting = false; // True while pivoting
    this._shown = false;

    this._pivotViewPos = math.vec4();
    this._pivotProjPos = math.vec4();
    this._pivotCanvasPos = math.vec2();
    this._cameraDirty = true;

    this._onViewMatrix = this._scene.camera.on("viewMatrix", function () {
        this$1._cameraDirty = true;
    });

    this._onProjMatrix = this._scene.camera.on("projMatrix", function () {
        this$1._cameraDirty = true;
    });

    this._onTick = this._scene.on("tick", function () {
        this$1.updatePivotElement();
    });
};

PivotController.prototype.updatePivotElement = function updatePivotElement () {

    var camera = this._scene.camera;
    var canvas = this._scene.canvas;

    if (this._pivoting && this._cameraDirty) {

        math.transformPoint3(camera.viewMatrix, this.getPivotPos(), this._pivotViewPos);
        this._pivotViewPos[3] = 1;
        math.transformPoint4(camera.projMatrix, this._pivotViewPos, this._pivotProjPos);

        var canvasAABB = canvas.boundary;
        var canvasWidth = canvasAABB[2];
        var canvasHeight = canvasAABB[3];

        this._pivotCanvasPos[0] = Math.floor((1 + this._pivotProjPos[0] / this._pivotProjPos[3]) * canvasWidth / 2);
        this._pivotCanvasPos[1] = Math.floor((1 - this._pivotProjPos[1] / this._pivotProjPos[3]) * canvasHeight / 2);

        var canvasElem = canvas.canvas;
        var canvasBoundingRect = canvasElem.getBoundingClientRect();

        if (this._pivotElement) {
            this._pivotElement.style.left = (Math.floor(canvasBoundingRect.left + this._pivotCanvasPos[0]) - (this._pivotElement.clientWidth / 2) + window.scrollX) + "px";
            this._pivotElement.style.top = (Math.floor(canvasBoundingRect.top + this._pivotCanvasPos[1]) - (this._pivotElement.clientHeight / 2) + window.scrollY) + "px";
        }
        this._cameraDirty = false;
    }
};

/**
 * Sets the HTML DOM element that will represent the pivot position.
 *
 * @param pivotElement
 */
PivotController.prototype.setPivotElement = function setPivotElement (pivotElement) {
    this._pivotElement = pivotElement;
};

/**
 * Begins pivoting.
 */
PivotController.prototype.startPivot = function startPivot () {

    if (this._cameraLookingDownwards()) {
        this._pivoting = false;
        return false;
    }

    var camera = this._scene.camera;

    var lookat = math.lookAtMat4v(camera.eye, camera.look, camera.worldUp);
    math.transformPoint3(lookat, this.getPivotPos(), this._cameraOffset);

    var pivotPos = this.getPivotPos();
    this._cameraOffset[2] += math.distVec3(camera.eye, pivotPos);

    lookat = math.inverseMat4(lookat);

    var offset = math.transformVec3(lookat, this._cameraOffset);
    var diff = math.vec3();

    math.subVec3(camera.eye, pivotPos, diff);
    math.addVec3(diff, offset);

    if (camera.zUp) {
        var t = diff[1];
        diff[1] = diff[2];
        diff[2] = t;
    }

    this._radius = math.lenVec3(diff);
    this._polar = Math.acos(diff[1] / this._radius);
    this._azimuth = Math.atan2(diff[0], diff[2]);
    this._pivoting = true;
};

PivotController.prototype._cameraLookingDownwards = function _cameraLookingDownwards () { // Returns true if angle between camera viewing direction and World-space "up" axis is too small
    var camera = this._scene.camera;
    var forwardAxis = math.normalizeVec3(math.subVec3(camera.look, camera.eye, tempVec3a$1));
    var rightAxis = math.cross3Vec3(forwardAxis, camera.worldUp, tempVec3b$1);
    var rightAxisLen = math.sqLenVec3(rightAxis);
    return (rightAxisLen <= 0.0001);
};

/**
 * Returns true if we are currently pivoting.
 *
 * @returns {boolean}
 */
PivotController.prototype.getPivoting = function getPivoting () {
    return this._pivoting;
};

/**
 * Sets a 3D World-space position to pivot about.
 *
 * @param {Number[]} worldPos The new World-space pivot position.
 */
PivotController.prototype.setPivotPos = function setPivotPos (worldPos) {
    this._pivotWorldPos.set(worldPos);
    this._pivotPosSet = true;
};

/**
 * Sets the pivot position to the 3D projection of the given 2D canvas coordinates on a sphere centered
 * at the viewpoint. The radius of the sphere is configured via {@link CameraControl#smartPivot}.
 *
 * @param canvasPos
 */
PivotController.prototype.setCanvasPivotPos = function setCanvasPivotPos (canvasPos) {
    var camera = this._scene.camera;
    var pivotShereRadius = Math.abs(math.distVec3(this._scene.center, camera.eye));
    var transposedProjectMat = camera.project.transposedMatrix;
    var Pt3 = transposedProjectMat.subarray(8, 12);
    var Pt4 = transposedProjectMat.subarray(12);
    var D = [0, 0, -1.0, 1];
    var screenZ = math.dotVec4(D, Pt3) / math.dotVec4(D, Pt4);
    var worldPos = tempVec4a;
    camera.project.unproject(canvasPos, screenZ, tempVec4b, tempVec4c, worldPos);
    var eyeWorldPosVec = math.normalizeVec3(math.subVec3(worldPos, camera.eye, tempVec3a$1));
    var posOnSphere = math.addVec3(camera.eye, math.mulVec3Scalar(eyeWorldPosVec, pivotShereRadius, tempVec3b$1), tempVec3c$1);
    this.setPivotPos(posOnSphere);
};

/**
 * Gets the current position we're pivoting about.
 * @returns {Number[]} The current World-space pivot position.
 */
PivotController.prototype.getPivotPos = function getPivotPos () {
    return (this._pivotPosSet) ? this._pivotWorldPos : this._scene.camera.look; // Avoid pivoting about [0,0,0] by default
};

/**
 * Continues to pivot.
 *
 * @param {Number} yawInc Yaw rotation increment.
 * @param {Number} pitchInc Pitch rotation increment.
 */
PivotController.prototype.continuePivot = function continuePivot (yawInc, pitchInc) {
    if (!this._pivoting) {
        return;
    }
    if (yawInc === 0 && pitchInc === 0) {
        return;
    }
    var camera = this._scene.camera;
    var dx = -yawInc;
    var dy = -pitchInc;
    if (camera.worldUp[2] === 1) {
        dx = -dx;
    }
    this._azimuth += -dx * .01;
    this._polar += dy * .01;
    this._polar = math.clamp(this._polar, .001, Math.PI - .001);
    var pos = [
        this._radius * Math.sin(this._polar) * Math.sin(this._azimuth),
        this._radius * Math.cos(this._polar),
        this._radius * Math.sin(this._polar) * Math.cos(this._azimuth)
    ];
    if (camera.worldUp[2] === 1) {
        var t = pos[1];
        pos[1] = pos[2];
        pos[2] = t;
    }
    // Preserve the eye->look distance, since in xeokit "look" is the point-of-interest, not the direction vector.
    var eyeLookLen = math.lenVec3(math.subVec3(camera.look, camera.eye, math.vec3()));
    var pivotPos = this.getPivotPos();
    math.addVec3(pos, pivotPos);
    var lookat = math.lookAtMat4v(pos, pivotPos, camera.worldUp);
    lookat = math.inverseMat4(lookat);
    var offset = math.transformVec3(lookat, this._cameraOffset);
    lookat[12] -= offset[0];
    lookat[13] -= offset[1];
    lookat[14] -= offset[2];
    var zAxis = [lookat[8], lookat[9], lookat[10]];
    camera.eye = [lookat[12], lookat[13], lookat[14]];
    math.subVec3(camera.eye, math.mulVec3Scalar(zAxis, eyeLookLen), camera.look);
    camera.up = [lookat[4], lookat[5], lookat[6]];
    this.showPivot();
};

/**
 * Shows the pivot position.
 *
 * Only works if we set an  HTML DOM element to represent the pivot position.
 */
PivotController.prototype.showPivot = function showPivot () {
        var this$1 = this;

    if (this._shown) {
        return;
    }
    if (this._hideTimeout !== null) {
        window.clearTimeout(this._hideTimeout);
        this._hideTimeout = null;
    }
    if (this._pivotElement) {
        this.updatePivotElement();
        this._pivotElement.style.visibility = "visible";
        this._shown = true;
        this._hideTimeout = window.setTimeout(function () {
            this$1.hidePivot();
        }, 1000);
    }
};

/**
 * Hides the pivot position.
 *
 * Only works if we set an  HTML DOM element to represent the pivot position.
 */
PivotController.prototype.hidePivot = function hidePivot () {
    if (!this._shown) {
        return;
    }
    if (this._hideTimeout !== null) {
        window.clearTimeout(this._hideTimeout);
        this._hideTimeout = null;
    }
    if (this._pivotElement) {
        this._pivotElement.style.visibility = "hidden";
    }
    this._shown = false;
};

/**
 * Finishes pivoting.
 */
PivotController.prototype.endPivot = function endPivot () {
    this._pivoting = false;
};

PivotController.prototype.destroy = function destroy () {
    this._scene.camera.off(this._onViewMatrix);
    this._scene.camera.off(this._onProjMatrix);
    this._scene.off(this._onTick);
};

/**
 *
 * @private
 */
var PickController = function PickController(cameraControl, configs) {

    this._scene = cameraControl.scene;

    this._cameraControl = cameraControl;

    this._scene.canvas.canvas.oncontextmenu = function (e) {
        e.preventDefault();
    };

    this._configs = configs;

    /**
     * Set true to schedule picking of an Entity.
     * @type {boolean}
     */
    this.schedulePickEntity = false;

    /**
     * Set true to schedule picking of a position on teh surface of an Entity.
     * @type {boolean}
     */
    this.schedulePickSurface = false;

    /**
     * The canvas position at which to do the next scheduled pick.
     * @type {Number[]}
     */
    this.pickCursorPos = math.vec2();

    /**
     * Will be true after picking to indicate that something was picked.
     * @type {boolean}
     */
    this.picked = false;

    /**
     * Will be true after picking to indicate that a position on the surface of an Entity was picked.
     * @type {boolean}
     */
    this.pickedSurface = false;

    /**
     * Will hold the PickResult after after picking.
     * @type {PickResult}
     */
    this.pickResult = null;

    this._lastPickedEntityId = null;

    this._needFireEvents = false;
};

/**
 * Immediately attempts a pick, if scheduled.
 */
PickController.prototype.update = function update () {

    if (!this._configs.pointerEnabled) {
        return;
    }

    if (!this.schedulePickEntity && !this.schedulePickSurface) {
        return;
    }

    this.picked = false;
    this.pickedSurface = false;
    this._needFireEvents = false;

    var hasHoverSurfaceSubs = this._cameraControl.hasSubs("hoverSurface");

    if (this.schedulePickSurface) {
        if (this.pickResult && this.pickResult.worldPos) {
            var pickResultCanvasPos = this.pickResult.canvasPos;
            if (pickResultCanvasPos[0] === this.pickCursorPos[0] && pickResultCanvasPos[1] === this.pickCursorPos[1]) {
                this.picked = true;
                this.pickedSurface = true;
                this._needFireEvents = hasHoverSurfaceSubs;
                this.schedulePickEntity = false;
                this.schedulePickSurface = false;
                return;
            }
        }
    }

    if (this.schedulePickEntity) {
        if (this.pickResult) {
            var pickResultCanvasPos$1 = this.pickResult.canvasPos;
            if (pickResultCanvasPos$1[0] === this.pickCursorPos[0] && pickResultCanvasPos$1[1] === this.pickCursorPos[1]) {
                this.picked = true;
                this.pickedSurface = false;
                this._needFireEvents = false;
                this.schedulePickEntity = false;
                this.schedulePickSurface = false;
                return;
            }
        }
    }

    if (this.schedulePickSurface) {

        this.pickResult = this._scene.pick({
            pickSurface: true,
            pickSurfaceNormal: false,
            canvasPos: this.pickCursorPos
        });

        if (this.pickResult) {
            this.picked = true;
            this.pickedSurface = true;
            this._needFireEvents = true;
        }

    } else { // schedulePickEntity == true

        this.pickResult = this._scene.pick({
            canvasPos: this.pickCursorPos
        });

        if (this.pickResult) {
            this.picked = true;
            this.pickedSurface = false;
            this._needFireEvents = true;
        }
    }

    this.schedulePickEntity = false;
    this.schedulePickSurface = false;
};

PickController.prototype.fireEvents = function fireEvents () {

    if (!this._needFireEvents) {
        return;
    }

    if (this.picked && this.pickResult && this.pickResult.entity) {

        var pickedEntityId = this.pickResult.entity.id;

        if (this._lastPickedEntityId !== pickedEntityId) {

            if (this._lastPickedEntityId !== undefined) {
                this._cameraControl.fire("hoverOut", {
                    entity: this._scene.objects[this._lastPickedEntityId]
                }, true);
            }

            this._cameraControl.fire("hoverEnter", this.pickResult, true);
            this._lastPickedEntityId = pickedEntityId;
        }

        this._cameraControl.fire("hover", this.pickResult, true);

        if (this.pickResult.worldPos) {
            this.pickedSurface = true;
            this._cameraControl.fire("hoverSurface", this.pickResult, true);
        }

    } else {

        if (this._lastPickedEntityId !== undefined) {
            this._cameraControl.fire("hoverOut", {
                entity: this._scene.objects[this._lastPickedEntityId]
            }, true);
            this._lastPickedEntityId = undefined;
        }

        this._cameraControl.fire("hoverOff", {
            canvasPos: this.pickCursorPos
        }, true);
    }

    this.pickResult = null;

    this._needFireEvents = false;
};

PickController.prototype.destroy = function destroy () {
};

/**
 * @private
 */

var canvasPos = math.vec2();

var getCanvasPosFromEvent$2 = function (event, canvasPos) {
    if (!event) {
        event = window.event;
        canvasPos[0] = event.x;
        canvasPos[1] = event.y;
    } else {
        var element = event.target;
        var totalOffsetLeft = 0;
        var totalOffsetTop = 0;
        while (element.offsetParent) {
            totalOffsetLeft += element.offsetLeft;
            totalOffsetTop += element.offsetTop;
            element = element.offsetParent;
        }
        canvasPos[0] = event.pageX - totalOffsetLeft;
        canvasPos[1] = event.pageY - totalOffsetTop;
    }
    return canvasPos;
};

/**
 * @private
 */
var MousePanRotateDollyHandler = function MousePanRotateDollyHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;

    var pickController = controllers.pickController;

    var lastX = 0;
    var lastY = 0;
    var lastXDown = 0;
    var lastYDown = 0;

    var mouseDownLeft;
    var mouseDownMiddle;
    var mouseDownRight;

    var mouseDownPicked = false;
    var pickedWorldPos = math.vec3();

    var mouseMovedOnCanvasSinceLastWheel = true;

    var canvas = this._scene.canvas.canvas;

    var keyDown = [];

    document.addEventListener("keydown", this._documentKeyDownHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }
        var keyCode = e.keyCode;
        keyDown[keyCode] = true;
    });

    document.addEventListener("keyup", this._documentKeyUpHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }
        var keyCode = e.keyCode;
        keyDown[keyCode] = false;
    });

    function setMousedownState(pick) {
        if ( pick === void 0 ) pick = true;

        canvas.style.cursor = "move";
        setMousedownPositions();
        if (pick) {
            setMousedownPick();
        }
    }

    function setMousedownPositions() {

        lastX = states.pointerCanvasPos[0];
        lastY = states.pointerCanvasPos[1];
        lastXDown = states.pointerCanvasPos[0];
        lastYDown = states.pointerCanvasPos[1];
    }

    function setMousedownPick() {
        pickController.pickCursorPos = states.pointerCanvasPos;
        pickController.schedulePickSurface = true;
        pickController.update();

        if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {
            mouseDownPicked = true;
            pickedWorldPos.set(pickController.pickResult.worldPos);
        } else {
            mouseDownPicked = false;
        }
    }

    canvas.addEventListener("mousedown", this._mouseDownHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        switch (e.which) {

            case 1: // Left button

                if (keyDown[scene.input.KEY_SHIFT] || configs.planView) {

                    mouseDownLeft = true;

                    setMousedownState();

                } else {

                    mouseDownLeft = true;

                    setMousedownState(false);
                }

                break;

            case 2: // Middle/both buttons

                mouseDownMiddle = true;

                setMousedownState();

                break;

            case 3: // Right button

                mouseDownRight = true;

                if (configs.panRightClick) {

                    setMousedownState();
                }

                break;
        }
    });

    document.addEventListener("mousemove", this._documentMouseMoveHandler = function () {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        if (!mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {
            return;
        }

        // Scaling drag-rotate to canvas boundary

        var canvasBoundary = scene.canvas.boundary;
        var canvasWidth = canvasBoundary[2] - canvasBoundary[0];
        var canvasHeight = canvasBoundary[3] - canvasBoundary[1];
        var x = states.pointerCanvasPos[0];
        var y = states.pointerCanvasPos[1];

        var panning = keyDown[scene.input.KEY_SHIFT] || configs.planView || (!configs.panRightClick && mouseDownMiddle) || (configs.panRightClick && mouseDownRight);

        if (panning) {

            var xPanDelta = (x - lastX);
            var yPanDelta = (y - lastY);

            var camera = scene.camera;

            // We use only canvasHeight here so that aspect ratio does not distort speed

            if (camera.projection === "perspective") {

                var depth = Math.abs(mouseDownPicked ? math.lenVec3(math.subVec3(pickedWorldPos, scene.camera.eye, [])) : scene.camera.eyeLookDist);
                var targetDistance = depth * Math.tan((camera.perspective.fov / 2) * Math.PI / 180.0);

                updates.panDeltaX += (1.5 * xPanDelta * targetDistance / canvasHeight);
                updates.panDeltaY += (1.5 * yPanDelta * targetDistance / canvasHeight);

            } else {

                updates.panDeltaX += 0.5 * camera.ortho.scale * (xPanDelta / canvasHeight);
                updates.panDeltaY += 0.5 * camera.ortho.scale * (yPanDelta / canvasHeight);
            }

        } else if (mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {

            if (!configs.planView) { // No rotating in plan-view mode

                if (configs.firstPerson) {
                    updates.rotateDeltaY -= ((x - lastX) / canvasWidth) * configs.dragRotationRate / 2;
                    updates.rotateDeltaX += ((y - lastY) / canvasHeight) * (configs.dragRotationRate / 4);

                } else {
                    updates.rotateDeltaY -= ((x - lastX) / canvasWidth) * (configs.dragRotationRate * 1.5);
                    updates.rotateDeltaX += ((y - lastY) / canvasHeight) * (configs.dragRotationRate * 1.5);
                }
            }
        }

        lastX = x;
        lastY = y;
    });

    canvas.addEventListener("mousemove", this._canvasMouseMoveHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        if (!states.mouseover) {
            return;
        }

        mouseMovedOnCanvasSinceLastWheel = true;
    });

    document.addEventListener("mouseup", this._documentMouseUpHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
        switch (e.which) {
            case 1: // Left button
                mouseDownLeft = false;
                mouseDownMiddle = false;
                mouseDownRight = false;
                break;
            case 2: // Middle/both buttons
                mouseDownLeft = false;
                mouseDownMiddle = false;
                mouseDownRight = false;
                break;
            case 3: // Right button
                mouseDownLeft = false;
                mouseDownMiddle = false;
                mouseDownRight = false;
                break;
        }
    });

    canvas.addEventListener("mouseup", this._mouseUpHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
        switch (e.which) {
            case 3: // Right button
                getCanvasPosFromEvent$2(e, canvasPos);
                var x = canvasPos[0];
                var y = canvasPos[1];
                if (Math.abs(x - lastXDown) < 3 && Math.abs(y - lastYDown) < 3) {
                    controllers.cameraControl.fire("rightClick", { // For context menus
                        pagePos: [Math.round(e.pageX), Math.round(e.pageY)],
                        canvasPos: canvasPos,
                        event: e
                    }, true);
                }
                break;
        }
        canvas.style.removeProperty("cursor");
    });

    canvas.addEventListener("mouseenter", this._mouseEnterHandler = function () {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
    });

    var maxElapsed = 1 / 20;
    var minElapsed = 1 / 60;

    var secsNowLast = null;

    canvas.addEventListener("wheel", this._mouseWheelHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
        var secsNow = performance.now() / 1000.0;
        var secsElapsed = (secsNowLast !== null) ? (secsNow - secsNowLast) : 0;
        secsNowLast = secsNow;
        if (secsElapsed > maxElapsed) {
            secsElapsed = maxElapsed;
        }
        if (secsElapsed < minElapsed) {
            secsElapsed = minElapsed;
        }
        var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
        if (delta === 0) {
            return;
        }
        var normalizedDelta = delta / Math.abs(delta);
        updates.dollyDelta += -normalizedDelta * secsElapsed * configs.mouseWheelDollyRate;

        if (mouseMovedOnCanvasSinceLastWheel) {
            states.followPointerDirty = true;
            mouseMovedOnCanvasSinceLastWheel = false;
        }

        e.preventDefault();
    });
};

MousePanRotateDollyHandler.prototype.reset = function reset () {
};

MousePanRotateDollyHandler.prototype.destroy = function destroy () {

    var canvas = this._scene.canvas.canvas;

    document.removeEventListener("keydown", this._documentKeyDownHandler);
    document.removeEventListener("keyup", this._documentKeyUpHandler);
    canvas.removeEventListener("mousedown", this._mouseDownHandler);
    document.removeEventListener("mousemove", this._documentMouseMoveHandler);
    canvas.removeEventListener("mousemove", this._canvasMouseMoveHandler);
    document.removeEventListener("mouseup", this._documentMouseUpHandler);
    canvas.removeEventListener("mouseup", this._mouseUpHandler);
    canvas.removeEventListener("mouseenter", this._mouseEnterHandler);
    canvas.removeEventListener("wheel", this._mouseWheelHandler);
};

var center = math.vec3();
var tempVec3a = math.vec3();
var tempVec3b = math.vec3();
var tempVec3c = math.vec3();
var tempVec3d = math.vec3();

var tempCameraTarget = {
    eye: math.vec3(),
    look: math.vec3(),
    up: math.vec3()
};

/**
 * @private
 */
var KeyboardAxisViewHandler = function KeyboardAxisViewHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;
    var cameraControl = controllers.cameraControl;
    var camera = scene.camera;

    scene.input.on("keydown", this._documentKeyDownHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }

        if (!states.mouseover) {
            return;
        }

        var axisViewRight = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_RIGHT);
        var axisViewBack = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BACK);
        var axisViewLeft = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_LEFT);
        var axisViewFront = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_FRONT);
        var axisViewTop = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_TOP);
        var axisViewBottom = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BOTTOM);

        if ((!axisViewRight) && (!axisViewBack) && (!axisViewLeft) && (!axisViewFront) && (!axisViewTop) && (!axisViewBottom)) {
            return;
        }

        var aabb = scene.aabb;
        var diag = math.getAABB3Diag(aabb);

        math.getAABB3Center(aabb, center);

        var perspectiveDist = Math.abs(diag / Math.tan(controllers.cameraFlight.fitFOV * math.DEGTORAD));
        var orthoScale = diag * 1.1;

        tempCameraTarget.orthoScale = orthoScale;

        if (axisViewRight) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldRight, perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(camera.worldUp);

        } else if (axisViewBack) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldForward, perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(camera.worldUp);

        } else if (axisViewLeft) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldRight, -perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(camera.worldUp);

        } else if (axisViewFront) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldForward, -perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(camera.worldUp);

        } else if (axisViewTop) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldUp, perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, 1, tempVec3b), tempVec3c));

        } else if (axisViewBottom) {

            tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(camera.worldUp, -perspectiveDist, tempVec3a), tempVec3d));
            tempCameraTarget.look.set(center);
            tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, -1, tempVec3b)));
        }

        if ((!configs.firstPerson) && configs.followPointer) {
            controllers.pivotController.setPivotPos(center);
        }

        if (controllers.cameraFlight.duration > 0) {
            controllers.cameraFlight.flyTo(tempCameraTarget, function () {
                if (controllers.pivotController.getPivoting() && configs.followPointer) {
                    controllers.pivotController.showPivot();
                }
            });

        } else {
            controllers.cameraFlight.jumpTo(tempCameraTarget);
            if (controllers.pivotController.getPivoting() && configs.followPointer) {
                controllers.pivotController.showPivot();
            }
        }
    });
};

KeyboardAxisViewHandler.prototype.reset = function reset () {
};

KeyboardAxisViewHandler.prototype.destroy = function destroy () {
    document.removeEventListener("keydown", this._documentKeyDownHandler);
};

/**
 * @private
 */
var MousePickHandler = function MousePickHandler(scene, controllers, configs, states, updates) {
    var this$1 = this;


    this._scene = scene;

    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;
    var cameraControl = controllers.cameraControl;

    this._clicks = 0;
    this._timeout = null;
    this._lastPickedEntityId = null;

    var leftDown = false;
    var rightDown = false;

    var canvas = this._scene.canvas.canvas;

    var flyCameraTo = function (pickResult) {
        var pos;
        if (pickResult && pickResult.worldPos) {
            pos = pickResult.worldPos;
        }
        var aabb = pickResult && pickResult.entity ? pickResult.entity.aabb : scene.aabb;
        if (pos) { // Fly to look at point, don't change eye->look dist
            var camera = scene.camera;
            math.subVec3(camera.eye, camera.look, []);
            controllers.cameraFlight.flyTo({
                // look: pos,
                // eye: xeokit.math.addVec3(pos, diff, []),
                // up: camera.up,
                aabb: aabb
            });
            // TODO: Option to back off to fit AABB in view
        } else {// Fly to fit target boundary in view
            controllers.cameraFlight.flyTo({
                aabb: aabb
            });
        }
    };

    canvas.addEventListener("mousemove", this._canvasMouseMoveHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        if (leftDown || rightDown) {
            return;
        }

        var hoverSubs = cameraControl.hasSubs("hover");
        var hoverOutSubs = cameraControl.hasSubs("hoverOut");
        var hoverOffSubs = cameraControl.hasSubs("hoverOff");
        var hoverSurfaceSubs = cameraControl.hasSubs("hoverSurface");

        if (hoverSubs || hoverOutSubs || hoverOffSubs || hoverSurfaceSubs) {

            pickController.pickCursorPos = states.pointerCanvasPos;
            pickController.schedulePickEntity = true;
            pickController.schedulePickSurface = hoverSurfaceSubs;

            pickController.update();

            if (pickController.pickResult) {

                var pickedEntityId = pickController.pickResult.entity.id;

                if (this$1._lastPickedEntityId !== pickedEntityId) {

                    if (this$1._lastPickedEntityId !== undefined) {

                        cameraControl.fire("hoverOut", { // Hovered off an entity
                            entity: scene.objects[this$1._lastPickedEntityId]
                        }, true);
                    }

                    cameraControl.fire("hoverEnter", pickController.pickResult, true); // Hovering over a new entity

                    this$1._lastPickedEntityId = pickedEntityId;
                }

                cameraControl.fire("hover", pickController.pickResult, true);

                if (pickController.pickResult.worldPos) { // Hovering the surface of an entity
                    cameraControl.fire("hoverSurface", pickController.pickResult, true);
                }

            } else {

                if (this$1._lastPickedEntityId !== undefined) {

                    cameraControl.fire("hoverOut", { // Hovered off an entity
                        entity: scene.objects[this$1._lastPickedEntityId]
                    }, true);

                    this$1._lastPickedEntityId = undefined;
                }

                cameraControl.fire("hoverOff", { // Not hovering on any entity
                    canvasPos: pickController.pickCursorPos
                }, true);
            }
        }
    });

    canvas.addEventListener('mousedown', this._canvasMouseDownHandler = function (e) {

        if (e.which === 1) {
            leftDown = true;
        }

        if (e.which === 3) {
            rightDown = true;
        }

        var leftButtonDown = (e.which === 1);

        if (!leftButtonDown) {
            return;
        }

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        // Left mouse button down to start pivoting

        states.mouseDownClientX = e.clientX;
        states.mouseDownClientY = e.clientY;
        states.mouseDownCursorX = states.pointerCanvasPos[0];
        states.mouseDownCursorY = states.pointerCanvasPos[1];

        if ((!configs.firstPerson) && configs.followPointer) {

            pickController.pickCursorPos = states.pointerCanvasPos;
            pickController.schedulePickSurface = true;

            pickController.update();

            if (e.which === 1) {// Left button
                var pickResult = pickController.pickResult;
                if (pickResult && pickResult.worldPos) {
                    pivotController.setPivotPos(pickResult.worldPos);
                    pivotController.startPivot();
                } else {
                    if (configs.smartPivot) {
                        pivotController.setCanvasPivotPos(states.pointerCanvasPos);
                    } else {
                        pivotController.setPivotPos(scene.camera.look);
                    }
                    pivotController.startPivot();
                }
            }
        }
    });

    document.addEventListener('mouseup', this._documentMouseUpHandler = function (e) {

        if (e.which === 1) {
            leftDown = false;
        }

        if (e.which === 3) {
            rightDown = false;
        }
    });

    canvas.addEventListener('mouseup', this._canvasMouseUpHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        var leftButtonUp = (e.which === 1);

        if (!leftButtonUp) {
            return;
        }

        // Left mouse button up to possibly pick or double-pick

        pivotController.hidePivot();

        if (Math.abs(e.clientX - states.mouseDownClientX) > 3 || Math.abs(e.clientY - states.mouseDownClientY) > 3) {
            return;
        }

        var pickedSubs = cameraControl.hasSubs("picked");
        var pickedNothingSubs = cameraControl.hasSubs("pickedNothing");
        var pickedSurfaceSubs = cameraControl.hasSubs("pickedSurface");
        var doublePickedSubs = cameraControl.hasSubs("doublePicked");
        var doublePickedSurfaceSubs = cameraControl.hasSubs("doublePickedSurface");
        var doublePickedNothingSubs = cameraControl.hasSubs("doublePickedNothing");

        if ((!configs.doublePickFlyTo) &&
            (!doublePickedSubs) &&
            (!doublePickedSurfaceSubs) &&
            (!doublePickedNothingSubs)) {

            //  Avoid the single/double click differentiation timeout

            if (pickedSubs || pickedNothingSubs || pickedSurfaceSubs) {

                pickController.pickCursorPos = states.pointerCanvasPos;
                pickController.schedulePickEntity = true;
                pickController.schedulePickSurface = pickedSurfaceSubs;
                pickController.update();

                if (pickController.pickResult) {

                    cameraControl.fire("picked", pickController.pickResult, true);

                    if (pickController.pickedSurface) {
                        cameraControl.fire("pickedSurface", pickController.pickResult, true);
                    }
                } else {
                    cameraControl.fire("pickedNothing", {
                        canvasPos: states.pointerCanvasPos
                    }, true);
                }
            }

            this$1._clicks = 0;

            return;
        }

        this$1._clicks++;

        if (this$1._clicks === 1) { // First click

            this$1._timeout = setTimeout(function () {

                pickController.pickCursorPos = states.pointerCanvasPos;
                pickController.schedulePickEntity = configs.doublePickFlyTo;
                pickController.schedulePickSurface = pickedSurfaceSubs;
                pickController.update();

                if (pickController.pickResult) {

                    cameraControl.fire("picked", pickController.pickResult, true);

                    if (pickController.pickedSurface) {

                        cameraControl.fire("pickedSurface", pickController.pickResult, true);

                        if ((!configs.firstPerson) && configs.followPointer) {
                            controllers.pivotController.setPivotPos(pickController.pickResult.worldPos);
                            if (controllers.pivotController.startPivot()) {
                                controllers.pivotController.showPivot();
                            }
                        }
                    }
                } else {
                    cameraControl.fire("pickedNothing", {
                        canvasPos: states.pointerCanvasPos
                    }, true);
                }

                this$1._clicks = 0;

            }, 250);  // FIXME: Too short for track pads

        } else { // Second click

            if (this$1._timeout !== null) {
                window.clearTimeout(this$1._timeout);
                this$1._timeout = null;
            }

            pickController.pickCursorPos = states.pointerCanvasPos;
            pickController.schedulePickEntity = configs.doublePickFlyTo || doublePickedSubs || doublePickedSurfaceSubs;
            pickController.schedulePickSurface = pickController.schedulePickEntity && doublePickedSurfaceSubs;
            pickController.update();

            if (pickController.pickResult) {

                cameraControl.fire("doublePicked", pickController.pickResult, true);

                if (pickController.pickedSurface) {
                    cameraControl.fire("doublePickedSurface", pickController.pickResult, true);
                }

                if (configs.doublePickFlyTo) {

                    flyCameraTo(pickController.pickResult);

                    if ((!configs.firstPerson) && configs.followPointer) {

                        var pickedEntityAABB = pickController.pickResult.entity.aabb;
                        var pickedEntityCenterPos = math.getAABB3Center(pickedEntityAABB);

                        controllers.pivotController.setPivotPos(pickedEntityCenterPos);

                        if (controllers.pivotController.startPivot()) {
                            controllers.pivotController.showPivot();
                        }
                    }
                }

            } else {

                cameraControl.fire("doublePickedNothing", {
                    canvasPos: states.pointerCanvasPos
                }, true);

                if (configs.doublePickFlyTo) {

                    flyCameraTo();

                    if ((!configs.firstPerson) && configs.followPointer) {

                        var sceneAABB = scene.aabb;
                        var sceneCenterPos = math.getAABB3Center(sceneAABB);

                        controllers.pivotController.setPivotPos(sceneCenterPos);

                        if (controllers.pivotController.startPivot()) {
                            controllers.pivotController.showPivot();
                        }
                    }
                }
            }

            this$1._clicks = 0;
        }
    }, false);
};

MousePickHandler.prototype.reset = function reset () {
    this._clicks = 0;
    this._lastPickedEntityId = null;
    if (this._timeout) {
        window.clearTimeout(this._timeout);
        this._timeout = null;
    }
};

MousePickHandler.prototype.destroy = function destroy () {
    var canvas = this._scene.canvas.canvas;
    canvas.removeEventListener("mousemove", this._canvasMouseMoveHandler);
    canvas.removeEventListener("mousedown", this._canvasMouseDownHandler);
    document.removeEventListener("mouseup", this._documentMouseUpHandler);
    canvas.removeEventListener("mouseup", this._canvasMouseUpHandler);
    if (this._timeout) {
        window.clearTimeout(this._timeout);
        this._timeout = null;
    }
};

/**
 * @private
 */
var KeyboardPanRotateDollyHandler = function KeyboardPanRotateDollyHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;
    var input = scene.input;

    var keyDownMap = [];

    var canvas = scene.canvas.canvas;

    controllers.pickController;

    var mouseMovedSinceLastKeyboardDolly = true;

    document.addEventListener("mousemove", this._documentMouseMoveHandler = function () {
        mouseMovedSinceLastKeyboardDolly = true;
    });

    document.addEventListener("keydown", this._documentKeyDownHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }
        if (!states.mouseover) {
            return;
        }
        var keyCode = e.keyCode;
        keyDownMap[keyCode] = true;

        if (keyCode === input.KEY_SHIFT) {
            canvas.style.cursor = "move";
        }
    });

    document.addEventListener("keyup", this._documentKeyUpHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }
        if (!states.mouseover) {
            return;
        }
        var keyCode = e.keyCode;
        keyDownMap[keyCode] = false;

        if (keyCode === input.KEY_SHIFT) {
            canvas.style.cursor = null;
        }
    });

    this._onTick = scene.on("tick", function (e) {

        if (!(configs.active && configs.pointerEnabled) || (!scene.input.keyboardEnabled)) {
            return;
        }

        if (!states.mouseover) {
            return;
        }

        var cameraControl = controllers.cameraControl;
        var elapsedSecs = (e.deltaTime / 1000.0);

        //-------------------------------------------------------------------------------------------------
        // Keyboard rotation
        //-------------------------------------------------------------------------------------------------

        if (!configs.planView) {

            var rotateYPos = cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_POS, keyDownMap);
            var rotateYNeg = cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_NEG, keyDownMap);
            var rotateXPos = cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_POS, keyDownMap);
            var rotateXNeg = cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_NEG, keyDownMap);

            var orbitDelta = elapsedSecs * configs.keyboardRotationRate;

            if (rotateYPos || rotateYNeg || rotateXPos || rotateXNeg) {

                if ((!configs.firstPerson) && configs.followPointer) {
                    controllers.pivotController.startPivot();
                }

                if (rotateYPos) {
                    updates.rotateDeltaY += orbitDelta;

                } else if (rotateYNeg) {
                    updates.rotateDeltaY -= orbitDelta;
                }

                if (rotateXPos) {
                    updates.rotateDeltaX += orbitDelta;

                } else if (rotateXNeg) {
                    updates.rotateDeltaX -= orbitDelta;
                }

                if ((!configs.firstPerson) && configs.followPointer) {
                    controllers.pivotController.startPivot();
                }
            }
        }

        //-------------------------------------------------------------------------------------------------
        // Keyboard panning
        //-------------------------------------------------------------------------------------------------

        if (!keyDownMap[input.KEY_CTRL] && !keyDownMap[input.KEY_ALT]) {

            var dollyBackwards = cameraControl._isKeyDownForAction(cameraControl.DOLLY_BACKWARDS, keyDownMap);
            var dollyForwards = cameraControl._isKeyDownForAction(cameraControl.DOLLY_FORWARDS, keyDownMap);

            if (dollyBackwards || dollyForwards) {

                var dollyDelta = elapsedSecs * configs.keyboardDollyRate;

                if ((!configs.firstPerson) && configs.followPointer) {
                    controllers.pivotController.startPivot();
                }
                if (dollyForwards) {
                    updates.dollyDelta -= dollyDelta;
                } else if (dollyBackwards) {
                    updates.dollyDelta += dollyDelta;
                }

                if (mouseMovedSinceLastKeyboardDolly) {
                    states.followPointerDirty = true;
                    mouseMovedSinceLastKeyboardDolly = false;
                }
            }
        }

        var panForwards = cameraControl._isKeyDownForAction(cameraControl.PAN_FORWARDS, keyDownMap);
        var panBackwards = cameraControl._isKeyDownForAction(cameraControl.PAN_BACKWARDS, keyDownMap);
        var panLeft = cameraControl._isKeyDownForAction(cameraControl.PAN_LEFT, keyDownMap);
        var panRight = cameraControl._isKeyDownForAction(cameraControl.PAN_RIGHT, keyDownMap);
        var panUp = cameraControl._isKeyDownForAction(cameraControl.PAN_UP, keyDownMap);
        var panDown = cameraControl._isKeyDownForAction(cameraControl.PAN_DOWN, keyDownMap);

        var panDelta = (keyDownMap[input.KEY_ALT] ? 0.3 : 1.0) * elapsedSecs * configs.keyboardPanRate; // ALT for slower pan rate

        if (panForwards || panBackwards || panLeft || panRight || panUp || panDown) {

            if ((!configs.firstPerson) && configs.followPointer) {
                controllers.pivotController.startPivot();
            }

            if (panDown) {
                updates.panDeltaY += panDelta;

            } else if (panUp) {
                updates.panDeltaY += -panDelta;
            }

            if (panRight) {
                updates.panDeltaX += -panDelta;

            } else if (panLeft) {
                updates.panDeltaX += panDelta;
            }

            if (panBackwards) {
                updates.panDeltaZ += panDelta;

            } else if (panForwards) {
                updates.panDeltaZ += -panDelta;
            }
        }
    });
};

KeyboardPanRotateDollyHandler.prototype.reset = function reset () {
};

KeyboardPanRotateDollyHandler.prototype.destroy = function destroy () {

    this._scene.off(this._onTick);

    document.removeEventListener("mousemove", this._documentMouseMoveHandler);
    document.removeEventListener("keydown", this._documentKeyDownHandler);
    document.removeEventListener("keyup", this._documentKeyUpHandler);
};

var SCALE_DOLLY_EACH_FRAME = 1; // Recalculate dolly speed for eye->target distance on each Nth frame
var EPSILON = 0.001;
var tempVec3 = math.vec3();

/**
 * Handles camera updates on each "tick" that were scheduled by the various controllers.
 *
 * @private
 */
var CameraUpdater = function CameraUpdater(scene, controllers, configs, states, updates) {

    this._scene = scene;
    var camera = scene.camera;
    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;
    var panController = controllers.panController;

    var countDown = SCALE_DOLLY_EACH_FRAME; // Decrements on each tick
    var dollyDistFactor = 1.0; // Calculated when countDown is zero
    var followPointerWorldPos = null; // Holds the pointer's World position when configs.followPointer is true
        
    this._onTick = scene.on("tick", function () {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        var cursorType = "default";

        //----------------------------------------------------------------------------------------------------------
        // Dolly decay
        //------------------------------------------------------------------------------------  ----------------------

        if (Math.abs(updates.dollyDelta) < EPSILON) {
            updates.dollyDelta = 0;
        }

        //----------------------------------------------------------------------------------------------------------
        // Rotation decay
        //----------------------------------------------------------------------------------------------------------

        if (Math.abs(updates.rotateDeltaX) < EPSILON) {
            updates.rotateDeltaX = 0;
        }

        if (Math.abs(updates.rotateDeltaY) < EPSILON) {
            updates.rotateDeltaY = 0;
        }

        if (updates.rotateDeltaX !== 0 || updates.rotateDeltaY !== 0) {
            updates.dollyDelta = 0;
        }

        //----------------------------------------------------------------------------------------------------------
        // Dolly speed eye->look scaling
        //
        // If pointer is over an object, then dolly speed is proportional to the distance to that object.
        //
        // If pointer is not over an object, then dolly speed is proportional to the distance to the last
        // object the pointer was over. This is so that we can dolly to structures that may have gaps through
        // which empty background shows, that the pointer may inadvertently be over. In these cases, we don't
        // want dolly speed wildly varying depending on how accurately the user avoids the gaps with the pointer.
        //----------------------------------------------------------------------------------------------------------

        if (configs.followPointer) {

            if (--countDown <= 0) {

                countDown = SCALE_DOLLY_EACH_FRAME;

                if (updates.dollyDelta !== 0) {
                    if (updates.rotateDeltaY === 0 && updates.rotateDeltaX === 0) {

                        if (configs.followPointer && states.followPointerDirty) {

                            pickController.pickCursorPos = states.pointerCanvasPos;
                            pickController.schedulePickSurface = true;
                            pickController.update();

                            if (pickController.pickResult && pickController.pickResult.worldPos) {
                                followPointerWorldPos = pickController.pickResult.worldPos;
                                    
                            } else {
                                dollyDistFactor = 1.0;
                                followPointerWorldPos = null;
                            }

                            states.followPointerDirty = false;
                        }
                    }

                    if (followPointerWorldPos) {
                        var dist = Math.abs(math.lenVec3(math.subVec3(followPointerWorldPos, scene.camera.eye, tempVec3)));
                        dollyDistFactor = dist / configs.dollyProximityThreshold;
                    }

                    if (dollyDistFactor < configs.dollyMinSpeed) {
                        dollyDistFactor = configs.dollyMinSpeed;
                    }
                }
            }
        }

        var dollyDeltaForDist = (updates.dollyDelta * dollyDistFactor);

        //----------------------------------------------------------------------------------------------------------
        // Rotation
        //----------------------------------------------------------------------------------------------------------

        if (updates.rotateDeltaY !== 0 || updates.rotateDeltaX !== 0) {

            if ((!configs.firstPerson) && configs.followPointer && pivotController.getPivoting()) {
                pivotController.continuePivot(updates.rotateDeltaY, updates.rotateDeltaX);
                pivotController.showPivot();

            } else {

                if (updates.rotateDeltaX !== 0) {
                    if (configs.firstPerson) {
                        camera.pitch(-updates.rotateDeltaX);
                    } else {
                        camera.orbitPitch(updates.rotateDeltaX);
                    }
                }

                if (updates.rotateDeltaY !== 0) {
                    if (configs.firstPerson) {
                        camera.yaw(updates.rotateDeltaY);
                    } else {
                        camera.orbitYaw(updates.rotateDeltaY);
                    }
                }
            }

            updates.rotateDeltaX *= configs.rotationInertia;
            updates.rotateDeltaY *= configs.rotationInertia;

            cursorType = "grabbing";
        }

        //----------------------------------------------------------------------------------------------------------
        // Panning
        //----------------------------------------------------------------------------------------------------------

        if (Math.abs(updates.panDeltaX) < EPSILON) {
            updates.panDeltaX = 0;
        }

        if (Math.abs(updates.panDeltaY) < EPSILON) {
            updates.panDeltaY = 0;
        }

        if (Math.abs(updates.panDeltaZ) < EPSILON) {
            updates.panDeltaZ = 0;
        }

        if (updates.panDeltaX !== 0 || updates.panDeltaY !== 0 || updates.panDeltaZ !== 0) {

            var vec = math.vec3();

            vec[0] = updates.panDeltaX;
            vec[1] = updates.panDeltaY;
            vec[2] = updates.panDeltaZ;

            var verticalEye;
            var verticalLook;

            if (configs.constrainVertical) {

                if (camera.xUp) {
                    verticalEye = camera.eye[0];
                    verticalLook = camera.look[0];
                } else if (camera.yUp) {
                    verticalEye = camera.eye[1];
                    verticalLook = camera.look[1];
                } else if (camera.zUp) {
                    verticalEye = camera.eye[2];
                    verticalLook = camera.look[2];
                }

                camera.pan(vec);

                var eye = camera.eye;
                var look = camera.look;

                if (camera.xUp) {
                    eye[0] = verticalEye;
                    look[0] = verticalLook;
                } else if (camera.yUp) {
                    eye[1] = verticalEye;
                    look[1] = verticalLook;
                } else if (camera.zUp) {
                    eye[2] = verticalEye;
                    look[2] = verticalLook;
                }

                camera.eye = eye;
                camera.look = look;

            } else {
                camera.pan(vec);
            }

            cursorType = "grabbing";
        }

        updates.panDeltaX *= configs.panInertia;
        updates.panDeltaY *= configs.panInertia;
        updates.panDeltaZ *= configs.panInertia;

        //----------------------------------------------------------------------------------------------------------
        // Dollying
        //----------------------------------------------------------------------------------------------------------

        if (dollyDeltaForDist !== 0) {

            if (dollyDeltaForDist < 0) {
                cursorType = "zoom-in";
            } else {
                cursorType = "zoom-out";
            }

            if (configs.firstPerson) {

                var verticalEye$1;
                var verticalLook$1;

                if (configs.constrainVertical) {
                    if (camera.xUp) {
                        verticalEye$1 = camera.eye[0];
                        verticalLook$1 = camera.look[0];
                    } else if (camera.yUp) {
                        verticalEye$1 = camera.eye[1];
                        verticalLook$1 = camera.look[1];
                    } else if (camera.zUp) {
                        verticalEye$1 = camera.eye[2];
                        verticalLook$1 = camera.look[2];
                    }
                }

                if (configs.followPointer) {
                    var dolliedThroughSurface = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
                    if (dolliedThroughSurface) {
                        states.followPointerDirty = true;
                    }
                } else {
                    camera.pan([0, 0, dollyDeltaForDist]);
                    camera.ortho.scale = camera.ortho.scale - dollyDeltaForDist;
                }

                if (configs.constrainVertical) {
                    var eye$1 = camera.eye;
                    var look$1 = camera.look;
                    if (camera.xUp) {
                        eye$1[0] = verticalEye$1;
                        look$1[0] = verticalLook$1;
                    } else if (camera.yUp) {
                        eye$1[1] = verticalEye$1;
                        look$1[1] = verticalLook$1;
                    } else if (camera.zUp) {
                        eye$1[2] = verticalEye$1;
                        look$1[2] = verticalLook$1;
                    }
                    camera.eye = eye$1;
                    camera.look = look$1;
                }

            } else if (configs.planView) {

                if (configs.followPointer) {
                    var dolliedThroughSurface$1 = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
                    if (dolliedThroughSurface$1) {
                        states.followPointerDirty = true;
                    }
                } else {
                    camera.ortho.scale = camera.ortho.scale + dollyDeltaForDist;
                    camera.zoom(dollyDeltaForDist);
                }

            } else { // Orbiting

                if (configs.followPointer) {
                    var dolliedThroughSurface$2 = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
                    if (dolliedThroughSurface$2) {
                        states.followPointerDirty = true;
                    }
                } else {
                    camera.ortho.scale = camera.ortho.scale + dollyDeltaForDist;
                    camera.zoom(dollyDeltaForDist);
                }
            }

            updates.dollyDelta *= configs.dollyInertia;
        }

        pickController.fireEvents();

        document.body.style.cursor = cursorType;
    });
};


CameraUpdater.prototype.destroy = function destroy () {
    this._scene.off(this._onTick);
};

/**
 * @private
 */
var MouseMiscHandler = function MouseMiscHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;

    var canvas = this._scene.canvas.canvas;

    canvas.addEventListener("mouseenter", this._mouseEnterHandler = function () {
        states.mouseover = true;
    });

    canvas.addEventListener("mouseleave", this._mouseLeaveHandler = function () {
        states.mouseover = false;
        canvas.style.cursor = null;
    });

    document.addEventListener("mousemove", this._mouseMoveHandler = function (e) {
        getCanvasPosFromEvent$1(e, canvas, states.pointerCanvasPos);
    });

    canvas.addEventListener("mousedown", this._mouseDownHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
        getCanvasPosFromEvent$1(e, canvas, states.pointerCanvasPos);
        states.mouseover = true;
    });

    canvas.addEventListener("mouseup", this._mouseUpHandler = function (e) {
        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }
    });
};

MouseMiscHandler.prototype.reset = function reset () {
};

MouseMiscHandler.prototype.destroy = function destroy () {

    var canvas = this._scene.canvas.canvas;

    document.removeEventListener("mousemove", this._mouseMoveHandler);
    canvas.removeEventListener("mouseenter", this._mouseEnterHandler);
    canvas.removeEventListener("mouseleave", this._mouseLeaveHandler);
    canvas.removeEventListener("mousedown", this._mouseDownHandler);
    canvas.removeEventListener("mouseup", this._mouseUpHandler);
};

function getCanvasPosFromEvent$1(event, canvas, canvasPos) {
    if (!event) {
        event = window.event;
        canvasPos[0] = event.x;
        canvasPos[1] = event.y;
    } else {
        var ref = canvas.getBoundingClientRect();
        var x = ref.x;
        var y = ref.y;
        canvasPos[0] = event.clientX - x;
        canvasPos[1] = event.clientY - y;
    }
    return canvasPos;
}

var getCanvasPosFromEvent = function (event, canvasPos) {
    if (!event) {
        event = window.event;
        canvasPos[0] = event.x;
        canvasPos[1] = event.y;
    } else {
        var element = event.target;
        var totalOffsetLeft = 0;
        var totalOffsetTop = 0;
        while (element.offsetParent) {
            totalOffsetLeft += element.offsetLeft;
            totalOffsetTop += element.offsetTop;
            element = element.offsetParent;
        }
        canvasPos[0] = event.pageX - totalOffsetLeft;
        canvasPos[1] = event.pageY - totalOffsetTop;
    }
    return canvasPos;
};

/**
 * @private
 */
var TouchPanRotateAndDollyHandler = function TouchPanRotateAndDollyHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;

    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;

    var tapStartCanvasPos = math.vec2();
    var tapCanvasPos0 = math.vec2();
    var tapCanvasPos1 = math.vec2();
    var touch0Vec = math.vec2();

    var lastCanvasTouchPosList = [];
    var canvas = this._scene.canvas.canvas;

    var numTouches = 0;
    var waitForTick = false;

    this._onTick = scene.on("tick", function () {
        waitForTick = false;
    });

    canvas.addEventListener("touchstart", this._canvasTouchStartHandler = function (event) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        event.preventDefault();

        var touches = event.touches;
        var changedTouches = event.changedTouches;

        states.touchStartTime = Date.now();

        if (touches.length === 1 && changedTouches.length === 1) {

            states.touchStartTime;

            getCanvasPosFromEvent(touches[0], tapStartCanvasPos);

            if (configs.followPointer) {

                pickController.pickCursorPos = tapStartCanvasPos;
                pickController.schedulePickSurface = true;
                pickController.update();

                if (!configs.planView) {

                    if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {

                        pivotController.setPivotPos(pickController.pickResult.worldPos);

                        if (!configs.firstPerson && pivotController.startPivot()) {
                            pivotController.showPivot();
                        }

                    } else {

                        if (configs.smartPivot) {
                            pivotController.setCanvasPivotPos(states.pointerCanvasPos);
                        } else {
                            pivotController.setPivotPos(scene.camera.look);
                        }

                        if (!configs.firstPerson && pivotController.startPivot()) {
                            pivotController.showPivot();
                        }
                    }
                }
            }

        }

        while (lastCanvasTouchPosList.length < touches.length) {
            lastCanvasTouchPosList.push(math.vec2());
        }

        for (var i = 0, len = touches.length; i < len; ++i) {
            getCanvasPosFromEvent(touches[i], lastCanvasTouchPosList[i]);
        }

        numTouches = touches.length;
    });

    canvas.addEventListener("touchmove", this._canvasTouchMoveHandler = function (event) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        event.stopPropagation();
        event.preventDefault();

        if (waitForTick) {
            // Limit changes detection to one per frame
            return;
        }

        waitForTick = true;

        // Scaling drag-rotate to canvas boundary

        var canvasBoundary = scene.canvas.boundary;
        var canvasWidth = canvasBoundary[2] - canvasBoundary[0];
        var canvasHeight = canvasBoundary[3] - canvasBoundary[1];

        var touches = event.touches;

        if (event.touches.length !== numTouches) {
            // Two fingers were pressed, then one of them is removed
            // We don't want to rotate in this case (weird behavior)
            return;
        }

        if (numTouches === 1) {

            getCanvasPosFromEvent(touches[0], tapCanvasPos0);

            //-----------------------------------------------------------------------------------------------
            // Drag rotation
            //-----------------------------------------------------------------------------------------------

            math.subVec2(tapCanvasPos0, lastCanvasTouchPosList[0], touch0Vec);

            var xPanDelta = touch0Vec[0];
            var yPanDelta = touch0Vec[1];

            if (states.longTouchTimeout !== null && (Math.abs(xPanDelta) > configs.longTapRadius || Math.abs(yPanDelta) > configs.longTapRadius)) {
                clearTimeout(states.longTouchTimeout);
                states.longTouchTimeout = null;
            }

            if (configs.planView) { // No rotating in plan-view mode

                var camera = scene.camera;

                // We use only canvasHeight here so that aspect ratio does not distort speed

                if (camera.projection === "perspective") {

                    var touchPicked = false;
                    var pickedWorldPos = [0, 0, 0];

                    var depth = Math.abs(touchPicked ? math.lenVec3(math.subVec3(pickedWorldPos, scene.camera.eye, [])) : scene.camera.eyeLookDist);
                    var targetDistance = depth * Math.tan((camera.perspective.fov / 2) * Math.PI / 180.0);

                    updates.panDeltaX += (xPanDelta * targetDistance / canvasHeight) * configs.touchPanRate;
                    updates.panDeltaY += (yPanDelta * targetDistance / canvasHeight) * configs.touchPanRate;

                } else {

                    updates.panDeltaX += 0.5 * camera.ortho.scale * (xPanDelta / canvasHeight) * configs.touchPanRate;
                    updates.panDeltaY += 0.5 * camera.ortho.scale * (yPanDelta / canvasHeight) * configs.touchPanRate;
                }

            } else {
                updates.rotateDeltaY -= (xPanDelta / canvasWidth) * (configs.dragRotationRate * 1.0); // Full horizontal rotation
                updates.rotateDeltaX += (yPanDelta / canvasHeight) * (configs.dragRotationRate * 1.5); // Half vertical rotation
            }

        } else if (numTouches === 2) {

            var touch0 = touches[0];
            var touch1 = touches[1];

            getCanvasPosFromEvent(touch0, tapCanvasPos0);
            getCanvasPosFromEvent(touch1, tapCanvasPos1);

            var lastMiddleTouch = math.geometricMeanVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);
            var currentMiddleTouch = math.geometricMeanVec2(tapCanvasPos0, tapCanvasPos1);

            var touchDelta = math.vec2();

            math.subVec2(lastMiddleTouch, currentMiddleTouch, touchDelta);

            var xPanDelta$1 = touchDelta[0];
            var yPanDelta$1 = touchDelta[1];

            var camera$1 = scene.camera;

            // Dollying

            var d1 = math.distVec2([touch0.pageX, touch0.pageY], [touch1.pageX, touch1.pageY]);
            var d2 = math.distVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);

            var dollyDelta = (d2 - d1) * configs.touchDollyRate;

            updates.dollyDelta = dollyDelta;

            if (Math.abs(dollyDelta) < 1.0) {

                // We use only canvasHeight here so that aspect ratio does not distort speed

                if (camera$1.projection === "perspective") {
                    var pickedWorldPos$1 = pickController.pickResult ? pickController.pickResult.worldPos : scene.center;

                    var depth$1 = Math.abs(math.lenVec3(math.subVec3(pickedWorldPos$1, scene.camera.eye, [])));
                    var targetDistance$1 = depth$1 * Math.tan((camera$1.perspective.fov / 2) * Math.PI / 180.0);

                    updates.panDeltaX -= (xPanDelta$1 * targetDistance$1 / canvasHeight) * configs.touchPanRate;
                    updates.panDeltaY -= (yPanDelta$1 * targetDistance$1 / canvasHeight) * configs.touchPanRate;

                } else {

                    updates.panDeltaX -= 0.5 * camera$1.ortho.scale * (xPanDelta$1 / canvasHeight) * configs.touchPanRate;
                    updates.panDeltaY -= 0.5 * camera$1.ortho.scale * (yPanDelta$1 / canvasHeight) * configs.touchPanRate;
                }
            }


            states.pointerCanvasPos = currentMiddleTouch;
        }

        for (var i = 0; i < numTouches; ++i) {
            getCanvasPosFromEvent(touches[i], lastCanvasTouchPosList[i]);
        }
    });
};

TouchPanRotateAndDollyHandler.prototype.reset = function reset () {
};

TouchPanRotateAndDollyHandler.prototype.destroy = function destroy () {
    var canvas = this._scene.canvas.canvas;
    canvas.removeEventListener("touchstart", this._canvasTouchStartHandler);
    canvas.removeEventListener("touchmove", this._canvasTouchMoveHandler);
    this._scene.off(this._onTick);
};

var TAP_INTERVAL = 150;
var DBL_TAP_INTERVAL = 325;
var TAP_DISTANCE_THRESHOLD = 4;

/**
 * @private
 */
var TouchPickHandler = function TouchPickHandler(scene, controllers, configs, states, updates) {

    this._scene = scene;

    var pickController = controllers.pickController;
    var cameraControl = controllers.cameraControl;

    var touchStartTime;
    var activeTouches = [];
    var tapStartPos = new Float32Array(2);
    var tapStartTime = -1;
    var lastTapTime = -1;

    var canvas = this._scene.canvas.canvas;

    var flyCameraTo = function (pickResult) {
        var pos;
        if (pickResult && pickResult.worldPos) {
            pos = pickResult.worldPos;
        }
        var aabb = pickResult ? pickResult.entity.aabb : scene.aabb;
        if (pos) { // Fly to look at point, don't change eye->look dist
            var camera = scene.camera;
            math.subVec3(camera.eye, camera.look, []);
            controllers.cameraFlight.flyTo({
                aabb: aabb
            });
            // TODO: Option to back off to fit AABB in view
        } else {// Fly to fit target boundary in view
            controllers.cameraFlight.flyTo({
                aabb: aabb
            });
        }
    };

    canvas.addEventListener("touchstart", this._canvasTouchStartHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        if (states.longTouchTimeout !== null) {
            clearTimeout(states.longTouchTimeout);
            states.longTouchTimeout = null;
        }

        var touches = e.touches;
        var changedTouches = e.changedTouches;

        touchStartTime = Date.now();

        if (touches.length === 1 && changedTouches.length === 1) {
            tapStartTime = touchStartTime;
            tapStartPos[0] = touches[0].pageX;
            tapStartPos[1] = touches[0].pageY;

            var rightClickClientX = touches[0].clientX;
            var rightClickClientY = touches[0].clientY;

            var rightClickPageX = touches[0].pageX;
            var rightClickPageY = touches[0].pageY;

            states.longTouchTimeout = setTimeout(function () {
                controllers.cameraControl.fire("rightClick", { // For context menus
                    pagePos: [Math.round(rightClickPageX), Math.round(rightClickPageY)],
                    canvasPos: [Math.round(rightClickClientX), Math.round(rightClickClientY)],
                    event: e
                }, true);

                states.longTouchTimeout = null;
            }, configs.longTapTimeout);

        } else {
            tapStartTime = -1;
        }

        while (activeTouches.length < touches.length) {
            activeTouches.push(new Float32Array(2));
        }

        for (var i = 0, len = touches.length; i < len; ++i) {
            activeTouches[i][0] = touches[i].pageX;
            activeTouches[i][1] = touches[i].pageY;
        }

        activeTouches.length = touches.length;

    }, {passive: true});


    canvas.addEventListener("touchend", this._canvasTouchEndHandler = function (e) {

        if (!(configs.active && configs.pointerEnabled)) {
            return;
        }

        var currentTime = Date.now();
        var touches = e.touches;
        var changedTouches = e.changedTouches;

        var pickedSurfaceSubs = cameraControl.hasSubs("pickedSurface");

        if (states.longTouchTimeout !== null) {
            clearTimeout(states.longTouchTimeout);
            states.longTouchTimeout = null;
        }

        // process tap

        if (touches.length === 0 && changedTouches.length === 1) {

            if (tapStartTime > -1 && currentTime - tapStartTime < TAP_INTERVAL) {

                if (lastTapTime > -1 && tapStartTime - lastTapTime < DBL_TAP_INTERVAL) {

                    // Double-tap

                    pickController.pickCursorPos[0] = Math.round(changedTouches[0].clientX);
                    pickController.pickCursorPos[1] = Math.round(changedTouches[0].clientY);
                    pickController.schedulePickEntity = true;
                    pickController.schedulePickSurface = pickedSurfaceSubs;

                    pickController.update();

                    if (pickController.pickResult) {

                        cameraControl.fire("doublePicked", pickController.pickResult);

                        if (pickController.pickedSurface) {
                            cameraControl.fire("doublePickedSurface", pickController.pickResult);
                        }

                        if (configs.doublePickFlyTo) {
                            flyCameraTo(pickController.pickResult);
                        }
                    } else {
                        cameraControl.fire("doublePickedNothing");
                        if (configs.doublePickFlyTo) {
                            flyCameraTo();
                        }
                    }

                    lastTapTime = -1;

                } else if (math.distVec2(activeTouches[0], tapStartPos) < TAP_DISTANCE_THRESHOLD) {

                    // Single-tap

                    pickController.pickCursorPos[0] = Math.round(changedTouches[0].clientX);
                    pickController.pickCursorPos[1] = Math.round(changedTouches[0].clientY);
                    pickController.schedulePickEntity = true;
                    pickController.schedulePickSurface = pickedSurfaceSubs;

                    pickController.update();

                    if (pickController.pickResult) {

                        cameraControl.fire("picked", pickController.pickResult);

                        if (pickController.pickedSurface) {
                            cameraControl.fire("pickedSurface", pickController.pickResult);
                        }

                    } else {
                        cameraControl.fire("pickedNothing");
                    }

                    lastTapTime = currentTime;
                }

                tapStartTime = -1;
            }
        }

        activeTouches.length = touches.length;

        for (var i = 0, len = touches.length; i < len; ++i) {
            activeTouches[i][0] = touches[i].pageX;
            activeTouches[i][1] = touches[i].pageY;
        }

        e.stopPropagation();

    }, {passive: true});

};

TouchPickHandler.prototype.reset = function reset () {
    // TODO
    // tapStartTime = -1;
    // lastTapTime = -1;

};

TouchPickHandler.prototype.destroy = function destroy () {
    var canvas = this._scene.canvas.canvas;
    canvas.removeEventListener("touchstart", this._canvasTouchStartHandler);
    canvas.removeEventListener("touchend", this._canvasTouchEndHandler);
};

/**
 * @desc Controls the {@link Camera} with user input, and fires events when the user interacts with pickable {@link Entity}s.
 *
 * # Contents
 *
 * * [Overview](#overview)
 * * [Examples](#examples)
 * * [Orbit Mode](#orbit-mode)
 *      + [Following the Pointer in Orbit Mode](#--following-the-pointer-in-orbit-mode--)
 *      + [Showing the Pivot Position](#--showing-the-pivot-position--)
 *      + [Axis-Aligned Views in Orbit Mode](#--axis-aligned-views-in-orbit-mode--)
 *      + [View-Fitting Entitys in Orbit Mode](#--view-fitting-entitys-in-orbit-mode--)
 * * [First-Person Mode](#first-person-mode)
 *      + [Following the Pointer in First-Person Mode](#--following-the-pointer-in-first-person-mode--)
 *      + [Constraining Vertical Position in First-Person Mode](#--constraining-vertical-position-in-first-person-mode--)
 *      + [Axis-Aligned Views in First-Person Mode](#--axis-aligned-views-in-first-person-mode--)
 *      + [View-Fitting Entitys in First-Person Mode](#--view-fitting-entitys-in-first-person-mode--)
 * * [Plan-View Mode](#plan-view-mode)
 *      + [Following the Pointer in Plan-View Mode](#--following-the-pointer-in-plan-view-mode--)
 *      + [Axis-Aligned Views in Plan-View Mode](#--axis-aligned-views-in-plan-view-mode--)
 * * [CameraControl Events](#cameracontrol-events)
 *      + ["hover"](#---hover---)
 *      + ["hoverOff"](#---hoveroff---)
 *      + ["hoverEnter"](#---hoverenter---)
 *      + ["hoverOut"](#---hoverout---)
 *      + ["picked"](#---picked---)
 *      + ["pickedSurface"](#---pickedsurface---)
 *      + ["pickedNothing"](#---pickednothing---)
 *      + ["doublePicked"](#---doublepicked---)
 *      + ["doublePickedSurface"](#---doublepickedsurface---)
 *      + ["doublePickedNothing"](#---doublepickednothing---)
 *      + ["rightClick"](#---rightclick---)
 * * [Custom Keyboard Mappings](#custom-keyboard-mappings)
 *
 * <br><br>
 *
 * # Overview
 *
 * * Each {@link Viewer} has a ````CameraControl````, located at {@link Viewer#cameraControl}.
 * * {@link CameraControl#navMode} selects the navigation mode:
 *      * ````"orbit"```` rotates the {@link Camera} position about the target.
 *      * ````"firstPerson"```` rotates the World about the Camera position.
 *      * ````"planView"```` never rotates, but still allows to pan and dolly, typically for an axis-aligned view.
 * * {@link CameraControl#followPointer} makes the Camera follow the mouse or touch pointer.
 * * {@link CameraControl#constrainVertical} locks the Camera to its current height when in first-person mode.
 * * ````CameraControl```` fires pick events when we hover, click or tap on an {@link Entity}.
 * <br><br>
 *
 * # Examples
 *
 * * [Orbit Navigation - Duplex Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_orbit_Duplex)
 * * [Orbit Navigation - Holter Tower Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_orbit_HolterTower)
 * * [First-Person Navigation - Duplex Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_firstPerson_Duplex)
 * * [First-Person Navigation - Holter Tower Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_firstPerson_HolterTower)
 * * [Plan-view Navigation - Schependomlaan Model](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_planView_Schependomlaan)
 * * [Custom Keyboard Mapping](https://xeokit.github.io/xeokit-sdk/examples/#CameraControl_keyMap)
 * <br><br>
 *
 * # Orbit Mode
 *
 * In orbit mode, ````CameraControl```` orbits the {@link Camera} about the target.
 *
 * To enable orbit mode:
 *
 * ````javascript
 * const cameraControl = myViewer.cameraControl;
 * cameraControl.navMode = "orbit";
 * ````
 *
 * Then orbit by:
 *
 * * left-dragging the mouse,
 * * tap-dragging the touch pad, and
 * * pressing arrow keys, or ````Q```` and ````E```` on a QWERTY keyboard, or ````A```` and ````E```` on an AZERTY keyboard.
 * <br><br>
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys, or ````W```` and ````S```` on a QWERTY keyboard, or ````Z```` and ````S```` for AZERTY.
 * <br><br>
 *
 * Pan horizontally and vertically by:
 *
 * * right-dragging the mouse,
 * * left-dragging the mouse with the SHIFT key down,
 * * tap-dragging the touch pad with SHIFT down,
 * * pressing the ````A````, ````D````, ````Z```` and ````X```` keys on a QWERTY keyboard, and
 * * pressing the ````Q````, ````D````, ````W```` and ````X```` keys on an AZERTY keyboard,
 * <br><br>
 *
 * ## Following the Pointer in Orbit Mode
 *
 * When {@link CameraControl#followPointer} is ````true````in orbiting mode, the mouse or touch pointer will dynamically
 * indicate the target that the {@link Camera} will orbit, as well as dolly to and from.
 *
 * Lets ensure that we're in orbit mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "orbit";
 * cameraControl.followPointer = true;
 * ````
 *
 * ## Smart Pivoting
 *
 * TODO
 *
 * ## Showing the Pivot Position
 *
 * We can configure {@link CameraControl#pivotElement} with an HTML element to indicate the current
 * pivot position. The indicator will appear momentarily each time we move the {@link Camera} while in orbit mode with
 * {@link CameraControl#followPointer} set ````true````.
 *
 * First we'll define some CSS to style our pivot indicator as a black dot with a white border:
 *
 * ````css
 * .camera-pivot-marker {
 *      color: #ffffff;
 *      position: absolute;
 *      width: 25px;
 *      height: 25px;
 *      border-radius: 15px;
 *      border: 2px solid #ebebeb;
 *      background: black;
 *      visibility: hidden;
 *      box-shadow: 5px 5px 15px 1px #000000;
 *      z-index: 10000;
 *      pointer-events: none;
 * }
 * ````
 *
 * Then we'll attach our pivot indicator's HTML element to the ````CameraControl````:
 *
 * ````javascript
 * const pivotElement = document.createRange().createContextualFragment("<div class='camera-pivot-marker'></div>").firstChild;
 *
 * document.body.appendChild(pivotElement);
 *
 * cameraControl.pivotElement = pivotElement;
 * ````
 *
 * ## Axis-Aligned Views in Orbit Mode
 *
 * In orbit mode, we can use keys 1-6 to position the {@link Camera} to look at the center of the {@link Scene} from along each of the
 * six World-space axis. Pressing one of these keys will fly the {@link Camera} to the corresponding axis-aligned view.
 *
 * ## View-Fitting Entitys in Orbit Mode
 *
 * When {@link CameraControl#doublePickFlyTo} is ````true````, we can left-double-click or
 * double-tap (ie. "double-pick") an {@link Entity} to fit it to view. This will cause the {@link Camera}
 * to fly to that Entity. Our target then becomes the center of that Entity. If we are currently pivoting,
 * then our pivot position is then also set to the Entity center.
 *
 * Disable that behaviour by setting {@link CameraControl#doublePickFlyTo} ````false````.
 *
 * # First-Person Mode
 *
 * In first-person mode, ````CameraControl```` rotates the World about the {@link Camera} position.
 *
 * To enable first-person mode:
 *
 * ````javascript
 * cameraControl.navMode = "firstPerson";
 * ````
 *
 * Then rotate by:
 *
 * * left-dragging the mouse,
 * * tap-dragging the touch pad,
 * * pressing arrow keys, or ````Q```` and ````E```` on a QWERTY keyboard, or ````A```` and ````E```` on an AZERTY keyboard.
 * <br><br>
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys, or ````W```` and ````S```` on a QWERTY keyboard, or ````Z```` and ````S```` for AZERTY.
 * <br><br>
 *
 * Pan left, right, up and down by:
 *
 * * left-dragging or right-dragging the mouse, and
 * * tap-dragging the touch pad with SHIFT down.
 *
 * Pan forwards, backwards, left, right, up and down by pressing the ````WSADZX```` keys on a QWERTY keyboard,
 * or ````WSQDWX```` keys on an AZERTY keyboard.
 * <br><br>
 *
 * ## Following the Pointer in First-Person Mode
 *
 * When {@link CameraControl#followPointer} is ````true```` in first-person mode, the mouse or touch pointer will dynamically
 * indicate the target to which the {@link Camera} will dolly to and from. In first-person mode, however, the World will always rotate
 * about the {@link Camera} position.
 *
 * Lets ensure that we're in first-person mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "firstPerson";
 * cameraControl.followPointer = true;
 * ````
 *
 * When the pointer is over empty space, the target will remain the last object that the pointer was over.
 *
 * ## Constraining Vertical Position in First-Person Mode
 *
 * In first-person mode, we can lock the {@link Camera} to its current position on the vertical World axis, which is useful for walk-through navigation:
 *
 * ````javascript
 * cameraControl.constrainVertical = true;
 * ````
 *
 * ## Axis-Aligned Views in First-Person Mode
 *
 * In first-person mode we can use keys 1-6 to position the {@link Camera} to look at the center of
 * the {@link Scene} from along each of the six World-space axis. Pressing one of these keys will fly the {@link Camera} to the
 * corresponding axis-aligned view.
 *
 * ## View-Fitting Entitys in First-Person Mode
 *
 * As in orbit mode, when in first-person mode and {@link CameraControl#doublePickFlyTo} is ````true````, we can double-click
 * or double-tap an {@link Entity} (ie. "double-picking") to fit it in view. This will cause the {@link Camera} to fly to
 * that Entity. Our target then becomes the center of that Entity.
 *
 * Disable that behaviour by setting {@link CameraControl#doublePickFlyTo} ````false````.
 *
 * # Plan-View Mode
 *
 * In plan-view mode, ````CameraControl```` pans and rotates the {@link Camera}, without rotating it.
 *
 * To enable plan-view mode:
 *
 * ````javascript
 * cameraControl.navMode = "planView";
 * ````
 *
 * Dolly forwards and backwards by:
 *
 * * spinning the mouse wheel,
 * * pinching on the touch pad, and
 * * pressing the ````+```` and ````-```` keys.
 *
 * <br>
 * Pan left, right, up and down by:
 *
 * * left-dragging or right-dragging the mouse, and
 * * tap-dragging the touch pad with SHIFT down.
 *
 * Pan forwards, backwards, left, right, up and down by pressing the ````WSADZX```` keys on a QWERTY keyboard,
 * or ````WSQDWX```` keys on an AZERTY keyboard.
 * <br><br>
 *
 * ## Following the Pointer in Plan-View Mode
 *
 * When {@link CameraControl#followPointer} is ````true```` in plan-view mode, the mouse or touch pointer will dynamically
 * indicate the target to which the {@link Camera} will dolly to and from.  In plan-view mode, however, the {@link Camera} cannot rotate.
 *
 * Lets ensure that we're in plan-view mode, then enable the {@link Camera} to follow the pointer:
 *
 * ````javascript
 * cameraControl.navMode = "planView";
 * cameraControl.followPointer = true; // Default
 * ````
 *
 * When the pointer is over empty space, the target will remain the last object that the pointer was over.
 *
 * ## Axis-Aligned Views in Plan-View Mode
 *
 * As in orbit and first-person modes, in plan-view mode we can use keys 1-6 to position the {@link Camera} to look at the center of
 * the {@link Scene} from along each of the six World-space axis. Pressing one of these keys will fly the {@link Camera} to the
 * corresponding axis-aligned view.
 *
 * # CameraControl Events
 *
 * ````CameraControl```` fires events as we interact with {@link Entity}s using mouse or touch input.
 *
 * The following examples demonstrate how to subscribe to those events.
 *
 * The first example shows how to save a handle to a subscription, which we can later use to unsubscribe.
 *
 * ## "hover"
 *
 * Event fired when the pointer moves while hovering over an Entity.
 *
 * ````javascript
 * const onHover = cameraControl.on("hover", (e) => {
 *      const entity = e.entity; // Entity
 *      const canvasPos = e.canvasPos; // 2D canvas position
 * });
 * ````
 *
 * To unsubscribe from the event:
 *
 * ````javascript
 * cameraControl.off(onHover);
 * ````
 *
 * ## "hoverOff"
 *
 * Event fired when the pointer moves while hovering over empty space.
 *
 * ````javascript
 * cameraControl.on("hoverOff", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "hoverEnter"
 *
 * Event fired when the pointer moves onto an Entity.
 *
 * ````javascript
 * cameraControl.on("hoverEnter", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "hoverOut"
 *
 * Event fired when the pointer moves off an Entity.
 *
 * ````javascript
 * cameraControl.on("hoverOut", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "picked"
 *
 * Event fired when we left-click or tap on an Entity.
 *
 * ````javascript
 * cameraControl.on("picked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "pickedSurface"
 *
 * Event fired when we left-click or tap on the surface of an Entity.
 *
 * ````javascript
 * cameraControl.on("picked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 *      const worldPos = e.worldPos; // 3D World-space position
 *      const viewPos = e.viewPos; // 3D View-space position
 *      const worldNormal = e.worldNormal; // 3D World-space normal vector
 * });
 * ````
 *
 * ## "pickedNothing"
 *
 * Event fired when we left-click or tap on empty space.
 *
 * ````javascript
 * cameraControl.on("pickedNothing", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "doublePicked"
 *
 * Event fired wwhen we left-double-click or double-tap on an Entity.
 *
 * ````javascript
 * cameraControl.on("doublePicked", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "doublePickedSurface"
 *
 * Event fired when we left-double-click or double-tap on the surface of an Entity.
 *
 * ````javascript
 * cameraControl.on("doublePickedSurface", (e) => {
 *      const entity = e.entity;
 *      const canvasPos = e.canvasPos;
 *      const worldPos = e.worldPos;
 *      const viewPos = e.viewPos;
 *      const worldNormal = e.worldNormal;
 * });
 * ````
 *
 * ## "doublePickedNothing"
 *
 * Event fired when we left-double-click or double-tap on empty space.
 *
 * ````javascript
 * cameraControl.on("doublePickedNothing", (e) => {
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## "rightClick"
 *
 * Event fired when we right-click on the canvas.
 *
 * ````javascript
 * cameraControl.on("rightClick", (e) => {
 *      const event = e.event; // Mouse event
 *      const canvasPos = e.canvasPos;
 * });
 * ````
 *
 * ## Custom Keyboard Mappings
 *
 * We can customize````CameraControl```` key bindings as shown below.
 *
 * In this example, we'll just set the default bindings for a QWERTY keyboard.
 *
 * ````javascript
 * const input = myViewer.scene.input;
 *
 * cameraControl.navMode = "orbit";
 * cameraControl.followPointer = true;
 *
 * const keyMap = {};
 *
 * keyMap[cameraControl.PAN_LEFT] = [input.KEY_A];
 * keyMap[cameraControl.PAN_RIGHT] = [input.KEY_D];
 * keyMap[cameraControl.PAN_UP] = [input.KEY_Z];
 * keyMap[cameraControl.PAN_DOWN] = [input.KEY_X];
 * keyMap[cameraControl.DOLLY_FORWARDS] = [input.KEY_W, input.KEY_ADD];
 * keyMap[cameraControl.DOLLY_BACKWARDS] = [input.KEY_S, input.KEY_SUBTRACT];
 * keyMap[cameraControl.ROTATE_X_POS] = [input.KEY_DOWN_ARROW];
 * keyMap[cameraControl.ROTATE_X_NEG] = [input.KEY_UP_ARROW];
 * keyMap[cameraControl.ROTATE_Y_POS] = [input.KEY_LEFT_ARROW];
 * keyMap[cameraControl.ROTATE_Y_NEG] = [input.KEY_RIGHT_ARROW];
 * keyMap[cameraControl.AXIS_VIEW_RIGHT] = [input.KEY_NUM_1];
 * keyMap[cameraControl.AXIS_VIEW_BACK] = [input.KEY_NUM_2];
 * keyMap[cameraControl.AXIS_VIEW_LEFT] = [input.KEY_NUM_3];
 * keyMap[cameraControl.AXIS_VIEW_FRONT] = [input.KEY_NUM_4];
 * keyMap[cameraControl.AXIS_VIEW_TOP] = [input.KEY_NUM_5];
 * keyMap[cameraControl.AXIS_VIEW_BOTTOM] = [input.KEY_NUM_6];
 *
 * cameraControl.keyMap = keyMap;
 * ````
 *
 * We can also just configure default bindings for a specified keyboard layout, like this:
 *
 * ````javascript
 * cameraControl.keyMap = "qwerty";
 * ````
 *
 * Then, ````CameraControl```` will internally set {@link CameraControl#keyMap} to the default key map for the QWERTY
 * layout (which is the same set of mappings we set in the previous example). In other words, if we subsequently
 * read {@link CameraControl#keyMap}, it will now be a key map, instead of the "qwerty" string value we set it to.
 *
 * Supported layouts are, so far:
 *
 * * ````"qwerty"````
 * * ````"azerty"````
 */
var CameraControl = /*@__PURE__*/(function (Component) {
    function CameraControl(owner, cfg) {
        if ( cfg === void 0 ) cfg = {};


        Component.call(this, owner, cfg);

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_LEFT = 0;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_RIGHT = 1;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_UP = 2;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_DOWN = 3;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_FORWARDS = 4;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.PAN_BACKWARDS = 5;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.ROTATE_X_POS = 6;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.ROTATE_X_NEG = 7;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.ROTATE_Y_POS = 8;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.ROTATE_Y_NEG = 9;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.DOLLY_FORWARDS = 10;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.DOLLY_BACKWARDS = 11;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_RIGHT = 12;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_BACK = 13;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_LEFT = 14;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_FRONT = 15;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_TOP = 16;

        /**
         * Identifies the XX action.
         * @final
         * @type {Number}
         */
        this.AXIS_VIEW_BOTTOM = 17;

        this._keyMap = {}; // Maps key codes to the above actions

        this.scene.canvas.canvas.oncontextmenu = function (e) {
            e.preventDefault();
        };

        // User-settable CameraControl configurations

        this._configs = {

            // Private

            longTapTimeout: 600, // Millisecs
            longTapRadius: 5, // Pixels

            // General

            active: true,
            keyboardLayout: "qwerty",
            navMode: "orbit",
            planView: false,
            firstPerson: false,
            followPointer: true,
            doublePickFlyTo: true,
            panRightClick: true,
            showPivot: false,
            pointerEnabled: true,
            constrainVertical: false,
            smartPivot: false,

            // Rotation

            dragRotationRate: 360.0,
            keyboardRotationRate: 90.0,
            rotationInertia: 0.0,

            // Panning

            keyboardPanRate: 1.0,
            touchPanRate: 1.0,
            panInertia: 0.5,

            // Dollying

            keyboardDollyRate: 10,
            mouseWheelDollyRate: 100,
            touchDollyRate: 0.2,
            dollyInertia: 0,
            dollyProximityThreshold: 30.0,
            dollyMinSpeed: 0.04
        };

        // Current runtime state of the CameraControl

        this._states = {
            pointerCanvasPos: math.vec2(),
            mouseover: false,
            followPointerDirty: true,
            mouseDownClientX: 0,
            mouseDownClientY: 0,
            mouseDownCursorX: 0,
            mouseDownCursorY: 0,
            touchStartTime: null,
            activeTouches: [],
            tapStartPos: math.vec2(),
            tapStartTime: -1,
            lastTapTime: -1,
            longTouchTimeout: null
        };

        // Updates for CameraUpdater to process on next Scene "tick" event

        this._updates = {
            rotateDeltaX: 0,
            rotateDeltaY: 0,
            panDeltaX: 0,
            panDeltaY: 0,
            panDeltaZ: 0,
            dollyDelta: 0
        };

        // Controllers to assist input event handlers with controlling the Camera

        var scene = this.scene;

        this._controllers = {
            cameraControl: this,
            pickController: new PickController(this, this._configs),
            pivotController: new PivotController(scene, this._configs),
            panController: new PanController(scene),
            cameraFlight: new CameraFlightAnimation(this, {
                duration: 0.5
            })
        };

        // Input event handlers

        this._handlers = [
            new MouseMiscHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new TouchPanRotateAndDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new MousePanRotateDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new KeyboardAxisViewHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new MousePickHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new TouchPickHandler(this.scene, this._controllers, this._configs, this._states, this._updates),
            new KeyboardPanRotateDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates)
        ];

        // Applies scheduled updates to the Camera on each Scene "tick" event

        this._cameraUpdater = new CameraUpdater(this.scene, this._controllers, this._configs, this._states, this._updates);

        // Set initial user configurations

        this.navMode = cfg.navMode;
        if (cfg.planView) {
            this.planView = cfg.planView;
        }
        this.constrainVertical = cfg.constrainVertical;
        if (cfg.keyboardLayout) {
            this.keyboardLayout = cfg.keyboardLayout; // Deprecated
        } else {
            this.keyMap = cfg.keyMap;
        }
        this.doublePickFlyTo = cfg.doublePickFlyTo;
        this.panRightClick = cfg.panRightClick;
        this.active = cfg.active;
        this.followPointer = cfg.followPointer;
        this.rotationInertia = cfg.rotationInertia;
        this.keyboardPanRate = cfg.keyboardPanRate;
        this.touchPanRate = cfg.touchPanRate;
        this.keyboardRotationRate = cfg.keyboardRotationRate;
        this.dragRotationRate = cfg.dragRotationRate;
        this.touchDollyRate = cfg.touchDollyRate;
        this.dollyInertia = cfg.dollyInertia;
        this.dollyProximityThreshold = cfg.dollyProximityThreshold;
        this.dollyMinSpeed = cfg.dollyMinSpeed;
        this.panInertia = cfg.panInertia;
        this.pointerEnabled = true;
        this.keyboardDollyRate = cfg.keyboardDollyRate;
        this.mouseWheelDollyRate = cfg.mouseWheelDollyRate;
    }

    if ( Component ) CameraControl.__proto__ = Component;
    CameraControl.prototype = Object.create( Component && Component.prototype );
    CameraControl.prototype.constructor = CameraControl;

    var prototypeAccessors = { keyMap: { configurable: true },pivotElement: { configurable: true },active: { configurable: true },navMode: { configurable: true },pointerEnabled: { configurable: true },followPointer: { configurable: true },pivotPos: { configurable: true },dollyToPointer: { configurable: true },panToPointer: { configurable: true },planView: { configurable: true },firstPerson: { configurable: true },constrainVertical: { configurable: true },doublePickFlyTo: { configurable: true },panRightClick: { configurable: true },rotationInertia: { configurable: true },keyboardPanRate: { configurable: true },touchPanRate: { configurable: true },keyboardRotationRate: { configurable: true },dragRotationRate: { configurable: true },keyboardDollyRate: { configurable: true },touchDollyRate: { configurable: true },mouseWheelDollyRate: { configurable: true },dollyInertia: { configurable: true },dollyProximityThreshold: { configurable: true },dollyMinSpeed: { configurable: true },panInertia: { configurable: true },keyboardLayout: { configurable: true },smartPivot: { configurable: true } };

    /**
     * Sets custom mappings of keys to ````CameraControl```` actions.
     *
     * See class docs for usage.
     *
     * @param {{Number:Number}|String} value Either a set of new key mappings, or a string to select a keyboard layout,
     * which causes ````CameraControl```` to use the default key mappings for that layout.
     */
    prototypeAccessors.keyMap.set = function (value) {
        value = value || "qwerty";
        if (utils.isString(value)) {
            var input = this.scene.input;
            var keyMap = {};

            switch (value) {

                default:
                    this.error("Unsupported value for 'keyMap': " + value + " defaulting to 'qwerty'");
                // Intentional fall-through to "qwerty"
                case "qwerty":
                    keyMap[this.PAN_LEFT] = [input.KEY_A];
                    keyMap[this.PAN_RIGHT] = [input.KEY_D];
                    keyMap[this.PAN_UP] = [input.KEY_Z];
                    keyMap[this.PAN_DOWN] = [input.KEY_X];
                    keyMap[this.PAN_BACKWARDS] = [];
                    keyMap[this.PAN_FORWARDS] = [];
                    keyMap[this.DOLLY_FORWARDS] = [input.KEY_W, input.KEY_ADD];
                    keyMap[this.DOLLY_BACKWARDS] = [input.KEY_S, input.KEY_SUBTRACT];
                    keyMap[this.ROTATE_X_POS] = [input.KEY_DOWN_ARROW];
                    keyMap[this.ROTATE_X_NEG] = [input.KEY_UP_ARROW];
                    keyMap[this.ROTATE_Y_POS] = [input.KEY_Q, input.KEY_LEFT_ARROW];
                    keyMap[this.ROTATE_Y_NEG] = [input.KEY_E, input.KEY_RIGHT_ARROW];
                    keyMap[this.AXIS_VIEW_RIGHT] = [input.KEY_NUM_1];
                    keyMap[this.AXIS_VIEW_BACK] = [input.KEY_NUM_2];
                    keyMap[this.AXIS_VIEW_LEFT] = [input.KEY_NUM_3];
                    keyMap[this.AXIS_VIEW_FRONT] = [input.KEY_NUM_4];
                    keyMap[this.AXIS_VIEW_TOP] = [input.KEY_NUM_5];
                    keyMap[this.AXIS_VIEW_BOTTOM] = [input.KEY_NUM_6];
                    break;

                case "azerty":
                    keyMap[this.PAN_LEFT] = [input.KEY_Q];
                    keyMap[this.PAN_RIGHT] = [input.KEY_D];
                    keyMap[this.PAN_UP] = [input.KEY_W];
                    keyMap[this.PAN_DOWN] = [input.KEY_X];
                    keyMap[this.PAN_BACKWARDS] = [];
                    keyMap[this.PAN_FORWARDS] = [];
                    keyMap[this.DOLLY_FORWARDS] = [input.KEY_Z, input.KEY_ADD];
                    keyMap[this.DOLLY_BACKWARDS] = [input.KEY_S, input.KEY_SUBTRACT];
                    keyMap[this.ROTATE_X_POS] = [input.KEY_DOWN_ARROW];
                    keyMap[this.ROTATE_X_NEG] = [input.KEY_UP_ARROW];
                    keyMap[this.ROTATE_Y_POS] = [input.KEY_A, input.KEY_LEFT_ARROW];
                    keyMap[this.ROTATE_Y_NEG] = [input.KEY_E, input.KEY_RIGHT_ARROW];
                    keyMap[this.AXIS_VIEW_RIGHT] = [input.KEY_NUM_1];
                    keyMap[this.AXIS_VIEW_BACK] = [input.KEY_NUM_2];
                    keyMap[this.AXIS_VIEW_LEFT] = [input.KEY_NUM_3];
                    keyMap[this.AXIS_VIEW_FRONT] = [input.KEY_NUM_4];
                    keyMap[this.AXIS_VIEW_TOP] = [input.KEY_NUM_5];
                    keyMap[this.AXIS_VIEW_BOTTOM] = [input.KEY_NUM_6];
                    break;
            }

            this._keyMap = keyMap;
        } else {
            var keyMap$1 = value;
            this._keyMap = keyMap$1;
        }
    };

    /**
     * Gets custom mappings of keys to {@link CameraControl} actions.
     *
     * @returns {{Number:Number}} Current key mappings.
     */
    prototypeAccessors.keyMap.get = function () {
        return this._keyMap;
    };

    /**
     * Returns true if any keys configured for the given action are down.
     * @param action
     * @param keyDownMap
     * @private
     */
    CameraControl.prototype._isKeyDownForAction = function _isKeyDownForAction (action, keyDownMap) {
        var keys = this._keyMap[action];
        if (!keys) {
            return false;
        }
        if (!keyDownMap) {
            keyDownMap = this.scene.input.keyDown;
        }
        for (var i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            if (keyDownMap[key]) {
                return true;
            }
        }
        return false;
    };

    /**
     * Sets the HTMl element to represent the pivot point when {@link CameraControl#followPointer} is true.
     *
     * See class comments for an example.
     *
     * @param {HTMLElement} element HTML element representing the pivot point.
     */
    prototypeAccessors.pivotElement.set = function (element) {
        this._controllers.pivotController.setPivotElement(element);
    };

    /**
     *  Sets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @param {Boolean} value Set ````true```` to activate this ````CameraControl````.
     */
    prototypeAccessors.active.set = function (value) {
        this._configs.active = value !== false;
    };

    /**
     * Gets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} Returns ````true```` if this ````CameraControl```` is active.
     */
    prototypeAccessors.active.get = function () {
        return this._configs.active;
    };

    /**
     * Sets the current navigation mode.
     *
     * Accepted values are:
     *
     * * "orbit" - rotation orbits about the current target or pivot point,
     * * "firstPerson" - rotation is about the current eye position,
     * * "planView" - rotation is disabled.
     *
     * See class comments for more info.
     *
     * @param {String} navMode The navigation mode: "orbit", "firstPerson" or "planView".
     */
    prototypeAccessors.navMode.set = function (navMode) {
        navMode = navMode || "orbit";
        if (navMode !== "firstPerson" && navMode !== "orbit" && navMode !== "planView") {
            this.error("Unsupported value for navMode: " + navMode + " - supported values are 'orbit', 'firstPerson' and 'planView' - defaulting to 'orbit'");
            navMode = "orbit";
        }
        this._configs.firstPerson = (navMode === "firstPerson");
        this._configs.planView = (navMode === "planView");
        if (this._configs.firstPerson || this._configs.planView) {
            this._controllers.pivotController.hidePivot();
            this._controllers.pivotController.endPivot();
        }
        this._configs.navMode = navMode;
    };

    /**
     * Gets the current navigation mode.
     *
     * @returns {String} The navigation mode: "orbit", "firstPerson" or "planView".
     */
    prototypeAccessors.navMode.get = function () {
        return this._configs.navMode;
    };

    /**
     * Sets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is useful when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without disturbing the {@link Camera}.
     *
     * @param {Boolean} value Set ````true```` to enable mouse and touch input.
     */
    prototypeAccessors.pointerEnabled.set = function (value) {
        this._reset();
        this._configs.pointerEnabled = !!value;
    };

    CameraControl.prototype._reset = function _reset () {
        for (var i = 0, len = this._handlers.length; i < len; i++) {
            var handler = this._handlers[i];
            if (handler.reset) {
                handler.reset();
            }
        }

        this._updates.panDeltaX = 0;
        this._updates.panDeltaY = 0;
        this._updates.rotateDeltaX = 0;
        this._updates.rotateDeltaY = 0;
        this._updates.dolyDelta = 0;
    };

    /**
     * Gets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is desirable when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without interfering with the {@link Camera}.
     *
     * @returns {Boolean} Returns ````true```` if mouse and touch input is enabled.
     */
    prototypeAccessors.pointerEnabled.get = function () {
        return this._configs.pointerEnabled;
    };

    /**
     * Sets whether the {@link Camera} follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @param {Boolean} value Set ````true```` to enable the Camera to follow the pointer.
     */
    prototypeAccessors.followPointer.set = function (value) {
        this._configs.followPointer = (value !== false);
    };

    /**
     * Sets whether the {@link Camera} follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @returns {Boolean} Returns ````true```` if the Camera follows the pointer.
     */
    prototypeAccessors.followPointer.get = function () {
        return this._configs.followPointer;
    };

    /**
     * Sets the current World-space 3D target position.
     *
     * Only applies when {@link CameraControl#followPointer} is ````true````.
     *
     * @param {Number[]} worldPos The new World-space 3D target position.
     */
    prototypeAccessors.pivotPos.set = function (worldPos) {
        this._controllers.pivotController.setPivotPos(worldPos);
    };

    /**
     * Gets the current World-space 3D pivot position.
     *
     * Only applies when {@link CameraControl#followPointer} is ````true````.
     *
     * @return {Number[]} worldPos The current World-space 3D pivot position.
     */
    prototypeAccessors.pivotPos.get = function () {
        return this._controllers.pivotController.getPivotPos();
    };

    /**
     * @deprecated
     * @param {Boolean} value Set ````true```` to enable dolly-to-pointer behaviour.
     */
    prototypeAccessors.dollyToPointer.set = function (value) {
        this.warn("dollyToPointer property is deprecated - replaced with followPointer");
        this.followPointer = value;
    };

    /**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */
    prototypeAccessors.dollyToPointer.get = function () {
        this.warn("dollyToPointer property is deprecated - replaced with followPointer");
        return this.followPointer;
    };

    /**
     * @deprecated
     * @param {Boolean} value Set ````true```` to enable dolly-to-pointer behaviour.
     */
    prototypeAccessors.panToPointer.set = function (value) {
        this.warn("panToPointer property is deprecated - replaced with followPointer");
    };

    /**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */
    prototypeAccessors.panToPointer.get = function () {
        this.warn("panToPointer property is deprecated - replaced with followPointer");
        return false;
    };

    /**
     * Sets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @param {Boolean} value Set ````true```` to enable plan-view mode.
     * @deprecated
     */
    prototypeAccessors.planView.set = function (value) {
        this._configs.planView = !!value;
        this._configs.firstPerson = false;
        if (this._configs.planView) {
            this._controllers.pivotController.hidePivot();
            this._controllers.pivotController.endPivot();
        }
        this.warn("planView property is deprecated - replaced with navMode");
    };

    /**
     * Gets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if plan-view mode is enabled.
     * @deprecated
     */
    prototypeAccessors.planView.get = function () {
        this.warn("planView property is deprecated - replaced with navMode");
        return this._configs.planView;
    };

    /**
     * Sets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link Camera#eye} rotates about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @param {Boolean} value Set ````true```` to enable first-person mode.
     * @deprecated
     */
    prototypeAccessors.firstPerson.set = function (value) {
        this.warn("firstPerson property is deprecated - replaced with navMode");
        this._configs.firstPerson = !!value;
        this._configs.planView = false;
        if (this._configs.firstPerson) {
            this._controllers.pivotController.hidePivot();
            this._controllers.pivotController.endPivot();
        }
    };

    /**
     * Gets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link Camera#eye} rotates about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link CameraControl#navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if first-person mode is enabled.
     * @deprecated
     */
    prototypeAccessors.firstPerson.get = function () {
        this.warn("firstPerson property is deprecated - replaced with navMode");
        return this._configs.firstPerson;
    };

    /**
     * Sets whether to vertically constrain the {@link Camera} position for first-person navigation.
     *
     * When set ````true````, this constrains {@link Camera#eye} to its current vertical position.
     *
     * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set ````true```` to vertically constrain the Camera.
     */
    prototypeAccessors.constrainVertical.set = function (value) {
        this._configs.constrainVertical = !!value;
    };

    /**
     * Gets whether to vertically constrain the {@link Camera} position for first-person navigation.
     *
     * When set ````true````, this constrains {@link Camera#eye} to its current vertical position.
     *
     * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} ````true```` when Camera is vertically constrained.
     */
    prototypeAccessors.constrainVertical.get = function () {
        return this._configs.constrainVertical;
    };

    /**
     * Sets whether double-picking an {@link Entity} causes the {@link Camera} to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @param {Boolean} value Set ````true```` to enable double-pick-fly-to mode.
     */
    prototypeAccessors.doublePickFlyTo.set = function (value) {
        this._configs.doublePickFlyTo = value !== false;
    };

    /**
     * Gets whether double-picking an {@link Entity} causes the {@link Camera} to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when double-pick-fly-to mode is enabled.
     */
    prototypeAccessors.doublePickFlyTo.get = function () {
        return this._configs.doublePickFlyTo;
    };

    /**
     * Sets whether either right-clicking (true) or middle-clicking (false) pans the {@link Camera}.
     *
     * Default is ````true````.
     *
     * @param {Boolean} value Set ````false```` to disable pan on right-click.
     */
    prototypeAccessors.panRightClick.set = function (value) {
        this._configs.panRightClick = value !== false;
    };

    /**
     * Gets whether right-clicking pans the {@link Camera}.
     *
     * Default is ````true````.
     *
     * @returns {Boolean} Returns ````false```` when pan on right-click is disabled.
     */
    prototypeAccessors.panRightClick.get = function () {
        return this._configs.panRightClick;
    };

    /**
     * Sets a factor in range ````[0..1]```` indicating how much the {@link Camera} keeps moving after you finish rotating it.
     *
     * A value of ````0.0```` causes it to immediately stop, ````0.5```` causes its movement to decay 50% on each tick,
     * while ````1.0```` causes no decay, allowing it continue moving, by the current rate of rotation.
     *
     * You may choose an inertia of zero when you want be able to precisely rotate the Camera,
     * without interference from inertia. Zero inertia can also mean that less frames are rendered while
     * you are rotating the Camera.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
     *
     * @param {Number} rotationInertia New inertial factor.
     */
    prototypeAccessors.rotationInertia.set = function (rotationInertia) {
        this._configs.rotationInertia = (rotationInertia !== undefined && rotationInertia !== null) ? rotationInertia : 0.0;
    };

    /**
     * Gets the rotation inertia factor.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
     *
     * @returns {Number} The inertia factor.
     */
    prototypeAccessors.rotationInertia.get = function () {
        return this._configs.rotationInertia;
    };

    /**
     * Sets how much the {@link Camera} pans each second with keyboard input.
     *
     * Default is ````5.0````, to pan the Camera ````5.0```` World-space units every second that
     * a panning key is depressed. See the ````CameraControl```` class documentation for which keys control
     * panning.
     *
     * Panning direction is aligned to our Camera's orientation. When we pan horizontally, we pan
     * to our left and right, when we pan vertically, we pan upwards and downwards, and when we pan forwards
     * and backwards, we pan along the direction the Camera is pointing.
     *
     * Unlike dollying when {@link followPointer} is ````true````, panning does not follow the pointer.
     *
     * @param {Number} keyboardPanRate The new keyboard pan rate.
     */
    prototypeAccessors.keyboardPanRate.set = function (keyboardPanRate) {
        this._configs.keyboardPanRate = (keyboardPanRate !== null && keyboardPanRate !== undefined) ? keyboardPanRate : 5.0;
    };


    /**
     * Sets how fast the camera pans on touch panning
     *
     * @param {Number} touchPanRate The new touch pan rate.
     */
    prototypeAccessors.touchPanRate.set = function (touchPanRate) {
        this._configs.touchPanRate = (touchPanRate !== null && touchPanRate !== undefined) ? touchPanRate : 1.0;
    };

    /**
     * Gets how fast the {@link Camera} pans on touch panning
     *
     * Default is ````1.0````.
     *
     * @returns {Number} The current touch pan rate.
     */
    prototypeAccessors.touchPanRate.get = function () {
        return this._configs.touchPanRate;
    };

    /**
     * Gets how much the {@link Camera} pans each second with keyboard input.
     *
     * Default is ````5.0````.
     *
     * @returns {Number} The current keyboard pan rate.
     */
    prototypeAccessors.keyboardPanRate.get = function () {
        return this._configs.keyboardPanRate;
    };

    /**
     * Sets how many degrees per second the {@link Camera} rotates/orbits with keyboard input.
     *
     * Default is ````90.0````, to rotate/orbit the Camera ````90.0```` degrees every second that
     * a rotation key is depressed. See the ````CameraControl```` class documentation for which keys control
     * rotation/orbit.
     *
     * @param {Number} keyboardRotationRate The new keyboard rotation rate.
     */
    prototypeAccessors.keyboardRotationRate.set = function (keyboardRotationRate) {
        this._configs.keyboardRotationRate = (keyboardRotationRate !== null && keyboardRotationRate !== undefined) ? keyboardRotationRate : 90.0;
    };

    /**
     * Sets how many degrees per second the {@link Camera} rotates/orbits with keyboard input.
     *
     * Default is ````90.0````.
     *
     * @returns {Number} The current keyboard rotation rate.
     */
    prototypeAccessors.keyboardRotationRate.get = function () {
        return this._configs.keyboardRotationRate;
    };

    /**
     * Sets the current drag rotation rate.
     *
     * This configures how many degrees the {@link Camera} rotates/orbits for a full sweep of the canvas by mouse or touch dragging.
     *
     * For example, a value of ````360.0```` indicates that the ````Camera```` rotates/orbits ````360.0```` degrees horizontally
     * when we sweep the entire width of the canvas.
     *
     * ````CameraControl```` makes vertical rotation half as sensitive as horizontal rotation, so that we don't tend to
     * flip upside-down. Therefore, a value of ````360.0```` rotates/orbits the ````Camera```` through ````180.0```` degrees
     * vertically when we sweep the entire height of the canvas.
     *
     * Default is ````360.0````.
     *
     * @param {Number} dragRotationRate The new drag rotation rate.
     */
    prototypeAccessors.dragRotationRate.set = function (dragRotationRate) {
        this._configs.dragRotationRate = (dragRotationRate !== null && dragRotationRate !== undefined) ? dragRotationRate : 360.0;
    };

    /**
     * Gets the current drag rotation rate.
     *
     * Default is ````360.0````.
     *
     * @returns {Number} The current drag rotation rate.
     */
    prototypeAccessors.dragRotationRate.get = function () {
        return this._configs.dragRotationRate;
    };

    /**
     * Sets how much the {@link Camera} dollys each second with keyboard input.
     *
     * Default is ````15.0````, to dolly the {@link Camera} ````15.0```` World-space units per second while we hold down
     * the ````+```` and ````-```` keys.
     *
     * @param {Number} keyboardDollyRate The new keyboard dolly rate.
     */
    prototypeAccessors.keyboardDollyRate.set = function (keyboardDollyRate) {
        this._configs.keyboardDollyRate = (keyboardDollyRate !== null && keyboardDollyRate !== undefined) ? keyboardDollyRate : 15.0;
    };

    /**
     * Gets how much the {@link Camera} dollys each second with keyboard input.
     *
     * Default is ````15.0````.
     *
     * @returns {Number} The current keyboard dolly rate.
     */
    prototypeAccessors.keyboardDollyRate.get = function () {
        return this._configs.keyboardDollyRate;
    };

    /**
     * Sets how much the {@link Camera} dollys with touch input.
     *
     * Default is ````0.2````
     *
     * @param {Number} touchDollyRate The new touch dolly rate.
     */
    prototypeAccessors.touchDollyRate.set = function (touchDollyRate) {
        this._configs.touchDollyRate = (touchDollyRate !== null && touchDollyRate !== undefined) ? touchDollyRate : 0.2;
    };

    /**
     * Gets how much the {@link Camera} dollys each second with touch input.
     *
     * Default is ````0.2````.
     *
     * @returns {Number} The current touch dolly rate.
     */
    prototypeAccessors.touchDollyRate.get = function () {
        return this._configs.touchDollyRate;
    };

    /**
     * Sets how much the {@link Camera} dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````, to dolly the {@link Camera} ````10.0```` World-space units per second as we spin
     * the mouse wheel.
     *
     * @param {Number} mouseWheelDollyRate The new mouse wheel dolly rate.
     */
    prototypeAccessors.mouseWheelDollyRate.set = function (mouseWheelDollyRate) {
        this._configs.mouseWheelDollyRate = (mouseWheelDollyRate !== null && mouseWheelDollyRate !== undefined) ? mouseWheelDollyRate : 100.0;
    };

    /**
     * Gets how much the {@link Camera} dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````.
     *
     * @returns {Number} The current mouseWheel dolly rate.
     */
    prototypeAccessors.mouseWheelDollyRate.get = function () {
        return this._configs.mouseWheelDollyRate;
    };

    /**
     * Sets the dolly inertia factor.
     *
     * This factor configures how much the {@link Camera} keeps moving after you finish dollying it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes dollying to immediately stop,
     * ````0.5```` causes dollying to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows dollying
     * to continue until further input stops it.
     *
     * You might set ````dollyInertia```` to zero when you want be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders less frames while dollying the Camera,
     * which can improve rendering performance.
     *
     * Default is ````0````.
     *
     * @param {Number} dollyInertia New dolly inertia factor.
     */
    prototypeAccessors.dollyInertia.set = function (dollyInertia) {
        this._configs.dollyInertia = (dollyInertia !== undefined && dollyInertia !== null) ? dollyInertia : 0;
    };

    /**
     * Gets the dolly inertia factor.
     *
     * Default is ````0````.
     *
     * @returns {Number} The current dolly inertia factor.
     */
    prototypeAccessors.dollyInertia.get = function () {
        return this._configs.dollyInertia;
    };

    /**
     * Sets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @param {Number} dollyProximityThreshold New dolly proximity threshold.
     */
    prototypeAccessors.dollyProximityThreshold.set = function (dollyProximityThreshold) {
        this._configs.dollyProximityThreshold = (dollyProximityThreshold !== undefined && dollyProximityThreshold !== null) ? dollyProximityThreshold : 35.0;
    };

    /**
     * Gets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @returns {Number} The current dolly proximity threshold.
     */
    prototypeAccessors.dollyProximityThreshold.get = function () {
        return this._configs.dollyProximityThreshold;
    };

    /**
     * Sets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @param {Number} dollyMinSpeed New dolly minimum speed.
     */
    prototypeAccessors.dollyMinSpeed.set = function (dollyMinSpeed) {
        this._configs.dollyMinSpeed = (dollyMinSpeed !== undefined && dollyMinSpeed !== null) ? dollyMinSpeed : 0.04;
    };

    /**
     * Gets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @returns {Number} The current minimum dolly speed.
     */
    prototypeAccessors.dollyMinSpeed.get = function () {
        return this._configs.dollyMinSpeed;
    };

    /**
     * Sets the pan inertia factor.
     *
     * This factor configures how much the {@link Camera} keeps moving after you finish panning it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes panning to immediately stop,
     * ````0.5```` causes panning to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows panning
     * to continue until further input stops it.
     *
     * You might set ````panInertia```` to zero when you want be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders less frames while panning the Camera,
     * wich can improve rendering performance.
     *
     * Default is ````0.5````.
     *
     * @param {Number} panInertia New pan inertia factor.
     */
    prototypeAccessors.panInertia.set = function (panInertia) {
        this._configs.panInertia = (panInertia !== undefined && panInertia !== null) ? panInertia : 0.5;
    };

    /**
     * Gets the pan inertia factor.
     *
     * Default is ````0.5````.
     *
     * @returns {Number} The current pan inertia factor.
     */
    prototypeAccessors.panInertia.get = function () {
        return this._configs.panInertia;
    };

    /**
     * Sets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @param {String} value Selects the keyboard layout.
     */
    prototypeAccessors.keyboardLayout.set = function (value) {
        // this.warn("keyboardLayout property is deprecated - use keyMap property instead");
        value = value || "qwerty";
        if (value !== "qwerty" && value !== "azerty") {
            this.error("Unsupported value for keyboardLayout - defaulting to 'qwerty'");
            value = "qwerty";
        }
        this._configs.keyboardLayout = value;
        this.keyMap = this._configs.keyboardLayout;
    };

    /**
     * Gets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @returns {String} The current keyboard layout.
     */
    prototypeAccessors.keyboardLayout.get = function () {
        return this._configs.keyboardLayout;
    };

    /**
     * Sets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link Camera#eye} and sized to the {@link Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * @param {Boolean} enabled Set ````true```` to pivot by default about the selected point on the virtual sphere, or ````false```` to pivot by default about {@link Camera#look}.
     */
    prototypeAccessors.smartPivot.set = function (enabled) {
        this._configs.smartPivot = (enabled !== false);
    };

    /**
     * Gets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link Camera#eye} and sized to the {@link Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link Camera#look}.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when pivoting by default about the selected point on the virtual sphere, or ````false```` when pivoting by default about {@link Camera#look}.
     */
    prototypeAccessors.smartPivot.get = function () {
        return this._configs.smartPivot;
    };

    /**
     * Destroys this ````CameraControl````.
     * @private
     */
    CameraControl.prototype.destroy = function destroy () {
        this._destroyHandlers();
        this._destroyControllers();
        this._cameraUpdater.destroy();
        Component.prototype.destroy.call(this);
    };

    CameraControl.prototype._destroyHandlers = function _destroyHandlers () {
        for (var i = 0, len = this._handlers.length; i < len; i++) {
            var handler = this._handlers[i];
            if (handler.destroy) {
                handler.destroy();
            }
        }
    };

    CameraControl.prototype._destroyControllers = function _destroyControllers () {
        for (var i = 0, len = this._controllers.length; i < len; i++) {
            var controller = this._controllers[i];
            if (controller.destroy) {
                controller.destroy();
            }
        }
    };

    Object.defineProperties( CameraControl.prototype, prototypeAccessors );

    return CameraControl;
}(Component));

/**
 * @desc Metadata corresponding to an {@link Entity} that represents a model.
 *
 * An {@link Entity} represents a model when {@link Entity#isModel} is ````true````
 *
 * A MetaModel corresponds to an {@link Entity} by having the same {@link MetaModel#id} as the {@link Entity#id}.
 *
 * A MetaModel is created by {@link MetaScene#createMetaModel} and belongs to a {@link MetaScene}.
 *
 * Each MetaModel is registered by {@link MetaModel#id} in {@link MetaScene#metaModels}.
 *
 * A {@link MetaModel} represents its object structure with a tree of {@link MetaObject}s, with {@link MetaModel#rootMetaObject} referencing the root {@link MetaObject}.
 *
 * @class MetaModel
 */
var MetaModel = function MetaModel(metaScene, id, projectId, revisionId, author, createdAt, creatingApplication, schema, propertySets, rootMetaObject) {

    /**
     * Globally-unique ID.
     *
     * MetaModels are registered by ID in {@link MetaScene#metaModels}.
     *
     * When this MetaModel corresponds to an {@link Entity} then this ID will match the {@link Entity#id}.
     *
     * @property id
     * @type {String|Number}
     */
    this.id = id;

    /**
     * The project ID
     * @property projectId
     * @type {String|Number}
     */
    this.projectId = projectId;

    /**
     * The revision ID, if available.
     *
     * Will be undefined if not available.
     *
     * @property revisionId
     * @type {String|Number}
     */
    this.revisionId = revisionId;

    /**
     * The model author, if available.
     *
     * Will be undefined if not available.
     *
     * @property author
     * @type {String}
     */
    this.author = author;

    /**
     * The date the model was created, if available.
     *
     * Will be undefined if not available.
     *
     * @property createdAt
     * @type {String}
     */
    this.createdAt = createdAt;

    /**
     * The application that created the model, if available.
     *
     * Will be undefined if not available.
     *
     * @property creatingApplication
     * @type {String}
     */
    this.creatingApplication = creatingApplication;

    /**
     * The model schema version, if available.
     *
     * Will be undefined if not available.
     *
     * @property schema
     * @type {String}
     */
    this.schema = schema;

    /**
     * Metadata on the {@link Scene}.
     *
     * @property metaScene
     * @type {MetaScene}
     */
    this.metaScene = metaScene;

    /**
     * The {@link PropertySet}s in this MetaModel.
     *
     * @property propertySets
     * @type {{String:PropertySet}}
     */
    this.propertySets = propertySets;

    /**
     * The root {@link MetaObject} in this MetaModel's composition structure hierarchy.
     *
     * @property rootMetaObject
     * @type {MetaObject}
     */
    this.rootMetaObject = rootMetaObject;
};

MetaModel.prototype.getJSON = function getJSON () {

    var metaObjects = [];

    function visit(metaObject) {
        var metaObjectCfg = {
            id: metaObject.id,
            extId: metaObject.extId,
            type: metaObject.type,
            name: metaObject.name
        };
        if (metaObject.parent) {
            metaObjectCfg.parent = metaObject.parent.id;
        }
        metaObjects.push(metaObjectCfg);
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                visit(children[i]);
            }
        }
    }

    visit(this.rootMetaObject);

    var json = {
        id: this.id,
        projectId: this.projectId,
        revisionId: this.revisionId,
        metaObjects: metaObjects
    };
    return json;
};

/**
 * @desc Metadata corresponding to an {@link Entity} that represents an object.
 *
 * An {@link Entity} represents an object when {@link Entity#isObject} is ````true````
 *
 * A MetaObject corresponds to an {@link Entity} by having the same {@link MetaObject#id} as the {@link Entity#id}.
 *
 * A MetaObject is created within {@link MetaScene#createMetaModel} and belongs to a {@link MetaModel}.
 *
 * Each MetaObject is registered by {@link MetaObject#id} in {@link MetaScene#metaObjects}.
 *
 * A {@link MetaModel} represents its object structure with a tree of MetaObjects, with {@link MetaModel#rootMetaObject} referencing
 * the root MetaObject.
 *
 * @class MetaObject
 */
var MetaObject = function MetaObject(metaModel, id, originalSystemId, name, type, propertySets, parent, children, external) {

    /**
     * Model metadata.
     *
     * @property metaModel
     * @type {MetaModel}
     */
    this.metaModel = metaModel;

    /**
     * Globally-unique ID.
     *
     * MetaObject instances are registered by this ID in {@link MetaScene#metaObjects}.
     *
     * @property id
     * @type {String|Number}
     */
    this.id = id;

    /**
     * ID of the corresponding object within the originating system, if any.
     *
     * @type {String}
     * @abstract
     */
    this.originalSystemId = originalSystemId;

    /**
     * Human-readable name.
     *
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * Type - often an IFC product type.
     *
     * @property type
     * @type {String}
     */
    this.type = type;

    /**
     * Optional {@link PropertySet}s used by this MetaObject.
     *
     * @property propertySets
     * @type {PropertySet[]}
     */
    this.propertySets = propertySets;

    if (parent !== undefined && parent !== null) {

        /**
         * The parent MetaObject within the structure hierarchy.
         *
         * Undefined when this is the root of its structure.
         *
         * @property parent
         * @type {MetaObject}
         */
        this.parent = parent;
    }

    if (children !== undefined && children !== null) {

        /**
         * Child ObjectMeta instances within the structure hierarchy.
         *
         * Undefined when there are no children.
         *
         * @property children
         * @type {Array}
         */
        this.children = children;
    }

    if (external !== undefined && external !== null) {

        /**
         * External application-specific metadata
         *
         * Undefined when there are is no external application-specific metadata.
         *
         * @property external
         * @type {*}
         */
        this.external = external;
    }
};

/**
 * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the subtree.
 *
 * @returns {String[]} Array of {@link MetaObject#id}s.
 */
MetaObject.prototype.getObjectIDsInSubtree = function getObjectIDsInSubtree () {
    var objectIds = [];

    function visit(metaObject) {
        if (!metaObject) {
            return;
        }
        objectIds.push(metaObject.id);
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                visit(children[i]);
            }
        }
    }

    visit(this);
    return objectIds;
};


/**
 * Iterates over the {@link MetaObject}s within the subtree.
 *
 * @param {Function} callback Callback fired at each {@link MetaObject}.
 */
MetaObject.prototype.withMetaObjectsInSubtree = function withMetaObjectsInSubtree (callback) {

    function visit(metaObject) {
        if (!metaObject) {
            return;
        }
        callback(metaObject);
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                visit(children[i]);
            }
        }
    }

    visit(this);
};

/**
 * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the subtree that have the given {@link MetaObject#type}s.
 *
 * @param {String[]} types {@link MetaObject#type} values.
 * @returns {String[]} Array of {@link MetaObject#id}s.
 */
MetaObject.prototype.getObjectIDsInSubtreeByType = function getObjectIDsInSubtreeByType (types) {
    var mask = {};
    for (var i = 0, len = types.length; i < len; i++) {
        mask[types[i]] = types[i];
    }
    var objectIds = [];

    function visit(metaObject) {
        if (!metaObject) {
            return;
        }
        if (mask[metaObject.type]) {
            objectIds.push(metaObject.id);
        }
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                visit(children[i]);
            }
        }
    }

    visit(this);
    return objectIds;
};

/**
 * Returns properties of this MeteObject as JSON.
 *
 * @returns {{id: (String|Number), type: String, name: String, parent: (String|Number|Undefined)}}
 */
MetaObject.prototype.getJSON = function getJSON () {
    var json = {
        id: this.id,
        type: this.type,
        name: this.name
    };
    if (this.parent) {
        json.parent = this.parent.id;
    }
    return json;
};

/**
 * @desc A property within a {@link PropertySet}.
 *
 * @class Property
 */
var Property = function Property(name, value, type, valueType, description) {

    /**
     * The name of this property.
     *
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * The type of this property.
     *
     * @property type
     * @type {Number|String}
     */
    this.type = type;

    /**
     * The value of this property.
     *
     * @property value
     * @type {*}
     */
    this.value = value;

    /**
     * The type of this property's value.
     *
     * @property valueType
     * @type {Number|String}
     */
    this.valueType = valueType;

    /**
     * Informative text to explain the property.
     *
     * @property name
     * @type {String}
     */
    this.description = description;
};

/**
 * @desc A set of properties associated with one or more {@link MetaObject}s.
 *
 * A PropertySet is created within {@link MetaScene#createMetaModel} and belongs to a {@link MetaModel}.
 *
 * Each PropertySet is registered by {@link PropertySet#id} in {@link MetaScene#propertySets} and {@link MetaModel#propertySets}.
 *
 * @class PropertySet
 */
var PropertySet = function PropertySet(id, originalSystemId, name, type, properties) {

    /**
     * Globally-unique ID.
     *
     * PropertySet instances are registered by this ID in {@link MetaScene#propertySets} and {@link MetaModel#propertySets}.
     *
     * @property id
     * @type {String}
     */
    this.id = id;

    /**
     * ID of the corresponding object within the originating system, if any.
     *
     * @type {String}
     * @abstract
     */
    this.originalSystemId = originalSystemId;

    /**
     * Human-readable name of this PropertySet.
     *
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * Type of this PropertySet.
     *
     * @property type
     * @type {String}
     */
    this.type = type;

    /**
     * Properties within this PropertySet.
     *
     * @property properties
     * @type {Property[]}
     */
    this.properties = [];

    if (properties) {
        for (var i = 0, len = properties.length; i < len; i++) {
            var property = properties[i];
            this.properties.push(new Property(property.label, property.value, property.type, property.valueType, property.description));
        }
    }
};

/**
 * @desc Metadata corresponding to a {@link Scene}.
 *
 * * Located in {@link Viewer#metaScene}.
 * * Contains {@link MetaModel}s and {@link MetaObject}s.
 * * [Scene Graphs user guide](https://github.com/xeokit/xeokit-sdk/wiki/Scene-Graphs)
 * * [Scene graph example with metadata](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneGraph_metadata)
 */
var MetaScene = function MetaScene(viewer, scene) {

    /**
     * The {@link Viewer}.
     * @property viewer
     * @type {Viewer}
     */
    this.viewer = viewer;

    /**
     * The {@link Scene}.
     * @property scene
     * @type {Scene}
     */
    this.scene = scene;

    /**
     * The {@link MetaModel}s belonging to this MetaScene, each mapped to its {@link MetaModel#modelId}.
     *
     * @type {{String:MetaModel}}
     */
    this.metaModels = {};

    /**
     * The {@link PropertySet}s belonging to this MetaScene, each mapped to its {@link PropertySet#id}.
     *
     * @type {{String:PropertySet}}
     */
    this.propertySets = {};

    /**
     * The {@link MetaObject}s belonging to this MetaScene, each mapped to its {@link MetaObject#id}.
     *
     * @type {{String:MetaObject}}
     */
    this.metaObjects = {};

    /**
     * The {@link MetaObject}s belonging to this MetaScene, each mapped to its {@link MetaObject#type}.
     *
     * @type {{String:MetaObject}}
     */
    this.metaObjectsByType = {};

    /**
     * Tracks number of MetaObjects of each type.
     * @private
     */
    this._typeCounts = {};

    /**
     * Subscriptions to events sent with {@link fire}.
     * @private
     */
    this._eventSubs = {};
};

/**
 * Subscribes to an event fired at this Viewer.
 *
 * @param {String} event The event
 * @param {Function} callback Callback fired on the event
 */
MetaScene.prototype.on = function on (event, callback) {
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = [];
        this._eventSubs[event] = subs;
    }
    subs.push(callback);
};

/**
 * Fires an event at this Viewer.
 *
 * @param {String} event Event name
 * @param {Object} value Event parameters
 */
MetaScene.prototype.fire = function fire (event, value) {
    var subs = this._eventSubs[event];
    if (subs) {
        for (var i = 0, len = subs.length; i < len; i++) {
            subs[i](value);
        }
    }
};

/**
 * Unsubscribes from an event fired at this Viewer.
 * @param event
 */
MetaScene.prototype.off = function off (event) { // TODO

};

/**
 * Creates a {@link MetaModel} in this MetaScene.
 *
 * The MetaModel will contain a hierarchy of {@link MetaObject}s, created from the
 * meta objects in ````metaModelData````.
 *
 * The meta object hierarchy in ````metaModelData```` is expected to be non-cyclic, with a single root. If the meta
 * objects are cyclic, then this method will log an error and attempt to recover by creating a dummy root MetaObject
 * of type "Model" and connecting all other MetaObjects as its direct children. If the meta objects contain multiple
 * roots, then this method similarly attempts to recover by creating a dummy root MetaObject of type "Model" and
 * connecting all the root MetaObjects as its children.
 *
 * @param {String} modelId ID for the new {@link MetaModel}, which will have {@link MetaModel#id} set to this value.
 * @param {Object} metaModelData Data for the {@link MetaModel}.
 * @param {Object} [options] Options for creating the {@link MetaModel}.
 * @param {Object} [options.includeTypes] When provided, only create {@link MetaObject}s with types in this list.
 * @param {Object} [options.excludeTypes] When provided, never create {@link MetaObject}s with types in this list.
 * @param {Boolean} [options.globalizeObjectIds=false] Whether to globalize each {@link MetaObject#id}. Set this ````true```` when you need to load multiple instances of the same meta model, to avoid ID clashes between the meta objects in the different instances.
 * @returns {MetaModel} The new MetaModel.
 */
MetaScene.prototype.createMetaModel = function createMetaModel (modelId, metaModelData, options) {
        if ( options === void 0 ) options = {};


    var projectId = metaModelData.projectId || "none";
    var revisionId = metaModelData.revisionId || "none";
    var newPropertySets = metaModelData.propertySets || [];
    var newObjects = metaModelData.metaObjects || [];
    var author = metaModelData.author;
    var createdAt = metaModelData.createdAt;
    var creatingApplication = metaModelData.creatingApplication;
    var schema = metaModelData.schema;
    // if (options.excludeTypes) {
    // excludeTypes = {};
    // for (let i = 0, len = options.excludeTypes.length; i < len; i++) {
    //     includeTypes[options.excludeTypes[i]] = true;
    // }
    // }

    var metaModel = new MetaModel(this, modelId, projectId, revisionId, author, createdAt, creatingApplication, schema, [], null);

    this.metaModels[modelId] = metaModel;

    for (var i = 0, len = newPropertySets.length; i < len; i++) {
        var propertySetCfg = newPropertySets[i];
        var propertySetId = propertySetCfg.id;
        var propertySet = new PropertySet(propertySetId, propertySetCfg.originalSystemId, propertySetCfg.name, propertySetCfg.type, propertySetCfg.properties);
        metaModel.propertySets[propertySetId] = propertySet;
        this.propertySets[propertySetId] = propertySet;
    }

    var rootMetaObjects = [];

    for (var i$1 = 0, len$1 = newObjects.length; i$1 < len$1; i$1++) {
        var newObject = newObjects[i$1];
        if (newObject.parent === undefined || newObject.parent === null) {
            rootMetaObjects.push(newObject);
        }
    }

    if (rootMetaObjects.length === 0) {
        this.scene.error("Cyclic containment hierarchy found in metamodel - will flatten the hierarchy and insert fake 'Model' root");
        var fakeRoot = {
            "id": modelId + ".fakeRoot",
            "name": modelId,
            "type": "Model",
            "parent": null
        };
        for (var i$2 = 0, len$2 = newObjects.length; i$2 < len$2; i$2++) {
            newObjects[i$2].parent = fakeRoot.id;
        }
        newObjects.push(fakeRoot);
    }

    if (rootMetaObjects.length > 1) {
        this.scene.error("Multiple containment hierarchy root found in metamodel - will insert fake 'Model' root");
        var fakeRoot$1 = {
            "id": modelId + ".fakeRoot",
            "name": modelId,
            "type": "Model",
            "parent": null
        };
        newObjects.push(fakeRoot$1);
        for (var i$3 = 0, len$3 = rootMetaObjects.length; i$3 < len$3; i$3++) {
            rootMetaObjects[i$3].parent = fakeRoot$1.id;
        }
    }

    for (var i$4 = 0, len$4 = newObjects.length; i$4 < len$4; i$4++) {
        var newObject$1 = newObjects[i$4];
        var type = newObject$1.type;
        var objectId = options.globalizeObjectIds ? math.globalizeObjectId(modelId, newObject$1.id) : newObject$1.id;
        var originalSystemId = newObject$1.id;
        var name = newObject$1.name;
        var propertySets = [];
        if (newObject$1.propertySetIds && newObject$1.propertySetIds.length > 0) {
            for (var j = 0, lenj = newObject$1.propertySetIds.length; j < lenj; j++) {
                var propertySetId$1 = newObject$1.propertySetIds[j];
                var propertySet$1 = metaModel.propertySets[propertySetId$1];
                if (propertySet$1) {
                    propertySets.push(propertySet$1);
                }
            }
        }
        var parent = null;
        var children = null;
        var external = newObject$1.external;
        var metaObject = new MetaObject(metaModel, objectId, originalSystemId, name, type, propertySets, parent, children, external);
        this.metaObjects[objectId] = metaObject;
        (this.metaObjectsByType[type] || (this.metaObjectsByType[type] = {}))[objectId] = metaObject;
        if (this._typeCounts[type] === undefined) {
            this._typeCounts[type] = 1;
        } else {
            this._typeCounts[type]++;
        }
    }

    for (var i$5 = 0, len$5 = newObjects.length; i$5 < len$5; i$5++) {
        var newObject$2 = newObjects[i$5];
        var objectId$1 = options.globalizeObjectIds ? math.globalizeObjectId(modelId, newObject$2.id) : newObject$2.id;
        var metaObject$1 = this.metaObjects[objectId$1];
        if (!metaObject$1) {
            continue;
        }
        if (newObject$2.parent === undefined || newObject$2.parent === null) {
            metaModel.rootMetaObject = metaObject$1;
        } else if (newObject$2.parent) {
            var parentId = options.globalizeObjectIds ? math.globalizeObjectId(modelId, newObject$2.parent) : newObject$2.parent;
            var parentMetaObject = this.metaObjects[parentId];
            if (parentMetaObject) {
                metaObject$1.parent = parentMetaObject;
                parentMetaObject.children = parentMetaObject.children || [];
                parentMetaObject.children.push(metaObject$1);
            }
        }
    }

    this.fire("metaModelCreated", modelId);
    return metaModel;
};

/**
 * Removes a {@link MetaModel} from this MetaScene.
 *
 * Fires a "metaModelDestroyed" event with the value of the {@link MetaModel#id}.
 *
 * @param {String} id ID of the target {@link MetaModel}.
 */
MetaScene.prototype.destroyMetaModel = function destroyMetaModel (id) {
    var metaModel = this.metaModels[id];
    if (!metaModel) {
        return;
    }
    this._removeMetaModel(metaModel);
    this.fire("metaModelDestroyed", id);
};

MetaScene.prototype._removeMetaModel = function _removeMetaModel (metaModel) {
        var this$1 = this;

    var metaObjects = this.metaObjects;
    var metaObjectsByType = this.metaObjectsByType;
    var visit = function (metaObject) {
        delete metaObjects[metaObject.id];
        var types = metaObjectsByType[metaObject.type];
        if (types && types[metaObject.id]) {
            delete types[metaObject.id];
            if (--this$1._typeCounts[metaObject.type] === 0) {
                delete this$1._typeCounts[metaObject.type];
                delete metaObjectsByType[metaObject.type];
            }
        }
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                var childMetaObject = children[i];
                visit(childMetaObject);
            }
        }
    };
    visit(metaModel.rootMetaObject);
    for (var propertySetId in metaModel.propertySets) {
        if (metaModel.propertySets.hasOwnProperty(propertySetId)) {
            delete this.propertySets[propertySetId];
        }
    }
    delete this.metaModels[metaModel.id];
};

/**
 * Gets the {@link MetaObject#id}s of the {@link MetaObject}s that have the given {@link MetaObject#type}.
 *
 * @param {String} type The type.
 * @returns {String[]} Array of {@link MetaObject#id}s.
 */
MetaScene.prototype.getObjectIDsByType = function getObjectIDsByType (type) {
    var metaObjects = this.metaObjectsByType[type];
    return metaObjects ? Object.keys(metaObjects) : [];
};

/**
 * Gets the {@link MetaObject#id}s of the {@link MetaObject}s within the given subtree.
 *
 * @param {String} id  ID of the root {@link MetaObject} of the given subtree.
 * @param {String[]} [includeTypes] Optional list of types to include.
 * @param {String[]} [excludeTypes] Optional list of types to exclude.
 * @returns {String[]} Array of {@link MetaObject#id}s.
 */
MetaScene.prototype.getObjectIDsInSubtree = function getObjectIDsInSubtree (id, includeTypes, excludeTypes) {
    var list = [];
    var metaObject = this.metaObjects[id];
    var includeMask = (includeTypes && includeTypes.length > 0) ? arrayToMap(includeTypes) : null;
    var excludeMask = (excludeTypes && excludeTypes.length > 0) ? arrayToMap(excludeTypes) : null;

    function visit(metaObject) {
        if (!metaObject) {
            return;
        }
        var include = true;
        if (excludeMask && excludeMask[metaObject.type]) {
            include = false;
        } else if (includeMask && (!includeMask[metaObject.type])) {
            include = false;
        }
        if (include) {
            list.push(metaObject.id);
        }
        var children = metaObject.children;
        if (children) {
            for (var i = 0, len = children.length; i < len; i++) {
                visit(children[i]);
            }
        }
    }

    visit(metaObject);
    return list;
};

/**
 * Iterates over the {@link MetaObject}s within the subtree.
 *
 * @param {String} id ID of root {@link MetaObject}.
 * @param {Function} callback Callback fired at each {@link MetaObject}.
 */
MetaScene.prototype.withMetaObjectsInSubtree = function withMetaObjectsInSubtree (id, callback) {
    var metaObject = this.metaObjects[id];
    if (!metaObject) {
        return;
    }
    metaObject.withMetaObjectsInSubtree(callback);
};

function arrayToMap(array) {
    var map = {};
    for (var i = 0, len = array.length; i < len; i++) {
        map[array[i]] = true;
    }
    return map;
}

/**
 * The 3D Viewer at the heart of the xeokit SDK.
 *
 * * A Viewer wraps a single {@link Scene}
 * * Add {@link Plugin}s to a Viewer to extend its functionality.
 * * {@link Viewer#metaScene} holds metadata about models in the
 * Viewer's {@link MetaScene}.
 * * Use {@link Viewer#cameraFlight} to fly or jump the {@link Scene}'s
 * {@link Camera} to target positions, boundaries or {@link Entity}s.
 *
 * @public
 */
var Viewer = function Viewer(cfg) {

    /**
     * The Viewer's current language setting.
     * @property language
     * @deprecated
     * @type {String}
     */
    this.language = "en";

    /**
     * The viewer's locale service.
     *
     * This is configured via the Viewer's constructor.
     *
     * By default, this service will be an instance of {@link LocaleService}, which will just return
     * null translations for all given strings and phrases.
     *
     * @property localeService
     * @type {LocaleService}
     * @since 2.0
     */
    this.localeService = cfg.localeService || new LocaleService();

    /**
     * The Viewer's {@link Scene}.
     * @property scene
     * @type {Scene}
     */
    this.scene = new Scene(this, {
        canvasId: cfg.canvasId,
        canvasElement: cfg.canvasElement,
        webgl2: false,
        contextAttr: {
            preserveDrawingBuffer: cfg.preserveDrawingBuffer !== false,
            premultipliedAlpha: (!!cfg.premultipliedAlpha),
            antialias: (cfg.antialias !== false)
        },
        spinnerElementId: cfg.spinnerElementId,
        transparent: (cfg.transparent !== false),
        gammaInput: true,
        gammaOutput: false,
        backgroundColor: cfg.backgroundColor,
        backgroundColorFromAmbientLight: cfg.backgroundColorFromAmbientLight,
        ticksPerRender: 1,
        ticksPerOcclusionTest: 20,
        units: cfg.units,
        scale: cfg.scale,
        origin: cfg.origin,
        saoEnabled: cfg.saoEnabled,
        alphaDepthMask: (cfg.alphaDepthMask !== false),
        entityOffsetsEnabled: (!!cfg.entityOffsetsEnabled),
        pickSurfacePrecisionEnabled: (!!cfg.pickSurfacePrecisionEnabled),
        logarithmicDepthBufferEnabled: (!!cfg.logarithmicDepthBufferEnabled),
        pbrEnabled: (!!cfg.pbrEnabled)
    });

    /**
     * Metadata about the {@link Scene} and the models and objects within it.
     * @property metaScene
     * @type {MetaScene}
     * @readonly
     */
    this.metaScene = new MetaScene(this, this.scene);

    /**
     * The Viewer's ID.
     * @property id
     *
     * @type {String|Number}
     */
    this.id = cfg.id || this.scene.id;

    /**
     * The Viewer's {@link Camera}. This is also found on {@link Scene#camera}.
     * @property camera
     * @type {Camera}
     */
    this.camera = this.scene.camera;

    /**
     * The Viewer's {@link CameraFlightAnimation}, which
     * is used to fly the {@link Scene}'s {@link Camera} to given targets.
     * @property cameraFlight
     * @type {CameraFlightAnimation}
     */
    this.cameraFlight = new CameraFlightAnimation(this.scene, {
        duration: 0.5
    });

    /**
     * The Viewer's {@link CameraControl}, which
     * controls the {@link Scene}'s {@link Camera} with mouse,  touch and keyboard input.
     * @property cameraControl
     * @type {CameraControl}
     */
    this.cameraControl = new CameraControl(this.scene, {
        // panToPointer: true,
        doublePickFlyTo: true
    });

    this._plugins = [];

    /**
     * Subscriptions to events sent with {@link fire}.
     * @private
     */
    this._eventSubs = {};
};

/**
 * Subscribes to an event fired at this Viewer.
 *
 * @param {String} event The event
 * @param {Function} callback Callback fired on the event
 */
Viewer.prototype.on = function on (event, callback) {
    var subs = this._eventSubs[event];
    if (!subs) {
        subs = [];
        this._eventSubs[event] = subs;
    }
    subs.push(callback);
};

/**
 * Fires an event at this Viewer.
 *
 * @param {String} event Event name
 * @param {Object} value Event parameters
 */
Viewer.prototype.fire = function fire (event, value) {
    var subs = this._eventSubs[event];
    if (subs) {
        for (var i = 0, len = subs.length; i < len; i++) {
            subs[i](value);
        }
    }
};

/**
 * Unsubscribes from an event fired at this Viewer.
 * @param event
 */
Viewer.prototype.off = function off (event) { // TODO

};

/**
 * Logs a message to the JavaScript developer console, prefixed with the ID of this Viewer.
 *
 * @param {String} msg The message
 */
Viewer.prototype.log = function log (msg) {
    console.log(("[xeokit viewer " + (this.id) + "]: " + msg));
};

/**
 * Logs an error message to the JavaScript developer console, prefixed with the ID of this Viewer.
 *
 * @param {String} msg The error message
 */
Viewer.prototype.error = function error (msg) {
    console.error(("[xeokit viewer " + (this.id) + "]: " + msg));
};

/**
 * Installs a Plugin.
 *
 * @private
 */
Viewer.prototype.addPlugin = function addPlugin (plugin) {
    this._plugins.push(plugin);
};

/**
 * Uninstalls a Plugin, clearing content from it first.
 *
 * @private
 */
Viewer.prototype.removePlugin = function removePlugin (plugin) {
    for (var i = 0, len = this._plugins.length; i < len; i++) {
        var p = this._plugins[i];
        if (p === plugin) {
            if (p.clear) {
                p.clear();
            }
            this._plugins.splice(i, 1);
            return;
        }
    }
};

/**
 * Sends a message to installed Plugins.
 *
 * The message can optionally be accompanied by a value.
 * @private
 */
Viewer.prototype.sendToPlugins = function sendToPlugins (name, value) {
    for (var i = 0, len = this._plugins.length; i < len; i++) {
        var p = this._plugins[i];
        if (p.send) {
            p.send(name, value);
        }
    }
};

/**
 * @private
 * @deprecated
 */
Viewer.prototype.clear = function clear () {
    throw "Viewer#clear() no longer implemented - use '#sendToPlugins(\"clear\") instead";
};

/**
 * @private
 * @deprecated
 */
Viewer.prototype.resetView = function resetView () {
    throw "Viewer#resetView() no longer implemented - use CameraMemento & ObjectsMemento classes instead";
};

/**
 * Enter snapshot mode.
 *
 * Switches rendering to a hidden snapshot canvas.
 *
 * Exit snapshot mode using {@link Viewer#endSnapshot}.
 */
Viewer.prototype.beginSnapshot = function beginSnapshot () {
    if (this._snapshotBegun) {
        return;
    }
    this.scene._renderer.beginSnapshot();
    this._snapshotBegun = true;
};

/**
 * Gets a snapshot of this Viewer's {@link Scene} as a Base64-encoded image.
 *
 * #### Usage:
 *
 * ````javascript
 * const imageData = viewer.getSnapshot({
 *width: 500,
 *height: 500,
 *format: "png"
 * });
 * ````
 * @param {*} [params] Capture options.
 * @param {Number} [params.width] Desired width of result in pixels - defaults to width of canvas.
 * @param {Number} [params.height] Desired height of result in pixels - defaults to height of canvas.
 * @param {String} [params.format="jpeg"] Desired format; "jpeg", "png" or "bmp".
 * @param {Boolean} [params.includeGizmos=false] When true, will include gizmos like {@link SectionPlane} in the snapshot.
 * @returns {String} String-encoded image data URI.
 */
Viewer.prototype.getSnapshot = function getSnapshot (params) {
        if ( params === void 0 ) params = {};


    var needFinishSnapshot = (!this._snapshotBegun);

    if (!this._snapshotBegun) {
        this.beginSnapshot();
    }

    if (!params.includeGizmos) {
        this.sendToPlugins("snapshotStarting"); // Tells plugins to hide things that shouldn't be in snapshot
    }

    var resize = (params.width !== undefined && params.height !== undefined);
    var canvas = this.scene.canvas.canvas;
    var saveWidth = canvas.clientWidth;
    var saveHeight = canvas.clientHeight;
    var saveCssWidth = canvas.style.width;
    var saveCssHeight = canvas.style.height;

    var width = params.width ? Math.floor(params.width) : canvas.width;
    var height = params.height ? Math.floor(params.height) : canvas.height;

    if (resize) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
    }

    this.scene._renderer.renderSnapshot();

    var imageDataURI = this.scene._renderer.readSnapshot(params);

    if (resize) {
        canvas.style.width = saveCssWidth;
        canvas.style.height = saveCssHeight;
        canvas.width = saveWidth;
        canvas.height = saveHeight;

        this.scene.glRedraw();
    }

    if (!params.includeGizmos) {
        this.sendToPlugins("snapshotFinished");
    }

    if (needFinishSnapshot) {
        this.endSnapshot();
    }

    return imageDataURI;
};

/**
 * Exits snapshot mode.
 *
 * Switches rendering back to the main canvas.
 *
 */
Viewer.prototype.endSnapshot = function endSnapshot () {
    if (!this._snapshotBegun) {
        return;
    }
    this.scene._renderer.endSnapshot();
    this.scene._renderer.render({force: true});
    this._snapshotBegun = false;
};

/** Destroys this Viewer.
 */
Viewer.prototype.destroy = function destroy () {
    var plugins = this._plugins.slice(); // Array will modify as we delete plugins
    for (var i = 0, len = plugins.length; i < len; i++) {
        var plugin = plugins[i];
        plugin.destroy();
    }
    this.scene.destroy();
};

export { AmbientLight, AngleMeasurementsPlugin, AnnotationsPlugin, AxisGizmoPlugin, BCFViewpointsPlugin, CameraMemento, CameraPath, CameraPathAnimation, Component, ContextMenu, CubicBezierCurve, Curve, DirLight, DistanceMeasurementsPlugin, EdgeMaterial, EmphasisMaterial, FastNavPlugin, Fresnel, GLTFDefaultDataSource, GLTFLoaderPlugin, ImagePlane, LambertMaterial, LightMap, LocaleService, Map, Marker, Mesh, MetallicMaterial, ModelMemento, NavCubePlugin, Node, OBJLoaderPlugin, ObjectsMemento, Path, PerformanceModel, PhongMaterial, Plugin, PointLight, QuadraticBezierCurve, Queue, ReadableGeometry, ReflectionMap, STLDefaultDataSource, STLLoaderPlugin, SectionPlane, SectionPlanesPlugin, Skybox, SkyboxesPlugin, SpecularMaterial, SplineCurve, StoreyViewsPlugin, Texture, TreeViewPlugin, VBOGeometry, ViewCullPlugin, Viewer, XKTDefaultDataSource, XKTLoaderPlugin, XML3DLoaderPlugin, buildBoxGeometry, buildBoxLinesGeometry, buildCylinderGeometry, buildGridGeometry, buildPlaneGeometry, buildSphereGeometry, buildTorusGeometry, buildVectorTextGeometry, load3DSGeometry, loadOBJGeometry, math, utils };
